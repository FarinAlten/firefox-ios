/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs":
/*!*********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressMetaData: () => (/* binding */ AddressMetaData),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// The data below is initially copied from\n// https://chromium-i18n.appspot.com/ssl-aggregate-address\n\n// See https://github.com/googlei18n/libaddressinput/wiki/AddressValidationMetadata for\n// documentation on how to use the data.\n\n// WARNING: DO NOT change any value or add additional properties in addressData.\n// We only accept the metadata of the supported countries that is copied from libaddressinput directly.\n// Please edit AddressMetaDataExtension.sys.mjs instead if you want to add new property as complement\n// or overwrite the existing properties.\n\nconst AddressMetaData = {\n  \"data/AD\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/AD\",\n    key: \"AD\",\n    lang: \"ca\",\n    languages: \"ca\",\n    name: \"ANDORRA\",\n    posturl:\n      \"http://www.correos.es/comun/CodigosPostales/1010_s-CodPostal.asp?Provincia=\",\n    sub_isoids: \"07~02~03~08~04~05~06\",\n    sub_keys:\n      \"Parròquia d'Andorra la Vella~Canillo~Encamp~Escaldes-Engordany~La Massana~Ordino~Sant Julià de Lòria\",\n    sub_names:\n      \"Andorra la Vella~Canillo~Encamp~Escaldes-Engordany~La Massana~Ordino~Sant Julià de Lòria\",\n    sub_zipexs: \"AD500~AD100~AD200~AD700~AD400~AD300~AD600\",\n    sub_zips: \"AD50[01]~AD10[01]~AD20[01]~AD70[01]~AD40[01]~AD30[01]~AD60[01]\",\n    zip: \"AD[1-7]0\\\\d\",\n    zipex: \"AD100,AD501,AD700\",\n  },\n  \"data/AE\": {\n    fmt: \"%N%n%O%n%A%n%S\",\n    id: \"data/AE\",\n    key: \"AE\",\n    lang: \"ar\",\n    languages: \"ar\",\n    lfmt: \"%N%n%O%n%A%n%S\",\n    name: \"UNITED ARAB EMIRATES\",\n    require: \"AS\",\n    state_name_type: \"emirate\",\n    sub_isoids: \"AZ~SH~FU~UQ~DU~RK~AJ\",\n    sub_keys:\n      \"أبو ظبي~إمارة الشارقةّ~الفجيرة~ام القيوين~إمارة دبيّ~إمارة رأس الخيمة~عجمان\",\n    sub_lnames:\n      \"Abu Dhabi~Sharjah~Fujairah~Umm Al Quwain~Dubai~Ras al Khaimah~Ajman\",\n    sub_names: \"أبو ظبي~الشارقة~الفجيرة~ام القيوين~دبي~رأس الخيمة~عجمان\",\n  },\n  \"data/AF\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/AF\",\n    key: \"AF\",\n    name: \"AFGHANISTAN\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1001,2601,3801\",\n  },\n  \"data/AG\": {\n    id: \"data/AG\",\n    key: \"AG\",\n    name: \"ANTIGUA AND BARBUDA\",\n    require: \"A\",\n  },\n  \"data/AI\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/AI\",\n    key: \"AI\",\n    name: \"ANGUILLA\",\n    zip: \"(?:AI-)?2640\",\n    zipex: \"2640\",\n  },\n  \"data/AL\": {\n    fmt: \"%N%n%O%n%A%n%Z%n%C\",\n    id: \"data/AL\",\n    key: \"AL\",\n    name: \"ALBANIA\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1001,1017,3501\",\n  },\n  \"data/AM\": {\n    fmt: \"%N%n%O%n%A%n%Z%n%C%n%S\",\n    id: \"data/AM\",\n    key: \"AM\",\n    lang: \"hy\",\n    languages: \"hy\",\n    lfmt: \"%N%n%O%n%A%n%Z%n%C%n%S\",\n    name: \"ARMENIA\",\n    sub_isoids: \"AG~AR~AV~GR~ER~LO~KT~SH~SU~VD~TV\",\n    sub_keys:\n      \"Արագածոտն~Արարատ~Արմավիր~Գեղարքունիք~Երևան~Լոռի~Կոտայք~Շիրակ~Սյունիք~Վայոց ձոր~Տավուշ\",\n    sub_lnames:\n      \"Aragatsotn~Ararat~Armavir~Gegharkunik~Yerevan~Lori~Kotayk~Shirak~Syunik~Vayots Dzor~Tavush\",\n    sub_zipexs:\n      \"0201,0514~0601,0823~0901,1149~1201,1626~0000,0099~1701,2117~2201,2506~2601,3126~3201,3519~3601,3810~3901,4216\",\n    sub_zips:\n      \"0[2-5]~0[6-8]~09|1[01]~1[2-6]~00~1[7-9]|2[01]~2[2-5]~2[6-9]|3[01]~3[2-5]~3[6-8]~39|4[0-2]\",\n    zip: \"(?:37)?\\\\d{4}\",\n    zipex: \"375010,0002,0010\",\n  },\n  \"data/AO\": { id: \"data/AO\", key: \"AO\", name: \"ANGOLA\" },\n  \"data/AQ\": { id: \"data/AQ\", key: \"AQ\", name: \"ANTARCTICA\" },\n  \"data/AR\": {\n    fmt: \"%N%n%O%n%A%n%Z %C%n%S\",\n    id: \"data/AR\",\n    key: \"AR\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"ARGENTINA\",\n    posturl: \"http://www.correoargentino.com.ar/formularios/cpa\",\n    sub_isoids: \"B~K~H~U~C~X~W~E~P~Y~L~F~M~N~Q~R~A~J~D~Z~S~G~V~T\",\n    sub_keys:\n      \"Buenos Aires~Catamarca~Chaco~Chubut~Ciudad Autónoma de Buenos Aires~Córdoba~Corrientes~Entre Ríos~Formosa~Jujuy~La Pampa~La Rioja~Mendoza~Misiones~Neuquén~Río Negro~Salta~San Juan~San Luis~Santa Cruz~Santa Fe~Santiago del Estero~Tierra del Fuego~Tucumán\",\n    sub_names:\n      \"Buenos Aires~Catamarca~Chaco~Chubut~Ciudad Autónoma de Buenos Aires~Córdoba~Corrientes~Entre Ríos~Formosa~Jujuy~La Pampa~La Rioja~Mendoza~Misiones~Neuquén~Río Negro~Salta~San Juan~San Luis~Santa Cruz~Santa Fe~Santiago del Estero~Tierra del Fuego~Tucumán\",\n    sub_zips:\n      \"B?[1-36-8]~K?[45]~H?3~U?[89]~C?1~X?[235-8]~W?3~E?[1-3]~P?[37]~Y?4~L?[3568]~F?5~M?[56]~N?3~Q?[38]~R?[89]~A?[34]~J?5~D?[4-6]~Z?[89]~S?[2368]~G?[2-5]~V?9~T?[45]\",\n    upper: \"ACZ\",\n    zip: \"((?:[A-HJ-NP-Z])?\\\\d{4})([A-Z]{3})?\",\n    zipex: \"C1070AAM,C1000WAM,B1000TBU,X5187XAB\",\n  },\n  \"data/AS\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/AS\",\n    key: \"AS\",\n    name: \"AMERICAN SAMOA\",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    upper: \"ACNOS\",\n    zip: \"(96799)(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"96799\",\n  },\n  \"data/AT\": {\n    fmt: \"%O%n%N%n%A%n%Z %C\",\n    id: \"data/AT\",\n    key: \"AT\",\n    name: \"AUSTRIA\",\n    posturl: \"http://www.post.at/post_subsite_postleitzahlfinder.php\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1010,3741\",\n  },\n  \"data/AU\": {\n    fmt: \"%O%n%N%n%A%n%C %S %Z\",\n    id: \"data/AU\",\n    key: \"AU\",\n    lang: \"en\",\n    languages: \"en\",\n    locality_name_type: \"suburb\",\n    name: \"AUSTRALIA\",\n    posturl: \"http://www1.auspost.com.au/postcodes/\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    sub_isoids: \"ACT~NSW~NT~QLD~SA~TAS~VIC~WA\",\n    sub_keys: \"ACT~NSW~NT~QLD~SA~TAS~VIC~WA\",\n    sub_names:\n      \"Australian Capital Territory~New South Wales~Northern Territory~Queensland~South Australia~Tasmania~Victoria~Western Australia\",\n    sub_zipexs:\n      \"0200,2540,2618,2999~1000,2888,3585,3707~0800,0999~4000,9999~5000~7000,7999~3000,8000~6000,0872\",\n    sub_zips:\n      \"29|2540|260|261[0-8]|02|2620~1|2[0-57-8]|26[2-9]|261[189]|3500|358[56]|3644|3707~0[89]~[49]~5|0872~7~[38]~6|0872\",\n    upper: \"CS\",\n    zip: \"\\\\d{4}\",\n    zipex: \"2060,3171,6430,4000,4006,3001\",\n  },\n  \"data/AW\": { id: \"data/AW\", key: \"AW\", name: \"ARUBA\" },\n  \"data/AZ\": {\n    fmt: \"%N%n%O%n%A%nAZ %Z %C\",\n    id: \"data/AZ\",\n    key: \"AZ\",\n    name: \"AZERBAIJAN\",\n    postprefix: \"AZ \",\n    zip: \"\\\\d{4}\",\n    zipex: \"1000\",\n  },\n  \"data/BA\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/BA\",\n    key: \"BA\",\n    name: \"BOSNIA AND HERZEGOVINA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"71000\",\n  },\n  \"data/BB\": {\n    fmt: \"%N%n%O%n%A%n%C, %S %Z\",\n    id: \"data/BB\",\n    key: \"BB\",\n    name: \"BARBADOS\",\n    state_name_type: \"parish\",\n    zip: \"BB\\\\d{5}\",\n    zipex: \"BB23026,BB22025\",\n  },\n  \"data/BD\": {\n    fmt: \"%N%n%O%n%A%n%C - %Z\",\n    id: \"data/BD\",\n    key: \"BD\",\n    name: \"BANGLADESH\",\n    posturl: \"http://www.bangladeshpost.gov.bd/PostCode.asp\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1340,1000\",\n  },\n  \"data/BE\": {\n    fmt: \"%O%n%N%n%A%n%Z %C\",\n    id: \"data/BE\",\n    key: \"BE\",\n    name: \"BELGIUM\",\n    posturl:\n      \"http://www.post.be/site/nl/residential/customerservice/search/postal_codes.html\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}\",\n    zipex: \"4000,1000\",\n  },\n  \"data/BF\": {\n    fmt: \"%N%n%O%n%A%n%C %X\",\n    id: \"data/BF\",\n    key: \"BF\",\n    name: \"BURKINA FASO\",\n  },\n  \"data/BG\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/BG\",\n    key: \"BG\",\n    name: \"BULGARIA (REP.)\",\n    posturl: \"http://www.bgpost.bg/?cid=5\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1000,1700\",\n  },\n  \"data/BH\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/BH\",\n    key: \"BH\",\n    name: \"BAHRAIN\",\n    zip: \"(?:\\\\d|1[0-2])\\\\d{2}\",\n    zipex: \"317\",\n  },\n  \"data/BI\": { id: \"data/BI\", key: \"BI\", name: \"BURUNDI\" },\n  \"data/BJ\": { id: \"data/BJ\", key: \"BJ\", name: \"BENIN\", upper: \"AC\" },\n  \"data/BL\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/BL\",\n    key: \"BL\",\n    name: \"SAINT BARTHELEMY\",\n    posturl:\n      \"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"9[78][01]\\\\d{2}\",\n    zipex: \"97100\",\n  },\n  \"data/BM\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/BM\",\n    key: \"BM\",\n    name: \"BERMUDA\",\n    posturl: \"http://www.landvaluation.bm/\",\n    zip: \"[A-Z]{2} ?[A-Z0-9]{2}\",\n    zipex: \"FL 07,HM GX,HM 12\",\n  },\n  \"data/BN\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/BN\",\n    key: \"BN\",\n    name: \"BRUNEI DARUSSALAM\",\n    posturl: \"http://www.post.gov.bn/SitePages/postcodes.aspx\",\n    zip: \"[A-Z]{2} ?\\\\d{4}\",\n    zipex: \"BT2328,KA1131,BA1511\",\n  },\n  \"data/BO\": { id: \"data/BO\", key: \"BO\", name: \"BOLIVIA\", upper: \"AC\" },\n  \"data/BQ\": {\n    id: \"data/BQ\",\n    key: \"BQ\",\n    name: \"BONAIRE, SINT EUSTATIUS, AND SABA\",\n  },\n  \"data/BR\": {\n    fmt: \"%O%n%N%n%A%n%D%n%C-%S%n%Z\",\n    id: \"data/BR\",\n    key: \"BR\",\n    lang: \"pt\",\n    languages: \"pt\",\n    name: \"BRAZIL\",\n    posturl: \"http://www.buscacep.correios.com.br/\",\n    require: \"ASCZ\",\n    state_name_type: \"state\",\n    sub_isoids:\n      \"AC~AL~AP~AM~BA~CE~DF~ES~GO~MA~MT~MS~MG~PA~PB~PR~PE~PI~RJ~RN~RS~RO~RR~SC~SP~SE~TO\",\n    sub_keys:\n      \"AC~AL~AP~AM~BA~CE~DF~ES~GO~MA~MT~MS~MG~PA~PB~PR~PE~PI~RJ~RN~RS~RO~RR~SC~SP~SE~TO\",\n    sub_mores:\n      \"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\",\n    sub_names:\n      \"Acre~Alagoas~Amapá~Amazonas~Bahia~Ceará~Distrito Federal~Espírito Santo~Goiás~Maranhão~Mato Grosso~Mato Grosso do Sul~Minas Gerais~Pará~Paraíba~Paraná~Pernambuco~Piauí~Rio de Janeiro~Rio Grande do Norte~Rio Grande do Sul~Rondônia~Roraima~Santa Catarina~São Paulo~Sergipe~Tocantins\",\n    sub_zipexs:\n      \"69900-000,69999-999~57000-000,57999-999~68900-000,68999-999~69000-000,69400-123~40000-000,48999-999~60000-000,63999-999~70000-000,73500-123~29000-000,29999-999~72800-000,73700-123~65000-000,65999-999~78000-000,78899-999~79000-000,79999-999~30000-000,39999-999~66000-000,68899-999~58000-000,58999-999~80000-000,87999-999~50000-000,56999-999~64000-000,64999-999~20000-000,28999-999~59000-000,59999-999~90000-000,99999-999~76800-000,78900-000,78999-999~69300-000,69399-999~88000-000,89999-999~01000-000,13000-123~49000-000,49999-999~77000-000,77999-999\",\n    sub_zips:\n      \"699~57~689~69[0-24-8]~4[0-8]~6[0-3]~7[0-1]|72[0-7]|73[0-6]~29~72[89]|73[7-9]|7[4-6]~65~78[0-8]~79~3~6[6-7]|68[0-8]~58~8[0-7]~5[0-6]~64~2[0-8]~59~9~76[89]|789~693~8[89]~[01][1-9]~49~77\",\n    sublocality_name_type: \"neighborhood\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}-?\\\\d{3}\",\n    zipex: \"40301-110,70002-900\",\n  },\n  \"data/BS\": {\n    fmt: \"%N%n%O%n%A%n%C, %S\",\n    id: \"data/BS\",\n    key: \"BS\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"BAHAMAS\",\n    state_name_type: \"island\",\n    sub_isoids: \"~AK~~BY~BI~CI~~~EX~~HI~IN~LI~MG~~RI~RC~SS~SW\",\n    sub_keys:\n      \"Abaco~Acklins~Andros~Berry Islands~Bimini~Cat Island~Crooked Island~Eleuthera~Exuma~Grand Bahama~Harbour Island~Inagua~Long Island~Mayaguana~N.P.~Ragged Island~Rum Cay~San Salvador~Spanish Wells\",\n    sub_names:\n      \"Abaco Islands~Acklins~Andros Island~Berry Islands~Bimini~Cat Island~Crooked Island~Eleuthera~Exuma and Cays~Grand Bahama~Harbour Island~Inagua~Long Island~Mayaguana~New Providence~Ragged Island~Rum Cay~San Salvador~Spanish Wells\",\n  },\n  \"data/BT\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/BT\",\n    key: \"BT\",\n    name: \"BHUTAN\",\n    posturl: \"http://www.bhutanpost.bt/postcodes/\",\n    zip: \"\\\\d{5}\",\n    zipex: \"11001,31101,35003\",\n  },\n  \"data/BV\": { id: \"data/BV\", key: \"BV\", name: \"BOUVET ISLAND\" },\n  \"data/BW\": { id: \"data/BW\", key: \"BW\", name: \"BOTSWANA\" },\n  \"data/BY\": {\n    fmt: \"%S%n%Z %C%n%A%n%O%n%N\",\n    id: \"data/BY\",\n    key: \"BY\",\n    name: \"BELARUS\",\n    posturl: \"http://ex.belpost.by/addressbook/\",\n    zip: \"\\\\d{6}\",\n    zipex: \"223016,225860,220050\",\n  },\n  \"data/BZ\": { id: \"data/BZ\", key: \"BZ\", name: \"BELIZE\" },\n  \"data/CA\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/CA\",\n    key: \"CA\",\n    lang: \"en\",\n    languages: \"en~fr\",\n    name: \"CANADA\",\n    posturl: \"https://www.canadapost.ca/cpo/mc/personal/postalcode/fpc.jsf\",\n    require: \"ACSZ\",\n    sub_isoids: \"AB~BC~MB~NB~NL~NT~NS~NU~ON~PE~QC~SK~YT\",\n    sub_keys: \"AB~BC~MB~NB~NL~NT~NS~NU~ON~PE~QC~SK~YT\",\n    sub_names:\n      \"Alberta~British Columbia~Manitoba~New Brunswick~Newfoundland and Labrador~Northwest Territories~Nova Scotia~Nunavut~Ontario~Prince Edward Island~Quebec~Saskatchewan~Yukon\",\n    sub_zips:\n      \"T~V~R~E~A~X0E|X0G|X1A~B~X0A|X0B|X0C~K|L|M|N|P~C~G|H|J|K1A~S|R8A~Y\",\n    upper: \"ACNOSZ\",\n    zip: \"[ABCEGHJKLMNPRSTVXY]\\\\d[ABCEGHJ-NPRSTV-Z] ?\\\\d[ABCEGHJ-NPRSTV-Z]\\\\d\",\n    zipex: \"H3Z 2Y7,V8X 3X4,T0L 1K0,T0H 1A0,K1A 0B1\",\n  },\n  \"data/CA--fr\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/CA--fr\",\n    key: \"CA\",\n    lang: \"fr\",\n    name: \"CANADA\",\n    posturl: \"https://www.canadapost.ca/cpo/mc/personal/postalcode/fpc.jsf\",\n    require: \"ACSZ\",\n    sub_isoids: \"AB~BC~PE~MB~NB~NS~NU~ON~QC~SK~NL~NT~YT\",\n    sub_keys: \"AB~BC~PE~MB~NB~NS~NU~ON~QC~SK~NL~NT~YT\",\n    sub_names:\n      \"Alberta~Colombie-Britannique~Île-du-Prince-Édouard~Manitoba~Nouveau-Brunswick~Nouvelle-Écosse~Nunavut~Ontario~Québec~Saskatchewan~Terre-Neuve-et-Labrador~Territoires du Nord-Ouest~Yukon\",\n    sub_zips:\n      \"T~V~C~R~E~B~X0A|X0B|X0C~K|L|M|N|P~G|H|J|K1A~S|R8A~A~X0E|X0G|X1A~Y\",\n    upper: \"ACNOSZ\",\n    zip: \"[ABCEGHJKLMNPRSTVXY]\\\\d[ABCEGHJ-NPRSTV-Z] ?\\\\d[ABCEGHJ-NPRSTV-Z]\\\\d\",\n    zipex: \"H3Z 2Y7,V8X 3X4,T0L 1K0,T0H 1A0,K1A 0B1\",\n  },\n  \"data/CC\": {\n    fmt: \"%O%n%N%n%A%n%C %S %Z\",\n    id: \"data/CC\",\n    key: \"CC\",\n    name: \"COCOS (KEELING) ISLANDS\",\n    upper: \"CS\",\n    zip: \"6799\",\n    zipex: \"6799\",\n  },\n  \"data/CD\": { id: \"data/CD\", key: \"CD\", name: \"CONGO (DEM. REP.)\" },\n  \"data/CF\": { id: \"data/CF\", key: \"CF\", name: \"CENTRAL AFRICAN REPUBLIC\" },\n  \"data/CG\": { id: \"data/CG\", key: \"CG\", name: \"CONGO (REP.)\" },\n  \"data/CH\": {\n    fmt: \"%O%n%N%n%A%nCH-%Z %C\",\n    id: \"data/CH\",\n    key: \"CH\",\n    name: \"SWITZERLAND\",\n    postprefix: \"CH-\",\n    posturl: \"http://www.post.ch/db/owa/pv_plz_pack/pr_main\",\n    require: \"ACZ\",\n    upper: \"\",\n    zip: \"\\\\d{4}\",\n    zipex: \"2544,1211,1556,3030\",\n  },\n  \"data/CI\": {\n    fmt: \"%N%n%O%n%X %A %C %X\",\n    id: \"data/CI\",\n    key: \"CI\",\n    name: \"COTE D'IVOIRE\",\n  },\n  \"data/CK\": { id: \"data/CK\", key: \"CK\", name: \"COOK ISLANDS\" },\n  \"data/CL\": {\n    fmt: \"%N%n%O%n%A%n%Z %C%n%S\",\n    id: \"data/CL\",\n    key: \"CL\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"CHILE\",\n    posturl: \"http://www.correos.cl/SitePages/home.aspx\",\n    sub_isoids: \"AN~AR~AP~AT~AI~BI~CO~LI~LL~LR~MA~ML~RM~TA~VS\",\n    sub_keys:\n      \"Antofagasta~Araucanía~Arica y Parinacota~Atacama~Aysén~Biobío~Coquimbo~O'Higgins~Los Lagos~Los Ríos~Magallanes~Maule~Región Metropolitana~Tarapacá~Valparaíso\",\n    sub_mores:\n      \"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\",\n    sub_names:\n      \"Antofagasta~Araucanía~Arica y Parinacota~Atacama~Aysén del General Carlos Ibáñez del Campo~Biobío~Coquimbo~Libertador General Bernardo O'Higgins~Los Lagos~Los Ríos~Magallanes y de la Antártica Chilena~Maule~Metropolitana de Santiago~Tarapacá~Valparaíso\",\n    zip: \"\\\\d{7}\",\n    zipex: \"8340457,8720019,1230000,8329100\",\n  },\n  \"data/CM\": { id: \"data/CM\", key: \"CM\", name: \"CAMEROON\" },\n  \"data/CN\": {\n    fmt: \"%Z%n%S%C%D%n%A%n%O%n%N\",\n    id: \"data/CN\",\n    key: \"CN\",\n    lang: \"zh\",\n    languages: \"zh\",\n    lfmt: \"%N%n%O%n%A%n%D%n%C%n%S, %Z\",\n    name: \"CHINA\",\n    posturl: \"http://www.ems.com.cn/serviceguide/you_bian_cha_xun.html\",\n    require: \"ACSZ\",\n    sub_isoids:\n      \"34~92~11~50~35~62~44~45~52~46~13~41~23~42~43~22~32~36~21~15~64~63~37~14~61~31~51~71~12~54~91~65~53~33\",\n    sub_keys:\n      \"安徽省~澳门~北京市~重庆市~福建省~甘肃省~广东省~广西壮族自治区~贵州省~海南省~河北省~河南省~黑龙江省~湖北省~湖南省~吉林省~江苏省~江西省~辽宁省~内蒙古自治区~宁夏回族自治区~青海省~山东省~山西省~陕西省~上海市~四川省~台湾~天津市~西藏自治区~香港~新疆维吾尔自治区~云南省~浙江省\",\n    sub_lnames:\n      \"Anhui Sheng~Macau~Beijing Shi~Chongqing Shi~Fujian Sheng~Gansu Sheng~Guangdong Sheng~Guangxi Zhuangzuzizhiqu~Guizhou Sheng~Hainan Sheng~Hebei Sheng~Henan Sheng~Heilongjiang Sheng~Hubei Sheng~Hunan Sheng~Jilin Sheng~Jiangsu Sheng~Jiangxi Sheng~Liaoning Sheng~Neimenggu Zizhiqu~Ningxia Huizuzizhiqu~Qinghai Sheng~Shandong Sheng~Shanxi Sheng~Shaanxi Sheng~Shanghai Shi~Sichuan Sheng~Taiwan~Tianjin Shi~Xizang Zizhiqu~Hong Kong~Xinjiang Weiwuerzizhiqu~Yunnan Sheng~Zhejiang Sheng\",\n    sub_mores:\n      \"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\",\n    sub_names:\n      \"安徽省~澳门~北京市~重庆市~福建省~甘肃省~广东省~广西~贵州省~海南省~河北省~河南省~黑龙江省~湖北省~湖南省~吉林省~江苏省~江西省~辽宁省~内蒙古~宁夏~青海省~山东省~山西省~陕西省~上海市~四川省~台湾~天津市~西藏~香港~新疆~云南省~浙江省\",\n    sub_xrequires: \"~A~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ACS~~~\",\n    sub_xzips: \"~999078~~~~~~~~~~~~~~~~~~~~~~~~~~\\\\d{3}(\\\\d{2})?~~~999077~~~\",\n    sublocality_name_type: \"district\",\n    upper: \"S\",\n    zip: \"\\\\d{6}\",\n    zipex: \"266033,317204,100096,100808\",\n  },\n  \"data/CO\": {\n    fmt: \"%N%n%O%n%A%n%C, %S, %Z\",\n    id: \"data/CO\",\n    key: \"CO\",\n    name: \"COLOMBIA\",\n    posturl: \"http://www.codigopostal.gov.co/\",\n    require: \"AS\",\n    state_name_type: \"department\",\n    zip: \"\\\\d{6}\",\n    zipex: \"111221,130001,760011\",\n  },\n  \"data/CR\": {\n    fmt: \"%N%n%O%n%A%n%S, %C%n%Z\",\n    id: \"data/CR\",\n    key: \"CR\",\n    name: \"COSTA RICA\",\n    posturl: \"https://www.correos.go.cr/nosotros/codigopostal/busqueda.html\",\n    require: \"ACS\",\n    zip: \"\\\\d{4,5}|\\\\d{3}-\\\\d{4}\",\n    zipex: \"1000,2010,1001\",\n  },\n  \"data/CU\": {\n    fmt: \"%N%n%O%n%A%n%C %S%n%Z\",\n    id: \"data/CU\",\n    key: \"CU\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"CUBA\",\n    sub_isoids: \"15~09~08~06~12~14~11~99~03~10~04~16~01~07~13~05\",\n    sub_keys:\n      \"Artemisa~Camagüey~Ciego de Ávila~Cienfuegos~Granma~Guantánamo~Holguín~Isla de la Juventud~La Habana~Las Tunas~Matanzas~Mayabeque~Pinar del Río~Sancti Spíritus~Santiago de Cuba~Villa Clara\",\n    zip: \"\\\\d{5}\",\n    zipex: \"10700\",\n  },\n  \"data/CV\": {\n    fmt: \"%N%n%O%n%A%n%Z %C%n%S\",\n    id: \"data/CV\",\n    key: \"CV\",\n    lang: \"pt\",\n    languages: \"pt\",\n    name: \"CAPE VERDE\",\n    state_name_type: \"island\",\n    sub_isoids: \"BV~BR~~MA~SL~~~~SV\",\n    sub_keys:\n      \"Boa Vista~Brava~Fogo~Maio~Sal~Santiago~Santo Antão~São Nicolau~São Vicente\",\n    zip: \"\\\\d{4}\",\n    zipex: \"7600\",\n  },\n  \"data/CW\": { id: \"data/CW\", key: \"CW\", name: \"CURACAO\" },\n  \"data/CX\": {\n    fmt: \"%O%n%N%n%A%n%C %S %Z\",\n    id: \"data/CX\",\n    key: \"CX\",\n    name: \"CHRISTMAS ISLAND\",\n    upper: \"CS\",\n    zip: \"6798\",\n    zipex: \"6798\",\n  },\n  \"data/CY\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/CY\",\n    key: \"CY\",\n    name: \"CYPRUS\",\n    zip: \"\\\\d{4}\",\n    zipex: \"2008,3304,1900\",\n  },\n  \"data/CZ\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/CZ\",\n    key: \"CZ\",\n    name: \"CZECH REP.\",\n    posturl: \"http://psc.ceskaposta.cz/CleanForm.action\",\n    require: \"ACZ\",\n    zip: \"\\\\d{3} ?\\\\d{2}\",\n    zipex: \"100 00,251 66,530 87,110 00,225 99\",\n  },\n  \"data/DE\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/DE\",\n    key: \"DE\",\n    name: \"GERMANY\",\n    posturl: \"http://www.postdirekt.de/plzserver/\",\n    require: \"ACZ\",\n    zip: \"\\\\d{5}\",\n    zipex: \"26133,53225\",\n  },\n  \"data/DJ\": { id: \"data/DJ\", key: \"DJ\", name: \"DJIBOUTI\" },\n  \"data/DK\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/DK\",\n    key: \"DK\",\n    name: \"DENMARK\",\n    posturl:\n      \"http://www.postdanmark.dk/da/Privat/Kundeservice/postnummerkort/Sider/Find-postnummer.aspx\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}\",\n    zipex: \"8660,1566\",\n  },\n  \"data/DM\": { id: \"data/DM\", key: \"DM\", name: \"DOMINICA\" },\n  \"data/DO\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/DO\",\n    key: \"DO\",\n    name: \"DOMINICAN REP.\",\n    posturl: \"http://inposdom.gob.do/codigo-postal/\",\n    zip: \"\\\\d{5}\",\n    zipex: \"11903,10101\",\n  },\n  \"data/DZ\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/DZ\",\n    key: \"DZ\",\n    name: \"ALGERIA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"40304,16027\",\n  },\n  \"data/EC\": {\n    fmt: \"%N%n%O%n%A%n%Z%n%C\",\n    id: \"data/EC\",\n    key: \"EC\",\n    name: \"ECUADOR\",\n    posturl: \"http://www.codigopostal.gob.ec/\",\n    upper: \"CZ\",\n    zip: \"\\\\d{6}\",\n    zipex: \"090105,092301\",\n  },\n  \"data/EE\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/EE\",\n    key: \"EE\",\n    name: \"ESTONIA\",\n    posturl: \"https://www.omniva.ee/era/sihtnumbrite_otsing\",\n    zip: \"\\\\d{5}\",\n    zipex: \"69501,11212\",\n  },\n  \"data/EG\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S%n%Z\",\n    id: \"data/EG\",\n    key: \"EG\",\n    lang: \"ar\",\n    languages: \"ar\",\n    lfmt: \"%N%n%O%n%A%n%C%n%S%n%Z\",\n    name: \"EGYPT\",\n    sub_isoids:\n      \"ASN~AST~ALX~IS~LX~BA~BH~GZ~DK~SUZ~SHR~GH~FYM~C~KB~MNF~MN~WAD~BNS~PTS~JS~DT~SHG~SIN~KN~KFS~MT\",\n    sub_keys:\n      \"أسوان~أسيوط~الإسكندرية~الإسماعيلية~الأقصر~البحر الأحمر~البحيرة~الجيزة~الدقهلية~السويس~الشرقية~الغربية~الفيوم~القاهرة~القليوبية~المنوفية~المنيا~الوادي الجديد~بني سويف~بورسعيد~جنوب سيناء~دمياط~سوهاج~شمال سيناء~قنا~كفر الشيخ~مطروح\",\n    sub_lnames:\n      \"Aswan Governorate~Asyut Governorate~Alexandria Governorate~Ismailia Governorate~Luxor Governorate~Red Sea Governorate~El Beheira Governorate~Giza Governorate~Dakahlia Governorate~Suez Governorate~Ash Sharqia Governorate~Gharbia Governorate~Faiyum Governorate~Cairo Governorate~Qalyubia Governorate~Menofia Governorate~Menia Governorate~New Valley Governorate~Beni Suef Governorate~Port Said Governorate~South Sinai Governorate~Damietta Governorate~Sohag Governorate~North Sinai Governorate~Qena Governorate~Kafr El Sheikh Governorate~Matrouh Governorate\",\n    sub_zipexs:\n      \"81000~71000~21000,23000~41000~85000~84000~22000~12000~35000~43000~44000~31000~63000~11000~13000~32000~61000~72000~62000~42000~46000~34000~82000~45000~83000~33000~51000\",\n    sub_zips:\n      \"81~71~2[13]~41~85~84~22~12~35~43~44~31~63~11~13~32~61~72~62~42~46~34~82~45~83~33~51\",\n    zip: \"\\\\d{5}\",\n    zipex: \"12411,11599\",\n  },\n  \"data/EH\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/EH\",\n    key: \"EH\",\n    name: \"WESTERN SAHARA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"70000,72000\",\n  },\n  \"data/ER\": { id: \"data/ER\", key: \"ER\", name: \"ERITREA\" },\n  \"data/ES\": {\n    fmt: \"%N%n%O%n%A%n%Z %C %S\",\n    id: \"data/ES\",\n    key: \"ES\",\n    lang: \"es\",\n    languages: \"es~ca~gl~eu\",\n    name: \"SPAIN\",\n    posturl:\n      \"http://www.correos.es/contenido/13-MenuRec2/04-MenuRec24/1010_s-CodPostal.asp\",\n    require: \"ACSZ\",\n    sub_keys:\n      \"VI~AB~A~AL~O~AV~BA~B~BU~CC~CA~S~CS~CE~CR~CO~CU~GI~GR~GU~SS~H~HU~PM~J~C~LO~GC~LE~L~LU~M~MA~ML~MU~NA~OR~P~PO~SA~TF~SG~SE~SO~T~TE~TO~V~VA~BI~ZA~Z\",\n    sub_names:\n      \"Álava~Albacete~Alicante~Almería~Asturias~Ávila~Badajoz~Barcelona~Burgos~Cáceres~Cádiz~Cantabria~Castellón~Ceuta~Ciudad Real~Córdoba~Cuenca~Girona~Granada~Guadalajara~Guipúzcoa~Huelva~Huesca~Islas Baleares~Jaén~La Coruña~La Rioja~Las Palmas~León~Lérida~Lugo~Madrid~Málaga~Melilla~Murcia~Navarra~Ourense~Palencia~Pontevedra~Salamanca~Santa Cruz de Tenerife~Segovia~Sevilla~Soria~Tarragona~Teruel~Toledo~Valencia~Valladolid~Vizcaya~Zamora~Zaragoza\",\n    sub_zips:\n      \"01~02~03~04~33~05~06~08~09~10~11~39~12~51~13~14~16~17~18~19~20~21~22~07~23~15~26~35~24~25~27~28~29~52~30~31~32~34~36~37~38~40~41~42~43~44~45~46~47~48~49~50\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"28039,28300,28070\",\n  },\n  \"data/ES--ca\": {\n    fmt: \"%N%n%O%n%A%n%Z %C %S\",\n    id: \"data/ES--ca\",\n    key: \"ES\",\n    lang: \"ca\",\n    name: \"SPAIN\",\n    posturl:\n      \"http://www.correos.es/contenido/13-MenuRec2/04-MenuRec24/1010_s-CodPostal.asp\",\n    require: \"ACSZ\",\n    sub_keys:\n      \"A~AB~AL~VI~O~AV~BA~B~BI~BU~CC~CA~S~CS~CE~CR~CO~CU~GI~GR~GU~SS~H~HU~PM~J~C~LO~GC~LE~L~LU~M~MA~ML~MU~NA~OR~P~PO~SA~TF~SG~SE~SO~T~TE~TO~V~VA~ZA~Z\",\n    sub_names:\n      \"Alacant~Albacete~Almeria~Araba~Asturias~Àvila~Badajoz~Barcelona~Bizkaia~Burgos~Cáceres~Cadis~Cantabria~Castelló~Ceuta~Ciudad Real~Córdoba~Cuenca~Girona~Granada~Guadalajara~Guipúscoa~Huelva~Huesca~Illes Balears~Jaén~La Corunya~La Rioja~Las Palmas~León~Lleida~Lugo~Madrid~Málaga~Melilla~Murcia~Navarra~Ourense~Palencia~Pontevedra~Salamanca~Santa Cruz de Tenerife~Segovia~Sevilla~Soria~Tarragona~Teruel~Toledo~València~Valladolid~Zamora~Zaragoza\",\n    sub_zips:\n      \"03~02~04~01~33~05~06~08~48~09~10~11~39~12~51~13~14~16~17~18~19~20~21~22~07~23~15~26~35~24~25~27~28~29~52~30~31~32~34~36~37~38~40~41~42~43~44~45~46~47~49~50\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"28039,28300,28070\",\n  },\n  \"data/ES--eu\": {\n    fmt: \"%N%n%O%n%A%n%Z %C %S\",\n    id: \"data/ES--eu\",\n    key: \"ES\",\n    lang: \"eu\",\n    name: \"SPAIN\",\n    posturl:\n      \"http://www.correos.es/contenido/13-MenuRec2/04-MenuRec24/1010_s-CodPostal.asp\",\n    require: \"ACSZ\",\n    sub_keys:\n      \"A~AB~AL~VI~O~AV~BA~B~BI~BU~CC~CA~S~CS~CE~CR~C~CU~SS~GI~GR~GU~H~HU~PM~J~CO~LO~GC~LE~L~LU~M~MA~ML~MU~NA~OR~P~PO~SA~TF~SG~SE~SO~T~TE~TO~V~VA~ZA~Z\",\n    sub_names:\n      \"Alacant~Albacete~Almería~Araba~Asturias~Ávila~Badajoz~Barcelona~Bizkaia~Burgos~Cáceres~Cádiz~Cantabria~Castelló~Ceuta~Ciudad Real~Coruña~Cuenca~Gipuzkoa~Girona~Granada~Guadalajara~Huelva~Huesca~Illes Balears~Jaén~Kordoba~La Rioja~Las Palmas~León~Lleida~Lugo~Madrid~Málaga~Melilla~Murtzia~Nafarroa~Ourense~Palentzia~Pontevedra~Salamanca~Santa Cruz Tenerifekoa~Segovia~Sevilla~Soria~Tarragona~Teruel~Toledo~Valentzia~Valladolid~Zamora~Zaragoza\",\n    sub_zips:\n      \"03~02~04~01~33~05~06~08~48~09~10~11~39~12~51~13~15~16~20~17~18~19~21~22~07~23~14~26~35~24~25~27~28~29~52~30~31~32~34~36~37~38~40~41~42~43~44~45~46~47~49~50\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"28039,28300,28070\",\n  },\n  \"data/ES--gl\": {\n    fmt: \"%N%n%O%n%A%n%Z %C %S\",\n    id: \"data/ES--gl\",\n    key: \"ES\",\n    lang: \"gl\",\n    name: \"SPAIN\",\n    posturl:\n      \"http://www.correos.es/contenido/13-MenuRec2/04-MenuRec24/1010_s-CodPostal.asp\",\n    require: \"ACSZ\",\n    sub_keys:\n      \"C~A~VI~AB~AL~GC~O~AV~BA~B~BI~BU~CC~CA~S~CS~CE~CR~CO~CU~GR~GU~SS~H~HU~PM~LO~LE~L~LU~M~MA~ML~MU~NA~OR~P~PO~SA~TF~SG~SE~SO~T~TE~TO~V~VA~J~GI~ZA~Z\",\n    sub_names:\n      \"A Coruña~Alacant~Álava~Albacete~Almería~As Palmas~Asturias~Ávila~Badaxoz~Barcelona~Biscaia~Burgos~Cáceres~Cádiz~Cantabria~Castelló~Ceuta~Cidade Real~Córdoba~Cuenca~Granada~Guadalajara~Guipúscoa~Huelva~Huesca~Illas Baleares~La Rioja~León~Lleida~Lugo~Madrid~Málaga~Melilla~Murcia~Navarra~Ourense~Palencia~Pontevedra~Salamanca~Santa Cruz de Tenerife~Segovia~Sevilla~Soria~Tarragona~Teruel~Toledo~Valencia~Valladolid~Xaén~Xirona~Zamora~Zaragoza\",\n    sub_zips:\n      \"15~03~01~02~04~35~33~05~06~08~48~09~10~11~39~12~51~13~14~16~18~19~20~21~22~07~26~24~25~27~28~29~52~30~31~32~34~36~37~38~40~41~42~43~44~45~46~47~23~17~49~50\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"28039,28300,28070\",\n  },\n  \"data/ET\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/ET\",\n    key: \"ET\",\n    name: \"ETHIOPIA\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1000\",\n  },\n  \"data/FI\": {\n    fmt: \"%O%n%N%n%A%nFI-%Z %C\",\n    id: \"data/FI\",\n    key: \"FI\",\n    name: \"FINLAND\",\n    postprefix: \"FI-\",\n    posturl: \"http://www.verkkoposti.com/e3/postinumeroluettelo\",\n    require: \"ACZ\",\n    zip: \"\\\\d{5}\",\n    zipex: \"00550,00011\",\n  },\n  \"data/FJ\": { id: \"data/FJ\", key: \"FJ\", name: \"FIJI\" },\n  \"data/FK\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/FK\",\n    key: \"FK\",\n    name: \"FALKLAND ISLANDS (MALVINAS)\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"FIQQ 1ZZ\",\n    zipex: \"FIQQ 1ZZ\",\n  },\n  \"data/FM\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/FM\",\n    key: \"FM\",\n    name: \"MICRONESIA (Federated State of)\",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    upper: \"ACNOS\",\n    zip: \"(9694[1-4])(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"96941,96944\",\n  },\n  \"data/FO\": {\n    fmt: \"%N%n%O%n%A%nFO%Z %C\",\n    id: \"data/FO\",\n    key: \"FO\",\n    name: \"FAROE ISLANDS\",\n    postprefix: \"FO\",\n    posturl: \"http://www.postur.fo/\",\n    zip: \"\\\\d{3}\",\n    zipex: \"100\",\n  },\n  \"data/FR\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/FR\",\n    key: \"FR\",\n    name: \"FRANCE\",\n    posturl:\n      \"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\",\n    require: \"ACZ\",\n    upper: \"CX\",\n    zip: \"\\\\d{2} ?\\\\d{3}\",\n    zipex: \"33380,34092,33506\",\n  },\n  \"data/GA\": { id: \"data/GA\", key: \"GA\", name: \"GABON\" },\n  \"data/GB\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/GB\",\n    key: \"GB\",\n    locality_name_type: \"post_town\",\n    name: \"UNITED KINGDOM\",\n    posturl: \"http://www.royalmail.com/postcode-finder\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"GIR ?0AA|(?:(?:AB|AL|B|BA|BB|BD|BF|BH|BL|BN|BR|BS|BT|BX|CA|CB|CF|CH|CM|CO|CR|CT|CV|CW|DA|DD|DE|DG|DH|DL|DN|DT|DY|E|EC|EH|EN|EX|FK|FY|G|GL|GY|GU|HA|HD|HG|HP|HR|HS|HU|HX|IG|IM|IP|IV|JE|KA|KT|KW|KY|L|LA|LD|LE|LL|LN|LS|LU|M|ME|MK|ML|N|NE|NG|NN|NP|NR|NW|OL|OX|PA|PE|PH|PL|PO|PR|RG|RH|RM|S|SA|SE|SG|SK|SL|SM|SN|SO|SP|SR|SS|ST|SW|SY|TA|TD|TF|TN|TQ|TR|TS|TW|UB|W|WA|WC|WD|WF|WN|WR|WS|WV|YO|ZE)(?:\\\\d[\\\\dA-Z]? ?\\\\d[ABD-HJLN-UW-Z]{2}))|BFPO ?\\\\d{1,4}\",\n    zipex:\n      \"EC1Y 8SY,GIR 0AA,M2 5BQ,M34 4AB,CR0 2YR,DN16 9AA,W1A 4ZZ,EC1A 1HQ,OX14 4PG,BS18 8HF,NR25 7HG,RH6 0NP,BH23 6AA,B6 5BA,SO23 9AP,PO1 3AX,BFPO 61\",\n  },\n  \"data/GD\": { id: \"data/GD\", key: \"GD\", name: \"GRENADA (WEST INDIES)\" },\n  \"data/GE\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/GE\",\n    key: \"GE\",\n    name: \"GEORGIA\",\n    posturl: \"http://www.georgianpost.ge/index.php?page=10\",\n    zip: \"\\\\d{4}\",\n    zipex: \"0101\",\n  },\n  \"data/GF\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/GF\",\n    key: \"GF\",\n    name: \"FRENCH GUIANA\",\n    posturl:\n      \"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"9[78]3\\\\d{2}\",\n    zipex: \"97300\",\n  },\n  \"data/GG\": {\n    fmt: \"%N%n%O%n%A%n%C%nGUERNSEY%n%Z\",\n    id: \"data/GG\",\n    key: \"GG\",\n    name: \"CHANNEL ISLANDS\",\n    posturl: \"http://www.guernseypost.com/postcode_finder/\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"GY\\\\d[\\\\dA-Z]? ?\\\\d[ABD-HJLN-UW-Z]{2}\",\n    zipex: \"GY1 1AA,GY2 2BT\",\n  },\n  \"data/GH\": { id: \"data/GH\", key: \"GH\", name: \"GHANA\" },\n  \"data/GI\": {\n    fmt: \"%N%n%O%n%A%nGIBRALTAR%n%Z\",\n    id: \"data/GI\",\n    key: \"GI\",\n    name: \"GIBRALTAR\",\n    require: \"A\",\n    zip: \"GX11 1AA\",\n    zipex: \"GX11 1AA\",\n  },\n  \"data/GL\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/GL\",\n    key: \"GL\",\n    name: \"GREENLAND\",\n    require: \"ACZ\",\n    zip: \"39\\\\d{2}\",\n    zipex: \"3900,3950,3911\",\n  },\n  \"data/GM\": { id: \"data/GM\", key: \"GM\", name: \"GAMBIA\" },\n  \"data/GN\": {\n    fmt: \"%N%n%O%n%Z %A %C\",\n    id: \"data/GN\",\n    key: \"GN\",\n    name: \"GUINEA\",\n    zip: \"\\\\d{3}\",\n    zipex: \"001,200,100\",\n  },\n  \"data/GP\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/GP\",\n    key: \"GP\",\n    name: \"GUADELOUPE\",\n    posturl:\n      \"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"9[78][01]\\\\d{2}\",\n    zipex: \"97100\",\n  },\n  \"data/GQ\": { id: \"data/GQ\", key: \"GQ\", name: \"EQUATORIAL GUINEA\" },\n  \"data/GR\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/GR\",\n    key: \"GR\",\n    name: \"GREECE\",\n    posturl: \"http://www.elta.gr/findapostcode.aspx\",\n    require: \"ACZ\",\n    zip: \"\\\\d{3} ?\\\\d{2}\",\n    zipex: \"151 24,151 10,101 88\",\n  },\n  \"data/GS\": {\n    fmt: \"%N%n%O%n%A%n%n%C%n%Z\",\n    id: \"data/GS\",\n    key: \"GS\",\n    name: \"SOUTH GEORGIA\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"SIQQ 1ZZ\",\n    zipex: \"SIQQ 1ZZ\",\n  },\n  \"data/GT\": {\n    fmt: \"%N%n%O%n%A%n%Z- %C\",\n    id: \"data/GT\",\n    key: \"GT\",\n    name: \"GUATEMALA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"09001,01501\",\n  },\n  \"data/GU\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/GU\",\n    key: \"GU\",\n    name: \"GUAM\",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACZ\",\n    upper: \"ACNO\",\n    zip: \"(969(?:[12]\\\\d|3[12]))(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"96910,96931\",\n  },\n  \"data/GW\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/GW\",\n    key: \"GW\",\n    name: \"GUINEA-BISSAU\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1000,1011\",\n  },\n  \"data/GY\": { id: \"data/GY\", key: \"GY\", name: \"GUYANA\" },\n  \"data/HK\": {\n    fmt: \"%S%n%C%n%A%n%O%n%N\",\n    id: \"data/HK\",\n    key: \"HK\",\n    lang: \"zh-Hant\",\n    languages: \"zh-Hant~en\",\n    lfmt: \"%N%n%O%n%A%n%C%n%S\",\n    locality_name_type: \"district\",\n    name: \"HONG KONG\",\n    require: \"AS\",\n    state_name_type: \"area\",\n    sub_keys: \"Kowloon~Hong Kong Island~New Territories\",\n    sub_mores: \"true~true~true\",\n    sub_names: \"九龍~香港島~新界\",\n    upper: \"S\",\n  },\n  \"data/HK--en\": {\n    fmt: \"%S%n%C%n%A%n%O%n%N\",\n    id: \"data/HK--en\",\n    key: \"HK\",\n    lang: \"en\",\n    lfmt: \"%N%n%O%n%A%n%C%n%S\",\n    locality_name_type: \"district\",\n    name: \"HONG KONG\",\n    require: \"AS\",\n    state_name_type: \"area\",\n    sub_keys: \"Hong Kong Island~Kowloon~New Territories\",\n    sub_lnames: \"Hong Kong Island~Kowloon~New Territories\",\n    sub_mores: \"true~true~true\",\n    upper: \"S\",\n  },\n  \"data/HM\": {\n    fmt: \"%O%n%N%n%A%n%C %S %Z\",\n    id: \"data/HM\",\n    key: \"HM\",\n    name: \"HEARD AND MCDONALD ISLANDS\",\n    upper: \"CS\",\n    zip: \"\\\\d{4}\",\n    zipex: \"7050\",\n  },\n  \"data/HN\": {\n    fmt: \"%N%n%O%n%A%n%C, %S%n%Z\",\n    id: \"data/HN\",\n    key: \"HN\",\n    name: \"HONDURAS\",\n    require: \"ACS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"31301\",\n  },\n  \"data/HR\": {\n    fmt: \"%N%n%O%n%A%nHR-%Z %C\",\n    id: \"data/HR\",\n    key: \"HR\",\n    name: \"CROATIA\",\n    postprefix: \"HR-\",\n    posturl: \"http://www.posta.hr/default.aspx?pretpum\",\n    zip: \"\\\\d{5}\",\n    zipex: \"10000,21001,10002\",\n  },\n  \"data/HT\": {\n    fmt: \"%N%n%O%n%A%nHT%Z %C\",\n    id: \"data/HT\",\n    key: \"HT\",\n    name: \"HAITI\",\n    postprefix: \"HT\",\n    zip: \"\\\\d{4}\",\n    zipex: \"6120,5310,6110,8510\",\n  },\n  \"data/HU\": {\n    fmt: \"%N%n%O%n%C%n%A%n%Z\",\n    id: \"data/HU\",\n    key: \"HU\",\n    name: \"HUNGARY (Rep.)\",\n    posturl: \"http://posta.hu/ugyfelszolgalat/iranyitoszam_kereso\",\n    require: \"ACZ\",\n    upper: \"ACNO\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1037,2380,1540\",\n  },\n  \"data/ID\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S %Z\",\n    id: \"data/ID\",\n    key: \"ID\",\n    lang: \"id\",\n    languages: \"id\",\n    name: \"INDONESIA\",\n    require: \"AS\",\n    sub_isoids:\n      \"AC~BA~BT~BE~YO~JK~GO~JA~JB~JT~JI~KB~KS~KT~KI~KU~BB~KR~LA~MA~MU~NB~NT~PA~PB~RI~SR~SN~ST~SG~SA~SB~SS~SU\",\n    sub_keys:\n      \"Aceh~Bali~Banten~Bengkulu~Daerah Istimewa Yogyakarta~DKI Jakarta~Gorontalo~Jambi~Jawa Barat~Jawa Tengah~Jawa Timur~Kalimantan Barat~Kalimantan Selatan~Kalimantan Tengah~Kalimantan Timur~Kalimantan Utara~Kepulauan Bangka Belitung~Kepulauan Riau~Lampung~Maluku~Maluku Utara~Nusa Tenggara Barat~Nusa Tenggara Timur~Papua~Papua Barat~Riau~Sulawesi Barat~Sulawesi Selatan~Sulawesi Tengah~Sulawesi Tenggara~Sulawesi Utara~Sumatera Barat~Sumatera Selatan~Sumatera Utara\",\n    zip: \"\\\\d{5}\",\n    zipex: \"40115\",\n  },\n  \"data/IE\": {\n    fmt: \"%N%n%O%n%A%n%D%n%C%n%S %Z\",\n    id: \"data/IE\",\n    key: \"IE\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"IRELAND\",\n    posturl: \"https://finder.eircode.ie\",\n    state_name_type: \"county\",\n    sub_isoids:\n      \"CW~CN~CE~C~DL~D~G~KY~KE~KK~LS~LM~LK~LD~LH~MO~MH~MN~OY~RN~SO~TA~WD~WH~WX~WW\",\n    sub_keys:\n      \"Co. Carlow~Co. Cavan~Co. Clare~Co. Cork~Co. Donegal~Co. Dublin~Co. Galway~Co. Kerry~Co. Kildare~Co. Kilkenny~Co. Laois~Co. Leitrim~Co. Limerick~Co. Longford~Co. Louth~Co. Mayo~Co. Meath~Co. Monaghan~Co. Offaly~Co. Roscommon~Co. Sligo~Co. Tipperary~Co. Waterford~Co. Westmeath~Co. Wexford~Co. Wicklow\",\n    sublocality_name_type: \"townland\",\n    zip: \"[\\\\dA-Z]{3} ?[\\\\dA-Z]{4}\",\n    zip_name_type: \"eircode\",\n    zipex: \"A65 F4E2\",\n  },\n  \"data/IL\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/IL\",\n    key: \"IL\",\n    name: \"ISRAEL\",\n    posturl: \"http://www.israelpost.co.il/zipcode.nsf/demozip?openform\",\n    zip: \"\\\\d{5}(?:\\\\d{2})?\",\n    zipex: \"9614303\",\n  },\n  \"data/IM\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/IM\",\n    key: \"IM\",\n    name: \"ISLE OF MAN\",\n    posturl: \"https://www.iompost.com/tools-forms/postcode-finder/\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"IM\\\\d[\\\\dA-Z]? ?\\\\d[ABD-HJLN-UW-Z]{2}\",\n    zipex: \"IM2 1AA,IM99 1PS\",\n  },\n  \"data/IN\": {\n    fmt: \"%N%n%O%n%A%n%C %Z%n%S\",\n    id: \"data/IN\",\n    key: \"IN\",\n    lang: \"en\",\n    languages: \"en~hi\",\n    name: \"INDIA\",\n    posturl: \"https://www.indiapost.gov.in/vas/pages/FindPinCode.aspx\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    sub_isoids:\n      \"AN~AP~AR~AS~BR~CH~CT~DN~DD~DL~GA~GJ~HR~HP~JK~JH~KA~KL~LD~MP~MH~MN~ML~MZ~NL~OR~PY~PB~RJ~SK~TN~TG~TR~UP~UT~WB\",\n    sub_keys:\n      \"Andaman and Nicobar Islands~Andhra Pradesh~Arunachal Pradesh~Assam~Bihar~Chandigarh~Chhattisgarh~Dadra and Nagar Haveli~Daman and Diu~Delhi~Goa~Gujarat~Haryana~Himachal Pradesh~Jammu and Kashmir~Jharkhand~Karnataka~Kerala~Lakshadweep~Madhya Pradesh~Maharashtra~Manipur~Meghalaya~Mizoram~Nagaland~Odisha~Puducherry~Punjab~Rajasthan~Sikkim~Tamil Nadu~Telangana~Tripura~Uttar Pradesh~Uttarakhand~West Bengal\",\n    sub_names:\n      \"Andaman & Nicobar~Andhra Pradesh~Arunachal Pradesh~Assam~Bihar~Chandigarh~Chhattisgarh~Dadra & Nagar Haveli~Daman & Diu~Delhi~Goa~Gujarat~Haryana~Himachal Pradesh~Jammu & Kashmir~Jharkhand~Karnataka~Kerala~Lakshadweep~Madhya Pradesh~Maharashtra~Manipur~Meghalaya~Mizoram~Nagaland~Odisha~Puducherry~Punjab~Rajasthan~Sikkim~Tamil Nadu~Telangana~Tripura~Uttar Pradesh~Uttarakhand~West Bengal\",\n    sub_zips:\n      \"744~5[0-3]~79[0-2]~78~8[0-5]~16|1440[3-9]~49~396~396~11~403~3[6-9]~1[23]~17~1[89]~81[4-9]|82|83[0-5]~5[4-9]|53[7-9]~6[7-9]|6010|607008|777~682~4[5-8]|490~4[0-4]~79[56]~79[34]~796~79[78]~7[5-7]~60[579]~1[456]~3[0-4]~737|750~6[0-6]|536~5[0-3]~799~2[0-35-8]|24[0-7]|26[12]~24[46-9]|254|26[23]~7[0-4]\",\n    zip: \"\\\\d{6}\",\n    zip_name_type: \"pin\",\n    zipex: \"110034,110001\",\n  },\n  \"data/IN--hi\": {\n    fmt: \"%N%n%O%n%A%n%C %Z%n%S\",\n    id: \"data/IN--hi\",\n    key: \"IN\",\n    lang: \"hi\",\n    name: \"INDIA\",\n    posturl: \"https://www.indiapost.gov.in/vas/pages/FindPinCode.aspx\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    sub_isoids:\n      \"AN~AR~AS~AP~UP~UT~OR~KA~KL~GJ~GA~CH~CT~JK~JH~TN~TG~TR~DD~DN~DL~NL~PB~WB~PY~BR~MN~MP~MH~MZ~ML~RJ~LD~SK~HR~HP\",\n    sub_keys:\n      \"Andaman & Nicobar~Arunachal Pradesh~Assam~Andhra Pradesh~Uttar Pradesh~Uttarakhand~Odisha~Karnataka~Kerala~Gujarat~Goa~Chandigarh~Chhattisgarh~Jammu & Kashmir~Jharkhand~Tamil Nadu~Telangana~Tripura~Daman & Diu~Dadra & Nagar Haveli~Delhi~Nagaland~Punjab~West Bengal~Puducherry~Bihar~Manipur~Madhya Pradesh~Maharashtra~Mizoram~Meghalaya~Rajasthan~Lakshadweep~Sikkim~Haryana~Himachal Pradesh\",\n    sub_names:\n      \"अंडमान और निकोबार द्वीपसमूह~अरुणाचल प्रदेश~असम~आंध्र प्रदेश~उत्तर प्रदेश~उत्तराखण्ड~ओड़िशा~कर्नाटक~केरल~गुजरात~गोआ~चंडीगढ़~छत्तीसगढ़~जम्मू और कश्मीर~झारखण्ड~तमिल नाडु~तेलंगाना~त्रिपुरा~दमन और दीव~दादरा और नगर हवेली~दिल्ली~नागालैंड~पंजाब~पश्चिम बंगाल~पांडिचेरी~बिहार~मणिपुर~मध्य प्रदेश~महाराष्ट्र~मिजोरम~मेघालय~राजस्थान~लक्षद्वीप~सिक्किम~हरियाणा~हिमाचल प्रदेश\",\n    sub_zips:\n      \"744~79[0-2]~78~5[0-3]~2[0-35-8]|24[0-7]|26[12]~24[46-9]|254|26[23]~7[5-7]~5[4-9]|53[7-9]~6[7-9]|6010|607008|777~3[6-9]~403~16|1440[3-9]~49~1[89]~81[4-9]|82|83[0-5]~6[0-6]|536~5[0-3]~799~396~396~11~79[78]~1[456]~7[0-4]~60[579]~8[0-5]~79[56]~4[5-8]|490~4[0-4]~796~79[34]~3[0-4]~682~737|750~1[23]~17\",\n    zip: \"\\\\d{6}\",\n    zip_name_type: \"pin\",\n    zipex: \"110034,110001\",\n  },\n  \"data/IO\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/IO\",\n    key: \"IO\",\n    name: \"BRITISH INDIAN OCEAN TERRITORY\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"BBND 1ZZ\",\n    zipex: \"BBND 1ZZ\",\n  },\n  \"data/IQ\": {\n    fmt: \"%O%n%N%n%A%n%C, %S%n%Z\",\n    id: \"data/IQ\",\n    key: \"IQ\",\n    name: \"IRAQ\",\n    require: \"ACS\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"31001\",\n  },\n  \"data/IR\": {\n    fmt: \"%O%n%N%n%S%n%C, %D%n%A%n%Z\",\n    id: \"data/IR\",\n    key: \"IR\",\n    lang: \"fa\",\n    languages: \"fa\",\n    name: \"IRAN\",\n    sub_isoids:\n      \"01~02~03~04~32~05~06~07~08~29~30~31~10~11~12~13~14~28~26~16~15~17~18~27~19~20~21~22~23~24~25\",\n    sub_keys:\n      \"استان آذربایجان شرقی~استان آذربایجان غربی~استان اردبیل~استان اصفهان~استان البرز~استان ایلام~استان بوشهر~استان تهران~استان چهارمحال و بختیاری~استان خراسان جنوبی~استان خراسان رضوی~استان خراسان شمالی~استان خوزستان~استان زنجان~استان سمنان~استان سیستان و بلوچستان~استان فارس~استان قزوین~استان قم~استان کردستان~استان کرمان~استان کرمانشاه~استان کهگیلویه و بویراحمد~استان گلستان~استان گیلان~استان لرستان~استان مازندران~استان مرکزی~استان هرمزگان~استان همدان~استان یزد\",\n    sub_lnames:\n      \"East Azerbaijan Province~West Azerbaijan Province~Ardabil Province~Isfahan Province~Alborz Province~Ilam Province~Bushehr Province~Tehran Province~Chaharmahal and Bakhtiari Province~South Khorasan Province~Razavi Khorasan Province~North Khorasan Province~Khuzestan Province~Zanjan Province~Semnan Province~Sistan and Baluchestan Province~Fars Province~Qazvin Province~Qom Province~Kurdistan Province~Kerman Province~Kermanshah Province~Kohgiluyeh and Boyer-Ahmad Province~Golestan Province~Gilan Province~Lorestan Province~Mazandaran Province~Markazi Province~Hormozgan Province~Hamadan Province~Yazd Province\",\n    sublocality_name_type: \"neighborhood\",\n    zip: \"\\\\d{5}-?\\\\d{5}\",\n    zipex: \"11936-12345\",\n  },\n  \"data/IS\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/IS\",\n    key: \"IS\",\n    name: \"ICELAND\",\n    posturl: \"http://www.postur.is/einstaklingar/posthus/postnumer/\",\n    zip: \"\\\\d{3}\",\n    zipex: \"320,121,220,110\",\n  },\n  \"data/IT\": {\n    fmt: \"%N%n%O%n%A%n%Z %C %S\",\n    id: \"data/IT\",\n    key: \"IT\",\n    lang: \"it\",\n    languages: \"it\",\n    name: \"ITALY\",\n    posturl: \"http://www.poste.it/online/cercacap/\",\n    require: \"ACSZ\",\n    sub_isoids:\n      \"AG~AL~AN~AO~AR~AP~AT~AV~BA~BT~BL~BN~BG~BI~BO~BZ~BS~BR~CA~CL~CB~CI~CE~CT~CZ~CH~CO~CS~CR~KR~CN~EN~FM~FE~FI~FG~FC~FR~GE~GO~GR~IM~IS~AQ~SP~LT~LE~LC~LI~LO~LU~MC~MN~MS~MT~VS~ME~MI~MO~MB~NA~NO~NU~OG~OT~OR~PD~PA~PR~PV~PG~PU~PE~PC~PI~PT~PN~PZ~PO~RG~RA~RC~RE~RI~RN~RM~RO~SA~SS~SV~SI~SR~SO~TA~TE~TR~TO~TP~TN~TV~TS~UD~VA~VE~VB~VC~VR~VV~VI~VT\",\n    sub_keys:\n      \"AG~AL~AN~AO~AR~AP~AT~AV~BA~BT~BL~BN~BG~BI~BO~BZ~BS~BR~CA~CL~CB~CI~CE~CT~CZ~CH~CO~CS~CR~KR~CN~EN~FM~FE~FI~FG~FC~FR~GE~GO~GR~IM~IS~AQ~SP~LT~LE~LC~LI~LO~LU~MC~MN~MS~MT~VS~ME~MI~MO~MB~NA~NO~NU~OG~OT~OR~PD~PA~PR~PV~PG~PU~PE~PC~PI~PT~PN~PZ~PO~RG~RA~RC~RE~RI~RN~RM~RO~SA~SS~SV~SI~SR~SO~TA~TE~TR~TO~TP~TN~TV~TS~UD~VA~VE~VB~VC~VR~VV~VI~VT\",\n    sub_names:\n      \"Agrigento~Alessandria~Ancona~Aosta~Arezzo~Ascoli Piceno~Asti~Avellino~Bari~Barletta-Andria-Trani~Belluno~Benevento~Bergamo~Biella~Bologna~Bolzano~Brescia~Brindisi~Cagliari~Caltanissetta~Campobasso~Carbonia-Iglesias~Caserta~Catania~Catanzaro~Chieti~Como~Cosenza~Cremona~Crotone~Cuneo~Enna~Fermo~Ferrara~Firenze~Foggia~Forlì-Cesena~Frosinone~Genova~Gorizia~Grosseto~Imperia~Isernia~L'Aquila~La Spezia~Latina~Lecce~Lecco~Livorno~Lodi~Lucca~Macerata~Mantova~Massa-Carrara~Matera~Medio Campidano~Messina~Milano~Modena~Monza e Brianza~Napoli~Novara~Nuoro~Ogliastra~Olbia-Tempio~Oristano~Padova~Palermo~Parma~Pavia~Perugia~Pesaro e Urbino~Pescara~Piacenza~Pisa~Pistoia~Pordenone~Potenza~Prato~Ragusa~Ravenna~Reggio Calabria~Reggio Emilia~Rieti~Rimini~Roma~Rovigo~Salerno~Sassari~Savona~Siena~Siracusa~Sondrio~Taranto~Teramo~Terni~Torino~Trapani~Trento~Treviso~Trieste~Udine~Varese~Venezia~Verbano-Cusio-Ossola~Vercelli~Verona~Vibo Valentia~Vicenza~Viterbo\",\n    sub_zips:\n      \"92~15~60~11~52~63~14~83~70~76[01]~32~82~24~13[89]~40~39~25~72~0912[1-9]|0913[0-4]|0901[0289]|0902[03468]|0903[0234]|0904|0803[035]|08043~93~860[1-4]|86100~0901[013-7]~81~95~88[01]~66~22~87~26[01]~88[89]~12|18025~94~638|63900~44~50~71~47[015]~03~16~34[01]7~58~18~860[7-9]|86170~67~19~04~73~23[89]~57~26[89]~55~62~46~54~75~0902[012579]|0903[015-9]|09040~98~20~41~208|20900~80~28[01]~080[1-3]|08100~08037|0804[024-9]~08020|0702|0703[08]~090[7-9]|09170|0801[039]|0803[04]~35~90~43~27~06~61~65~29~56~51~330[7-9]|33170~85~59~97~48~89[01]~42~02~47[89]~00~45~84~070[14]|0703[0-79]|07100~17|12071~53~96~23[01]~74~64~05~10~91~38~31~3401|341[0-689]|34062~330[1-5]|33100~21~30~28[89]~13[01]~37~89[89]~36~01\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"00144,47037,39049\",\n  },\n  \"data/JE\": {\n    fmt: \"%N%n%O%n%A%n%C%nJERSEY%n%Z\",\n    id: \"data/JE\",\n    key: \"JE\",\n    name: \"CHANNEL ISLANDS\",\n    posturl: \"http://www.jerseypost.com/tools/postcode-address-finder/\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"JE\\\\d[\\\\dA-Z]? ?\\\\d[ABD-HJLN-UW-Z]{2}\",\n    zipex: \"JE1 1AA,JE2 2BT\",\n  },\n  \"data/JM\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S %X\",\n    id: \"data/JM\",\n    key: \"JM\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"JAMAICA\",\n    require: \"ACS\",\n    state_name_type: \"parish\",\n    sub_isoids: \"13~09~01~12~04~02~06~14~11~08~05~03~07~10\",\n    sub_keys:\n      \"Clarendon~Hanover~Kingston~Manchester~Portland~St. Andrew~St. Ann~St. Catherine~St. Elizabeth~St. James~St. Mary~St. Thomas~Trelawny~Westmoreland\",\n  },\n  \"data/JO\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/JO\",\n    key: \"JO\",\n    name: \"JORDAN\",\n    zip: \"\\\\d{5}\",\n    zipex: \"11937,11190\",\n  },\n  \"data/JP\": {\n    fmt: \"〒%Z%n%S%n%A%n%O%n%N\",\n    id: \"data/JP\",\n    key: \"JP\",\n    lang: \"ja\",\n    languages: \"ja\",\n    lfmt: \"%N%n%O%n%A, %S%n%Z\",\n    name: \"JAPAN\",\n    posturl: \"http://www.post.japanpost.jp/zipcode/\",\n    require: \"ASZ\",\n    state_name_type: \"prefecture\",\n    sub_isoids:\n      \"01~02~03~04~05~06~07~08~09~10~11~12~13~14~15~16~17~18~19~20~21~22~23~24~25~26~27~28~29~30~31~32~33~34~35~36~37~38~39~40~41~42~43~44~45~46~47\",\n    sub_keys:\n      \"北海道~青森県~岩手県~宮城県~秋田県~山形県~福島県~茨城県~栃木県~群馬県~埼玉県~千葉県~東京都~神奈川県~新潟県~富山県~石川県~福井県~山梨県~長野県~岐阜県~静岡県~愛知県~三重県~滋賀県~京都府~大阪府~兵庫県~奈良県~和歌山県~鳥取県~島根県~岡山県~広島県~山口県~徳島県~香川県~愛媛県~高知県~福岡県~佐賀県~長崎県~熊本県~大分県~宮崎県~鹿児島県~沖縄県\",\n    sub_lnames:\n      \"Hokkaido~Aomori~Iwate~Miyagi~Akita~Yamagata~Fukushima~Ibaraki~Tochigi~Gunma~Saitama~Chiba~Tokyo~Kanagawa~Niigata~Toyama~Ishikawa~Fukui~Yamanashi~Nagano~Gifu~Shizuoka~Aichi~Mie~Shiga~Kyoto~Osaka~Hyogo~Nara~Wakayama~Tottori~Shimane~Okayama~Hiroshima~Yamaguchi~Tokushima~Kagawa~Ehime~Kochi~Fukuoka~Saga~Nagasaki~Kumamoto~Oita~Miyazaki~Kagoshima~Okinawa\",\n    sub_zips:\n      \"0[4-9]|00[1-7]~03|018~02~98~01~99~9[67]~3[01]~32|311|349~37|38[49]~3[3-6]~2[6-9]~1[0-8]|19[0-8]|20~2[1-5]|199~9[45]|389~93~92|939~91|922~40~3[89]|949~50~4[1-9]~4[4-9]|431~51|498|647~52~6[0-2]|520~5[3-9]|618|630~6[5-7]|563~63|64[78]~64|519~68~69|68[45]~7[01]~7[23]~7[45]~77~76~79~78~8[0-3]|871~84~85|81[17]|848~86~87|839~88~89~90\",\n    upper: \"S\",\n    zip: \"\\\\d{3}-?\\\\d{4}\",\n    zipex: \"154-0023,350-1106,951-8073,112-0001,208-0032,231-0012\",\n  },\n  \"data/KE\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/KE\",\n    key: \"KE\",\n    name: \"KENYA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"20100,00100\",\n  },\n  \"data/KG\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/KG\",\n    key: \"KG\",\n    name: \"KYRGYZSTAN\",\n    zip: \"\\\\d{6}\",\n    zipex: \"720001\",\n  },\n  \"data/KH\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/KH\",\n    key: \"KH\",\n    name: \"CAMBODIA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"12203,14206,12000\",\n  },\n  \"data/KI\": {\n    fmt: \"%N%n%O%n%A%n%S%n%C\",\n    id: \"data/KI\",\n    key: \"KI\",\n    name: \"KIRIBATI\",\n    state_name_type: \"island\",\n    upper: \"ACNOS\",\n  },\n  \"data/KM\": { id: \"data/KM\", key: \"KM\", name: \"COMOROS\", upper: \"AC\" },\n  \"data/KN\": {\n    fmt: \"%N%n%O%n%A%n%C, %S\",\n    id: \"data/KN\",\n    key: \"KN\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"SAINT KITTS AND NEVIS\",\n    require: \"ACS\",\n    state_name_type: \"island\",\n    sub_isoids: \"N~K\",\n    sub_keys: \"Nevis~St. Kitts\",\n  },\n  \"data/KP\": {\n    fmt: \"%Z%n%S%n%C%n%A%n%O%n%N\",\n    id: \"data/KP\",\n    key: \"KP\",\n    lang: \"ko\",\n    languages: \"ko\",\n    lfmt: \"%N%n%O%n%A%n%C%n%S, %Z\",\n    name: \"NORTH KOREA\",\n    sub_isoids: \"07~13~10~04~02~03~01~08~09~05~06\",\n    sub_keys:\n      \"강원도~라선 특별시~량강도~자강도~평안 남도~평안 북도~평양 직할시~함경 남도~함경 북도~황해남도~황해북도\",\n    sub_lnames:\n      \"Kangwon~Rason~Ryanggang~Chagang~South Pyongan~North Pyongan~Pyongyang~South Hamgyong~North Hamgyong~South Hwanghae~North Hwanghae\",\n  },\n  \"data/KR\": {\n    fmt: \"%S %C%D%n%A%n%O%n%N%n%Z\",\n    id: \"data/KR\",\n    key: \"KR\",\n    lang: \"ko\",\n    languages: \"ko\",\n    lfmt: \"%N%n%O%n%A%n%D%n%C%n%S%n%Z\",\n    name: \"SOUTH KOREA\",\n    posturl: \"http://www.epost.go.kr/search/zipcode/search5.jsp\",\n    require: \"ACSZ\",\n    state_name_type: \"do_si\",\n    sub_isoids: \"42~41~48~47~29~27~30~26~11~50~31~28~46~45~49~44~43\",\n    sub_keys:\n      \"강원도~경기도~경상남도~경상북도~광주광역시~대구광역시~대전광역시~부산광역시~서울특별시~세종특별자치시~울산광역시~인천광역시~전라남도~전라북도~제주특별자치도~충청남도~충청북도\",\n    sub_lnames:\n      \"Gangwon-do~Gyeonggi-do~Gyeongsangnam-do~Gyeongsangbuk-do~Gwangju~Daegu~Daejeon~Busan~Seoul~Sejong~Ulsan~Incheon~Jeollanam-do~Jeollabuk-do~Jeju-do~Chungcheongnam-do~Chungcheongbuk-do\",\n    sub_mores:\n      \"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\",\n    sub_names:\n      \"강원~경기~경남~경북~광주~대구~대전~부산~서울~세종~울산~인천~전남~전북~제주~충남~충북\",\n    sub_zipexs:\n      \"25627~12410~53286~38540~62394~42456~34316~46706~06321~30065~44782~23024~59222~56445~63563~32832~28006\",\n    sub_zips:\n      \"2[456]\\\\d{2}~1[0-8]\\\\d{2}~5[0-3]\\\\d{2}~(?:3[6-9]|40)\\\\d{2}~6[12]\\\\d{2}~4[12]\\\\d{2}~3[45]\\\\d{2}~4[6-9]\\\\d{2}~0[1-8]\\\\d{2}~30[01]\\\\d~4[45]\\\\d{2}~2[1-3]\\\\d{2}~5[7-9]\\\\d{2}~5[4-6]\\\\d{2}~63[0-356]\\\\d~3[1-3]\\\\d{2}~2[789]\\\\d{2}\",\n    sublocality_name_type: \"district\",\n    upper: \"Z\",\n    zip: \"\\\\d{5}\",\n    zipex: \"03051\",\n  },\n  \"data/KW\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/KW\",\n    key: \"KW\",\n    name: \"KUWAIT\",\n    zip: \"\\\\d{5}\",\n    zipex: \"54541,54551,54404,13009\",\n  },\n  \"data/KY\": {\n    fmt: \"%N%n%O%n%A%n%S %Z\",\n    id: \"data/KY\",\n    key: \"KY\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"CAYMAN ISLANDS\",\n    posturl: \"http://www.caymanpost.gov.ky/\",\n    require: \"AS\",\n    state_name_type: \"island\",\n    sub_keys: \"Cayman Brac~Grand Cayman~Little Cayman\",\n    zip: \"KY\\\\d-\\\\d{4}\",\n    zipex: \"KY1-1100,KY1-1702,KY2-2101\",\n  },\n  \"data/KZ\": {\n    fmt: \"%Z%n%S%n%C%n%A%n%O%n%N\",\n    id: \"data/KZ\",\n    key: \"KZ\",\n    name: \"KAZAKHSTAN\",\n    zip: \"\\\\d{6}\",\n    zipex: \"040900,050012\",\n  },\n  \"data/LA\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/LA\",\n    key: \"LA\",\n    name: \"LAO (PEOPLE'S DEM. REP.)\",\n    zip: \"\\\\d{5}\",\n    zipex: \"01160,01000\",\n  },\n  \"data/LB\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/LB\",\n    key: \"LB\",\n    name: \"LEBANON\",\n    zip: \"(?:\\\\d{4})(?: ?(?:\\\\d{4}))?\",\n    zipex: \"2038 3054,1107 2810,1000\",\n  },\n  \"data/LC\": { id: \"data/LC\", key: \"LC\", name: \"SAINT LUCIA\" },\n  \"data/LI\": {\n    fmt: \"%O%n%N%n%A%nFL-%Z %C\",\n    id: \"data/LI\",\n    key: \"LI\",\n    name: \"LIECHTENSTEIN\",\n    postprefix: \"FL-\",\n    posturl: \"http://www.post.ch/db/owa/pv_plz_pack/pr_main\",\n    require: \"ACZ\",\n    zip: \"948[5-9]|949[0-8]\",\n    zipex: \"9496,9491,9490,9485\",\n  },\n  \"data/LK\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/LK\",\n    key: \"LK\",\n    name: \"SRI LANKA\",\n    posturl: \"http://www.slpost.gov.lk/\",\n    zip: \"\\\\d{5}\",\n    zipex: \"20000,00100\",\n  },\n  \"data/LR\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/LR\",\n    key: \"LR\",\n    name: \"LIBERIA\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1000\",\n  },\n  \"data/LS\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/LS\",\n    key: \"LS\",\n    name: \"LESOTHO\",\n    zip: \"\\\\d{3}\",\n    zipex: \"100\",\n  },\n  \"data/LT\": {\n    fmt: \"%O%n%N%n%A%nLT-%Z %C\",\n    id: \"data/LT\",\n    key: \"LT\",\n    name: \"LITHUANIA\",\n    postprefix: \"LT-\",\n    posturl: \"http://www.post.lt/lt/?id=316\",\n    zip: \"\\\\d{5}\",\n    zipex: \"04340,03500\",\n  },\n  \"data/LU\": {\n    fmt: \"%O%n%N%n%A%nL-%Z %C\",\n    id: \"data/LU\",\n    key: \"LU\",\n    name: \"LUXEMBOURG\",\n    postprefix: \"L-\",\n    posturl:\n      \"https://www.post.lu/fr/grandes-entreprises/solutions-postales/rechercher-un-code-postal\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}\",\n    zipex: \"4750,2998\",\n  },\n  \"data/LV\": {\n    fmt: \"%N%n%O%n%A%n%C, %Z\",\n    id: \"data/LV\",\n    key: \"LV\",\n    name: \"LATVIA\",\n    posturl: \"http://www.pasts.lv/lv/uzzinas/nodalas/\",\n    zip: \"LV-\\\\d{4}\",\n    zipex: \"LV-1073,LV-1000\",\n  },\n  \"data/LY\": { id: \"data/LY\", key: \"LY\", name: \"LIBYA\" },\n  \"data/MA\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/MA\",\n    key: \"MA\",\n    name: \"MOROCCO\",\n    zip: \"\\\\d{5}\",\n    zipex: \"53000,10000,20050,16052\",\n  },\n  \"data/MC\": {\n    fmt: \"%N%n%O%n%A%nMC-%Z %C %X\",\n    id: \"data/MC\",\n    key: \"MC\",\n    name: \"MONACO\",\n    postprefix: \"MC-\",\n    zip: \"980\\\\d{2}\",\n    zipex: \"98000,98020,98011,98001\",\n  },\n  \"data/MD\": {\n    fmt: \"%N%n%O%n%A%nMD-%Z %C\",\n    id: \"data/MD\",\n    key: \"MD\",\n    name: \"Rep. MOLDOVA\",\n    postprefix: \"MD-\",\n    zip: \"\\\\d{4}\",\n    zipex: \"2012,2019\",\n  },\n  \"data/ME\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/ME\",\n    key: \"ME\",\n    name: \"MONTENEGRO\",\n    zip: \"8\\\\d{4}\",\n    zipex: \"81257,81258,81217,84314,85366\",\n  },\n  \"data/MF\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/MF\",\n    key: \"MF\",\n    name: \"SAINT MARTIN\",\n    posturl:\n      \"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"9[78][01]\\\\d{2}\",\n    zipex: \"97100\",\n  },\n  \"data/MG\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/MG\",\n    key: \"MG\",\n    name: \"MADAGASCAR\",\n    zip: \"\\\\d{3}\",\n    zipex: \"501,101\",\n  },\n  \"data/MH\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/MH\",\n    key: \"MH\",\n    name: \"MARSHALL ISLANDS\",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    upper: \"ACNOS\",\n    zip: \"(969[67]\\\\d)(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"96960,96970\",\n  },\n  \"data/MK\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/MK\",\n    key: \"MK\",\n    name: \"MACEDONIA\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1314,1321,1443,1062\",\n  },\n  \"data/ML\": { id: \"data/ML\", key: \"ML\", name: \"MALI\" },\n  \"data/MM\": {\n    fmt: \"%N%n%O%n%A%n%C, %Z\",\n    id: \"data/MM\",\n    key: \"MM\",\n    name: \"MYANMAR\",\n    zip: \"\\\\d{5}\",\n    zipex: \"11181\",\n  },\n  \"data/MN\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S %Z\",\n    id: \"data/MN\",\n    key: \"MN\",\n    name: \"MONGOLIA\",\n    posturl: \"http://www.zipcode.mn/\",\n    zip: \"\\\\d{5}\",\n    zipex: \"65030,65270\",\n  },\n  \"data/MO\": {\n    fmt: \"%A%n%O%n%N\",\n    id: \"data/MO\",\n    key: \"MO\",\n    lfmt: \"%N%n%O%n%A\",\n    name: \"MACAO\",\n    require: \"A\",\n  },\n  \"data/MP\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/MP\",\n    key: \"MP\",\n    name: \"NORTHERN MARIANA ISLANDS\",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    upper: \"ACNOS\",\n    zip: \"(9695[012])(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"96950,96951,96952\",\n  },\n  \"data/MQ\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/MQ\",\n    key: \"MQ\",\n    name: \"MARTINIQUE\",\n    posturl:\n      \"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"9[78]2\\\\d{2}\",\n    zipex: \"97220\",\n  },\n  \"data/MR\": { id: \"data/MR\", key: \"MR\", name: \"MAURITANIA\", upper: \"AC\" },\n  \"data/MS\": { id: \"data/MS\", key: \"MS\", name: \"MONTSERRAT\" },\n  \"data/MT\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/MT\",\n    key: \"MT\",\n    name: \"MALTA\",\n    posturl: \"http://postcodes.maltapost.com/\",\n    upper: \"CZ\",\n    zip: \"[A-Z]{3} ?\\\\d{2,4}\",\n    zipex: \"NXR 01,ZTN 05,GPO 01,BZN 1130,SPB 6031,VCT 1753\",\n  },\n  \"data/MU\": {\n    fmt: \"%N%n%O%n%A%n%Z%n%C\",\n    id: \"data/MU\",\n    key: \"MU\",\n    name: \"MAURITIUS\",\n    upper: \"CZ\",\n    zip: \"\\\\d{3}(?:\\\\d{2}|[A-Z]{2}\\\\d{3})\",\n    zipex: \"42602\",\n  },\n  \"data/MV\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/MV\",\n    key: \"MV\",\n    name: \"MALDIVES\",\n    posturl: \"http://www.maldivespost.com/?lid=10\",\n    zip: \"\\\\d{5}\",\n    zipex: \"20026\",\n  },\n  \"data/MW\": {\n    fmt: \"%N%n%O%n%A%n%C %X\",\n    id: \"data/MW\",\n    key: \"MW\",\n    name: \"MALAWI\",\n  },\n  \"data/MX\": {\n    fmt: \"%N%n%O%n%A%n%D%n%Z %C, %S\",\n    id: \"data/MX\",\n    key: \"MX\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"MEXICO\",\n    posturl:\n      \"http://www.correosdemexico.gob.mx/ServiciosLinea/Paginas/ccpostales.aspx\",\n    require: \"ACZ\",\n    state_name_type: \"state\",\n    sub_isoids:\n      \"AGU~BCN~BCS~CAM~CHP~CHH~CMX~COA~COL~DUR~MEX~GUA~GRO~HID~JAL~MIC~MOR~NAY~NLE~OAX~PUE~QUE~ROO~SLP~SIN~SON~TAB~TAM~TLA~VER~YUC~ZAC\",\n    sub_keys:\n      \"Ags.~B.C.~B.C.S.~Camp.~Chis.~Chih.~CDMX~Coah.~Col.~Dgo.~Méx.~Gto.~Gro.~Hgo.~Jal.~Mich.~Mor.~Nay.~N.L.~Oax.~Pue.~Qro.~Q.R.~S.L.P.~Sin.~Son.~Tab.~Tamps.~Tlax.~Ver.~Yuc.~Zac.\",\n    sub_names:\n      \"Aguascalientes~Baja California~Baja California Sur~Campeche~Chiapas~Chihuahua~Ciudad de México~Coahuila de Zaragoza~Colima~Durango~Estado de México~Guanajuato~Guerrero~Hidalgo~Jalisco~Michoacán~Morelos~Nayarit~Nuevo León~Oaxaca~Puebla~Querétaro~Quintana Roo~San Luis Potosí~Sinaloa~Sonora~Tabasco~Tamaulipas~Tlaxcala~Veracruz~Yucatán~Zacatecas\",\n    sub_zipexs:\n      \"20000,20999~21000,22999~23000,23999~24000,24999~29000,30999~31000,33999~00000,16999~25000,27999~28000,28999~34000,35999~50000,57999~36000,38999~39000,41999~42000,43999~44000,49999~58000,61999~62000,62999~63000,63999~64000,67999~68000,71999~72000,75999~76000,76999~77000,77999~78000,79999~80000,82999~83000,85999~86000,86999~87000,89999~90000,90999~91000,96999~97000,97999~98000,99999\",\n    sub_zips:\n      \"20~2[12]~23~24~29|30~3[1-3]~0|1[0-6]~2[5-7]~28~3[45]~5[0-7]~3[6-8]~39|4[01]~4[23]~4[4-9]~5[89]|6[01]~62~63~6[4-7]~6[89]|7[01]~7[2-5]~76~77~7[89]~8[0-2]~8[3-5]~86~8[7-9]~90~9[1-6]~97~9[89]\",\n    sublocality_name_type: \"neighborhood\",\n    upper: \"CSZ\",\n    zip: \"\\\\d{5}\",\n    zipex: \"02860,77520,06082\",\n  },\n  \"data/MY\": {\n    fmt: \"%N%n%O%n%A%n%D%n%Z %C%n%S\",\n    id: \"data/MY\",\n    key: \"MY\",\n    lang: \"ms\",\n    languages: \"ms\",\n    name: \"MALAYSIA\",\n    posturl: \"http://www.pos.com.my\",\n    require: \"ACZ\",\n    state_name_type: \"state\",\n    sub_isoids: \"01~02~03~14~15~04~05~06~08~09~07~16~12~13~10~11\",\n    sub_keys:\n      \"Johor~Kedah~Kelantan~Kuala Lumpur~Labuan~Melaka~Negeri Sembilan~Pahang~Perak~Perlis~Pulau Pinang~Putrajaya~Sabah~Sarawak~Selangor~Terengganu\",\n    sub_zipexs:\n      \"79000,86999~05000,09999,34950~15000,18599~50000,60000~87000,87999~75000,78399~70000,73599~25000,28999,39000,49000,69000~30000,36899,39000~01000,02799~10000,14999~62000,62999~88000,91999~93000,98999~40000,48999,63000,68199~20000,24999\",\n    sub_zips:\n      \"79|8[0-6]~0[5-9]|34950~1[5-9]~5|60~87~7[5-8]~7[0-4]~2[5-8]|[346]9~3[0-6]|39000~0[12]~1[0-4]~62~8[89]|9[01]~9[3-8]~4[0-8]|6[3-8]~2[0-4]\",\n    sublocality_name_type: \"village_township\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"43000,50754,88990,50670\",\n  },\n  \"data/MZ\": {\n    fmt: \"%N%n%O%n%A%n%Z %C%S\",\n    id: \"data/MZ\",\n    key: \"MZ\",\n    lang: \"pt\",\n    languages: \"pt\",\n    name: \"MOZAMBIQUE\",\n    sub_isoids: \"P~MPM~G~I~B~L~N~A~S~T~Q\",\n    sub_keys:\n      \"Cabo Delgado~Cidade de Maputo~Gaza~Inhambane~Manica~Maputo~Nampula~Niassa~Sofala~Tete~Zambezia\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1102,1119,3212\",\n  },\n  \"data/NA\": { id: \"data/NA\", key: \"NA\", name: \"NAMIBIA\" },\n  \"data/NC\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/NC\",\n    key: \"NC\",\n    name: \"NEW CALEDONIA\",\n    posturl:\n      \"http://poste.opt.nc/index.php?option=com_content&view=article&id=80&Itemid=131\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"988\\\\d{2}\",\n    zipex: \"98814,98800,98810\",\n  },\n  \"data/NE\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/NE\",\n    key: \"NE\",\n    name: \"NIGER\",\n    zip: \"\\\\d{4}\",\n    zipex: \"8001\",\n  },\n  \"data/NF\": {\n    fmt: \"%O%n%N%n%A%n%C %S %Z\",\n    id: \"data/NF\",\n    key: \"NF\",\n    name: \"NORFOLK ISLAND\",\n    upper: \"CS\",\n    zip: \"2899\",\n    zipex: \"2899\",\n  },\n  \"data/NG\": {\n    fmt: \"%N%n%O%n%A%n%D%n%C %Z%n%S\",\n    id: \"data/NG\",\n    key: \"NG\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"NIGERIA\",\n    posturl: \"http://www.nigeriapostcodes.com/\",\n    state_name_type: \"state\",\n    sub_isoids:\n      \"AB~AD~AK~AN~BA~BY~BE~BO~CR~DE~EB~ED~EK~EN~FC~GO~IM~JI~KD~KN~KT~KE~KO~KW~LA~NA~NI~OG~ON~OS~OY~PL~RI~SO~TA~YO~ZA\",\n    sub_keys:\n      \"Abia~Adamawa~Akwa Ibom~Anambra~Bauchi~Bayelsa~Benue~Borno~Cross River~Delta~Ebonyi~Edo~Ekiti~Enugu~Federal Capital Territory~Gombe~Imo~Jigawa~Kaduna~Kano~Katsina~Kebbi~Kogi~Kwara~Lagos~Nasarawa~Niger~Ogun State~Ondo~Osun~Oyo~Plateau~Rivers~Sokoto~Taraba~Yobe~Zamfara\",\n    upper: \"CS\",\n    zip: \"\\\\d{6}\",\n    zipex: \"930283,300001,931104\",\n  },\n  \"data/NI\": {\n    fmt: \"%N%n%O%n%A%n%Z%n%C, %S\",\n    id: \"data/NI\",\n    key: \"NI\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"NICARAGUA\",\n    posturl: \"http://www.correos.gob.ni/index.php/codigo-postal-2\",\n    state_name_type: \"department\",\n    sub_isoids: \"BO~CA~CI~CO~ES~GR~JI~LE~MD~MN~MS~MT~NS~AN~AS~SJ~RI\",\n    sub_keys:\n      \"Boaco~Carazo~Chinandega~Chontales~Esteli~Granada~Jinotega~Leon~Madriz~Managua~Masaya~Matagalpa~Nueva Segovia~Raan~Raas~Rio San Juan~Rivas\",\n    sub_zips:\n      \"5[12]~4[56]~2[5-7]~5[56]~3[12]~4[34]~6[56]~2[12]~3[45]~1[0-6]~4[12]~6[1-3]~3[7-9]~7[12]~8[1-3]~9[12]~4[78]\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"52000\",\n  },\n  \"data/NL\": {\n    fmt: \"%O%n%N%n%A%n%Z %C\",\n    id: \"data/NL\",\n    key: \"NL\",\n    name: \"NETHERLANDS\",\n    posturl: \"http://www.postnl.nl/voorthuis/\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4} ?[A-Z]{2}\",\n    zipex: \"1234 AB,2490 AA\",\n  },\n  \"data/NO\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/NO\",\n    key: \"NO\",\n    locality_name_type: \"post_town\",\n    name: \"NORWAY\",\n    posturl: \"http://adressesok.posten.no/nb/postal_codes/search\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}\",\n    zipex: \"0025,0107,6631\",\n  },\n  \"data/NP\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/NP\",\n    key: \"NP\",\n    name: \"NEPAL\",\n    posturl: \"http://www.gpo.gov.np/Home/Postalcode\",\n    zip: \"\\\\d{5}\",\n    zipex: \"44601\",\n  },\n  \"data/NR\": {\n    fmt: \"%N%n%O%n%A%n%S\",\n    id: \"data/NR\",\n    key: \"NR\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"NAURU CENTRAL PACIFIC\",\n    require: \"AS\",\n    state_name_type: \"district\",\n    sub_isoids: \"01~02~03~04~05~06~07~08~09~10~11~12~13~14\",\n    sub_keys:\n      \"Aiwo District~Anabar District~Anetan District~Anibare District~Baiti District~Boe District~Buada District~Denigomodu District~Ewa District~Ijuw District~Meneng District~Nibok District~Uaboe District~Yaren District\",\n  },\n  \"data/NU\": { id: \"data/NU\", key: \"NU\", name: \"NIUE\" },\n  \"data/NZ\": {\n    fmt: \"%N%n%O%n%A%n%D%n%C %Z\",\n    id: \"data/NZ\",\n    key: \"NZ\",\n    name: \"NEW ZEALAND\",\n    posturl:\n      \"http://www.nzpost.co.nz/Cultures/en-NZ/OnlineTools/PostCodeFinder/\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}\",\n    zipex: \"6001,6015,6332,8252,1030\",\n  },\n  \"data/OM\": {\n    fmt: \"%N%n%O%n%A%n%Z%n%C\",\n    id: \"data/OM\",\n    key: \"OM\",\n    name: \"OMAN\",\n    zip: \"(?:PC )?\\\\d{3}\",\n    zipex: \"133,112,111\",\n  },\n  \"data/PA\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S\",\n    id: \"data/PA\",\n    key: \"PA\",\n    name: \"PANAMA (REP.)\",\n    upper: \"CS\",\n  },\n  \"data/PE\": {\n    fmt: \"%N%n%O%n%A%n%C %Z%n%S\",\n    id: \"data/PE\",\n    key: \"PE\",\n    lang: \"es\",\n    languages: \"es\",\n    locality_name_type: \"district\",\n    name: \"PERU\",\n    posturl: \"http://www.serpost.com.pe/cpostal/codigo\",\n    sub_isoids:\n      \"AMA~ANC~APU~ARE~AYA~CAJ~CAL~CUS~LIM~HUV~HUC~ICA~JUN~LAL~LAM~LOR~MDD~MOQ~LMA~PAS~PIU~PUN~SAM~TAC~TUM~UCA\",\n    sub_keys:\n      \"Amazonas~Áncash~Apurímac~Arequipa~Ayacucho~Cajamarca~Callao~Cuzco~Gobierno Regional de Lima~Huancavelica~Huánuco~Ica~Junín~La Libertad~Lambayeque~Loreto~Madre de Dios~Moquegua~Municipalidad Metropolitana de Lima~Pasco~Piura~Puno~San Martín~Tacna~Tumbes~Ucayali\",\n    zip: \"(?:LIMA \\\\d{1,2}|CALLAO 0?\\\\d)|[0-2]\\\\d{4}\",\n    zipex: \"LIMA 23,LIMA 42,CALLAO 2,02001\",\n  },\n  \"data/PF\": {\n    fmt: \"%N%n%O%n%A%n%Z %C %S\",\n    id: \"data/PF\",\n    key: \"PF\",\n    name: \"FRENCH POLYNESIA\",\n    require: \"ACSZ\",\n    state_name_type: \"island\",\n    upper: \"CS\",\n    zip: \"987\\\\d{2}\",\n    zipex: \"98709\",\n  },\n  \"data/PG\": {\n    fmt: \"%N%n%O%n%A%n%C %Z %S\",\n    id: \"data/PG\",\n    key: \"PG\",\n    name: \"PAPUA NEW GUINEA\",\n    require: \"ACS\",\n    zip: \"\\\\d{3}\",\n    zipex: \"111\",\n  },\n  \"data/PH\": {\n    fmt: \"%N%n%O%n%A%n%D, %C%n%Z %S\",\n    id: \"data/PH\",\n    key: \"PH\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"PHILIPPINES\",\n    posturl: \"http://www.philpost.gov.ph/\",\n    sub_isoids:\n      \"ABR~AGN~AGS~AKL~ALB~ANT~APA~AUR~BAS~BAN~BTN~BTG~BEN~BIL~BOH~BUK~BUL~CAG~CAN~CAS~CAM~CAP~CAT~CAV~CEB~COM~NCO~DAV~DAS~DVO~DAO~DIN~EAS~GUI~IFU~ILN~ILS~ILI~ISA~KAL~LUN~LAG~LAN~LAS~LEY~MAG~MAD~MAS~00~MDC~MDR~MSC~MSR~MOU~NEC~NER~NSA~NUE~NUV~PLW~PAM~PAN~QUE~QUI~RIZ~ROM~WSA~SAR~SIG~SOR~SCO~SLE~SUK~SLU~SUN~SUR~TAR~TAW~ZMB~ZAN~ZAS~ZSI\",\n    sub_keys:\n      \"Abra~Agusan del Norte~Agusan del Sur~Aklan~Albay~Antique~Apayao~Aurora~Basilan~Bataan~Batanes~Batangas~Benguet~Biliran~Bohol~Bukidnon~Bulacan~Cagayan~Camarines Norte~Camarines Sur~Camiguin~Capiz~Catanduanes~Cavite~Cebu~Compostela Valley~Cotabato~Davao del Norte~Davao del Sur~Davao Occidental~Davao Oriental~Dinagat Islands~Eastern Samar~Guimaras~Ifugao~Ilocos Norte~Ilocos Sur~Iloilo~Isabela~Kalinga~La Union~Laguna~Lanao del Norte~Lanao del Sur~Leyte~Maguindanao~Marinduque~Masbate~Metro Manila~Mindoro Occidental~Mindoro Oriental~Misamis Occidental~Misamis Oriental~Mountain Province~Negros Occidental~Negros Oriental~Northern Samar~Nueva Ecija~Nueva Vizcaya~Palawan~Pampanga~Pangasinan~Quezon Province~Quirino~Rizal~Romblon~Samar~Sarangani~Siquijor~Sorsogon~South Cotabato~Southern Leyte~Sultan Kudarat~Sulu~Surigao del Norte~Surigao del Sur~Tarlac~Tawi-Tawi~Zambales~Zamboanga del Norte~Zamboanga del Sur~Zamboanga Sibuguey\",\n    sub_zipexs:\n      \"2800,2826~8600,8611~8500,8513~5600,5616~4500,4517~5700,5717~3800,3806,3808~3200,3207~7300,7306~2100,2114~3900,3905~4200,4234~2600,2615~6543,6550~6300,6337~8700,8723~3000,3024~3500,3528~4600,4612~4400,4436~9100,9104~5800,5816~4800,4810~4100,4126~6000,6053~8800,8810~9400,9417~8100,8120~8000,8010~8015,8013~8200,8210~8426,8412~6800,6822~5044,5046~3600,3610~2900,2922~2700,2733~5000,5043~3300,3336~3807,3809,3814~2500,2520~4000,4033~9200,9223~9300,9321,9700,9716~6500,6542~9600,9619~4900,4905~5400,5421~~5100,5111~5200,5214~7200,7215~9000,9025~2616,2625~6100,6132~6200,6224~6400,6423~3100,3133~3700,3714~5300,5322~2000,2022~2400,2447~4300,4342~3400,3405~1850,1990~5500,5516~6700,6725~8015~6225,6230~4700,4715~9500,9513~6600,6613~9800,9811~7400,7416~8400,8425~8300,8319~2300,2318~7500,7509~2200,2213~7100,7124~7000,7043~7000,7043\",\n    sub_zips:\n      \"28[0-2]~86[01]~85[01]~56[01]~45[01]~57[01]~380[0-68]~320~730~21[01]~390~42[0-3]~26(0|1[0-5])~65(4[3-9]|5)~63[0-3]~87[0-2]~30[0-2]~35[0-2]~46[01]~44[0-3]~910~58[01]~48[01]~41[0-2]~60[0-5]~88[01]~94[01]~81[0-2]~80[01]~801[1-5]~82[01]~84[12]~68[0-2]~504[4-6]~36[01]~29[0-2]~27[0-3]~50([0-3]|4[0-3])~33[0-3]~38(0[79]|1[0-4])~25[0-2]~40[0-3]~92[0-2]~9(3[0-2]|7[01])~65([0-3]|4[0-2])~96[01]~490~54[0-2]~~51[01]~52[01]~72[01]~90[0-2]~26(1[6-9]|2[0-5])~61[0-3]~62[0-2]~64[0-2]~31[0-3]~37[01]~53[0-2]~20[0-2]~24[0-4]~43[0-4]~340~1[89]~55[01]~67[0-2]~8015~62(2[5-9]|30)~47[01]~95[01]~66[10]~98[01]~74[01]~84[0-2]~83[01]~23[01]~750~22[01]~71[0-2]~70[0-4]~70[0-4]\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1008,1050,1135,1207,2000,1000\",\n  },\n  \"data/PK\": {\n    fmt: \"%N%n%O%n%A%n%C-%Z\",\n    id: \"data/PK\",\n    key: \"PK\",\n    name: \"PAKISTAN\",\n    posturl: \"http://www.pakpost.gov.pk/postcode.php\",\n    zip: \"\\\\d{5}\",\n    zipex: \"44000\",\n  },\n  \"data/PL\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/PL\",\n    key: \"PL\",\n    name: \"POLAND\",\n    posturl: \"http://kody.poczta-polska.pl/\",\n    require: \"ACZ\",\n    zip: \"\\\\d{2}-\\\\d{3}\",\n    zipex: \"00-950,05-470,48-300,32-015,00-940\",\n  },\n  \"data/PM\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/PM\",\n    key: \"PM\",\n    name: \"ST. PIERRE AND MIQUELON\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"9[78]5\\\\d{2}\",\n    zipex: \"97500\",\n  },\n  \"data/PN\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/PN\",\n    key: \"PN\",\n    name: \"PITCAIRN\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"PCRN 1ZZ\",\n    zipex: \"PCRN 1ZZ\",\n  },\n  \"data/PR\": {\n    fmt: \"%N%n%O%n%A%n%C PR %Z\",\n    id: \"data/PR\",\n    key: \"PR\",\n    name: \"PUERTO RICO\",\n    postprefix: \"PR \",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACZ\",\n    upper: \"ACNO\",\n    zip: \"(00[679]\\\\d{2})(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"00930\",\n  },\n  \"data/PT\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/PT\",\n    key: \"PT\",\n    name: \"PORTUGAL\",\n    posturl: \"http://www.ctt.pt/feapl_2/app/open/tools.jspx?tool=1\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}-\\\\d{3}\",\n    zipex: \"2725-079,1250-096,1201-950,2860-571,1208-148\",\n  },\n  \"data/PW\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/PW\",\n    key: \"PW\",\n    name: \"PALAU\",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    upper: \"ACNOS\",\n    zip: \"(969(?:39|40))(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"96940\",\n  },\n  \"data/PY\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/PY\",\n    key: \"PY\",\n    name: \"PARAGUAY\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1536,1538,1209\",\n  },\n  \"data/QA\": { id: \"data/QA\", key: \"QA\", name: \"QATAR\", upper: \"AC\" },\n  \"data/RE\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/RE\",\n    key: \"RE\",\n    name: \"REUNION\",\n    posturl:\n      \"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"9[78]4\\\\d{2}\",\n    zipex: \"97400\",\n  },\n  \"data/RO\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/RO\",\n    key: \"RO\",\n    name: \"ROMANIA\",\n    posturl: \"http://www.posta-romana.ro/zip_codes\",\n    upper: \"AC\",\n    zip: \"\\\\d{6}\",\n    zipex: \"060274,061357,200716\",\n  },\n  \"data/RS\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/RS\",\n    key: \"RS\",\n    name: \"REPUBLIC OF SERBIA\",\n    posturl:\n      \"http://www.posta.rs/struktura/lat/aplikacije/pronadji/nadji-postu.asp\",\n    zip: \"\\\\d{5,6}\",\n    zipex: \"106314\",\n  },\n  \"data/RU\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S%n%Z\",\n    id: \"data/RU\",\n    key: \"RU\",\n    lang: \"ru\",\n    languages: \"ru\",\n    lfmt: \"%N%n%O%n%A%n%C%n%S%n%Z\",\n    name: \"RUSSIAN FEDERATION\",\n    posturl: \"http://info.russianpost.ru/servlet/department\",\n    require: \"ACSZ\",\n    state_name_type: \"oblast\",\n    sub_isoids:\n      \"ALT~AMU~ARK~AST~BEL~BRY~VLA~VGG~VLG~VOR~YEV~ZAB~IVA~IRK~KB~KGD~KLU~KAM~KC~KEM~KIR~KOS~KDA~KYA~KGN~KRS~LEN~LIP~MAG~MOW~MOS~MUR~NEN~NIZ~NGR~NVS~OMS~ORE~ORL~PNZ~PER~PRI~PSK~AD~AL~BA~BU~DA~IN~KL~KR~KO~~ME~MO~SA~SE~TA~TY~UD~KK~ROS~RYA~SAM~SPE~SAR~SAK~SVE~~SMO~STA~TAM~TVE~TOM~TUL~TYU~ULY~KHA~KHM~CHE~CE~CU~CHU~YAN~YAR\",\n    sub_keys:\n      \"Алтайский край~Амурская область~Архангельская область~Астраханская область~Белгородская область~Брянская область~Владимирская область~Волгоградская область~Вологодская область~Воронежская область~Еврейская автономная область~Забайкальский край~Ивановская область~Иркутская область~Кабардино-Балкарская Республика~Калининградская область~Калужская область~Камчатский край~Карачаево-Черкесская Республика~Кемеровская область~Кировская область~Костромская область~Краснодарский край~Красноярский край~Курганская область~Курская область~Ленинградская область~Липецкая область~Магаданская область~Москва~Московская область~Мурманская область~Ненецкий автономный округ~Нижегородская область~Новгородская область~Новосибирская область~Омская область~Оренбургская область~Орловская область~Пензенская область~Пермский край~Приморский край~Псковская область~Республика Адыгея~Республика Алтай~Республика Башкортостан~Республика Бурятия~Республика Дагестан~Республика Ингушетия~Республика Калмыкия~Республика Карелия~Республика Коми~Автономна Республіка Крим~Республика Марий Эл~Республика Мордовия~Республика Саха (Якутия)~Республика Северная Осетия-Алания~Республика Татарстан~Республика Тыва~Республика Удмуртия~Республика Хакасия~Ростовская область~Рязанская область~Самарская область~Санкт-Петербург~Саратовская область~Сахалинская область~Свердловская область~Севастополь~Смоленская область~Ставропольский край~Тамбовская область~Тверская область~Томская область~Тульская область~Тюменская область~Ульяновская область~Хабаровский край~Ханты-Мансийский автономный округ~Челябинская область~Чеченская Республика~Чувашская Республика~Чукотский автономный округ~Ямало-Ненецкий автономный округ~Ярославская область\",\n    sub_lnames:\n      \"Altayskiy kray~Amurskaya oblast'~Arkhangelskaya oblast'~Astrakhanskaya oblast'~Belgorodskaya oblast'~Bryanskaya oblast'~Vladimirskaya oblast'~Volgogradskaya oblast'~Vologodskaya oblast'~Voronezhskaya oblast'~Evreyskaya avtonomnaya oblast'~Zabaykalskiy kray~Ivanovskaya oblast'~Irkutskaya oblast'~Kabardino-Balkarskaya Republits~Kaliningradskaya oblast'~Kaluzhskaya oblast'~Kamchatskiy kray~Karachaevo-Cherkesskaya Republits~Kemerovskaya oblast'~Kirovskaya oblast'~Kostromskaya oblast'~Krasnodarskiy kray~Krasnoyarskiy kray~Kurganskaya oblast'~Kurskaya oblast'~Leningradskaya oblast'~Lipetskaya oblast'~Magadanskaya oblast'~Moskva~Moskovskaya oblast'~Murmanskaya oblast'~Nenetskiy~Nizhegorodskaya oblast'~Novgorodskaya oblast'~Novosibirskaya oblast'~Omskaya oblast'~Orenburgskaya oblast'~Orlovskaya oblast'~Penzenskaya oblast'~Permskiy kray~Primorskiy kray~Pskovskaya oblast'~Respublika Adygeya~Altay Republits~Bashkortostan Republits~Buryatiya Republits~Dagestan Republits~Ingushetiya Republits~Respublika Kalmykiya~Kareliya Republits~Komi Republits~Respublika Krym~Respublika Mariy El~Respublika Mordoviya~Sakha (Yakutiya) Republits~Respublika Severnaya Osetiya-Alaniya~Respublika Tatarstan~Tyva Republits~Respublika Udmurtiya~Khakasiya Republits~Rostovskaya oblast'~Ryazanskaya oblast'~Samarskaya oblast'~Sankt-Peterburg~Saratovskaya oblast'~Sakhalinskaya oblast'~Sverdlovskaya oblast'~Sevastopol'~Smolenskaya oblast'~Stavropolskiy kray~Tambovskaya oblast'~Tverskaya oblast'~Tomskaya oblast'~Tulskaya oblast'~Tyumenskaya oblast'~Ulyanovskaya oblast'~Khabarovskiy kray~Khanty-Mansiyskiy avtonomnyy okrug~Chelyabinskaya oblast'~Chechenskaya Republits~Chuvashia~Chukotskiy~Yamalo-Nenetskiy~Yaroslavskaya oblast'\",\n    sub_names:\n      \"Алтайский край~Амурская область~Архангельская область~Астраханская область~Белгородская область~Брянская область~Владимирская область~Волгоградская область~Вологодская область~Воронежская область~Еврейская автономная область~Забайкальский край~Ивановская область~Иркутская область~Кабардино-Балкарская Республика~Калининградская область~Калужская область~Камчатский край~Карачаево-Черкесская Республика~Кемеровская область~Кировская область~Костромская область~Краснодарский край~Красноярский край~Курганская область~Курская область~Ленинградская область~Липецкая область~Магаданская область~Москва~Московская область~Мурманская область~Ненецкий автономный округ~Нижегородская область~Новгородская область~Новосибирская область~Омская область~Оренбургская область~Орловская область~Пензенская область~Пермский край~Приморский край~Псковская область~Республика Адыгея~Республика Алтай~Республика Башкортостан~Республика Бурятия~Республика Дагестан~Республика Ингушетия~Республика Калмыкия~Республика Карелия~Республика Коми~Республика Крым~Республика Марий Эл~Республика Мордовия~Республика Саха (Якутия)~Республика Северная Осетия-Алания~Республика Татарстан~Республика Тыва~Республика Удмуртия~Республика Хакасия~Ростовская область~Рязанская область~Самарская область~Санкт-Петербург~Саратовская область~Сахалинская область~Свердловская область~Севастополь~Смоленская область~Ставропольский край~Тамбовская область~Тверская область~Томская область~Тульская область~Тюменская область~Ульяновская область~Хабаровский край~Ханты-Мансийский автономный округ~Челябинская область~Чеченская Республика~Чувашская Республика~Чукотский автономный округ~Ямало-Ненецкий автономный округ~Ярославская область\",\n    sub_zips:\n      \"65[6-9]~67[56]~16[3-5]~41[4-6]~30[89]~24[1-3]~60[0-2]~40[0-4]~16[0-2]~39[4-7]~679~6(?:7[2-4]|87)~15[3-5]~66[4-9]~36[01]~23[6-8]~24[89]~68[348]~369~65[0-4]~61[0-3]~15[67]~35[0-4]~6(?:6[0-3]|4[78])~64[01]~30[5-7]~18[78]~39[89]~68[56]~1(?:0[1-9]|1|2|3[0-5]|4[0-4])~14[0-4]~18[34]~166~60[3-7]~17[3-5]~63[0-3]~64[4-6]~46[0-2]~30[23]~44[0-2]~61[4-9]~69[0-2]~18[0-2]~385~649~45[0-3]~67[01]~36[78]~386~35[89]~18[56]~16[7-9]~29[5-8]~42[45]~43[01]~67[78]~36[23]~42[0-3]~66[78]~42[67]~655~34[4-7]~39[01]~44[3-6]~19~41[0-3]~69[34]~62[0-4]~299~21[4-6]~35[5-7]~39[23]~17[0-2]~63[4-6]~30[01]~62[5-7]~43[23]~68[0-2]~628~45[4-7]~36[4-6]~42[89]~689~629~15[0-2]\",\n    upper: \"AC\",\n    zip: \"\\\\d{6}\",\n    zipex: \"247112,103375,188300\",\n  },\n  \"data/RW\": { id: \"data/RW\", key: \"RW\", name: \"RWANDA\", upper: \"AC\" },\n  \"data/SA\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/SA\",\n    key: \"SA\",\n    name: \"SAUDI ARABIA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"11564,11187,11142\",\n  },\n  \"data/SB\": { id: \"data/SB\", key: \"SB\", name: \"SOLOMON ISLANDS\" },\n  \"data/SC\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S\",\n    id: \"data/SC\",\n    key: \"SC\",\n    name: \"SEYCHELLES\",\n    state_name_type: \"island\",\n    upper: \"S\",\n  },\n  \"data/SD\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/SD\",\n    key: \"SD\",\n    locality_name_type: \"district\",\n    name: \"SUDAN\",\n    zip: \"\\\\d{5}\",\n    zipex: \"11042,11113\",\n  },\n  \"data/SE\": {\n    fmt: \"%O%n%N%n%A%nSE-%Z %C\",\n    id: \"data/SE\",\n    key: \"SE\",\n    locality_name_type: \"post_town\",\n    name: \"SWEDEN\",\n    postprefix: \"SE-\",\n    posturl:\n      \"http://www.posten.se/sv/Kundservice/Sidor/Sok-postnummer-resultat.aspx\",\n    require: \"ACZ\",\n    zip: \"\\\\d{3} ?\\\\d{2}\",\n    zipex: \"11455,12345,10500\",\n  },\n  \"data/SG\": {\n    fmt: \"%N%n%O%n%A%nSINGAPORE %Z\",\n    id: \"data/SG\",\n    key: \"SG\",\n    name: \"REP. OF SINGAPORE\",\n    posturl: \"https://www.singpost.com/find-postal-code\",\n    require: \"AZ\",\n    zip: \"\\\\d{6}\",\n    zipex: \"546080,308125,408600\",\n  },\n  \"data/SH\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/SH\",\n    key: \"SH\",\n    name: \"SAINT HELENA\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"(?:ASCN|STHL) 1ZZ\",\n    zipex: \"STHL 1ZZ\",\n  },\n  \"data/SI\": {\n    fmt: \"%N%n%O%n%A%nSI-%Z %C\",\n    id: \"data/SI\",\n    key: \"SI\",\n    name: \"SLOVENIA\",\n    postprefix: \"SI-\",\n    zip: \"\\\\d{4}\",\n    zipex: \"4000,1001,2500\",\n  },\n  \"data/SK\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/SK\",\n    key: \"SK\",\n    name: \"SLOVAKIA\",\n    posturl: \"http://psc.posta.sk\",\n    require: \"ACZ\",\n    zip: \"\\\\d{3} ?\\\\d{2}\",\n    zipex: \"010 01,023 14,972 48,921 01,975 99\",\n  },\n  \"data/SL\": { id: \"data/SL\", key: \"SL\", name: \"SIERRA LEONE\" },\n  \"data/SM\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/SM\",\n    key: \"SM\",\n    name: \"SAN MARINO\",\n    posturl: \"http://www.poste.it/online/cercacap/\",\n    require: \"AZ\",\n    zip: \"4789\\\\d\",\n    zipex: \"47890,47891,47895,47899\",\n  },\n  \"data/SN\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/SN\",\n    key: \"SN\",\n    name: \"SENEGAL\",\n    zip: \"\\\\d{5}\",\n    zipex: \"12500,46024,16556,10000\",\n  },\n  \"data/SO\": {\n    fmt: \"%N%n%O%n%A%n%C, %S %Z\",\n    id: \"data/SO\",\n    key: \"SO\",\n    lang: \"so\",\n    languages: \"so\",\n    name: \"SOMALIA\",\n    require: \"ACS\",\n    sub_isoids: \"AW~BK~BN~BR~BY~GA~GE~HI~JD~JH~MU~NU~SA~SD~SH~SO~TO~WO\",\n    sub_keys: \"AD~BK~BN~BR~BY~GG~GD~HR~JD~JH~MD~NG~SG~SD~SH~SL~TG~WG\",\n    sub_names:\n      \"Awdal~Bakool~Banaadir~Bari~Bay~Galguduud~Gedo~Hiiraan~Jubbada Dhexe~Jubbada Hoose~Mudug~Nugaal~Sanaag~Shabeellaha Dhexe~Shabeellaha Hoose~Sool~Togdheer~Woqooyi Galbeed\",\n    upper: \"ACS\",\n    zip: \"[A-Z]{2} ?\\\\d{5}\",\n    zipex: \"JH 09010,AD 11010\",\n  },\n  \"data/SR\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S\",\n    id: \"data/SR\",\n    key: \"SR\",\n    lang: \"nl\",\n    languages: \"nl\",\n    name: \"SURINAME\",\n    sub_isoids: \"BR~CM~CR~MA~NI~PR~PM~SA~SI~WA\",\n    sub_keys:\n      \"Brokopondo~Commewijne~Coronie~Marowijne~Nickerie~Para~Paramaribo~Saramacca~Sipaliwini~Wanica\",\n    upper: \"AS\",\n  },\n  \"data/SS\": { id: \"data/SS\", key: \"SS\", name: \"SOUTH SUDAN\" },\n  \"data/ST\": { id: \"data/ST\", key: \"ST\", name: \"SAO TOME AND PRINCIPE\" },\n  \"data/SV\": {\n    fmt: \"%N%n%O%n%A%n%Z-%C%n%S\",\n    id: \"data/SV\",\n    key: \"SV\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"EL SALVADOR\",\n    require: \"ACS\",\n    sub_isoids: \"AH~CA~CH~CU~LI~PA~UN~MO~SM~SS~SV~SA~SO~US\",\n    sub_keys:\n      \"Ahuachapan~Cabanas~Calatenango~Cuscatlan~La Libertad~La Paz~La Union~Morazan~San Miguel~San Salvador~San Vicente~Santa Ana~Sonsonate~Usulutan\",\n    sub_names:\n      \"Ahuachapán~Cabañas~Chalatenango~Cuscatlán~La Libertad~La Paz~La Unión~Morazán~San Miguel~San Salvador~San Vicente~Santa Ana~Sonsonate~Usulután\",\n    sub_zipexs:\n      \"CP 2101~CP 1201~CP 1301~CP 1401~CP 1501~CP 1601~CP 3101~CP 3201~CP 3301~CP 1101~CP 1701~CP 2201~CP 2301~CP 3401\",\n    sub_zips:\n      \"CP 21~CP 12~CP 13~CP 14~CP 15~CP 16~CP 31~CP 32~CP 33~CP 11~CP 17~CP 22~CP 23~CP 34\",\n    upper: \"CSZ\",\n    zip: \"CP [1-3][1-7][0-2]\\\\d\",\n    zipex: \"CP 1101\",\n  },\n  \"data/SX\": { id: \"data/SX\", key: \"SX\", name: \"SINT MAARTEN\" },\n  \"data/SY\": {\n    id: \"data/SY\",\n    key: \"SY\",\n    locality_name_type: \"district\",\n    name: \"SYRIA\",\n  },\n  \"data/SZ\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/SZ\",\n    key: \"SZ\",\n    name: \"SWAZILAND\",\n    posturl: \"http://www.sptc.co.sz/swazipost/codes/index.php\",\n    upper: \"ACZ\",\n    zip: \"[HLMS]\\\\d{3}\",\n    zipex: \"H100\",\n  },\n  \"data/TC\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/TC\",\n    key: \"TC\",\n    name: \"TURKS AND CAICOS ISLANDS\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"TKCA 1ZZ\",\n    zipex: \"TKCA 1ZZ\",\n  },\n  \"data/TD\": { id: \"data/TD\", key: \"TD\", name: \"CHAD\" },\n  \"data/TF\": { id: \"data/TF\", key: \"TF\", name: \"FRENCH SOUTHERN TERRITORIES\" },\n  \"data/TG\": { id: \"data/TG\", key: \"TG\", name: \"TOGO\" },\n  \"data/TH\": {\n    fmt: \"%N%n%O%n%A%n%D %C%n%S %Z\",\n    id: \"data/TH\",\n    key: \"TH\",\n    lang: \"th\",\n    languages: \"th\",\n    lfmt: \"%N%n%O%n%A%n%D, %C%n%S %Z\",\n    name: \"THAILAND\",\n    sub_isoids:\n      \"81~10~71~46~62~40~38~22~24~20~18~36~86~57~50~92~23~63~26~73~48~30~80~60~12~96~55~31~13~77~25~94~14~56~82~93~66~65~76~67~54~83~44~49~58~35~95~45~85~21~70~16~52~51~42~33~47~90~91~11~75~74~27~19~17~64~72~84~32~43~39~15~37~41~53~61~34\",\n    sub_keys:\n      \"กระบี่~กรุงเทพมหานคร~กาญจนบุรี~กาฬสินธุ์~กำแพงเพชร~ขอนแก่น~จังหวัด บึงกาฬ~จันทบุรี~ฉะเชิงเทรา~ชลบุรี~ชัยนาท~ชัยภูมิ~ชุมพร~เชียงราย~เชียงใหม่~ตรัง~ตราด~ตาก~นครนายก~นครปฐม~นครพนม~นครราชสีมา~นครศรีธรรมราช~นครสวรรค์~นนทบุรี~นราธิวาส~น่าน~บุรีรัมย์~ปทุมธานี~ประจวบคีรีขันธ์~ปราจีนบุรี~ปัตตานี~พระนครศรีอยุธยา~พะเยา~พังงา~พัทลุง~พิจิตร~พิษณุโลก~เพชรบุรี~เพชรบูรณ์~แพร่~ภูเก็ต~มหาสารคาม~มุกดาหาร~แม่ฮ่องสอน~ยโสธร~ยะลา~ร้อยเอ็ด~ระนอง~ระยอง~ราชบุรี~ลพบุรี~ลำปาง~ลำพูน~เลย~ศรีสะเกษ~สกลนคร~สงขลา~สตูล~สมุทรปราการ~สมุทรสงคราม~สมุทรสาคร~สระแก้ว~สระบุรี~สิงห์บุรี~สุโขทัย~สุพรรณบุรี~สุราษฎร์ธานี~สุรินทร์~หนองคาย~หนองบัวลำภู~อ่างทอง~อำนาจเจริญ~อุดรธานี~อุตรดิตถ์~อุทัยธานี~อุบลราชธานี\",\n    sub_lnames:\n      \"Krabi~Bangkok~Kanchanaburi~Kalasin~Kamphaeng Phet~Khon Kaen~Bueng Kan~Chanthaburi~Chachoengsao~Chon Buri~Chai Nat~Chaiyaphum~Chumpon~Chiang Rai~Chiang Mai~Trang~Trat~Tak~Nakhon Nayok~Nakhon Pathom~Nakhon Phanom~Nakhon Ratchasima~Nakhon Si Thammarat~Nakhon Sawan~Nonthaburi~Narathiwat~Nan~Buri Ram~Pathum Thani~Prachuap Khiri Khan~Prachin Buri~Pattani~Phra Nakhon Si Ayutthaya~Phayao~Phang Nga~Phattalung~Phichit~Phitsanulok~Phetchaburi~Phetchabun~Phrae~Phuket~Maha Sarakham~Mukdahan~Mae Hong Son~Yasothon~Yala~Roi Et~Ranong~Rayong~Ratchaburi~Lop Buri~Lampang~Lamphun~Loei~Si Sa Ket~Sakon Nakhon~Songkhla~Satun~Samut Prakan~Samut Songkhram~Samut Sakhon~Sa Kaeo~Saraburi~Sing Buri~Sukhothai~Suphanburi~Surat Thani~Surin~Nong Khai~Nong Bua Lam Phu~Ang Thong~Amnat Charoen~Udon Thani~Uttaradit~Uthai Thani~Ubon Ratchathani\",\n    sub_zips:\n      \"81~10~71~46~62~40~~22~24~20~17~36~86~57~50~92~23~63~26~73~48~30~80~60~11~96~55~31~12~77~25~94~13~56~82~93~66~65~76~67~54~83~44~49~58~35~95~45~85~21~70~15~52~51~42~33~47~90~91~10~75~74~27~18~16~64~72~84~32~43~39~14~37~41~53~61~34\",\n    upper: \"S\",\n    zip: \"\\\\d{5}\",\n    zipex: \"10150,10210\",\n  },\n  \"data/TJ\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/TJ\",\n    key: \"TJ\",\n    name: \"TAJIKISTAN\",\n    zip: \"\\\\d{6}\",\n    zipex: \"735450,734025\",\n  },\n  \"data/TK\": { id: \"data/TK\", key: \"TK\", name: \"TOKELAU\" },\n  \"data/TL\": { id: \"data/TL\", key: \"TL\", name: \"TIMOR-LESTE\" },\n  \"data/TM\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/TM\",\n    key: \"TM\",\n    name: \"TURKMENISTAN\",\n    zip: \"\\\\d{6}\",\n    zipex: \"744000\",\n  },\n  \"data/TN\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/TN\",\n    key: \"TN\",\n    name: \"TUNISIA\",\n    posturl: \"http://www.poste.tn/codes.php\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1002,8129,3100,1030\",\n  },\n  \"data/TO\": { id: \"data/TO\", key: \"TO\", name: \"TONGA\" },\n  \"data/TR\": {\n    fmt: \"%N%n%O%n%A%n%Z %C/%S\",\n    id: \"data/TR\",\n    key: \"TR\",\n    lang: \"tr\",\n    languages: \"tr\",\n    locality_name_type: \"district\",\n    name: \"TURKEY\",\n    posturl: \"http://postakodu.ptt.gov.tr/\",\n    require: \"ACZ\",\n    sub_isoids:\n      \"01~02~03~04~68~05~06~07~75~08~09~10~74~72~69~11~12~13~14~15~16~17~18~19~20~21~81~22~23~24~25~26~27~28~29~30~31~76~32~34~35~46~78~70~36~37~38~71~39~40~79~41~42~43~44~45~47~33~48~49~50~51~52~80~53~54~55~56~57~58~63~73~59~60~61~62~64~65~77~66~67\",\n    sub_keys:\n      \"Adana~Adıyaman~Afyon~Ağrı~Aksaray~Amasya~Ankara~Antalya~Ardahan~Artvin~Aydın~Balıkesir~Bartın~Batman~Bayburt~Bilecik~Bingöl~Bitlis~Bolu~Burdur~Bursa~Çanakkale~Çankırı~Çorum~Denizli~Diyarbakır~Düzce~Edirne~Elazığ~Erzincan~Erzurum~Eskişehir~Gaziantep~Giresun~Gümüşhane~Hakkari~Hatay~Iğdır~Isparta~İstanbul~İzmir~Kahramanmaraş~Karabük~Karaman~Kars~Kastamonu~Kayseri~Kırıkkale~Kırklareli~Kırşehir~Kilis~Kocaeli~Konya~Kütahya~Malatya~Manisa~Mardin~Mersin~Muğla~Muş~Nevşehir~Niğde~Ordu~Osmaniye~Rize~Sakarya~Samsun~Siirt~Sinop~Sivas~Şanlıurfa~Şırnak~Tekirdağ~Tokat~Trabzon~Tunceli~Uşak~Van~Yalova~Yozgat~Zonguldak\",\n    sub_zips:\n      \"01~02~03~04~68~05~06~07~75~08~09~10~74~72~69~11~12~13~14~15~16~17~18~19~20~21~81~22~23~24~25~26~27~28~29~30~31~76~32~34~35~46~78~70~36~37~38~71~39~40~79~41~42~43~44~45~47~33~48~49~50~51~52~80~53~54~55~56~57~58~63~73~59~60~61~62~64~65~77~66~67\",\n    zip: \"\\\\d{5}\",\n    zipex: \"01960,06101\",\n  },\n  \"data/TT\": { id: \"data/TT\", key: \"TT\", name: \"TRINIDAD AND TOBAGO\" },\n  \"data/TV\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S\",\n    id: \"data/TV\",\n    key: \"TV\",\n    lang: \"tyv\",\n    languages: \"tyv\",\n    name: \"TUVALU\",\n    state_name_type: \"island\",\n    sub_isoids: \"FUN~NMG~NMA~~NIT~NUI~NKF~NKL~VAI\",\n    sub_keys:\n      \"Funafuti~Nanumanga~Nanumea~Niulakita~Niutao~Nui~Nukufetau~Nukulaelae~Vaitupu\",\n    upper: \"ACS\",\n  },\n  \"data/TW\": {\n    fmt: \"%Z%n%S%C%n%A%n%O%n%N\",\n    id: \"data/TW\",\n    key: \"TW\",\n    lang: \"zh-Hant\",\n    languages: \"zh-Hant\",\n    lfmt: \"%N%n%O%n%A%n%C, %S %Z\",\n    name: \"TAIWAN\",\n    posturl:\n      \"http://www.post.gov.tw/post/internet/f_searchzone/index.jsp?ID=190102\",\n    require: \"ACSZ\",\n    state_name_type: \"county\",\n    sub_isoids:\n      \"TXG~TPE~TTT~TNN~ILA~HUA~~NAN~PIF~MIA~TAO~KHH~KEE~~YUN~NWT~HSZ~HSQ~CYI~CYQ~CHA~PEN\",\n    sub_keys:\n      \"台中市~台北市~台東縣~台南市~宜蘭縣~花蓮縣~金門縣~南投縣~屏東縣~苗栗縣~桃園市~高雄市~基隆市~連江縣~雲林縣~新北市~新竹市~新竹縣~嘉義市~嘉義縣~彰化縣~澎湖縣\",\n    sub_lnames:\n      \"Taichung City~Taipei City~Taitung County~Tainan City~Yilan County~Hualien County~Kinmen County~Nantou County~Pingtung County~Miaoli County~Taoyuan City~Kaohsiung City~Keelung City~Lienchiang County~Yunlin County~New Taipei City~Hsinchu City~Hsinchu County~Chiayi City~Chiayi County~Changhua County~Penghu County\",\n    sub_mores:\n      \"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\",\n    sub_zipexs:\n      \"400,408,411,439~100,119~950,966~700,745~260,272~970,983~890,896~540,558~900,947~350,369~320,338~800,815,817,852~200,206~209,212~630,655~207,208,220,253~~302,315~~602,625~500,530~880,885\",\n    sub_zips:\n      \"4[0-3]~1[01]~9[56]~7[0-4]~2[67]~9[78]~89~5[45]~9[0-4]~3[56]~3[23]~8[02-5]|81[1-579]~20[0-6]~209|21[012]~6[3-5]~20[78]|2[2345]~300~30[2-8]|31~600~60[1-9]|6[12]~5[0123]~88\",\n    zip: \"\\\\d{3}(?:\\\\d{2})?\",\n    zipex: \"104,106,10603,40867\",\n  },\n  \"data/TZ\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/TZ\",\n    key: \"TZ\",\n    name: \"TANZANIA (UNITED REP.)\",\n    zip: \"\\\\d{4,5}\",\n    zipex: \"6090,34413\",\n  },\n  \"data/UA\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S%n%Z\",\n    id: \"data/UA\",\n    key: \"UA\",\n    lang: \"uk\",\n    languages: \"uk\",\n    lfmt: \"%N%n%O%n%A%n%C%n%S%n%Z\",\n    name: \"UKRAINE\",\n    posturl: \"http://services.ukrposhta.com/postindex_new/\",\n    require: \"ACSZ\",\n    state_name_type: \"oblast\",\n    sub_isoids:\n      \"43~05~07~12~14~18~21~23~26~30~32~35~09~46~48~51~53~56~40~59~61~63~65~68~71~77~74\",\n    sub_keys:\n      \"Автономна Республіка Крим~Вінницька область~Волинська область~Дніпропетровська область~Донецька область~Житомирська область~Закарпатська область~Запорізька область~Івано-Франківська область~місто Київ~Київська область~Кіровоградська область~Луганська область~Львівська область~Миколаївська область~Одеська область~Полтавська область~Рівненська область~місто Севастополь~Сумська область~Тернопільська область~Харківська область~Херсонська область~Хмельницька область~Черкаська область~Чернівецька область~Чернігівська область\",\n    sub_lnames:\n      \"Crimea~Vinnyts'ka oblast~Volyns'ka oblast~Dnipropetrovsk oblast~Donetsk oblast~Zhytomyrs'ka oblast~Zakarpats'ka oblast~Zaporiz'ka oblast~Ivano-Frankivs'ka oblast~Kyiv city~Kiev oblast~Kirovohrads'ka oblast~Luhans'ka oblast~Lviv oblast~Mykolaivs'ka oblast~Odessa oblast~Poltavs'ka oblast~Rivnens'ka oblast~Sevastopol' city~Sums'ka oblast~Ternopil's'ka oblast~Kharkiv oblast~Khersons'ka oblast~Khmel'nyts'ka oblast~Cherkas'ka oblast~Chernivets'ka oblast~Chernihivs'ka oblast\",\n    sub_names:\n      \"Автономна Республіка Крим~Вінницька область~Волинська область~Дніпропетровська область~Донецька область~Житомирська область~Закарпатська область~Запорізька область~Івано-Франківська область~Київ~Київська область~Кіровоградська область~Луганська область~Львівська область~Миколаївська область~Одеська область~Полтавська область~Рівненська область~Севастополь~Сумська область~Тернопільська область~Харківська область~Херсонська область~Хмельницька область~Черкаська область~Чернівецька область~Чернігівська область\",\n    sub_zips:\n      \"9[5-8]~2[1-4]~4[3-5]~49|5[0-3]~8[3-7]~1[0-3]~8[89]|90~69|7[0-2]~7[6-8]~0[1-6]~0[7-9]~2[5-8]~9[1-4]~79|8[0-2]~5[4-7]~6[5-8]~3[6-9]~3[3-5]~99~4[0-2]~4[6-8]~6[1-4]~7[3-5]~29|3[0-2]~1[89]|20~5[89]|60~1[4-7]\",\n    zip: \"\\\\d{5}\",\n    zipex: \"15432,01055,01001\",\n  },\n  \"data/UG\": { id: \"data/UG\", key: \"UG\", name: \"UGANDA\" },\n  \"data/US\": {\n    fmt: \"%N%n%O%n%A%n%C, %S %Z\",\n    id: \"data/US\",\n    key: \"US\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"UNITED STATES\",\n    posturl: \"https://tools.usps.com/go/ZipLookupAction!input.action\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    sub_isoids:\n      \"AL~AK~~AZ~AR~~~~CA~CO~CT~DE~DC~FL~GA~~HI~ID~IL~IN~IA~KS~KY~LA~ME~~MD~MA~MI~~MN~MS~MO~MT~NE~NV~NH~NJ~NM~NY~NC~ND~~OH~OK~OR~~PA~~RI~SC~SD~TN~TX~UT~VT~~VA~WA~WV~WI~WY\",\n    sub_keys:\n      \"AL~AK~AS~AZ~AR~AA~AE~AP~CA~CO~CT~DE~DC~FL~GA~GU~HI~ID~IL~IN~IA~KS~KY~LA~ME~MH~MD~MA~MI~FM~MN~MS~MO~MT~NE~NV~NH~NJ~NM~NY~NC~ND~MP~OH~OK~OR~PW~PA~PR~RI~SC~SD~TN~TX~UT~VT~VI~VA~WA~WV~WI~WY\",\n    sub_names:\n      \"Alabama~Alaska~American Samoa~Arizona~Arkansas~Armed Forces (AA)~Armed Forces (AE)~Armed Forces (AP)~California~Colorado~Connecticut~Delaware~District of Columbia~Florida~Georgia~Guam~Hawaii~Idaho~Illinois~Indiana~Iowa~Kansas~Kentucky~Louisiana~Maine~Marshall Islands~Maryland~Massachusetts~Michigan~Micronesia~Minnesota~Mississippi~Missouri~Montana~Nebraska~Nevada~New Hampshire~New Jersey~New Mexico~New York~North Carolina~North Dakota~Northern Mariana Islands~Ohio~Oklahoma~Oregon~Palau~Pennsylvania~Puerto Rico~Rhode Island~South Carolina~South Dakota~Tennessee~Texas~Utah~Vermont~Virgin Islands~Virginia~Washington~West Virginia~Wisconsin~Wyoming\",\n    sub_zipexs:\n      \"35000,36999~99500,99999~96799~85000,86999~71600,72999~34000,34099~09000,09999~96200,96699~90000,96199~80000,81999~06000,06999~19700,19999~20000,56999~32000,34999~30000,39901~96910,96932~96700,96899~83200,83999~60000,62999~46000,47999~50000,52999~66000,67999~40000,42799~70000,71599~03900,04999~96960,96979~20600,21999~01000,05544~48000,49999~96941,96944~55000,56799~38600,39799~63000,65999~59000,59999~68000,69999~88900,89999~03000,03899~07000,08999~87000,88499~10000,00544~27000,28999~58000,58999~96950,96952~43000,45999~73000,74999~97000,97999~96940~15000,19699~00600,00999~02800,02999~29000,29999~57000,57999~37000,38599~75000,73344~84000,84999~05000,05999~00800,00899~20100,24699~98000,99499~24700,26999~53000,54999~82000,83414\",\n    sub_zips:\n      \"3[56]~99[5-9]~96799~8[56]~71[6-9]|72~340~09~96[2-6]~9[0-5]|96[01]~8[01]~06~19[7-9]~20[02-5]|569~3[23]|34[1-9]~3[01]|398|39901~969([1-2]\\\\d|3[12])~967[0-8]|9679[0-8]|968~83[2-9]~6[0-2]~4[67]~5[0-2]~6[67]~4[01]|42[0-7]~70|71[0-5]~039|04~969[67]~20[6-9]|21~01|02[0-7]|05501|05544~4[89]~9694[1-4]~55|56[0-7]~38[6-9]|39[0-7]~6[3-5]~59~6[89]~889|89~03[0-8]~0[78]~87|88[0-4]~1[0-4]|06390|00501|00544~2[78]~58~9695[0-2]~4[3-5]~7[34]~97~969(39|40)~1[5-8]|19[0-6]~00[679]~02[89]~29~57~37|38[0-5]~7[5-9]|885|73301|73344~84~05~008~201|2[23]|24[0-6]~98|99[0-4]~24[7-9]|2[56]~5[34]~82|83[01]|83414\",\n    upper: \"CS\",\n    zip: \"(\\\\d{5})(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"95014,22162-1010\",\n  },\n  \"data/UY\": {\n    fmt: \"%N%n%O%n%A%n%Z %C %S\",\n    id: \"data/UY\",\n    key: \"UY\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"URUGUAY\",\n    posturl:\n      \"http://www.correo.com.uy/index.asp?codPag=codPost&switchMapa=codPost\",\n    sub_isoids: \"AR~CA~CL~CO~DU~FS~FD~LA~MA~MO~PA~RN~RV~RO~SA~SJ~SO~TA~TT\",\n    sub_keys:\n      \"Artigas~Canelones~Cerro Largo~Colonia~Durazno~Flores~Florida~Lavalleja~Maldonado~Montevideo~Paysandú~Río Negro~Rivera~Rocha~Salto~San José~Soriano~Tacuarembó~Treinta y Tres\",\n    sub_zips:\n      \"55~9[01]|1[456]~37~70|75204~97~85~94|9060|97005~30~20~1|91600~60~65|60002~40~27~50~80~75|70003~45~33|30203|30204|30302|37007\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"11600\",\n  },\n  \"data/UZ\": {\n    fmt: \"%N%n%O%n%A%n%Z %C%n%S\",\n    id: \"data/UZ\",\n    key: \"UZ\",\n    name: \"UZBEKISTAN\",\n    posturl: \"http://www.pochta.uz/ru/uslugi/indexsearch.html\",\n    upper: \"CS\",\n    zip: \"\\\\d{6}\",\n    zipex: \"702100,700000\",\n  },\n  \"data/VA\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/VA\",\n    key: \"VA\",\n    name: \"VATICAN\",\n    zip: \"00120\",\n    zipex: \"00120\",\n  },\n  \"data/VC\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/VC\",\n    key: \"VC\",\n    name: \"SAINT VINCENT AND THE GRENADINES (ANTILLES)\",\n    posturl:\n      \"http://www.svgpost.gov.vc/?option=com_content&view=article&id=3&Itemid=16\",\n    zip: \"VC\\\\d{4}\",\n    zipex: \"VC0100,VC0110,VC0400\",\n  },\n  \"data/VE\": {\n    fmt: \"%N%n%O%n%A%n%C %Z, %S\",\n    id: \"data/VE\",\n    key: \"VE\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"VENEZUELA\",\n    posturl: \"http://www.ipostel.gob.ve/index.php/oficinas-postales\",\n    require: \"ACS\",\n    state_name_type: \"state\",\n    sub_isoids: \"Z~B~C~D~E~F~G~H~Y~W~A~I~J~K~L~M~N~O~P~R~S~T~X~U~V\",\n    sub_keys:\n      \"Amazonas~Anzoátegui~Apure~Aragua~Barinas~Bolívar~Carabobo~Cojedes~Delta Amacuro~Dependencias Federales~Distrito Federal~Falcón~Guárico~Lara~Mérida~Miranda~Monagas~Nueva Esparta~Portuguesa~Sucre~Táchira~Trujillo~Vargas~Yaracuy~Zulia\",\n    upper: \"CS\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1010,3001,8011,1020\",\n  },\n  \"data/VG\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/VG\",\n    key: \"VG\",\n    name: \"VIRGIN ISLANDS (BRITISH)\",\n    require: \"A\",\n    zip: \"VG\\\\d{4}\",\n    zipex: \"VG1110,VG1150,VG1160\",\n  },\n  \"data/VI\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/VI\",\n    key: \"VI\",\n    name: \"VIRGIN ISLANDS (U.S.)\",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    upper: \"ACNOS\",\n    zip: \"(008(?:(?:[0-4]\\\\d)|(?:5[01])))(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"00802-1222,00850-9802\",\n  },\n  \"data/VN\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S %Z\",\n    id: \"data/VN\",\n    key: \"VN\",\n    lang: \"vi\",\n    languages: \"vi\",\n    lfmt: \"%N%n%O%n%A%n%C%n%S %Z\",\n    name: \"VIET NAM\",\n    posturl: \"http://postcode.vnpost.vn/services/search.aspx\",\n    sub_isoids:\n      \"44~43~55~54~53~56~50~57~31~58~40~59~04~CT~DN~33~72~71~39~45~30~03~63~HN~23~61~HP~73~14~66~34~47~28~01~09~02~35~41~67~22~18~36~68~32~24~27~29~13~25~52~05~37~20~69~21~SG~26~46~51~07~49~70~06\",\n    sub_keys:\n      \"An Giang~Bà Rịa–Vũng Tàu~Bạc Liêu~Bắc Giang~Bắc Kạn~Bắc Ninh~Bến Tre~Bình Dương~Bình Định~Bình Phước~Bình Thuận~Cà Mau~Cao Bằng~Cần Thơ~Đà Nẵng~Đắk Lắk~Đăk Nông~Điện Biên~Đồng Nai~Đồng Tháp~Gia Lai~Hà Giang~Hà Nam~Hà Nội~Hà Tĩnh~Hải Dương~Hải Phòng~Hậu Giang~Hòa Bình~Hưng Yên~Khánh Hòa~Kiên Giang~Kon Tum~Lai Châu~Lạng Sơn~Lào Cai~Lâm Đồng~Long An~Nam Định~Nghệ An~Ninh Bình~Ninh Thuận~Phú Thọ~Phú Yên~Quảng Bình~Quảng Nam~Quảng Ngãi~Quảng Ninh~Quảng Trị~Sóc Trăng~Sơn La~Tây Ninh~Thái Bình~Thái Nguyên~Thanh Hóa~Thành phố Hồ Chí Minh~Thừa Thiên–Huế~Tiền Giang~Trà Vinh~Tuyên Quang~Vĩnh Long~Vĩnh Phúc~Yên Bái\",\n    sub_lnames:\n      \"An Giang Province~Ba Ria-Vung Tau Province~Bac Lieu Province~Bac Giang Province~Bac Kan Province~Bac Ninh Province~Ben Tre Province~Binh Duong Province~Binh Dinh Province~Binh Phuoc Province~Binh Thuan Province~Ca Mau Province~Cao Bang Province~Can Tho City~Da Nang City~Dak Lak Province~Dak Nong Province~Dien Bien Province~Dong Nai Province~Dong Thap Province~Gia Lai Province~Ha Giang Province~Ha Nam Province~Hanoi City~Ha Tinh Province~Hai Duong Province~Haiphong City~Hau Giang Province~Hoa Binh Province~Hung Yen Province~Khanh Hoa Province~Kien Giang Province~Kon Tum Province~Lai Chau Province~Lang Song Province~Lao Cai Province~Lam Dong Province~Long An Province~Nam Dinh Province~Nghe An Province~Ninh Binh Province~Ninh Thuan Province~Phu Tho Province~Phu Yen Province~Quang Binh Province~Quang Nam Province~Quang Ngai Province~Quang Ninh Province~Quang Tri Province~Soc Trang Province~Son La Province~Tay Ninh Province~Thai Binh Province~Thai Nguyen Province~Thanh Hoa Province~Ho Chi Minh City~Thua Thien-Hue Province~Tien Giang Province~Tra Vinh Province~Tuyen Quang Province~Vinh Long Province~Vinh Phuc Province~Yen Bai Province\",\n    zip: \"\\\\d{5}\\\\d?\",\n    zipex: \"70010,55999\",\n  },\n  \"data/VU\": { id: \"data/VU\", key: \"VU\", name: \"VANUATU\" },\n  \"data/WF\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/WF\",\n    key: \"WF\",\n    name: \"WALLIS AND FUTUNA ISLANDS\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"986\\\\d{2}\",\n    zipex: \"98600\",\n  },\n  \"data/WS\": { id: \"data/WS\", key: \"WS\", name: \"SAMOA\" },\n  \"data/XK\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/XK\",\n    key: \"XK\",\n    name: \"KOSOVO\",\n    zip: \"[1-7]\\\\d{4}\",\n    zipex: \"10000\",\n  },\n  \"data/YE\": { id: \"data/YE\", key: \"YE\", name: \"YEMEN\" },\n  \"data/YT\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/YT\",\n    key: \"YT\",\n    name: \"MAYOTTE\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"976\\\\d{2}\",\n    zipex: \"97600\",\n  },\n  \"data/ZA\": {\n    fmt: \"%N%n%O%n%A%n%D%n%C%n%Z\",\n    id: \"data/ZA\",\n    key: \"ZA\",\n    name: \"SOUTH AFRICA\",\n    posturl: \"https://www.postoffice.co.za/Questions/postalcode.html\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}\",\n    zipex: \"0083,1451,0001\",\n  },\n  \"data/ZM\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/ZM\",\n    key: \"ZM\",\n    name: \"ZAMBIA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"50100,50101\",\n  },\n  \"data/ZW\": { id: \"data/ZW\", key: \"ZW\", name: \"ZIMBABWE\" },\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AddressMetaData);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs":
/*!******************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressMetaDataExtension: () => (/* binding */ AddressMetaDataExtension),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst AddressMetaDataExtension = {\n  \"data/AF\": {\n    alpha_3_code: \"AFG\",\n  },\n  \"data/AX\": {\n    alpha_3_code: \"ALA\",\n  },\n  \"data/AL\": {\n    alpha_3_code: \"ALB\",\n  },\n  \"data/DZ\": {\n    alpha_3_code: \"DZA\",\n  },\n  \"data/AS\": {\n    alpha_3_code: \"ASM\",\n  },\n  \"data/AD\": {\n    alpha_3_code: \"AND\",\n  },\n  \"data/AO\": {\n    alpha_3_code: \"AGO\",\n  },\n  \"data/AI\": {\n    alpha_3_code: \"AIA\",\n  },\n  \"data/AQ\": {\n    alpha_3_code: \"ATA\",\n  },\n  \"data/AG\": {\n    alpha_3_code: \"ATG\",\n  },\n  \"data/AR\": {\n    alpha_3_code: \"ARG\",\n  },\n  \"data/AM\": {\n    alpha_3_code: \"ARM\",\n  },\n  \"data/AW\": {\n    alpha_3_code: \"ABW\",\n  },\n  \"data/AU\": {\n    alpha_3_code: \"AUS\",\n  },\n  \"data/AT\": {\n    alpha_3_code: \"AUT\",\n  },\n  \"data/AZ\": {\n    alpha_3_code: \"AZE\",\n  },\n  \"data/BS\": {\n    alpha_3_code: \"BHS\",\n  },\n  \"data/BH\": {\n    alpha_3_code: \"BHR\",\n  },\n  \"data/BD\": {\n    alpha_3_code: \"BGD\",\n  },\n  \"data/BB\": {\n    alpha_3_code: \"BRB\",\n  },\n  \"data/BY\": {\n    alpha_3_code: \"BLR\",\n  },\n  \"data/BE\": {\n    alpha_3_code: \"BEL\",\n  },\n  \"data/BZ\": {\n    alpha_3_code: \"BLZ\",\n  },\n  \"data/BJ\": {\n    alpha_3_code: \"BEN\",\n  },\n  \"data/BM\": {\n    alpha_3_code: \"BMU\",\n  },\n  \"data/BT\": {\n    alpha_3_code: \"BTN\",\n  },\n  \"data/BO\": {\n    alpha_3_code: \"BOL\",\n  },\n  \"data/BQ\": {\n    alpha_3_code: \"BES\",\n  },\n  \"data/BA\": {\n    alpha_3_code: \"BIH\",\n  },\n  \"data/BW\": {\n    alpha_3_code: \"BWA\",\n  },\n  \"data/BV\": {\n    alpha_3_code: \"BVT\",\n  },\n  \"data/BR\": {\n    alpha_3_code: \"BRA\",\n  },\n  \"data/IO\": {\n    alpha_3_code: \"IOT\",\n  },\n  \"data/BN\": {\n    alpha_3_code: \"BRN\",\n  },\n  \"data/BG\": {\n    alpha_3_code: \"BGR\",\n  },\n  \"data/BF\": {\n    alpha_3_code: \"BFA\",\n  },\n  \"data/BI\": {\n    alpha_3_code: \"BDI\",\n  },\n  \"data/CV\": {\n    alpha_3_code: \"CPV\",\n  },\n  \"data/KH\": {\n    alpha_3_code: \"KHM\",\n  },\n  \"data/CM\": {\n    alpha_3_code: \"CMR\",\n  },\n  \"data/CA\": {\n    alpha_3_code: \"CAN\",\n  },\n  \"data/KY\": {\n    alpha_3_code: \"CYM\",\n  },\n  \"data/CF\": {\n    alpha_3_code: \"CAF\",\n  },\n  \"data/TD\": {\n    alpha_3_code: \"TCD\",\n  },\n  \"data/CL\": {\n    alpha_3_code: \"CHL\",\n  },\n  \"data/CN\": {\n    alpha_3_code: \"CHN\",\n  },\n  \"data/CX\": {\n    alpha_3_code: \"CXR\",\n  },\n  \"data/CC\": {\n    alpha_3_code: \"CCK\",\n  },\n  \"data/CO\": {\n    alpha_3_code: \"COL\",\n  },\n  \"data/KM\": {\n    alpha_3_code: \"COM\",\n  },\n  \"data/CG\": {\n    alpha_3_code: \"COG\",\n  },\n  \"data/CD\": {\n    alpha_3_code: \"COD\",\n  },\n  \"data/CK\": {\n    alpha_3_code: \"COK\",\n  },\n  \"data/CR\": {\n    alpha_3_code: \"CRI\",\n  },\n  \"data/CI\": {\n    alpha_3_code: \"CIV\",\n  },\n  \"data/HR\": {\n    alpha_3_code: \"HRV\",\n  },\n  \"data/CU\": {\n    alpha_3_code: \"CUB\",\n  },\n  \"data/CW\": {\n    alpha_3_code: \"CUW\",\n  },\n  \"data/CY\": {\n    alpha_3_code: \"CYP\",\n  },\n  \"data/CZ\": {\n    alpha_3_code: \"CZE\",\n  },\n  \"data/DK\": {\n    alpha_3_code: \"DNK\",\n  },\n  \"data/DJ\": {\n    alpha_3_code: \"DJI\",\n  },\n  \"data/DM\": {\n    alpha_3_code: \"DMA\",\n  },\n  \"data/DO\": {\n    alpha_3_code: \"DOM\",\n  },\n  \"data/EC\": {\n    alpha_3_code: \"ECU\",\n  },\n  \"data/EG\": {\n    alpha_3_code: \"EGY\",\n  },\n  \"data/SV\": {\n    alpha_3_code: \"SLV\",\n  },\n  \"data/GQ\": {\n    alpha_3_code: \"GNQ\",\n  },\n  \"data/ER\": {\n    alpha_3_code: \"ERI\",\n  },\n  \"data/EE\": {\n    alpha_3_code: \"EST\",\n  },\n  \"data/SZ\": {\n    alpha_3_code: \"SWZ\",\n  },\n  \"data/ET\": {\n    alpha_3_code: \"ETH\",\n  },\n  \"data/FK\": {\n    alpha_3_code: \"FLK\",\n  },\n  \"data/FO\": {\n    alpha_3_code: \"FRO\",\n  },\n  \"data/FJ\": {\n    alpha_3_code: \"FJI\",\n  },\n  \"data/FI\": {\n    alpha_3_code: \"FIN\",\n  },\n  \"data/FR\": {\n    alpha_3_code: \"FRA\",\n  },\n  \"data/GF\": {\n    alpha_3_code: \"GUF\",\n  },\n  \"data/PF\": {\n    alpha_3_code: \"PYF\",\n  },\n  \"data/TF\": {\n    alpha_3_code: \"ATF\",\n  },\n  \"data/GA\": {\n    alpha_3_code: \"GAB\",\n  },\n  \"data/GM\": {\n    alpha_3_code: \"GMB\",\n  },\n  \"data/GE\": {\n    alpha_3_code: \"GEO\",\n  },\n  \"data/DE\": {\n    alpha_3_code: \"DEU\",\n    address_reversed: true,\n  },\n  \"data/GH\": {\n    alpha_3_code: \"GHA\",\n  },\n  \"data/GI\": {\n    alpha_3_code: \"GIB\",\n  },\n  \"data/GR\": {\n    alpha_3_code: \"GRC\",\n  },\n  \"data/GL\": {\n    alpha_3_code: \"GRL\",\n  },\n  \"data/GD\": {\n    alpha_3_code: \"GRD\",\n  },\n  \"data/GP\": {\n    alpha_3_code: \"GLP\",\n  },\n  \"data/GU\": {\n    alpha_3_code: \"GUM\",\n  },\n  \"data/GT\": {\n    alpha_3_code: \"GTM\",\n  },\n  \"data/GG\": {\n    alpha_3_code: \"GGY\",\n  },\n  \"data/GN\": {\n    alpha_3_code: \"GIN\",\n  },\n  \"data/GW\": {\n    alpha_3_code: \"GNB\",\n  },\n  \"data/GY\": {\n    alpha_3_code: \"GUY\",\n  },\n  \"data/HT\": {\n    alpha_3_code: \"HTI\",\n  },\n  \"data/HM\": {\n    alpha_3_code: \"HMD\",\n  },\n  \"data/VA\": {\n    alpha_3_code: \"VAT\",\n  },\n  \"data/HN\": {\n    alpha_3_code: \"HND\",\n  },\n  \"data/HK\": {\n    alpha_3_code: \"HKG\",\n  },\n  \"data/HU\": {\n    alpha_3_code: \"HUN\",\n  },\n  \"data/IS\": {\n    alpha_3_code: \"ISL\",\n  },\n  \"data/IN\": {\n    alpha_3_code: \"IND\",\n  },\n  \"data/ID\": {\n    alpha_3_code: \"IDN\",\n  },\n  \"data/IR\": {\n    alpha_3_code: \"IRN\",\n  },\n  \"data/IQ\": {\n    alpha_3_code: \"IRQ\",\n  },\n  \"data/IE\": {\n    alpha_3_code: \"IRL\",\n  },\n  \"data/IM\": {\n    alpha_3_code: \"IMN\",\n  },\n  \"data/IL\": {\n    alpha_3_code: \"ISR\",\n  },\n  \"data/IT\": {\n    alpha_3_code: \"ITA\",\n  },\n  \"data/JM\": {\n    alpha_3_code: \"JAM\",\n  },\n  \"data/JP\": {\n    alpha_3_code: \"JPN\",\n  },\n  \"data/JE\": {\n    alpha_3_code: \"JEY\",\n  },\n  \"data/JO\": {\n    alpha_3_code: \"JOR\",\n  },\n  \"data/KZ\": {\n    alpha_3_code: \"KAZ\",\n  },\n  \"data/KE\": {\n    alpha_3_code: \"KEN\",\n  },\n  \"data/KI\": {\n    alpha_3_code: \"KIR\",\n  },\n  \"data/KP\": {\n    alpha_3_code: \"PRK\",\n  },\n  \"data/KR\": {\n    alpha_3_code: \"KOR\",\n  },\n  \"data/KW\": {\n    alpha_3_code: \"KWT\",\n  },\n  \"data/KG\": {\n    alpha_3_code: \"KGZ\",\n  },\n  \"data/LA\": {\n    alpha_3_code: \"LAO\",\n  },\n  \"data/LV\": {\n    alpha_3_code: \"LVA\",\n  },\n  \"data/LB\": {\n    alpha_3_code: \"LBN\",\n  },\n  \"data/LS\": {\n    alpha_3_code: \"LSO\",\n  },\n  \"data/LR\": {\n    alpha_3_code: \"LBR\",\n  },\n  \"data/LY\": {\n    alpha_3_code: \"LBY\",\n  },\n  \"data/LI\": {\n    alpha_3_code: \"LIE\",\n  },\n  \"data/LT\": {\n    alpha_3_code: \"LTU\",\n  },\n  \"data/LU\": {\n    alpha_3_code: \"LUX\",\n  },\n  \"data/MO\": {\n    alpha_3_code: \"MAC\",\n  },\n  \"data/MG\": {\n    alpha_3_code: \"MDG\",\n  },\n  \"data/MW\": {\n    alpha_3_code: \"MWI\",\n  },\n  \"data/MY\": {\n    alpha_3_code: \"MYS\",\n  },\n  \"data/MV\": {\n    alpha_3_code: \"MDV\",\n  },\n  \"data/ML\": {\n    alpha_3_code: \"MLI\",\n  },\n  \"data/MT\": {\n    alpha_3_code: \"MLT\",\n  },\n  \"data/MH\": {\n    alpha_3_code: \"MHL\",\n  },\n  \"data/MQ\": {\n    alpha_3_code: \"MTQ\",\n  },\n  \"data/MR\": {\n    alpha_3_code: \"MRT\",\n  },\n  \"data/MU\": {\n    alpha_3_code: \"MUS\",\n  },\n  \"data/YT\": {\n    alpha_3_code: \"MYT\",\n  },\n  \"data/MX\": {\n    alpha_3_code: \"MEX\",\n  },\n  \"data/FM\": {\n    alpha_3_code: \"FSM\",\n  },\n  \"data/MD\": {\n    alpha_3_code: \"MDA\",\n  },\n  \"data/MC\": {\n    alpha_3_code: \"MCO\",\n  },\n  \"data/MN\": {\n    alpha_3_code: \"MNG\",\n  },\n  \"data/ME\": {\n    alpha_3_code: \"MNE\",\n  },\n  \"data/MS\": {\n    alpha_3_code: \"MSR\",\n  },\n  \"data/MA\": {\n    alpha_3_code: \"MAR\",\n  },\n  \"data/MZ\": {\n    alpha_3_code: \"MOZ\",\n  },\n  \"data/MM\": {\n    alpha_3_code: \"MMR\",\n  },\n  \"data/NA\": {\n    alpha_3_code: \"NAM\",\n  },\n  \"data/NR\": {\n    alpha_3_code: \"NRU\",\n  },\n  \"data/NP\": {\n    alpha_3_code: \"NPL\",\n  },\n  \"data/NL\": {\n    alpha_3_code: \"NLD\",\n  },\n  \"data/NC\": {\n    alpha_3_code: \"NCL\",\n  },\n  \"data/NZ\": {\n    alpha_3_code: \"NZL\",\n  },\n  \"data/NI\": {\n    alpha_3_code: \"NIC\",\n  },\n  \"data/NE\": {\n    alpha_3_code: \"NER\",\n  },\n  \"data/NG\": {\n    alpha_3_code: \"NGA\",\n  },\n  \"data/NU\": {\n    alpha_3_code: \"NIU\",\n  },\n  \"data/NF\": {\n    alpha_3_code: \"NFK\",\n  },\n  \"data/MK\": {\n    alpha_3_code: \"MKD\",\n  },\n  \"data/MP\": {\n    alpha_3_code: \"MNP\",\n  },\n  \"data/NO\": {\n    alpha_3_code: \"NOR\",\n  },\n  \"data/OM\": {\n    alpha_3_code: \"OMN\",\n  },\n  \"data/PK\": {\n    alpha_3_code: \"PAK\",\n  },\n  \"data/PW\": {\n    alpha_3_code: \"PLW\",\n  },\n  \"data/PS\": {\n    alpha_3_code: \"PSE\",\n  },\n  \"data/PA\": {\n    alpha_3_code: \"PAN\",\n  },\n  \"data/PG\": {\n    alpha_3_code: \"PNG\",\n  },\n  \"data/PY\": {\n    alpha_3_code: \"PRY\",\n  },\n  \"data/PE\": {\n    alpha_3_code: \"PER\",\n  },\n  \"data/PH\": {\n    alpha_3_code: \"PHL\",\n  },\n  \"data/PN\": {\n    alpha_3_code: \"PCN\",\n  },\n  \"data/PL\": {\n    alpha_3_code: \"POL\",\n  },\n  \"data/PT\": {\n    alpha_3_code: \"PRT\",\n  },\n  \"data/PR\": {\n    alpha_3_code: \"PRI\",\n  },\n  \"data/QA\": {\n    alpha_3_code: \"QAT\",\n  },\n  \"data/RE\": {\n    alpha_3_code: \"REU\",\n  },\n  \"data/RO\": {\n    alpha_3_code: \"ROU\",\n  },\n  \"data/RU\": {\n    alpha_3_code: \"RUS\",\n  },\n  \"data/RW\": {\n    alpha_3_code: \"RWA\",\n  },\n  \"data/BL\": {\n    alpha_3_code: \"BLM\",\n  },\n  \"data/SH\": {\n    alpha_3_code: \"SHN\",\n  },\n  \"data/KN\": {\n    alpha_3_code: \"KNA\",\n  },\n  \"data/LC\": {\n    alpha_3_code: \"LCA\",\n  },\n  \"data/MF\": {\n    alpha_3_code: \"MAF\",\n  },\n  \"data/PM\": {\n    alpha_3_code: \"SPM\",\n  },\n  \"data/VC\": {\n    alpha_3_code: \"VCT\",\n  },\n  \"data/WS\": {\n    alpha_3_code: \"WSM\",\n  },\n  \"data/SM\": {\n    alpha_3_code: \"SMR\",\n  },\n  \"data/ST\": {\n    alpha_3_code: \"STP\",\n  },\n  \"data/SA\": {\n    alpha_3_code: \"SAU\",\n  },\n  \"data/SN\": {\n    alpha_3_code: \"SEN\",\n  },\n  \"data/RS\": {\n    alpha_3_code: \"SRB\",\n  },\n  \"data/SC\": {\n    alpha_3_code: \"SYC\",\n  },\n  \"data/SL\": {\n    alpha_3_code: \"SLE\",\n  },\n  \"data/SG\": {\n    alpha_3_code: \"SGP\",\n  },\n  \"data/SX\": {\n    alpha_3_code: \"SXM\",\n  },\n  \"data/SK\": {\n    alpha_3_code: \"SVK\",\n  },\n  \"data/SI\": {\n    alpha_3_code: \"SVN\",\n  },\n  \"data/SB\": {\n    alpha_3_code: \"SLB\",\n  },\n  \"data/SO\": {\n    alpha_3_code: \"SOM\",\n  },\n  \"data/ZA\": {\n    alpha_3_code: \"ZAF\",\n  },\n  \"data/GS\": {\n    alpha_3_code: \"SGS\",\n  },\n  \"data/SS\": {\n    alpha_3_code: \"SSD\",\n  },\n  \"data/ES\": {\n    alpha_3_code: \"ESP\",\n  },\n  \"data/LK\": {\n    alpha_3_code: \"LKA\",\n  },\n  \"data/SD\": {\n    alpha_3_code: \"SDN\",\n  },\n  \"data/SR\": {\n    alpha_3_code: \"SUR\",\n  },\n  \"data/SJ\": {\n    alpha_3_code: \"SJM\",\n  },\n  \"data/SE\": {\n    alpha_3_code: \"SWE\",\n  },\n  \"data/CH\": {\n    alpha_3_code: \"CHE\",\n  },\n  \"data/SY\": {\n    alpha_3_code: \"SYR\",\n  },\n  \"data/TW\": {\n    alpha_3_code: \"TWN\",\n  },\n  \"data/TJ\": {\n    alpha_3_code: \"TJK\",\n  },\n  \"data/TZ\": {\n    alpha_3_code: \"TZA\",\n  },\n  \"data/TH\": {\n    alpha_3_code: \"THA\",\n  },\n  \"data/TL\": {\n    alpha_3_code: \"TLS\",\n  },\n  \"data/TG\": {\n    alpha_3_code: \"TGO\",\n  },\n  \"data/TK\": {\n    alpha_3_code: \"TKL\",\n  },\n  \"data/TO\": {\n    alpha_3_code: \"TON\",\n  },\n  \"data/TT\": {\n    alpha_3_code: \"TTO\",\n  },\n  \"data/TN\": {\n    alpha_3_code: \"TUN\",\n  },\n  \"data/TR\": {\n    alpha_3_code: \"TUR\",\n  },\n  \"data/TM\": {\n    alpha_3_code: \"TKM\",\n  },\n  \"data/TC\": {\n    alpha_3_code: \"TCA\",\n  },\n  \"data/TV\": {\n    alpha_3_code: \"TUV\",\n  },\n  \"data/UG\": {\n    alpha_3_code: \"UGA\",\n  },\n  \"data/UA\": {\n    alpha_3_code: \"UKR\",\n  },\n  \"data/AE\": {\n    alpha_3_code: \"ARE\",\n  },\n  \"data/GB\": {\n    alpha_3_code: \"GBR\",\n  },\n  \"data/US\": {\n    alternative_names: [\n      \"US\",\n      \"United States of America\",\n      \"United States\",\n      \"America\",\n      \"U.S.\",\n      \"USA\",\n      \"U.S.A.\",\n      \"U.S.A\",\n    ],\n    alpha_3_code: \"USA\",\n  },\n  \"data/UM\": {\n    alpha_3_code: \"UMI\",\n  },\n  \"data/UY\": {\n    alpha_3_code: \"URY\",\n  },\n  \"data/UZ\": {\n    alpha_3_code: \"UZB\",\n  },\n  \"data/VU\": {\n    alpha_3_code: \"VUT\",\n  },\n  \"data/VE\": {\n    alpha_3_code: \"VEN\",\n  },\n  \"data/VN\": {\n    alpha_3_code: \"VNM\",\n  },\n  \"data/VG\": {\n    alpha_3_code: \"VGB\",\n  },\n  \"data/VI\": {\n    alpha_3_code: \"VIR\",\n  },\n  \"data/WF\": {\n    alpha_3_code: \"WLF\",\n  },\n  \"data/EH\": {\n    alpha_3_code: \"ESH\",\n  },\n  \"data/YE\": {\n    alpha_3_code: \"YEM\",\n  },\n  \"data/ZM\": {\n    alpha_3_code: \"ZMB\",\n  },\n  \"data/ZW\": {\n    alpha_3_code: \"ZWE\",\n  },\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AddressMetaDataExtension);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs":
/*!***************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressMetaDataLoader: () => (/* binding */ AddressMetaDataLoader),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  AddressMetaData: \"resource://gre/modules/shared/AddressMetaData.sys.mjs\",\n  AddressMetaDataExtension:\n    \"resource://gre/modules/shared/AddressMetaDataExtension.sys.mjs\",\n});\n\nclass AddressMetaDataLoader {\n  // Status of address data loading. We'll load all the countries with basic level 1\n  // information while requesting conutry information, and set country to true.\n  // Level 1 Set is for recording which country's level 1/level 2 data is loaded,\n  // since we only load this when getCountryAddressData called with level 1 parameter.\n  static dataLoaded = {\n    country: false,\n    level1: new Set(),\n  };\n\n  static addressData = {};\n\n  static DATA_PREFIX = \"data/\";\n\n  /**\n   * Load address meta data and extension into one object.\n   *\n   * @returns {object}\n   *          An object containing address data object with properties from extension.\n   */\n  static loadAddressMetaData() {\n    const addressMetaData = lazy.AddressMetaData;\n\n    for (const key in lazy.AddressMetaDataExtension) {\n      let addressDataForKey = addressMetaData[key];\n      if (!addressDataForKey) {\n        addressDataForKey = addressMetaData[key] = {};\n      }\n\n      Object.assign(addressDataForKey, lazy.AddressMetaDataExtension[key]);\n    }\n    return addressMetaData;\n  }\n\n  /**\n   * Convert certain properties' string value into array. We should make sure\n   * the cached data is parsed.\n   *\n   * @param   {object} data Original metadata from addressReferences.\n   * @returns {object} parsed metadata with property value that converts to array.\n   */\n  static #parse(data) {\n    if (!data) {\n      return null;\n    }\n\n    const properties = [\n      \"languages\",\n      \"sub_keys\",\n      \"sub_isoids\",\n      \"sub_names\",\n      \"sub_lnames\",\n    ];\n    for (const key of properties) {\n      if (!data[key]) {\n        continue;\n      }\n      // No need to normalize data if the value is array already.\n      if (Array.isArray(data[key])) {\n        return data;\n      }\n\n      data[key] = data[key].split(\"~\");\n    }\n    return data;\n  }\n\n  /**\n   * We'll cache addressData in the loader once the data loaded from scripts.\n   * It'll become the example below after loading addressReferences with extension:\n   * addressData: {\n   *               \"data/US\": {\"lang\": [\"en\"], ...// Data defined in libaddressinput metadata\n   *                           \"alternative_names\": ... // Data defined in extension }\n   *               \"data/CA\": {} // Other supported country metadata\n   *               \"data/TW\": {} // Other supported country metadata\n   *               \"data/TW/台北市\": {} // Other supported country level 1 metadata\n   *              }\n   *\n   * @param   {string} country\n   * @param   {string?} level1\n   * @returns {object} Default locale metadata\n   */\n  static #loadData(country, level1 = null) {\n    // Load the addressData if needed\n    if (!this.dataLoaded.country) {\n      this.addressData = this.loadAddressMetaData();\n      this.dataLoaded.country = true;\n    }\n    if (!level1) {\n      return this.#parse(this.addressData[`${this.DATA_PREFIX}${country}`]);\n    }\n    // If level1 is set, load addressReferences under country folder with specific\n    // country/level 1 for level 2 information.\n    if (!this.dataLoaded.level1.has(country)) {\n      Object.assign(this.addressData, this.loadAddressMetaData());\n      this.dataLoaded.level1.add(country);\n    }\n    return this.#parse(\n      this.addressData[`${this.DATA_PREFIX}${country}/${level1}`]\n    );\n  }\n\n  /**\n   * Return the region metadata with default locale and other locales (if exists).\n   *\n   * @param   {string} country\n   * @param   {string?} level1\n   * @returns {object} Return default locale and other locales metadata.\n   */\n  static getData(country, level1 = null) {\n    const defaultLocale = this.#loadData(country, level1);\n    if (!defaultLocale) {\n      return null;\n    }\n\n    const countryData = this.#parse(\n      this.addressData[`${this.DATA_PREFIX}${country}`]\n    );\n    let locales = [];\n    // TODO: Should be able to support multi-locale level 1/ level 2 metadata query\n    //      in Bug 1421886\n    if (countryData.languages) {\n      const list = countryData.languages.filter(\n        key => key !== countryData.lang\n      );\n      locales = list.map(key =>\n        this.#parse(this.addressData[`${defaultLocale.id}--${key}`])\n      );\n    }\n    return { defaultLocale, locales };\n  }\n\n  /**\n   * Return an array containing countries alpha2 codes.\n   *\n   * @returns {Array} Return an array containing countries alpha2 codes.\n   */\n  static get #countryCodes() {\n    return Object.keys(lazy.AddressMetaDataExtension).map(dataKey =>\n      dataKey.replace(this.DATA_PREFIX, \"\")\n    );\n  }\n\n  static getCountries(locales = []) {\n    const displayNames = new Intl.DisplayNames(locales, {\n      type: \"region\",\n      fallback: \"none\",\n    });\n    const countriesMap = new Map();\n    for (const countryCode of this.#countryCodes) {\n      countriesMap.set(countryCode, displayNames.of(countryCode));\n    }\n    return countriesMap;\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AddressMetaDataLoader);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/AddressParser.sys.mjs":
/*!*******************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/AddressParser.sys.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressParser: () => (/* binding */ AddressParser),\n/* harmony export */   StructuredStreetAddress: () => (/* binding */ StructuredStreetAddress)\n/* harmony export */ });\n/* eslint-disable no-useless-concat */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// NamedCaptureGroup class represents a named capturing group in a regular expression\nclass NamedCaptureGroup {\n  // The named of this capturing group\n  #name = null;\n\n  // The capturing group\n  #capture = null;\n\n  // The matched result\n  #match = null;\n\n  constructor(name, capture) {\n    this.#name = name;\n    this.#capture = capture;\n  }\n\n  get name() {\n    return this.#name;\n  }\n\n  get capture() {\n    return this.#capture;\n  }\n\n  get match() {\n    return this.#match;\n  }\n\n  // Setter for the matched result based on the match groups\n  setMatch(matchGroups) {\n    this.#match = matchGroups[this.#name];\n  }\n}\n\n// Base class for different part of a street address regular expression.\n// The regular expression is constructed with prefix, pattern, suffix\n// and separator to extract \"value\" part.\n// For examplem, when we write \"apt 4.\" to for floor number, its prefix is `apt`,\n// suffix is `.` and value to represent apartment number is `4`.\nclass StreetAddressPartRegExp extends NamedCaptureGroup {\n  constructor(name, prefix, pattern, suffix, sep, optional = false) {\n    prefix = prefix ?? \"\";\n    suffix = suffix ?? \"\";\n    super(\n      name,\n      `((?:${prefix})(?<${name}>${pattern})(?:${suffix})(?:${sep})+)${\n        optional ? \"?\" : \"\"\n      }`\n    );\n  }\n}\n\n// A regular expression to match the street number portion of a street address,\nclass StreetNumberRegExp extends StreetAddressPartRegExp {\n  static PREFIX = \"((no|°|º|number)(\\\\.|-|\\\\s)*)?\"; // From chromium source\n\n  static PATTERN = \"\\\\d+\\\\w?\";\n\n  // TODO: possible suffix : (th\\\\.|\\\\.)?\n  static SUFFIX = null;\n\n  constructor(sep, optional) {\n    super(\n      StreetNumberRegExp.name,\n      StreetNumberRegExp.PREFIX,\n      StreetNumberRegExp.PATTERN,\n      StreetNumberRegExp.SUFFIX,\n      sep,\n      optional\n    );\n  }\n}\n\n// A regular expression to match the street name portion of a street address,\nclass StreetNameRegExp extends StreetAddressPartRegExp {\n  static PREFIX = null;\n\n  static PATTERN = \"(?:[^\\\\s,]+(?:[^\\\\S\\\\r\\\\n]+[^\\\\s,]+)*?)\"; // From chromium source\n\n  // TODO: Should we consider suffix like (ave|st)?\n  static SUFFIX = null;\n\n  constructor(sep, optional) {\n    super(\n      StreetNameRegExp.name,\n      StreetNameRegExp.PREFIX,\n      StreetNameRegExp.PATTERN,\n      StreetNameRegExp.SUFFIX,\n      sep,\n      optional\n    );\n  }\n}\n\n// A regular expression to match the apartment number portion of a street address,\nclass ApartmentNumberRegExp extends StreetAddressPartRegExp {\n  static keyword = \"apt|apartment|wohnung|apto|-\" + \"|unit|suite|ste|#|room\"; // From chromium source // Firefox specific\n  static PREFIX = `(${ApartmentNumberRegExp.keyword})(\\\\.|\\\\s|-)*`;\n\n  static PATTERN = \"\\\\w*([-|\\\\/]\\\\w*)?\";\n\n  static SUFFIX = \"(\\\\.|\\\\s|-)*(ª)?\"; // From chromium source\n\n  constructor(sep, optional) {\n    super(\n      ApartmentNumberRegExp.name,\n      ApartmentNumberRegExp.PREFIX,\n      ApartmentNumberRegExp.PATTERN,\n      ApartmentNumberRegExp.SUFFIX,\n      sep,\n      optional\n    );\n  }\n}\n\n// A regular expression to match the floor number portion of a street address,\nclass FloorNumberRegExp extends StreetAddressPartRegExp {\n  static keyword =\n    \"floor|flur|fl|og|obergeschoss|ug|untergeschoss|geschoss|andar|piso|º\" + // From chromium source\n    \"|level|lvl\"; // Firefox specific\n  static PREFIX = `(${FloorNumberRegExp.keyword})?(\\\\.|\\\\s|-)*`; // TODO\n  static PATTERN = \"\\\\d{1,3}\\\\w?\";\n  static SUFFIX = `(st|nd|rd|th)?(\\\\.|\\\\s|-)*(${FloorNumberRegExp.keyword})?`; // TODO\n\n  constructor(sep, optional) {\n    super(\n      FloorNumberRegExp.name,\n      FloorNumberRegExp.PREFIX,\n      FloorNumberRegExp.PATTERN,\n      FloorNumberRegExp.SUFFIX,\n      sep,\n      optional\n    );\n  }\n}\n\n/**\n * Class represents a street address with the following fields:\n * - street number\n * - street name\n * - apartment number\n * - floor number\n */\nclass StructuredStreetAddress {\n  #street_number = null;\n  #street_name = null;\n  #apartment_number = null;\n  #floor_number = null;\n\n  // If name_first is true, then the street name is given first,\n  // otherwise the street number is given first.\n  constructor(\n    name_first,\n    street_number,\n    street_name,\n    apartment_number,\n    floor_number\n  ) {\n    this.#street_number = name_first\n      ? street_name?.toString()\n      : street_number?.toString();\n    this.#street_name = name_first\n      ? street_number?.toString()\n      : street_name?.toString();\n    this.#apartment_number = apartment_number?.toString();\n    this.#floor_number = floor_number?.toString();\n  }\n\n  get street_number() {\n    return this.#street_number;\n  }\n\n  get street_name() {\n    return this.#street_name;\n  }\n\n  get apartment_number() {\n    return this.#apartment_number;\n  }\n\n  get floor_number() {\n    return this.#floor_number;\n  }\n\n  toString() {\n    return `\n      street number: ${this.#street_number}\\n\n      street name: ${this.#street_name}\\n\n      apartment number: ${this.#apartment_number}\\n\n      floor number: ${this.#floor_number}\\n\n    `;\n  }\n}\n\nclass AddressParser {\n  /**\n   * Parse street address with the following pattern.\n   * street number, street name, apartment number(optional), floor number(optional)\n   * For example, 2 Harrison St #175 floor 2\n   *\n   * @param {string} address The street address to be parsed.\n   * @returns {StructuredStreetAddress}\n   */\n  static parseStreetAddress(address) {\n    if (!address) {\n      return null;\n    }\n\n    const separator = \"(\\\\s|,|$)\";\n\n    const regexpes = [\n      new StreetNumberRegExp(separator),\n      new StreetNameRegExp(separator),\n      new ApartmentNumberRegExp(separator, true),\n      new FloorNumberRegExp(separator, true),\n    ];\n\n    if (AddressParser.parse(address, regexpes)) {\n      return new StructuredStreetAddress(\n        false,\n        ...regexpes.map(regexp => regexp.match)\n      );\n    }\n\n    // Swap the street number and name.\n    const regexpesReverse = [\n      regexpes[1],\n      regexpes[0],\n      regexpes[2],\n      regexpes[3],\n    ];\n\n    if (AddressParser.parse(address, regexpesReverse)) {\n      return new StructuredStreetAddress(\n        true,\n        ...regexpesReverse.map(regexp => regexp.match)\n      );\n    }\n\n    return null;\n  }\n\n  static parse(address, regexpes) {\n    const options = {\n      trim: true,\n      merge_whitespace: true,\n    };\n    address = AddressParser.normalizeString(address, options);\n\n    const match = address.match(\n      new RegExp(`^(${regexpes.map(regexp => regexp.capture).join(\"\")})$`, \"i\")\n    );\n    if (!match) {\n      return null;\n    }\n\n    regexpes.forEach(regexp => regexp.setMatch(match.groups));\n    return regexpes.reduce((acc, current) => {\n      return { ...acc, [current.name]: current.match };\n    }, {});\n  }\n\n  static normalizeString(s, options) {\n    if (typeof s != \"string\") {\n      return s;\n    }\n\n    if (options.ignore_case) {\n      s = s.toLowerCase();\n    }\n\n    // process punctuation before whitespace because if a punctuation\n    // is replaced with whitespace, we might want to merge it later\n    if (options.remove_punctuation) {\n      s = AddressParser.replacePunctuation(s, \"\");\n    } else if (\"replace_punctuation\" in options) {\n      const replace = options.replace_punctuation;\n      s = AddressParser.replacePunctuation(s, replace);\n    }\n\n    // process whitespace\n    if (options.merge_whitespace) {\n      s = AddressParser.mergeWhitespace(s);\n    } else if (options.remove_whitespace) {\n      s = AddressParser.removeWhitespace(s);\n    }\n\n    return s.trim();\n  }\n\n  static replacePunctuation(s, replace) {\n    const regex = /\\p{Punctuation}/gu;\n    return s?.replace(regex, replace);\n  }\n\n  static removePunctuation(s) {\n    return s?.replace(/[.,\\/#!$%\\^&\\*;:{}=\\-_~()]/g, \"\");\n  }\n\n  static replaceControlCharacters(s) {\n    return s?.replace(/[\\t\\n\\r]/g, \" \");\n  }\n\n  static removeWhitespace(s) {\n    return s?.replace(/[\\s]/g, \"\");\n  }\n\n  static mergeWhitespace(s) {\n    return s?.replace(/\\s{2,}/g, \" \");\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressParser.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs":
/*!*******************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressRecord: () => (/* binding */ AddressRecord)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_shared_FormAutofillNameUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillNameUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_PhoneNumber_sys_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! resource://gre/modules/shared/PhoneNumber.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs\");\n/* harmony import */ var resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! resource://autofill/FormAutofill.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs\");\n/* eslint-disable no-useless-concat */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\n\n\n/**\n * The AddressRecord class serves to handle and normalize internal address records.\n * AddressRecord is used for processing and consistent data representation.\n */\nclass AddressRecord {\n  static NAME_COMPONENTS = [\"given-name\", \"additional-name\", \"family-name\"];\n\n  static STREET_ADDRESS_COMPONENTS = [\n    \"address-line1\",\n    \"address-line2\",\n    \"address-line3\",\n  ];\n  static TEL_COMPONENTS = [\n    \"tel-country-code\",\n    \"tel-national\",\n    \"tel-area-code\",\n    \"tel-local\",\n    \"tel-local-prefix\",\n    \"tel-local-suffix\",\n  ];\n\n  static computeFields(address) {\n    this.#computeNameFields(address);\n    this.#computeAddressLineFields(address);\n    this.#computeCountryFields(address);\n    this.#computeTelFields(address);\n  }\n\n  static #computeNameFields(address) {\n    // Compute split names\n    if (!(\"given-name\" in address)) {\n      const nameParts = resource_gre_modules_shared_FormAutofillNameUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillNameUtils.splitName(address.name);\n      address[\"given-name\"] = nameParts.given;\n      address[\"additional-name\"] = nameParts.middle;\n      address[\"family-name\"] = nameParts.family;\n    }\n  }\n\n  static #computeAddressLineFields(address) {\n    // Compute address lines\n    if (!(\"address-line1\" in address)) {\n      let streetAddress = [];\n      if (address[\"street-address\"]) {\n        streetAddress = address[\"street-address\"]\n          .split(\"\\n\")\n          .map(s => s.trim());\n      }\n      for (let i = 0; i < 3; i++) {\n        address[`address-line${i + 1}`] = streetAddress[i] || \"\";\n      }\n      if (streetAddress.length > 3) {\n        address[\"address-line3\"] = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.toOneLineAddress(\n          streetAddress.slice(2)\n        );\n      }\n    }\n  }\n\n  static #computeCountryFields(address) {\n    // Compute country name\n    if (!(\"country-name\" in address)) {\n      address[\"country-name\"] =\n        resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.FormAutofill.countries.get(address.country) ?? \"\";\n    }\n  }\n\n  static #computeTelFields(address) {\n    // Compute tel\n    if (!(\"tel-national\" in address)) {\n      if (address.tel) {\n        let tel = resource_gre_modules_shared_PhoneNumber_sys_mjs__WEBPACK_IMPORTED_MODULE_2__.PhoneNumber.Parse(\n          address.tel,\n          address.country || resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.FormAutofill.DEFAULT_REGION\n        );\n        if (tel) {\n          if (tel.countryCode) {\n            address[\"tel-country-code\"] = tel.countryCode;\n          }\n          if (tel.nationalNumber) {\n            address[\"tel-national\"] = tel.nationalNumber;\n          }\n\n          // PhoneNumberUtils doesn't support parsing the components of a telephone\n          // number so we hard coded the parser for US numbers only. We will need\n          // to figure out how to parse numbers from other regions when we support\n          // new countries in the future.\n          if (tel.nationalNumber && tel.countryCode == \"+1\") {\n            let telComponents = tel.nationalNumber.match(\n              /(\\d{3})((\\d{3})(\\d{4}))$/\n            );\n            if (telComponents) {\n              address[\"tel-area-code\"] = telComponents[1];\n              address[\"tel-local\"] = telComponents[2];\n              address[\"tel-local-prefix\"] = telComponents[3];\n              address[\"tel-local-suffix\"] = telComponents[4];\n            }\n          }\n        } else {\n          // Treat \"tel\" as \"tel-national\" directly if it can't be parsed.\n          address[\"tel-national\"] = address.tel;\n        }\n      }\n\n      this.TEL_COMPONENTS.forEach(c => {\n        address[c] = address[c] || \"\";\n      });\n    }\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/AutofillFormFactory.sys.mjs":
/*!*************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/AutofillFormFactory.sys.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutofillFormFactory: () => (/* binding */ AutofillFormFactory)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * A factory to generate AutofillForm objects that represent a set of autofillable fields\n * which aren't necessarily marked up with a <form> element.\n */\n\nconst lazy = {};\n\nChromeUtils.defineESModuleGetters(lazy, {\n  FormLikeFactory: \"resource://gre/modules/FormLikeFactory.sys.mjs\",\n});\n\nconst AutofillFormFactory = {\n  findRootForField(element) {\n    let ignoreForm;\n    try {\n      const bc = element.ownerGlobal.browsingContext;\n      ignoreForm = bc != bc.top;\n    } catch {\n      ignoreForm = false;\n    }\n    return lazy.FormLikeFactory.findRootForField(element, { ignoreForm });\n  },\n\n  createFromForm(aForm) {\n    return lazy.FormLikeFactory.createFromForm(aForm);\n  },\n\n  createFromField(aField) {\n    let ignoreForm;\n    try {\n      const bc = aField.ownerGlobal.browsingContext;\n      ignoreForm = bc != bc.top;\n    } catch {\n      ignoreForm = false;\n    }\n    return lazy.FormLikeFactory.createFromField(aField, { ignoreForm });\n  },\n};\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AutofillFormFactory.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs":
/*!***********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressTelemetry: () => (/* binding */ AddressTelemetry),\n/* harmony export */   AutofillTelemetry: () => (/* binding */ AutofillTelemetry)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\nconst { FIELD_STATES } = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils;\n\nclass AutofillTelemetryBase {\n  SUPPORTED_FIELDS = {};\n\n  EVENT_CATEGORY = null;\n  EVENT_OBJECT_FORM_INTERACTION = null;\n\n  HISTOGRAM_NUM_USES = null;\n  HISTOGRAM_PROFILE_NUM_USES = null;\n  HISTOGRAM_PROFILE_NUM_USES_KEY = null;\n\n  #initFormEventExtra(value) {\n    let extra = {};\n    for (const field of Object.values(this.SUPPORTED_FIELDS)) {\n      extra[field] = value;\n    }\n    return extra;\n  }\n\n  #setFormEventExtra(extra, key, value) {\n    if (!this.SUPPORTED_FIELDS[key]) {\n      return;\n    }\n\n    extra[this.SUPPORTED_FIELDS[key]] = value;\n  }\n\n  recordFormDetected(flowId, fieldDetails) {\n    let extra = this.#initFormEventExtra(\"false\");\n\n    let identified = new Set();\n    fieldDetails.forEach(detail => {\n      identified.add(detail.fieldName);\n\n      if (detail.reason == \"autocomplete\") {\n        this.#setFormEventExtra(extra, detail.fieldName, \"true\");\n      } else {\n        // confidence exists only when a field is identified by fathom.\n        let confidence =\n          detail.confidence > 0 ? Math.floor(100 * detail.confidence) / 100 : 0;\n\n        this.#setFormEventExtra(\n          extra,\n          detail.fieldName,\n          confidence ? confidence.toString() : \"0\"\n        );\n      }\n    });\n\n    this.recordFormEvent(\"detected\", flowId, extra);\n    try {\n      this.recordIframeLayoutDetection(flowId, fieldDetails);\n    } catch {}\n  }\n\n  recordPopupShown(flowId, fieldDetails) {\n    const extra = { field_name: fieldDetails[0].fieldName };\n    this.recordFormEvent(\"popup_shown\", flowId, extra);\n  }\n\n  setUpFormFilledExtra(fieldDetails, data) {\n    // Calculate values for telemetry\n    const extra = this.#initFormEventExtra(\"unavailable\");\n\n    for (const fieldDetail of fieldDetails) {\n      // It is possible that we don't autofill a field because it is cross-origin.\n      // When that happens, the data will not include that element.\n      let { filledState, filledValue, isFilledOnFieldsUpdate } =\n        data.get(fieldDetail.elementId) ?? {};\n      switch (filledState) {\n        case FIELD_STATES.AUTO_FILLED:\n          filledState = isFilledOnFieldsUpdate\n            ? \"filled_on_fields_update\"\n            : \"filled\";\n          break;\n        case FIELD_STATES.NORMAL:\n        default:\n          filledState =\n            fieldDetail.localName == \"select\" || filledValue?.length\n              ? \"user_filled\"\n              : \"not_filled\";\n          break;\n      }\n      this.#setFormEventExtra(extra, fieldDetail.fieldName, filledState);\n    }\n    return extra;\n  }\n\n  recordFormFilled(flowId, fieldDetails, data) {\n    const extra = this.setUpFormFilledExtra(fieldDetails, data);\n    this.recordFormEvent(\"filled\", flowId, extra);\n  }\n\n  recordFormFilledOnFieldsUpdate(flowId, fieldDetails, data) {\n    const extra = this.setUpFormFilledExtra(fieldDetails, data);\n    this.recordFormEvent(\"filled_on_fields_update\", flowId, extra);\n  }\n\n  recordFilledModified(flowId, fieldDetails) {\n    const extra = { field_name: fieldDetails[0].fieldName };\n    this.recordFormEvent(\"filled_modified\", flowId, extra);\n  }\n\n  recordFormSubmitted(flowId, fieldDetails, data) {\n    const extra = this.#initFormEventExtra(\"unavailable\");\n\n    for (const fieldDetail of fieldDetails) {\n      let { filledState, filledValue } = data.get(fieldDetail.elementId) ?? {};\n      switch (filledState) {\n        case FIELD_STATES.AUTO_FILLED:\n          filledState = \"autofilled\";\n          break;\n        case FIELD_STATES.NORMAL:\n        default:\n          filledState =\n            fieldDetail.localName == \"select\" || filledValue?.length\n              ? \"user_filled\"\n              : \"not_filled\";\n          break;\n      }\n      this.#setFormEventExtra(extra, fieldDetail.fieldName, filledState);\n    }\n\n    this.recordFormEvent(\"submitted\", flowId, extra);\n  }\n\n  recordFormCleared(flowId, fieldDetails) {\n    const extra = { field_name: fieldDetails[0].fieldName };\n\n    // Note that when a form is cleared, we also record `filled_modified` events\n    // for all the fields that have been cleared.\n    this.recordFormEvent(\"cleared\", flowId, extra);\n  }\n\n  recordFormEvent(_method, _flowId, _extra) {\n    throw new Error(\"Not implemented.\");\n  }\n\n  recordFormInteractionEvent(method, flowId, fieldDetails, data) {\n    if (!this.EVENT_OBJECT_FORM_INTERACTION) {\n      return undefined;\n    }\n    switch (method) {\n      case \"detected\":\n        return this.recordFormDetected(flowId, fieldDetails);\n      case \"popup_shown\":\n        return this.recordPopupShown(flowId, fieldDetails);\n      case \"filled\":\n        return this.recordFormFilled(flowId, fieldDetails, data);\n      case \"filled_on_fields_update\":\n        return this.recordFormFilledOnFieldsUpdate(flowId, fieldDetails, data);\n      case \"filled_modified\":\n        return this.recordFilledModified(flowId, fieldDetails);\n      case \"submitted\":\n        return this.recordFormSubmitted(flowId, fieldDetails, data);\n      case \"cleared\":\n        return this.recordFormCleared(flowId, fieldDetails);\n    }\n    return undefined;\n  }\n\n  recordDoorhangerEvent(method, object, flowId) {\n    const eventName = `${method}_${object}`.replace(/(_[a-z])/g, c =>\n      c[1].toUpperCase()\n    );\n    Glean[this.EVENT_CATEGORY][eventName]?.record({ value: flowId });\n  }\n\n  recordManageEvent(method) {\n    const eventName =\n      method.replace(/(_[a-z])/g, c => c[1].toUpperCase()) + \"Manage\";\n    Glean[this.EVENT_CATEGORY][eventName]?.record();\n  }\n\n  recordAutofillProfileCount(_count) {\n    throw new Error(\"Not implemented.\");\n  }\n\n  recordNumberOfUse(records) {\n    let histogram = Services.telemetry.getKeyedHistogramById(\n      this.HISTOGRAM_PROFILE_NUM_USES\n    );\n    histogram.clear();\n\n    for (let record of records) {\n      histogram.add(this.HISTOGRAM_PROFILE_NUM_USES_KEY, record.timesUsed);\n    }\n  }\n\n  recordIframeLayoutDetection(flowId, fieldDetails) {\n    const fieldsInMainFrame = [];\n    const fieldsInIframe = [];\n    const fieldsInSandboxedIframe = [];\n    const fieldsInCrossOrignIframe = [];\n\n    const iframes = new Set();\n    for (const fieldDetail of fieldDetails) {\n      const bc = BrowsingContext.get(fieldDetail.browsingContextId);\n      if (bc.top == bc) {\n        fieldsInMainFrame.push(fieldDetail);\n        continue;\n      }\n\n      iframes.add(bc);\n      fieldsInIframe.push(fieldDetail);\n      if (bc.sandboxFlags != 0) {\n        fieldsInSandboxedIframe.push(fieldDetail);\n      }\n\n      if (!resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.isBCSameOriginWithTop(bc)) {\n        fieldsInCrossOrignIframe.push(fieldDetail);\n      }\n    }\n\n    const extra = {\n      category: this.EVENT_CATEGORY,\n      flow_id: flowId,\n      iframe_count: iframes.size,\n      main_frame: fieldsInMainFrame.map(f => f.fieldName).toString(),\n      iframe: fieldsInIframe.map(f => f.fieldName).toString(),\n      cross_origin: fieldsInCrossOrignIframe.map(f => f.fieldName).toString(),\n      sandboxed: fieldsInSandboxedIframe.map(f => f.fieldName).toString(),\n    };\n\n    Glean.formautofill.iframeLayoutDetection.record(extra);\n  }\n}\n\nclass AddressTelemetry extends AutofillTelemetryBase {\n  EVENT_CATEGORY = \"address\";\n  EVENT_OBJECT_FORM_INTERACTION = \"AddressForm\";\n  EVENT_OBJECT_FORM_INTERACTION_EXT = \"AddressFormExt\";\n\n  HISTOGRAM_PROFILE_NUM_USES = \"AUTOFILL_PROFILE_NUM_USES\";\n  HISTOGRAM_PROFILE_NUM_USES_KEY = \"address\";\n\n  // Fields that are recorded in `address_form` and `address_form_ext` telemetry\n  SUPPORTED_FIELDS = {\n    \"street-address\": \"street_address\",\n    \"address-line1\": \"address_line1\",\n    \"address-line2\": \"address_line2\",\n    \"address-line3\": \"address_line3\",\n    \"address-level1\": \"address_level1\",\n    \"address-level2\": \"address_level2\",\n    \"postal-code\": \"postal_code\",\n    country: \"country\",\n    name: \"name\",\n    \"given-name\": \"given_name\",\n    \"additional-name\": \"additional_name\",\n    \"family-name\": \"family_name\",\n    email: \"email\",\n    organization: \"organization\",\n    tel: \"tel\",\n  };\n\n  // Fields that are recorded in `address_form` event telemetry extra_keys\n  static SUPPORTED_FIELDS_IN_FORM = [\n    \"street_address\",\n    \"address_line1\",\n    \"address_line2\",\n    \"address_line3\",\n    \"address_level2\",\n    \"address_level1\",\n    \"postal_code\",\n    \"country\",\n  ];\n\n  // Fields that are recorded in `address_form_ext` event telemetry extra_keys\n  static SUPPORTED_FIELDS_IN_FORM_EXT = [\n    \"name\",\n    \"given_name\",\n    \"additional_name\",\n    \"family_name\",\n    \"email\",\n    \"organization\",\n    \"tel\",\n  ];\n\n  recordFormEvent(method, flowId, extra) {\n    let extExtra = {};\n    if ([\"detected\", \"filled\", \"submitted\"].includes(method)) {\n      for (const [key, value] of Object.entries(extra)) {\n        if (AddressTelemetry.SUPPORTED_FIELDS_IN_FORM_EXT.includes(key)) {\n          extExtra[key] = value;\n          delete extra[key];\n        }\n      }\n    }\n\n    const eventMethod = method.replace(/(_[a-z])/g, c => c[1].toUpperCase());\n    Glean.address[eventMethod + this.EVENT_OBJECT_FORM_INTERACTION]?.record({\n      value: flowId,\n      ...extra,\n    });\n\n    if (Object.keys(extExtra).length) {\n      Glean.address[\n        eventMethod + this.EVENT_OBJECT_FORM_INTERACTION_EXT\n      ]?.record({ value: flowId, ...extExtra });\n    }\n  }\n\n  recordAutofillProfileCount(count) {\n    Glean.formautofillAddresses.autofillProfilesCount.set(count);\n  }\n}\n\nclass CreditCardTelemetry extends AutofillTelemetryBase {\n  EVENT_CATEGORY = \"creditcard\";\n  EVENT_OBJECT_FORM_INTERACTION = \"CcFormV2\";\n\n  HISTOGRAM_NUM_USES = \"CREDITCARD_NUM_USES\";\n  HISTOGRAM_PROFILE_NUM_USES = \"AUTOFILL_PROFILE_NUM_USES\";\n  HISTOGRAM_PROFILE_NUM_USES_KEY = \"credit_card\";\n\n  // Mapping of field name used in formautofill code to the field name\n  // used in the telemetry.\n  SUPPORTED_FIELDS = {\n    \"cc-name\": \"cc_name\",\n    \"cc-number\": \"cc_number\",\n    \"cc-type\": \"cc_type\",\n    \"cc-exp\": \"cc_exp\",\n    \"cc-exp-month\": \"cc_exp_month\",\n    \"cc-exp-year\": \"cc_exp_year\",\n  };\n  recordFormEvent(method, flowId, aExtra) {\n    // Don't modify the passed-in aExtra as it's reused.\n    const extra = Object.assign({ value: flowId }, aExtra);\n    const eventMethod = method.replace(/(_[a-z])/g, c => c[1].toUpperCase());\n    Glean.creditcard[eventMethod + this.EVENT_OBJECT_FORM_INTERACTION]?.record(\n      extra\n    );\n  }\n\n  recordFormDetected(flowId, fieldDetails) {\n    super.recordFormDetected(flowId, fieldDetails);\n    this.recordCcNumberFieldsCount(fieldDetails);\n  }\n\n  /**\n   * Collect the amount of consecutive cc number fields to help decide\n   * whether to support filling other field counts besides 1 and 4 fields\n   */\n  recordCcNumberFieldsCount(fieldDetails) {\n    const recordCount = count => {\n      const label = \"cc_number_fields_\" + (count > 4 ? \"other\" : count);\n      Glean.creditcard.detectedCcNumberFieldsCount[label].add(1);\n    };\n\n    let consecutiveCcNumberCount = 0;\n    for (const { fieldName, reason } of fieldDetails) {\n      if (fieldName == \"cc-number\" && reason == \"autocomplete\") {\n        consecutiveCcNumberCount++;\n      } else if (consecutiveCcNumberCount) {\n        recordCount(consecutiveCcNumberCount);\n        consecutiveCcNumberCount = 0;\n      }\n    }\n\n    if (consecutiveCcNumberCount) {\n      recordCount(consecutiveCcNumberCount);\n    }\n  }\n\n  recordNumberOfUse(records) {\n    super.recordNumberOfUse(records);\n\n    if (!this.HISTOGRAM_NUM_USES) {\n      return;\n    }\n\n    let histogram = Services.telemetry.getHistogramById(\n      this.HISTOGRAM_NUM_USES\n    );\n    histogram.clear();\n\n    for (let record of records) {\n      histogram.add(record.timesUsed);\n    }\n  }\n\n  recordAutofillProfileCount(count) {\n    Glean.formautofillCreditcards.autofillProfilesCount.set(count);\n  }\n}\n\nclass AutofillTelemetry {\n  static #creditCardTelemetry = new CreditCardTelemetry();\n  static #addressTelemetry = new AddressTelemetry();\n\n  // const for `type` parameter used in the utility functions\n  static ADDRESS = \"address\";\n  static CREDIT_CARD = \"creditcard\";\n\n  static #getTelemetryByFieldDetail(fieldDetail) {\n    return resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.isAddressField(fieldDetail.fieldName)\n      ? this.#addressTelemetry\n      : this.#creditCardTelemetry;\n  }\n\n  static #getTelemetryByType(type) {\n    return type == AutofillTelemetry.CREDIT_CARD\n      ? this.#creditCardTelemetry\n      : this.#addressTelemetry;\n  }\n\n  /**\n   * Utility functions for `doorhanger` event (defined in Events.yaml)\n   *\n   * Category: address or creditcard\n   * Event name: doorhanger\n   */\n  static recordDoorhangerShown(type, object, flowId) {\n    const telemetry = this.#getTelemetryByType(type);\n    telemetry.recordDoorhangerEvent(\"show\", object, flowId);\n  }\n\n  static recordDoorhangerClicked(type, method, object, flowId) {\n    const telemetry = this.#getTelemetryByType(type);\n\n    // We don't have `create` method in telemetry, we treat `create` as `save`\n    switch (method) {\n      case \"create\":\n        method = \"save\";\n        break;\n      case \"open-pref\":\n        method = \"pref\";\n        break;\n      case \"learn-more\":\n        method = \"learn_more\";\n        break;\n    }\n\n    telemetry.recordDoorhangerEvent(method, object, flowId);\n  }\n\n  /**\n   * Utility functions for form event (defined in Events.yaml)\n   *\n   * Category: address or creditcard\n   * Event name: cc_form_v2, or address_form\n   */\n\n  static recordFormInteractionEvent(method, flowId, fieldDetails, data) {\n    const telemetry = this.#getTelemetryByFieldDetail(fieldDetails[0]);\n    telemetry.recordFormInteractionEvent(method, flowId, fieldDetails, data);\n  }\n\n  static recordManageEvent(type, method) {\n    const telemetry = this.#getTelemetryByType(type);\n    telemetry.recordManageEvent(method);\n  }\n\n  static recordAutofillProfileCount(type, count) {\n    const telemetry = this.#getTelemetryByType(type);\n    telemetry.recordAutofillProfileCount(count);\n  }\n\n  /**\n   * Utility functions for address/credit card number of use\n   */\n  static recordNumberOfUse(type, records) {\n    const telemetry = this.#getTelemetryByType(type);\n    telemetry.recordNumberOfUse(records);\n  }\n\n  static recordFormSubmissionHeuristicCount(label) {\n    Glean.formautofill.formSubmissionHeuristic[label].add(1);\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs":
/*!***************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IOSAppConstants: () => (/* binding */ IOSAppConstants),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst IOS_DEFAULT_PREFERENCES = {\n  \"extensions.formautofill.creditCards.heuristics.mode\": 1,\n  \"extensions.formautofill.creditCards.heuristics.fathom.confidenceThreshold\": 0.5,\n  \"extensions.formautofill.creditCards.heuristics.fathom.highConfidenceThreshold\": 0.95,\n  \"extensions.formautofill.creditCards.heuristics.fathom.testConfidence\": 0,\n  \"extensions.formautofill.creditCards.heuristics.fathom.types\":\n    \"cc-number,cc-name\",\n  \"extensions.formautofill.addresses.capture.requiredFields\":\n    \"street-address,postal-code,address-level1,address-level2\",\n  \"extensions.formautofill.loglevel\": \"Warn\",\n  \"extensions.formautofill.addresses.supported\": \"off\",\n  \"extensions.formautofill.creditCards.supported\": \"detect\",\n  \"browser.search.region\": \"US\",\n  \"extensions.formautofill.creditCards.supportedCountries\": \"US,CA,GB,FR,DE\",\n  \"extensions.formautofill.addresses.enabled\": true,\n  \"extensions.formautofill.addresses.experiments.enabled\": true,\n  \"extensions.formautofill.addresses.capture.enabled\": false,\n  \"extensions.formautofill.addresses.supportedCountries\": \"\",\n  \"extensions.formautofill.creditCards.enabled\": true,\n  \"extensions.formautofill.reauth.enabled\": true,\n  \"extensions.formautofill.creditCards.hideui\": false,\n  \"extensions.formautofill.supportRTL\": false,\n  \"extensions.formautofill.creditCards.ignoreAutocompleteOff\": true,\n  \"extensions.formautofill.addresses.ignoreAutocompleteOff\": true,\n  \"extensions.formautofill.heuristics.enabled\": true,\n  \"extensions.formautofill.section.enabled\": true,\n  \"extensions.formautofill.heuristics.captureOnFormRemoval\": false,\n  \"extensions.formautofill.heuristics.captureOnPageNavigation\": false,\n  \"extensions.formautofill.heuristics.detectDynamicFormChanges\": false,\n  \"extensions.formautofill.heuristics.fillOnDynamicFormChanges\": false,\n  \"extensions.formautofill.focusOnAutofill\": false,\n  \"extensions.formautofill.test.ignoreVisibilityCheck\": false,\n  \"extensions.formautofill.heuristics.autofillSameOriginWithTop\": false,\n  \"signon.generation.confidenceThreshold\": 0.75,\n  \"extensions.formautofill.ml.experiment.enabled\": false,\n};\n\n// Used Mimic the behavior of .getAutocompleteInfo()\n// List from: https://searchfox.org/mozilla-central/source/dom/base/AutocompleteFieldList.h#89-149\n// Also found here: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete\nconst VALID_AUTOCOMPLETE_FIELDS = [\n  \"off\",\n  \"on\",\n  \"name\",\n  \"honorific-prefix\",\n  \"given-name\",\n  \"additional-name\",\n  \"family-name\",\n  \"honorific-suffix\",\n  \"nickname\",\n  \"email\",\n  \"username\",\n  \"new-password\",\n  \"current-password\",\n  \"one-time-code\",\n  \"organization-title\",\n  \"organization\",\n  \"street-address\",\n  \"address-line1\",\n  \"address-line2\",\n  \"address-line3\",\n  \"address-level4\",\n  \"address-level3\",\n  \"address-level2\",\n  \"address-level1\",\n  \"country\",\n  \"country-name\",\n  \"postal-code\",\n  \"cc-name\",\n  \"cc-given-name\",\n  \"cc-additional-name\",\n  \"cc-family-name\",\n  \"cc-number\",\n  \"cc-exp\",\n  \"cc-exp-month\",\n  \"cc-exp-year\",\n  \"cc-csc\",\n  \"cc-type\",\n  \"transaction-currency\",\n  \"transaction-amount\",\n  \"language\",\n  \"bday\",\n  \"bday-day\",\n  \"bday-month\",\n  \"bday-year\",\n  \"sex\",\n  \"tel\",\n  \"tel-country-code\",\n  \"tel-national\",\n  \"tel-area-code\",\n  \"tel-local\",\n  \"tel-extension\",\n  \"impp\",\n  \"url\",\n  \"photo\",\n];\n\nconst IOSAppConstants = Object.freeze({\n  platform: \"ios\",\n  prefs: IOS_DEFAULT_PREFERENCES,\n  validAutocompleteFields: VALID_AUTOCOMPLETE_FIELDS,\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IOSAppConstants);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs":
/*!****************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CreditCard: () => (/* binding */ CreditCard),\n/* harmony export */   NETWORK_NAMES: () => (/* binding */ NETWORK_NAMES)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// The list of known and supported credit card network ids (\"types\")\n// This list mirrors the networks from dom/payments/BasicCardPayment.cpp\n// and is defined by https://www.w3.org/Payments/card-network-ids\nconst SUPPORTED_NETWORKS = Object.freeze([\n  \"amex\",\n  \"cartebancaire\",\n  \"diners\",\n  \"discover\",\n  \"jcb\",\n  \"mastercard\",\n  \"mir\",\n  \"unionpay\",\n  \"visa\",\n]);\n\n// This lists stores lower cased variations of popular credit card network\n// names for matching against strings.\nconst NETWORK_NAMES = {\n  \"american express\": \"amex\",\n  \"master card\": \"mastercard\",\n  \"union pay\": \"unionpay\",\n};\n\n// Based on https://en.wikipedia.org/wiki/Payment_card_number\n//\n// Notice:\n//   - CarteBancaire (`4035`, `4360`) is now recognized as Visa.\n//   - UnionPay (`63--`) is now recognized as Discover.\n// This means that the order matters.\n// First we'll try to match more specific card,\n// and if that doesn't match we'll test against the more generic range.\nconst CREDIT_CARD_IIN = [\n  { type: \"amex\", start: 34, end: 34, len: 15 },\n  { type: \"amex\", start: 37, end: 37, len: 15 },\n  { type: \"cartebancaire\", start: 4035, end: 4035, len: 16 },\n  { type: \"cartebancaire\", start: 4360, end: 4360, len: 16 },\n  // We diverge from Wikipedia here, because Diners card\n  // support length of 14-19.\n  { type: \"diners\", start: 300, end: 305, len: [14, 19] },\n  { type: \"diners\", start: 3095, end: 3095, len: [14, 19] },\n  { type: \"diners\", start: 36, end: 36, len: [14, 19] },\n  { type: \"diners\", start: 38, end: 39, len: [14, 19] },\n  { type: \"discover\", start: 6011, end: 6011, len: [16, 19] },\n  { type: \"discover\", start: 622126, end: 622925, len: [16, 19] },\n  { type: \"discover\", start: 624000, end: 626999, len: [16, 19] },\n  { type: \"discover\", start: 628200, end: 628899, len: [16, 19] },\n  { type: \"discover\", start: 64, end: 65, len: [16, 19] },\n  { type: \"jcb\", start: 3528, end: 3589, len: [16, 19] },\n  { type: \"mastercard\", start: 2221, end: 2720, len: 16 },\n  { type: \"mastercard\", start: 51, end: 55, len: 16 },\n  { type: \"mir\", start: 2200, end: 2204, len: 16 },\n  { type: \"unionpay\", start: 62, end: 62, len: [16, 19] },\n  { type: \"unionpay\", start: 81, end: 81, len: [16, 19] },\n  { type: \"visa\", start: 4, end: 4, len: 16 },\n].sort((a, b) => b.start - a.start);\n\nclass CreditCard {\n  /**\n   * A CreditCard object represents a credit card, with\n   * number, name, expiration, network, and CCV.\n   * The number is the only required information when creating\n   * an object, all other members are optional. The number\n   * is validated during construction and will throw if invalid.\n   *\n   * @param {string} name, optional\n   * @param {string} number\n   * @param {string} expirationString, optional\n   * @param {string|number} expirationMonth, optional\n   * @param {string|number} expirationYear, optional\n   * @param {string} network, optional\n   * @param {string|number} ccv, optional\n   * @param {string} encryptedNumber, optional\n   * @throws if number is an invalid credit card number\n   */\n  constructor({\n    name,\n    number,\n    expirationString,\n    expirationMonth,\n    expirationYear,\n    network,\n    ccv,\n    encryptedNumber,\n  }) {\n    this._name = name;\n    this._unmodifiedNumber = number;\n    this._encryptedNumber = encryptedNumber;\n    this._ccv = ccv;\n    this.number = number;\n    let { month, year } = CreditCard.normalizeExpiration({\n      expirationString,\n      expirationMonth,\n      expirationYear,\n    });\n    this._expirationMonth = month;\n    this._expirationYear = year;\n    this.network = network;\n  }\n\n  set name(value) {\n    this._name = value;\n  }\n\n  set expirationMonth(value) {\n    if (typeof value == \"undefined\") {\n      this._expirationMonth = undefined;\n      return;\n    }\n    this._expirationMonth = CreditCard.normalizeExpirationMonth(value);\n  }\n\n  get expirationMonth() {\n    return this._expirationMonth;\n  }\n\n  set expirationYear(value) {\n    if (typeof value == \"undefined\") {\n      this._expirationYear = undefined;\n      return;\n    }\n    this._expirationYear = CreditCard.normalizeExpirationYear(value);\n  }\n\n  get expirationYear() {\n    return this._expirationYear;\n  }\n\n  set expirationString(value) {\n    let { month, year } = CreditCard.parseExpirationString(value);\n    this.expirationMonth = month;\n    this.expirationYear = year;\n  }\n\n  set ccv(value) {\n    this._ccv = value;\n  }\n\n  get number() {\n    return this._number;\n  }\n\n  /**\n   * Sets the number member of a CreditCard object. If the number\n   * is not valid according to the Luhn algorithm then the member\n   * will get set to the empty string before throwing an exception.\n   *\n   * @param {string} value\n   * @throws if the value is an invalid credit card number\n   */\n  set number(value) {\n    if (value) {\n      let normalizedNumber = CreditCard.normalizeCardNumber(value);\n      // Based on the information on wiki[1], the shortest valid length should be\n      // 12 digits (Maestro).\n      // [1] https://en.wikipedia.org/wiki/Payment_card_number\n      normalizedNumber = normalizedNumber.match(/^\\d{12,}$/)\n        ? normalizedNumber\n        : \"\";\n      this._number = normalizedNumber;\n    } else {\n      this._number = \"\";\n    }\n\n    if (value && !this.isValidNumber()) {\n      this._number = \"\";\n      throw new Error(\"Invalid credit card number\");\n    }\n  }\n\n  get network() {\n    return this._network;\n  }\n\n  set network(value) {\n    this._network = value || undefined;\n  }\n\n  // Implements the Luhn checksum algorithm as described at\n  // http://wikipedia.org/wiki/Luhn_algorithm\n  // Number digit lengths vary with network, but should fall within 12-19 range. [2]\n  // More details at https://en.wikipedia.org/wiki/Payment_card_number\n  isValidNumber() {\n    if (!this._number) {\n      return false;\n    }\n\n    // Remove dashes and whitespace\n    const number = CreditCard.normalizeCardNumber(this._number);\n\n    const len = number.length;\n    if (len < 12 || len > 19) {\n      return false;\n    }\n\n    if (!/^\\d+$/.test(number)) {\n      return false;\n    }\n\n    let total = 0;\n    for (let i = 0; i < len; i++) {\n      let ch = parseInt(number[len - i - 1], 10);\n      if (i % 2 == 1) {\n        // Double it, add digits together if > 10\n        ch *= 2;\n        if (ch > 9) {\n          ch -= 9;\n        }\n      }\n      total += ch;\n    }\n    return total % 10 == 0;\n  }\n\n  /**\n   * Normalizes a credit card number.\n   * @param {string} number\n   * @return {string | null}\n   * @memberof CreditCard\n   */\n  static normalizeCardNumber(number) {\n    if (!number) {\n      return null;\n    }\n    return number.replace(/[\\-\\s]/g, \"\");\n  }\n\n  /**\n   * Attempts to match the number against known network identifiers.\n   *\n   * @param {string} ccNumber Credit card number with no spaces or special characters in it.\n   *\n   * @returns {string|null}\n   */\n  static getType(ccNumber) {\n    if (!ccNumber) {\n      return null;\n    }\n\n    for (let i = 0; i < CREDIT_CARD_IIN.length; i++) {\n      const range = CREDIT_CARD_IIN[i];\n      if (typeof range.len == \"number\") {\n        if (range.len != ccNumber.length) {\n          continue;\n        }\n      } else if (\n        ccNumber.length < range.len[0] ||\n        ccNumber.length > range.len[1]\n      ) {\n        continue;\n      }\n\n      const prefixLength = Math.floor(Math.log10(range.start)) + 1;\n      const prefix = parseInt(ccNumber.substring(0, prefixLength), 10);\n      if (prefix >= range.start && prefix <= range.end) {\n        return range.type;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Attempts to retrieve a card network identifier based\n   * on a name.\n   *\n   * @param {string|undefined|null} name\n   *\n   * @returns {string|null}\n   */\n  static getNetworkFromName(name) {\n    if (!name) {\n      return null;\n    }\n    let lcName = name.trim().toLowerCase().normalize(\"NFKC\");\n    if (SUPPORTED_NETWORKS.includes(lcName)) {\n      return lcName;\n    }\n    for (let term in NETWORK_NAMES) {\n      if (lcName.includes(term)) {\n        return NETWORK_NAMES[term];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns true if the card number is valid and the\n   * expiration date has not passed. Otherwise false.\n   *\n   * @returns {boolean}\n   */\n  isValid() {\n    if (!this.isValidNumber()) {\n      return false;\n    }\n\n    let currentDate = new Date();\n    let currentYear = currentDate.getFullYear();\n    if (this._expirationYear > currentYear) {\n      return true;\n    }\n\n    // getMonth is 0-based, so add 1 because credit cards are 1-based\n    let currentMonth = currentDate.getMonth() + 1;\n    return (\n      this._expirationYear == currentYear &&\n      this._expirationMonth >= currentMonth\n    );\n  }\n\n  get maskedNumber() {\n    return CreditCard.getMaskedNumber(this._number);\n  }\n\n  get longMaskedNumber() {\n    return CreditCard.getLongMaskedNumber(this._number);\n  }\n\n  /**\n   * Get credit card display label. It should display masked numbers, the\n   * cardholder's name, and the expiration date, separated by a commas.\n   * In addition, the card type is provided in the accessibility label.\n   */\n  static getLabelInfo({ number, name, month, year, type }) {\n    let formatSelector = [\"number\"];\n    if (name) {\n      formatSelector.push(\"name\");\n    }\n    if (month && year) {\n      formatSelector.push(\"expiration\");\n    }\n    let stringId = `credit-card-label-${formatSelector.join(\"-\")}-2`;\n    return {\n      id: stringId,\n      args: {\n        number: CreditCard.getMaskedNumber(number),\n        name,\n        month: month?.toString(),\n        year: year?.toString(),\n        type,\n      },\n    };\n  }\n\n  /**\n   *\n   * Please use getLabelInfo above, as it allows for localization.\n   * @deprecated\n   */\n  static getLabel({ number, name }) {\n    let parts = [];\n\n    if (number) {\n      parts.push(CreditCard.getMaskedNumber(number));\n    }\n    if (name) {\n      parts.push(name);\n    }\n    return parts.join(\", \");\n  }\n\n  static normalizeExpirationMonth(month) {\n    month = parseInt(month, 10);\n    if (isNaN(month) || month < 1 || month > 12) {\n      return undefined;\n    }\n    return month;\n  }\n\n  static normalizeExpirationYear(year) {\n    year = parseInt(year, 10);\n    if (isNaN(year) || year < 0) {\n      return undefined;\n    }\n    if (year < 100) {\n      year += 2000;\n    }\n    return year;\n  }\n\n  static parseExpirationString(expirationString) {\n    let rules = [\n      {\n        regex: /(?:^|\\D)(\\d{2})(\\d{2})(?!\\d)/,\n      },\n      {\n        regex: /(?:^|\\D)(\\d{4})[-/](\\d{1,2})(?!\\d)/,\n        yearIndex: 0,\n        monthIndex: 1,\n      },\n      {\n        regex: /(?:^|\\D)(\\d{1,2})[-/](\\d{4})(?!\\d)/,\n        yearIndex: 1,\n        monthIndex: 0,\n      },\n      {\n        regex: /(?:^|\\D)(\\d{1,2})[-/](\\d{1,2})(?!\\d)/,\n      },\n      {\n        regex: /(?:^|\\D)(\\d{2})(\\d{2})(?!\\d)/,\n      },\n    ];\n\n    expirationString = expirationString.replaceAll(\" \", \"\");\n    for (let rule of rules) {\n      let result = rule.regex.exec(expirationString);\n      if (!result) {\n        continue;\n      }\n\n      let year, month;\n      const parsedResults = [parseInt(result[1], 10), parseInt(result[2], 10)];\n      if (!rule.yearIndex || !rule.monthIndex) {\n        month = parsedResults[0];\n        if (month > 12) {\n          year = parsedResults[0];\n          month = parsedResults[1];\n        } else {\n          year = parsedResults[1];\n        }\n      } else {\n        year = parsedResults[rule.yearIndex];\n        month = parsedResults[rule.monthIndex];\n      }\n\n      if (month >= 1 && month <= 12 && (year < 100 || year > 2000)) {\n        return { month, year };\n      }\n    }\n    return { month: undefined, year: undefined };\n  }\n\n  static normalizeExpiration({\n    expirationString,\n    expirationMonth,\n    expirationYear,\n  }) {\n    // Only prefer the string version if missing one or both parsed formats.\n    let parsedExpiration = {};\n    if (expirationString && (!expirationMonth || !expirationYear)) {\n      parsedExpiration = CreditCard.parseExpirationString(expirationString);\n    }\n    return {\n      month: CreditCard.normalizeExpirationMonth(\n        parsedExpiration.month || expirationMonth\n      ),\n      year: CreditCard.normalizeExpirationYear(\n        parsedExpiration.year || expirationYear\n      ),\n    };\n  }\n\n  static formatMaskedNumber(maskedNumber) {\n    return \"*\".repeat(4) + maskedNumber.substr(-4);\n  }\n\n  static getMaskedNumber(number) {\n    return \"*\".repeat(4) + \" \" + number.substr(-4);\n  }\n\n  static getLongMaskedNumber(number) {\n    return \"*\".repeat(number.length - 4) + number.substr(-4);\n  }\n\n  static getCreditCardLogo(network) {\n    const PATH = \"chrome://formautofill/content/\";\n    const THIRD_PARTY_PATH = PATH + \"third-party/\";\n    switch (network) {\n      case \"amex\":\n        return THIRD_PARTY_PATH + \"cc-logo-amex.png\";\n      case \"cartebancaire\":\n        return THIRD_PARTY_PATH + \"cc-logo-cartebancaire.png\";\n      case \"diners\":\n        return THIRD_PARTY_PATH + \"cc-logo-diners.svg\";\n      case \"discover\":\n        return THIRD_PARTY_PATH + \"cc-logo-discover.png\";\n      case \"jcb\":\n        return THIRD_PARTY_PATH + \"cc-logo-jcb.svg\";\n      case \"mastercard\":\n        return THIRD_PARTY_PATH + \"cc-logo-mastercard.svg\";\n      case \"mir\":\n        return THIRD_PARTY_PATH + \"cc-logo-mir.svg\";\n      case \"unionpay\":\n        return THIRD_PARTY_PATH + \"cc-logo-unionpay.svg\";\n      case \"visa\":\n        return THIRD_PARTY_PATH + \"cc-logo-visa.svg\";\n      default:\n        return PATH + \"icon-credit-card-generic.svg\";\n    }\n  }\n\n  /*\n   * Validates the number according to the Luhn algorithm. This\n   * method does not throw an exception if the number is invalid.\n   */\n  static isValidNumber(number) {\n    try {\n      new CreditCard({ number });\n    } catch (ex) {\n      return false;\n    }\n    return true;\n  }\n\n  static isValidNetwork(network) {\n    return SUPPORTED_NETWORKS.includes(network);\n  }\n\n  static getSupportedNetworks() {\n    return SUPPORTED_NETWORKS;\n  }\n\n  /**\n   * Localised names for supported networks are available in\n   * `browser/preferences/formAutofill.ftl`.\n   */\n  static getNetworkL10nId(network) {\n    return this.isValidNetwork(network)\n      ? `autofill-card-network-${network}`\n      : null;\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs":
/*!**********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CreditCardRecord: () => (/* binding */ CreditCardRecord)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/CreditCard.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormAutofillNameUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillNameUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs\");\n/* eslint-disable no-useless-concat */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\n/**\n * The CreditCardRecord class serves to handle and normalize internal credit card records.\n * Unlike the CreditCard class, which represents actual card data, CreditCardRecord is used\n * for processing and consistent data representation.\n */\nclass CreditCardRecord {\n  static normalizeFields(creditCard) {\n    this.#normalizeCCNameFields(creditCard);\n    this.#normalizeCCNumberFields(creditCard);\n    this.#normalizeCCExpirationDateFields(creditCard);\n    this.#normalizeCCTypeFields(creditCard);\n  }\n\n  static #normalizeCCNameFields(creditCard) {\n    if (!creditCard[\"cc-name\"]) {\n      creditCard[\"cc-name\"] = resource_gre_modules_shared_FormAutofillNameUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillNameUtils.joinNameParts({\n        given: creditCard[\"cc-given-name\"] ?? \"\",\n        middle: creditCard[\"cc-additional-name\"] ?? \"\",\n        family: creditCard[\"cc-family-name\"] ?? \"\",\n      });\n    }\n\n    delete creditCard[\"cc-given-name\"];\n    delete creditCard[\"cc-additional-name\"];\n    delete creditCard[\"cc-family-name\"];\n  }\n\n  static #normalizeCCNumberFields(creditCard) {\n    if (!(\"cc-number\" in creditCard)) {\n      return;\n    }\n\n    if (!resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.CreditCard.isValidNumber(creditCard[\"cc-number\"])) {\n      delete creditCard[\"cc-number\"];\n      return;\n    }\n\n    const card = new resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.CreditCard({ number: creditCard[\"cc-number\"] });\n    creditCard[\"cc-number\"] = card.number;\n  }\n\n  static #normalizeCCExpirationDateFields(creditCard) {\n    let normalizedExpiration = resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.CreditCard.normalizeExpiration({\n      expirationMonth: creditCard[\"cc-exp-month\"],\n      expirationYear: creditCard[\"cc-exp-year\"],\n      expirationString: creditCard[\"cc-exp\"],\n    });\n\n    creditCard[\"cc-exp-month\"] = normalizedExpiration.month ?? \"\";\n    creditCard[\"cc-exp-year\"] = normalizedExpiration.year ?? \"\";\n    delete creditCard[\"cc-exp\"];\n  }\n\n  static #normalizeCCTypeFields(creditCard) {\n    // Let's overwrite the credit card type with auto-detect algorithm\n    creditCard[\"cc-type\"] = resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.CreditCard.getType(creditCard[\"cc-number\"]) ?? \"\";\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs":
/*!***********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CreditCardRulesets: () => (/* binding */ CreditCardRulesets),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/third_party/fathom/fathom.mjs */ \"./firefox-ios/Client/Assets/CC_Script/fathom.mjs\");\n/* harmony import */ var resource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/XPCOMUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\");\n/* harmony import */ var resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! resource://gre/modules/CreditCard.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs\");\n/* harmony import */ var resource_gre_modules_FormLikeFactory_sys_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! resource://gre/modules/FormLikeFactory.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_LabelUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! resource://gre/modules/shared/LabelUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * Fathom ML model for identifying the fields of credit-card forms\n *\n * This is developed out-of-tree at https://github.com/mozilla-services/fathom-\n * form-autofill, where there is also over a GB of training, validation, and\n * testing data. To make changes, do your edits there (whether adding new\n * training pages, adding new rules, or both), retrain and evaluate as\n * documented at https://mozilla.github.io/fathom/training.html, paste the\n * coefficients emitted by the trainer into the ruleset, and finally copy the\n * ruleset's \"CODE TO COPY INTO PRODUCTION\" section to this file's \"CODE FROM\n * TRAINING REPOSITORY\" section.\n */\n\n/**\n * CODE UNIQUE TO PRODUCTION--NOT IN THE TRAINING REPOSITORY:\n */\n\n\n\n\n\n\n\n\n\n/**\n * Callthrough abstraction to allow .getAutocompleteInfo() to be mocked out\n * during training\n *\n * @param {Element} element DOM element to get info about\n * @returns {object} Page-author-provided autocomplete metadata\n */\nfunction getAutocompleteInfo(element) {\n  return element.getAutocompleteInfo();\n}\n\n/**\n * @param {string} selector A CSS selector that prunes away ineligible elements\n * @returns {Lhs} An LHS yielding the element the user has clicked or, if\n *  pruned, none\n */\nfunction queriedOrClickedElements(selector) {\n  return (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.element)(selector);\n}\n\n/**\n * START OF CODE PASTED FROM TRAINING REPOSITORY\n */\n\nvar FathomHeuristicsRegExp = {\n  RULES: {\n    \"cc-name\": undefined,\n    \"cc-number\": undefined,\n    \"cc-exp-month\": undefined,\n    \"cc-exp-year\": undefined,\n    \"cc-exp\": undefined,\n    \"cc-type\": undefined,\n  },\n\n  RULE_SETS: [\n    {\n      /* eslint-disable */\n      // Let us keep our consistent wrapping.\n      \"cc-name\":\n        // Firefox-specific rules\n        \"account.*holder.*name\" +\n        \"|^(credit[-\\\\s]?card|card).*name\" +\n        // de-DE\n        \"|^(kredit)?(karten|konto)inhaber\" +\n        \"|^(name).*karte\" +\n        // fr-FR\n        \"|nom.*(titulaire|détenteur)\" +\n        \"|(titulaire|détenteur).*(carte)\" +\n        // it-IT\n        \"|titolare.*carta\" +\n        // pl-PL\n        \"|posiadacz.*karty\" +\n        // es-ES\n        \"|nombre.*(titular|tarjeta)\" +\n        // nl-NL\n        \"|naam.*op.*kaart\" +\n        // Rules from Bitwarden\n        \"|cc-?name\" +\n        \"|card-?name\" +\n        \"|cardholder-?name\" +\n        \"|(^nom$)\" +\n        // Rules are from Chromium source codes\n        \"|card.?(?:holder|owner)|name.*(\\\\b)?on(\\\\b)?.*card\" +\n        \"|(?:card|cc).?name|cc.?full.?name\" +\n        \"|(?:card|cc).?owner\" +\n        \"|nom.*carte\" + // fr-FR\n        \"|nome.*cart\" + // it-IT\n        \"|名前\" + // ja-JP\n        \"|Имя.*карты\" + // ru\n        \"|信用卡开户名|开户名|持卡人姓名\" + // zh-CN\n        \"|持卡人姓名\", // zh-TW\n\n      \"cc-number\":\n        // Firefox-specific rules\n        // de-DE\n        \"(cc|kk)nr\" +\n        \"|(kredit)?(karten)(nummer|nr)\" +\n        // it-IT\n        \"|numero.*carta\" +\n        // fr-FR\n        \"|(numero|número|numéro).*(carte)\" +\n        // pl-PL\n        \"|numer.*karty\" +\n        // es-ES\n        \"|(número|numero).*tarjeta\" +\n        // nl-NL\n        \"|kaartnummer\" +\n        // Rules from Bitwarden\n        \"|cc-?number\" +\n        \"|cc-?num\" +\n        \"|card-?number\" +\n        \"|card-?num\" +\n        \"|cc-?no\" +\n        \"|card-?no\" +\n        \"|numero-?carte\" +\n        \"|num-?carte\" +\n        \"|cb-?num\" +\n        // Rules are from Chromium source codes\n        \"|(add)?(?:card|cc|acct).?(?:number|#|no|num)\" +\n        \"|カード番号\" + // ja-JP\n        \"|Номер.*карты\" + // ru\n        \"|信用卡号|信用卡号码\" + // zh-CN\n        \"|信用卡卡號\" + // zh-TW\n        \"|카드\", // ko-KR\n\n      \"cc-exp\":\n        // Firefox-specific rules\n        \"mm\\\\s*(\\/|\\\\|-)\\\\s*(yy|jj|aa)\" +\n        \"|(month|mois)\\\\s*(\\/|\\\\|-|et)\\\\s*(year|année)\" +\n        // de-DE\n        // fr-FR\n        // Rules from Bitwarden\n        \"|(^cc-?exp$)\" +\n        \"|(^card-?exp$)\" +\n        \"|(^cc-?expiration$)\" +\n        \"|(^card-?expiration$)\" +\n        \"|(^cc-?ex$)\" +\n        \"|(^card-?ex$)\" +\n        \"|(^card-?expire$)\" +\n        \"|(^card-?expiry$)\" +\n        \"|(^validite$)\" +\n        \"|(^expiration$)\" +\n        \"|(^expiry$)\" +\n        \"|mm-?yy\" +\n        \"|mm-?yyyy\" +\n        \"|yy-?mm\" +\n        \"|yyyy-?mm\" +\n        \"|expiration-?date\" +\n        \"|payment-?card-?expiration\" +\n        \"|(^payment-?cc-?date$)\" +\n        // Rules are from Chromium source codes\n        \"|expir|exp.*date|^expfield$\" +\n        \"|ablaufdatum|gueltig|gültig\" + // de-DE\n        \"|fecha\" + // es\n        \"|date.*exp\" + // fr-FR\n        \"|scadenza\" + // it-IT\n        \"|有効期限\" + // ja-JP\n        \"|validade\" + // pt-BR, pt-PT\n        \"|Срок действия карты\", // ru\n\n      \"cc-exp-month\":\n        // Firefox-specific rules\n        \"(cc|kk)month\" + // de-DE\n        // Rules from Bitwarden\n        \"|(^exp-?month$)\" +\n        \"|(^cc-?exp-?month$)\" +\n        \"|(^cc-?month$)\" +\n        \"|(^card-?month$)\" +\n        \"|(^cc-?mo$)\" +\n        \"|(^card-?mo$)\" +\n        \"|(^exp-?mo$)\" +\n        \"|(^card-?exp-?mo$)\" +\n        \"|(^cc-?exp-?mo$)\" +\n        \"|(^card-?expiration-?month$)\" +\n        \"|(^expiration-?month$)\" +\n        \"|(^cc-?mm$)\" +\n        \"|(^cc-?m$)\" +\n        \"|(^card-?mm$)\" +\n        \"|(^card-?m$)\" +\n        \"|(^card-?exp-?mm$)\" +\n        \"|(^cc-?exp-?mm$)\" +\n        \"|(^exp-?mm$)\" +\n        \"|(^exp-?m$)\" +\n        \"|(^expire-?month$)\" +\n        \"|(^expire-?mo$)\" +\n        \"|(^expiry-?month$)\" +\n        \"|(^expiry-?mo$)\" +\n        \"|(^card-?expire-?month$)\" +\n        \"|(^card-?expire-?mo$)\" +\n        \"|(^card-?expiry-?month$)\" +\n        \"|(^card-?expiry-?mo$)\" +\n        \"|(^mois-?validite$)\" +\n        \"|(^mois-?expiration$)\" +\n        \"|(^m-?validite$)\" +\n        \"|(^m-?expiration$)\" +\n        \"|(^expiry-?date-?field-?month$)\" +\n        \"|(^expiration-?date-?month$)\" +\n        \"|(^expiration-?date-?mm$)\" +\n        \"|(^exp-?mon$)\" +\n        \"|(^validity-?mo$)\" +\n        \"|(^exp-?date-?mo$)\" +\n        \"|(^cb-?date-?mois$)\" +\n        \"|(^date-?m$)\" +\n        // Rules are from Chromium source codes\n        \"|exp.*mo|ccmonth|cardmonth|addmonth\" +\n        \"|monat\" + // de-DE\n        // \"|fecha\" + // es\n        // \"|date.*exp\" + // fr-FR\n        // \"|scadenza\" + // it-IT\n        // \"|有効期限\" + // ja-JP\n        // \"|validade\" + // pt-BR, pt-PT\n        // \"|Срок действия карты\" + // ru\n        \"|月\", // zh-CN\n\n      \"cc-exp-year\":\n        // Firefox-specific rules\n        \"(cc|kk)year\" + // de-DE\n        // Rules from Bitwarden\n        \"|(^exp-?year$)\" +\n        \"|(^cc-?exp-?year$)\" +\n        \"|(^cc-?year$)\" +\n        \"|(^card-?year$)\" +\n        \"|(^cc-?yr$)\" +\n        \"|(^card-?yr$)\" +\n        \"|(^exp-?yr$)\" +\n        \"|(^card-?exp-?yr$)\" +\n        \"|(^cc-?exp-?yr$)\" +\n        \"|(^card-?expiration-?year$)\" +\n        \"|(^expiration-?year$)\" +\n        \"|(^cc-?yy$)\" +\n        \"|(^cc-?y$)\" +\n        \"|(^card-?yy$)\" +\n        \"|(^card-?y$)\" +\n        \"|(^card-?exp-?yy$)\" +\n        \"|(^cc-?exp-?yy$)\" +\n        \"|(^exp-?yy$)\" +\n        \"|(^exp-?y$)\" +\n        \"|(^cc-?yyyy$)\" +\n        \"|(^card-?yyyy$)\" +\n        \"|(^card-?exp-?yyyy$)\" +\n        \"|(^cc-?exp-?yyyy$)\" +\n        \"|(^expire-?year$)\" +\n        \"|(^expire-?yr$)\" +\n        \"|(^expiry-?year$)\" +\n        \"|(^expiry-?yr$)\" +\n        \"|(^card-?expire-?year$)\" +\n        \"|(^card-?expire-?yr$)\" +\n        \"|(^card-?expiry-?year$)\" +\n        \"|(^card-?expiry-?yr$)\" +\n        \"|(^an-?validite$)\" +\n        \"|(^an-?expiration$)\" +\n        \"|(^annee-?validite$)\" +\n        \"|(^annee-?expiration$)\" +\n        \"|(^expiry-?date-?field-?year$)\" +\n        \"|(^expiration-?date-?year$)\" +\n        \"|(^cb-?date-?ann$)\" +\n        \"|(^expiration-?date-?yy$)\" +\n        \"|(^expiration-?date-?yyyy$)\" +\n        \"|(^validity-?year$)\" +\n        \"|(^exp-?date-?year$)\" +\n        \"|(^date-?y$)\" +\n        // Rules are from Chromium source codes\n        \"|(add)?year\" +\n        \"|jahr\" + // de-DE\n        // \"|fecha\" + // es\n        // \"|scadenza\" + // it-IT\n        // \"|有効期限\" + // ja-JP\n        // \"|validade\" + // pt-BR, pt-PT\n        // \"|Срок действия карты\" + // ru\n        \"|年|有效期\", // zh-CN\n\n      \"cc-type\":\n        // Firefox-specific rules\n        \"type\" +\n        // de-DE\n        \"|Kartenmarke\" +\n        // Rules from Bitwarden\n        \"|(^cc-?type$)\" +\n        \"|(^card-?type$)\" +\n        \"|(^card-?brand$)\" +\n        \"|(^cc-?brand$)\" +\n        \"|(^cb-?type$)\",\n        // Rules are from Chromium source codes\n    },\n  ],\n\n  _getRule(name) {\n    let rules = [];\n    this.RULE_SETS.forEach(set => {\n      if (set[name]) {\n        rules.push(`(${set[name]})`.normalize(\"NFKC\"));\n      }\n    });\n\n    const value = new RegExp(rules.join(\"|\"), \"iu\");\n    Object.defineProperty(this.RULES, name, { get: undefined });\n    Object.defineProperty(this.RULES, name, { value });\n    return value;\n  },\n\n  init() {\n    Object.keys(this.RULES).forEach(field =>\n      Object.defineProperty(this.RULES, field, {\n        get() {\n          return FathomHeuristicsRegExp._getRule(field);\n        },\n      })\n    );\n  },\n};\n\nFathomHeuristicsRegExp.init();\n\nconst MMRegExp = /^mm$|\\(mm\\)/i;\nconst YYorYYYYRegExp = /^(yy|yyyy)$|\\(yy\\)|\\(yyyy\\)/i;\nconst monthRegExp = /month/i;\nconst yearRegExp = /year/i;\nconst MMYYRegExp = /mm\\s*(\\/|\\\\)\\s*yy/i;\nconst VisaCheckoutRegExp = /visa(-|\\s)checkout/i;\nconst CREDIT_CARD_NETWORK_REGEXP = new RegExp(\n  resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.CreditCard.getSupportedNetworks()\n    .concat(Object.keys(resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.NETWORK_NAMES))\n    .join(\"|\"),\n  \"gui\"\n  );\nconst TwoDigitYearRegExp = /(?:exp.*date[^y\\\\n\\\\r]*|mm\\\\s*[-/]?\\\\s*)yy(?:[^y]|$)/i;\nconst FourDigitYearRegExp = /(?:exp.*date[^y\\\\n\\\\r]*|mm\\\\s*[-/]?\\\\s*)yyyy(?:[^y]|$)/i;\nconst dwfrmRegExp = /^dwfrm/i;\nconst bmlRegExp = /bml/i;\nconst templatedValue = /^\\{\\{.*\\}\\}$/;\nconst firstRegExp = /first/i;\nconst lastRegExp = /last/i;\nconst giftRegExp = /gift/i;\nconst subscriptionRegExp = /subscription/i;\n\nfunction autocompleteStringMatches(element, ccString) {\n  const info = getAutocompleteInfo(element);\n  return info.fieldName === ccString;\n}\n\nfunction getFillableFormElements(element) {\n  const formLike = resource_gre_modules_FormLikeFactory_sys_mjs__WEBPACK_IMPORTED_MODULE_4__.FormLikeFactory.createFromField(element);\n  return Array.from(formLike.elements).filter(el =>\n    resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_2__.FormAutofillUtils.isCreditCardOrAddressFieldType(el)\n  );\n}\n\nfunction nextFillableFormField(element) {\n  const fillableFormElements = getFillableFormElements(element);\n  const elementIndex = fillableFormElements.indexOf(element);\n  return fillableFormElements[elementIndex + 1];\n}\n\nfunction previousFillableFormField(element) {\n  const fillableFormElements = getFillableFormElements(element);\n  const elementIndex = fillableFormElements.indexOf(element);\n  return fillableFormElements[elementIndex - 1];\n}\n\nfunction nextFieldPredicateIsTrue(element, predicate) {\n  const nextField = nextFillableFormField(element);\n  return !!nextField && predicate(nextField);\n}\n\nfunction previousFieldPredicateIsTrue(element, predicate) {\n  const previousField = previousFillableFormField(element);\n  return !!previousField && predicate(previousField);\n}\n\nfunction nextFieldMatchesExpYearAutocomplete(fnode) {\n  return nextFieldPredicateIsTrue(fnode.element, nextField =>\n    autocompleteStringMatches(nextField, \"cc-exp-year\")\n  );\n}\n\nfunction previousFieldMatchesExpMonthAutocomplete(fnode) {\n  return previousFieldPredicateIsTrue(fnode.element, previousField =>\n    autocompleteStringMatches(previousField, \"cc-exp-month\")\n  );\n}\n\n//////////////////////////////////////////////\n// Attribute Regular Expression Rules\nfunction idOrNameMatchRegExp(element, regExp) {\n  for (const str of [element.id, element.name]) {\n    if (regExp.test(str)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction getElementLabels(element) {\n  return {\n    *[Symbol.iterator]() {\n      const labels = resource_gre_modules_shared_LabelUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_5__.LabelUtils.findLabelElements(element);\n      for (let label of labels) {\n        yield* resource_gre_modules_shared_LabelUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_5__.LabelUtils.extractLabelStrings(label);\n      }\n    },\n  };\n}\n\nfunction labelsMatchRegExp(element, regExp) {\n  const elemStrings = getElementLabels(element);\n  for (const str of elemStrings) {\n    if (regExp.test(str)) {\n      return true;\n    }\n  }\n\n  const parentElement = element.parentElement;\n  // Bug 1634819: element.parentElement is null if element.parentNode is a ShadowRoot\n  if (!parentElement) {\n    return false;\n  }\n  // Check if the input is in a <td>, and, if so, check the textContent of the containing <tr>\n  if (parentElement.tagName === \"TD\" && parentElement.parentElement) {\n    // TODO: How bad is the assumption that the <tr> won't be the parent of the <td>?\n    return regExp.test(parentElement.parentElement.textContent);\n  }\n\n  // Check if the input is in a <dd>, and, if so, check the textContent of the preceding <dt>\n  if (\n    parentElement.tagName === \"DD\" &&\n    // previousElementSibling can be null\n    parentElement.previousElementSibling\n  ) {\n    return regExp.test(parentElement.previousElementSibling.textContent);\n  }\n  return false;\n}\n\nfunction closestLabelMatchesRegExp(element, regExp) {\n  const previousElementSibling = element.previousElementSibling;\n  if (\n    previousElementSibling !== null &&\n    previousElementSibling.tagName === \"LABEL\"\n  ) {\n    return regExp.test(previousElementSibling.textContent);\n  }\n\n  const nextElementSibling = element.nextElementSibling;\n  if (nextElementSibling !== null && nextElementSibling.tagName === \"LABEL\") {\n    return regExp.test(nextElementSibling.textContent);\n  }\n\n  return false;\n}\n\nfunction ariaLabelMatchesRegExp(element, regExp) {\n  const ariaLabel = element.getAttribute(\"aria-label\");\n  return !!ariaLabel && regExp.test(ariaLabel);\n}\n\nfunction placeholderMatchesRegExp(element, regExp) {\n  const placeholder = element.getAttribute(\"placeholder\");\n  return !!placeholder && regExp.test(placeholder);\n}\n\nfunction nextFieldIdOrNameMatchRegExp(element, regExp) {\n  return nextFieldPredicateIsTrue(element, nextField =>\n    idOrNameMatchRegExp(nextField, regExp)\n  );\n}\n\nfunction nextFieldLabelsMatchRegExp(element, regExp) {\n  return nextFieldPredicateIsTrue(element, nextField =>\n    labelsMatchRegExp(nextField, regExp)\n  );\n}\n\nfunction nextFieldPlaceholderMatchesRegExp(element, regExp) {\n  return nextFieldPredicateIsTrue(element, nextField =>\n    placeholderMatchesRegExp(nextField, regExp)\n  );\n}\n\nfunction nextFieldAriaLabelMatchesRegExp(element, regExp) {\n  return nextFieldPredicateIsTrue(element, nextField =>\n    ariaLabelMatchesRegExp(nextField, regExp)\n  );\n}\n\nfunction previousFieldIdOrNameMatchRegExp(element, regExp) {\n  return previousFieldPredicateIsTrue(element, previousField =>\n    idOrNameMatchRegExp(previousField, regExp)\n  );\n}\n\nfunction previousFieldLabelsMatchRegExp(element, regExp) {\n  return previousFieldPredicateIsTrue(element, previousField =>\n    labelsMatchRegExp(previousField, regExp)\n  );\n}\n\nfunction previousFieldPlaceholderMatchesRegExp(element, regExp) {\n  return previousFieldPredicateIsTrue(element, previousField =>\n    placeholderMatchesRegExp(previousField, regExp)\n  );\n}\n\nfunction previousFieldAriaLabelMatchesRegExp(element, regExp) {\n  return previousFieldPredicateIsTrue(element, previousField =>\n    ariaLabelMatchesRegExp(previousField, regExp)\n  );\n}\n//////////////////////////////////////////////\n\nfunction isSelectWithCreditCardOptions(fnode) {\n  // Check every select for options that match credit card network names in\n  // value or label.\n  const element = fnode.element;\n  if (element.tagName === \"SELECT\") {\n    for (let option of element.querySelectorAll(\"option\")) {\n      if (\n        resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.CreditCard.getNetworkFromName(option.value) ||\n        resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.CreditCard.getNetworkFromName(option.text)\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * If any of the regular expressions match multiple times, we assume the tested\n * string belongs to a radio button for payment type instead of card type.\n *\n * @param {Fnode} fnode\n * @returns {boolean}\n */\nfunction isRadioWithCreditCardText(fnode) {\n  const element = fnode.element;\n  const inputType = element.type;\n  if (!!inputType && inputType === \"radio\") {\n    const valueMatches = element.value.match(CREDIT_CARD_NETWORK_REGEXP);\n    if (valueMatches) {\n      return valueMatches.length === 1;\n    }\n\n    // Here we are checking that only one label matches only one entry in the regular expression.\n    const labels = getElementLabels(element);\n    let labelsMatched = 0;\n    for (const label of labels) {\n      const labelMatches = label.match(CREDIT_CARD_NETWORK_REGEXP);\n      if (labelMatches) {\n        if (labelMatches.length > 1) {\n          return false;\n        }\n        labelsMatched++;\n      }\n    }\n    if (labelsMatched > 0) {\n      return labelsMatched === 1;\n    }\n\n    const textContentMatches = element.textContent.match(\n      CREDIT_CARD_NETWORK_REGEXP\n    );\n    if (textContentMatches) {\n      return textContentMatches.length === 1;\n    }\n  }\n  return false;\n}\n\nfunction matchContiguousSubArray(array, subArray) {\n  return array.some((elm, i) =>\n    subArray.every((sElem, j) => sElem === array[i + j])\n  );\n}\n\nfunction isExpirationMonthLikely(element) {\n  if (element.tagName !== \"SELECT\") {\n    return false;\n  }\n\n  const options = [...element.options];\n  const desiredValues = Array(12)\n    .fill(1)\n    .map((v, i) => v + i);\n\n  // The number of month options shouldn't be less than 12 or larger than 13\n  // including the default option.\n  if (options.length < 12 || options.length > 13) {\n    return false;\n  }\n\n  return (\n    matchContiguousSubArray(\n      options.map(e => +e.value),\n      desiredValues\n    ) ||\n    matchContiguousSubArray(\n      options.map(e => +e.label),\n      desiredValues\n    )\n  );\n}\n\nfunction isExpirationYearLikely(element) {\n  if (element.tagName !== \"SELECT\") {\n    return false;\n  }\n\n  const options = [...element.options];\n  // A normal expiration year select should contain at least the last three years\n  // in the list.\n  const curYear = new Date().getFullYear();\n  const desiredValues = Array(3)\n    .fill(0)\n    .map((v, i) => v + curYear + i);\n\n  return (\n    matchContiguousSubArray(\n      options.map(e => +e.value),\n      desiredValues\n    ) ||\n    matchContiguousSubArray(\n      options.map(e => +e.label),\n      desiredValues\n    )\n  );\n}\n\nfunction nextFieldIsExpirationYearLikely(fnode) {\n  return nextFieldPredicateIsTrue(fnode.element, isExpirationYearLikely);\n}\n\nfunction previousFieldIsExpirationMonthLikely(fnode) {\n  return previousFieldPredicateIsTrue(fnode.element, isExpirationMonthLikely);\n}\n\nfunction attrsMatchExpWith2Or4DigitYear(fnode, regExpMatchingFunction) {\n  const element = fnode.element;\n  return (\n    regExpMatchingFunction(element, TwoDigitYearRegExp) ||\n    regExpMatchingFunction(element, FourDigitYearRegExp)\n  );\n}\n\nfunction maxLengthIs(fnode, maxLengthValue) {\n  return fnode.element.maxLength === maxLengthValue;\n}\n\nfunction roleIsMenu(fnode) {\n  const role = fnode.element.getAttribute(\"role\");\n  return !!role && role === \"menu\";\n}\n\nfunction idOrNameMatchDwfrmAndBml(fnode) {\n  return (\n    idOrNameMatchRegExp(fnode.element, dwfrmRegExp) &&\n    idOrNameMatchRegExp(fnode.element, bmlRegExp)\n  );\n}\n\nfunction hasTemplatedValue(fnode) {\n  const value = fnode.element.getAttribute(\"value\");\n  return !!value && templatedValue.test(value);\n}\n\nfunction inputTypeNotNumbery(fnode) {\n  const inputType = fnode.element.type;\n  if (inputType) {\n    return ![\"text\", \"tel\", \"number\"].includes(inputType);\n  }\n  return false;\n}\n\nfunction idOrNameMatchFirstAndLast(fnode) {\n  return (\n    idOrNameMatchRegExp(fnode.element, firstRegExp) &&\n    idOrNameMatchRegExp(fnode.element, lastRegExp)\n  );\n}\n\n/**\n * Compactly generate a series of rules that all take a single LHS type with no\n * .when() clause and have only a score() call on the right- hand side.\n *\n * @param {Lhs} inType The incoming fnode type that all rules take\n * @param {object} ruleMap A simple object used as a map with rule names\n *   pointing to scoring callbacks\n * @yields {Rule}\n */\nfunction* simpleScoringRules(inType, ruleMap) {\n  for (const [name, scoringCallback] of Object.entries(ruleMap)) {\n    yield (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(inType), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.score)(scoringCallback), { name });\n  }\n}\n\nfunction makeRuleset(coeffs, biases) {\n  return (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.ruleset)(\n    [\n      /**\n       * Factor out the page scan just for a little more speed during training.\n       * This selector is good for most fields. cardType is an exception: it\n       * cannot be type=month.\n       */\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)(\n        queriedOrClickedElements(\n          \"input:not([type]), input[type=text], input[type=textbox], input[type=email], input[type=tel], input[type=number], input[type=month], select, button\"\n        ),\n        (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"typicalCandidates\")\n      ),\n\n      /**\n       * number rules\n       */\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"typicalCandidates\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-number\")),\n      ...simpleScoringRules(\"cc-number\", {\n        idOrNameMatchNumberRegExp: fnode =>\n          idOrNameMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-number\"]\n          ),\n        labelsMatchNumberRegExp: fnode =>\n          labelsMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-number\"]),\n        closestLabelMatchesNumberRegExp: fnode =>\n          closestLabelMatchesRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-number\"]),\n        placeholderMatchesNumberRegExp: fnode =>\n          placeholderMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-number\"]\n          ),\n        ariaLabelMatchesNumberRegExp: fnode =>\n          ariaLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-number\"]\n          ),\n        idOrNameMatchGift: fnode =>\n          idOrNameMatchRegExp(fnode.element, giftRegExp),\n        labelsMatchGift: fnode => labelsMatchRegExp(fnode.element, giftRegExp),\n        placeholderMatchesGift: fnode =>\n          placeholderMatchesRegExp(fnode.element, giftRegExp),\n        ariaLabelMatchesGift: fnode =>\n          ariaLabelMatchesRegExp(fnode.element, giftRegExp),\n        idOrNameMatchSubscription: fnode =>\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\n        idOrNameMatchDwfrmAndBml,\n        hasTemplatedValue,\n        inputTypeNotNumbery,\n      }),\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-number\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.out)(\"cc-number\")),\n\n      /**\n       * name rules\n       */\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"typicalCandidates\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-name\")),\n      ...simpleScoringRules(\"cc-name\", {\n        idOrNameMatchNameRegExp: fnode =>\n          idOrNameMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-name\"]),\n        labelsMatchNameRegExp: fnode =>\n          labelsMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-name\"]),\n        closestLabelMatchesNameRegExp: fnode =>\n          closestLabelMatchesRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-name\"]),\n        placeholderMatchesNameRegExp: fnode =>\n          placeholderMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-name\"]\n          ),\n        ariaLabelMatchesNameRegExp: fnode =>\n          ariaLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-name\"]\n          ),\n        idOrNameMatchFirst: fnode =>\n          idOrNameMatchRegExp(fnode.element, firstRegExp),\n        labelsMatchFirst: fnode =>\n          labelsMatchRegExp(fnode.element, firstRegExp),\n        placeholderMatchesFirst: fnode =>\n          placeholderMatchesRegExp(fnode.element, firstRegExp),\n        ariaLabelMatchesFirst: fnode =>\n          ariaLabelMatchesRegExp(fnode.element, firstRegExp),\n        idOrNameMatchLast: fnode =>\n          idOrNameMatchRegExp(fnode.element, lastRegExp),\n        labelsMatchLast: fnode => labelsMatchRegExp(fnode.element, lastRegExp),\n        placeholderMatchesLast: fnode =>\n          placeholderMatchesRegExp(fnode.element, lastRegExp),\n        ariaLabelMatchesLast: fnode =>\n          ariaLabelMatchesRegExp(fnode.element, lastRegExp),\n        idOrNameMatchSubscription: fnode =>\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\n        idOrNameMatchFirstAndLast,\n        idOrNameMatchDwfrmAndBml,\n        hasTemplatedValue,\n      }),\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-name\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.out)(\"cc-name\")),\n\n      /**\n       * cardType rules\n       */\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)(\n        queriedOrClickedElements(\n          \"input:not([type]), input[type=text], input[type=textbox], input[type=email], input[type=tel], input[type=number], input[type=radio], select, button\"\n        ),\n        (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-type\")\n      ),\n      ...simpleScoringRules(\"cc-type\", {\n        idOrNameMatchTypeRegExp: fnode =>\n          idOrNameMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-type\"]),\n        labelsMatchTypeRegExp: fnode =>\n          labelsMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-type\"]),\n        closestLabelMatchesTypeRegExp: fnode =>\n          closestLabelMatchesRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-type\"]),\n        idOrNameMatchVisaCheckout: fnode =>\n          idOrNameMatchRegExp(fnode.element, VisaCheckoutRegExp),\n        ariaLabelMatchesVisaCheckout: fnode =>\n          ariaLabelMatchesRegExp(fnode.element, VisaCheckoutRegExp),\n        isSelectWithCreditCardOptions,\n        isRadioWithCreditCardText,\n        idOrNameMatchSubscription: fnode =>\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\n        idOrNameMatchDwfrmAndBml,\n        hasTemplatedValue,\n      }),\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-type\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.out)(\"cc-type\")),\n\n      /**\n       * expiration rules\n       */\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"typicalCandidates\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-exp\")),\n      ...simpleScoringRules(\"cc-exp\", {\n        labelsMatchExpRegExp: fnode =>\n          labelsMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-exp\"]),\n        closestLabelMatchesExpRegExp: fnode =>\n          closestLabelMatchesRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-exp\"]),\n        placeholderMatchesExpRegExp: fnode =>\n          placeholderMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp\"]\n          ),\n        labelsMatchExpWith2Or4DigitYear: fnode =>\n          attrsMatchExpWith2Or4DigitYear(fnode, labelsMatchRegExp),\n        placeholderMatchesExpWith2Or4DigitYear: fnode =>\n          attrsMatchExpWith2Or4DigitYear(fnode, placeholderMatchesRegExp),\n        labelsMatchMMYY: fnode => labelsMatchRegExp(fnode.element, MMYYRegExp),\n        placeholderMatchesMMYY: fnode =>\n          placeholderMatchesRegExp(fnode.element, MMYYRegExp),\n        maxLengthIs7: fnode => maxLengthIs(fnode, 7),\n        idOrNameMatchSubscription: fnode =>\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\n        idOrNameMatchDwfrmAndBml,\n        hasTemplatedValue,\n        isExpirationMonthLikely: fnode =>\n          isExpirationMonthLikely(fnode.element),\n        isExpirationYearLikely: fnode => isExpirationYearLikely(fnode.element),\n        idOrNameMatchMonth: fnode =>\n          idOrNameMatchRegExp(fnode.element, monthRegExp),\n        idOrNameMatchYear: fnode =>\n          idOrNameMatchRegExp(fnode.element, yearRegExp),\n        idOrNameMatchExpMonthRegExp: fnode =>\n          idOrNameMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        idOrNameMatchExpYearRegExp: fnode =>\n          idOrNameMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        idOrNameMatchValidation: fnode =>\n          idOrNameMatchRegExp(fnode.element, /validate|validation/i),\n      }),\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-exp\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.out)(\"cc-exp\")),\n\n      /**\n       * expirationMonth rules\n       */\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"typicalCandidates\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-exp-month\")),\n      ...simpleScoringRules(\"cc-exp-month\", {\n        idOrNameMatchExpMonthRegExp: fnode =>\n          idOrNameMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        labelsMatchExpMonthRegExp: fnode =>\n          labelsMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        closestLabelMatchesExpMonthRegExp: fnode =>\n          closestLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        placeholderMatchesExpMonthRegExp: fnode =>\n          placeholderMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        ariaLabelMatchesExpMonthRegExp: fnode =>\n          ariaLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        idOrNameMatchMonth: fnode =>\n          idOrNameMatchRegExp(fnode.element, monthRegExp),\n        labelsMatchMonth: fnode =>\n          labelsMatchRegExp(fnode.element, monthRegExp),\n        placeholderMatchesMonth: fnode =>\n          placeholderMatchesRegExp(fnode.element, monthRegExp),\n        ariaLabelMatchesMonth: fnode =>\n          ariaLabelMatchesRegExp(fnode.element, monthRegExp),\n        nextFieldIdOrNameMatchExpYearRegExp: fnode =>\n          nextFieldIdOrNameMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        nextFieldLabelsMatchExpYearRegExp: fnode =>\n          nextFieldLabelsMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        nextFieldPlaceholderMatchExpYearRegExp: fnode =>\n          nextFieldPlaceholderMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        nextFieldAriaLabelMatchExpYearRegExp: fnode =>\n          nextFieldAriaLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        nextFieldIdOrNameMatchYear: fnode =>\n          nextFieldIdOrNameMatchRegExp(fnode.element, yearRegExp),\n        nextFieldLabelsMatchYear: fnode =>\n          nextFieldLabelsMatchRegExp(fnode.element, yearRegExp),\n        nextFieldPlaceholderMatchesYear: fnode =>\n          nextFieldPlaceholderMatchesRegExp(fnode.element, yearRegExp),\n        nextFieldAriaLabelMatchesYear: fnode =>\n          nextFieldAriaLabelMatchesRegExp(fnode.element, yearRegExp),\n        nextFieldMatchesExpYearAutocomplete,\n        isExpirationMonthLikely: fnode =>\n          isExpirationMonthLikely(fnode.element),\n        nextFieldIsExpirationYearLikely,\n        maxLengthIs2: fnode => maxLengthIs(fnode, 2),\n        placeholderMatchesMM: fnode =>\n          placeholderMatchesRegExp(fnode.element, MMRegExp),\n        roleIsMenu,\n        idOrNameMatchSubscription: fnode =>\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\n        idOrNameMatchDwfrmAndBml,\n        hasTemplatedValue,\n      }),\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-exp-month\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.out)(\"cc-exp-month\")),\n\n      /**\n       * expirationYear rules\n       */\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"typicalCandidates\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-exp-year\")),\n      ...simpleScoringRules(\"cc-exp-year\", {\n        idOrNameMatchExpYearRegExp: fnode =>\n          idOrNameMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        labelsMatchExpYearRegExp: fnode =>\n          labelsMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        closestLabelMatchesExpYearRegExp: fnode =>\n          closestLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        placeholderMatchesExpYearRegExp: fnode =>\n          placeholderMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        ariaLabelMatchesExpYearRegExp: fnode =>\n          ariaLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        idOrNameMatchYear: fnode =>\n          idOrNameMatchRegExp(fnode.element, yearRegExp),\n        labelsMatchYear: fnode => labelsMatchRegExp(fnode.element, yearRegExp),\n        placeholderMatchesYear: fnode =>\n          placeholderMatchesRegExp(fnode.element, yearRegExp),\n        ariaLabelMatchesYear: fnode =>\n          ariaLabelMatchesRegExp(fnode.element, yearRegExp),\n        previousFieldIdOrNameMatchExpMonthRegExp: fnode =>\n          previousFieldIdOrNameMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        previousFieldLabelsMatchExpMonthRegExp: fnode =>\n          previousFieldLabelsMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        previousFieldPlaceholderMatchExpMonthRegExp: fnode =>\n          previousFieldPlaceholderMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        previousFieldAriaLabelMatchExpMonthRegExp: fnode =>\n          previousFieldAriaLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        previousFieldIdOrNameMatchMonth: fnode =>\n          previousFieldIdOrNameMatchRegExp(fnode.element, monthRegExp),\n        previousFieldLabelsMatchMonth: fnode =>\n          previousFieldLabelsMatchRegExp(fnode.element, monthRegExp),\n        previousFieldPlaceholderMatchesMonth: fnode =>\n          previousFieldPlaceholderMatchesRegExp(fnode.element, monthRegExp),\n        previousFieldAriaLabelMatchesMonth: fnode =>\n          previousFieldAriaLabelMatchesRegExp(fnode.element, monthRegExp),\n        previousFieldMatchesExpMonthAutocomplete,\n        isExpirationYearLikely: fnode => isExpirationYearLikely(fnode.element),\n        previousFieldIsExpirationMonthLikely,\n        placeholderMatchesYYOrYYYY: fnode =>\n          placeholderMatchesRegExp(fnode.element, YYorYYYYRegExp),\n        roleIsMenu,\n        idOrNameMatchSubscription: fnode =>\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\n        idOrNameMatchDwfrmAndBml,\n        hasTemplatedValue,\n      }),\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-exp-year\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.out)(\"cc-exp-year\")),\n    ],\n    coeffs,\n    biases\n  );\n}\n\nconst coefficients = {\n  \"cc-number\": [\n    [\"idOrNameMatchNumberRegExp\", 7.679469585418701],\n    [\"labelsMatchNumberRegExp\", 5.122580051422119],\n    [\"closestLabelMatchesNumberRegExp\", 2.1256935596466064],\n    [\"placeholderMatchesNumberRegExp\", 9.471800804138184],\n    [\"ariaLabelMatchesNumberRegExp\", 6.067715644836426],\n    [\"idOrNameMatchGift\", -22.946273803710938],\n    [\"labelsMatchGift\", -7.852959632873535],\n    [\"placeholderMatchesGift\", -2.355496406555176],\n    [\"ariaLabelMatchesGift\", -2.940307855606079],\n    [\"idOrNameMatchSubscription\", 0.11255314946174622],\n    [\"idOrNameMatchDwfrmAndBml\", -0.0006645023822784424],\n    [\"hasTemplatedValue\", -0.11370040476322174],\n    [\"inputTypeNotNumbery\", -3.750155210494995]\n  ],\n  \"cc-name\": [\n    [\"idOrNameMatchNameRegExp\", 7.496212959289551],\n    [\"labelsMatchNameRegExp\", 6.081472873687744],\n    [\"closestLabelMatchesNameRegExp\", 2.600574254989624],\n    [\"placeholderMatchesNameRegExp\", 5.750874042510986],\n    [\"ariaLabelMatchesNameRegExp\", 5.162227153778076],\n    [\"idOrNameMatchFirst\", -6.742659091949463],\n    [\"labelsMatchFirst\", -0.5234538912773132],\n    [\"placeholderMatchesFirst\", -3.4615235328674316],\n    [\"ariaLabelMatchesFirst\", -1.3145145177841187],\n    [\"idOrNameMatchLast\", -12.561869621276855],\n    [\"labelsMatchLast\", -0.27417105436325073],\n    [\"placeholderMatchesLast\", -1.434966802597046],\n    [\"ariaLabelMatchesLast\", -2.9319725036621094],\n    [\"idOrNameMatchFirstAndLast\", 24.123435974121094],\n    [\"idOrNameMatchSubscription\", 0.08349418640136719],\n    [\"idOrNameMatchDwfrmAndBml\", 0.01882520318031311],\n    [\"hasTemplatedValue\", 0.182317852973938]\n  ],\n  \"cc-type\": [\n    [\"idOrNameMatchTypeRegExp\", 2.0581533908843994],\n    [\"labelsMatchTypeRegExp\", 1.0784518718719482],\n    [\"closestLabelMatchesTypeRegExp\", 0.6995877623558044],\n    [\"idOrNameMatchVisaCheckout\", -3.320356845855713],\n    [\"ariaLabelMatchesVisaCheckout\", -3.4196767807006836],\n    [\"isSelectWithCreditCardOptions\", 10.337477684020996],\n    [\"isRadioWithCreditCardText\", 4.530318737030029],\n    [\"idOrNameMatchSubscription\", -3.7206356525421143],\n    [\"idOrNameMatchDwfrmAndBml\", -0.08782318234443665],\n    [\"hasTemplatedValue\", 0.1772511601448059]\n  ],\n  \"cc-exp\": [\n    [\"labelsMatchExpRegExp\", 7.588159561157227],\n    [\"closestLabelMatchesExpRegExp\", 1.41484534740448],\n    [\"placeholderMatchesExpRegExp\", 8.759064674377441],\n    [\"labelsMatchExpWith2Or4DigitYear\", -3.876218795776367],\n    [\"placeholderMatchesExpWith2Or4DigitYear\", 2.8364884853363037],\n    [\"labelsMatchMMYY\", 8.836017608642578],\n    [\"placeholderMatchesMMYY\", -0.5231751799583435],\n    [\"maxLengthIs7\", 1.3565447330474854],\n    [\"idOrNameMatchSubscription\", 0.1779913753271103],\n    [\"idOrNameMatchDwfrmAndBml\", 0.21037884056568146],\n    [\"hasTemplatedValue\", 0.14900512993335724],\n    [\"isExpirationMonthLikely\", -3.223409652709961],\n    [\"isExpirationYearLikely\", -2.536919593811035],\n    [\"idOrNameMatchMonth\", -3.6893014907836914],\n    [\"idOrNameMatchYear\", -3.108184337615967],\n    [\"idOrNameMatchExpMonthRegExp\", -2.264357089996338],\n    [\"idOrNameMatchExpYearRegExp\", -2.7957723140716553],\n    [\"idOrNameMatchValidation\", -2.29402756690979]\n  ],\n  \"cc-exp-month\": [\n    [\"idOrNameMatchExpMonthRegExp\", 0.2787344455718994],\n    [\"labelsMatchExpMonthRegExp\", 1.298413634300232],\n    [\"closestLabelMatchesExpMonthRegExp\", -11.206244468688965],\n    [\"placeholderMatchesExpMonthRegExp\", 1.2605619430541992],\n    [\"ariaLabelMatchesExpMonthRegExp\", 1.1330018043518066],\n    [\"idOrNameMatchMonth\", 6.1464314460754395],\n    [\"labelsMatchMonth\", 0.7051732540130615],\n    [\"placeholderMatchesMonth\", 0.7463492751121521],\n    [\"ariaLabelMatchesMonth\", 1.8244760036468506],\n    [\"nextFieldIdOrNameMatchExpYearRegExp\", 0.06347066164016724],\n    [\"nextFieldLabelsMatchExpYearRegExp\", -0.1692247837781906],\n    [\"nextFieldPlaceholderMatchExpYearRegExp\", 1.0434566736221313],\n    [\"nextFieldAriaLabelMatchExpYearRegExp\", 1.751156210899353],\n    [\"nextFieldIdOrNameMatchYear\", -0.532447338104248],\n    [\"nextFieldLabelsMatchYear\", 1.3248541355133057],\n    [\"nextFieldPlaceholderMatchesYear\", 0.604235827922821],\n    [\"nextFieldAriaLabelMatchesYear\", 1.5364223718643188],\n    [\"nextFieldMatchesExpYearAutocomplete\", 6.285938262939453],\n    [\"isExpirationMonthLikely\", 13.117807388305664],\n    [\"nextFieldIsExpirationYearLikely\", 7.182341575622559],\n    [\"maxLengthIs2\", 4.477289199829102],\n    [\"placeholderMatchesMM\", 14.403288841247559],\n    [\"roleIsMenu\", 5.770959854125977],\n    [\"idOrNameMatchSubscription\", -0.043085768818855286],\n    [\"idOrNameMatchDwfrmAndBml\", 0.02823038399219513],\n    [\"hasTemplatedValue\", 0.07234494388103485]\n  ],\n  \"cc-exp-year\": [\n    [\"idOrNameMatchExpYearRegExp\", 5.426016807556152],\n    [\"labelsMatchExpYearRegExp\", 1.3240209817886353],\n    [\"closestLabelMatchesExpYearRegExp\", -8.702284812927246],\n    [\"placeholderMatchesExpYearRegExp\", 0.9059725999832153],\n    [\"ariaLabelMatchesExpYearRegExp\", 0.5550334453582764],\n    [\"idOrNameMatchYear\", 5.362994194030762],\n    [\"labelsMatchYear\", 2.7185044288635254],\n    [\"placeholderMatchesYear\", 0.7883157134056091],\n    [\"ariaLabelMatchesYear\", 0.311492383480072],\n    [\"previousFieldIdOrNameMatchExpMonthRegExp\", 1.8155208826065063],\n    [\"previousFieldLabelsMatchExpMonthRegExp\", -0.46133187413215637],\n    [\"previousFieldPlaceholderMatchExpMonthRegExp\", 1.0374903678894043],\n    [\"previousFieldAriaLabelMatchExpMonthRegExp\", -0.5901495814323425],\n    [\"previousFieldIdOrNameMatchMonth\", -5.960310935974121],\n    [\"previousFieldLabelsMatchMonth\", 0.6495584845542908],\n    [\"previousFieldPlaceholderMatchesMonth\", 0.7198042273521423],\n    [\"previousFieldAriaLabelMatchesMonth\", 3.4590985774993896],\n    [\"previousFieldMatchesExpMonthAutocomplete\", 2.986003875732422],\n    [\"isExpirationYearLikely\", 4.021566390991211],\n    [\"previousFieldIsExpirationMonthLikely\", 9.298635482788086],\n    [\"placeholderMatchesYYOrYYYY\", 10.457176208496094],\n    [\"roleIsMenu\", 1.1051956415176392],\n    [\"idOrNameMatchSubscription\", 0.000688597559928894],\n    [\"idOrNameMatchDwfrmAndBml\", 0.15687309205532074],\n    [\"hasTemplatedValue\", -0.19141331315040588]\n  ],\n};\n\nconst biases = [\n  [\"cc-number\", -4.948795795440674],\n  [\"cc-name\", -5.3578081130981445],\n  [\"cc-type\", -5.979659557342529],\n  [\"cc-exp\", -5.849575996398926],\n  [\"cc-exp-month\", -8.844199180603027],\n  [\"cc-exp-year\", -6.499860763549805],\n];\n\n/**\n * END OF CODE PASTED FROM TRAINING REPOSITORY\n */\n\n/**\n * MORE CODE UNIQUE TO PRODUCTION--NOT IN THE TRAINING REPOSITORY:\n */\n// Currently there is a bug when a ruleset has multple types (ex, cc-name, cc-number)\n// and those types also has the same rules (ex. rule `hasTemplatedValue` is used in\n// all the tyoes). When the above case exists, the coefficient of the rule will be\n// overwritten, which means, we can't have different coefficient for the same rule on\n// different types. To workaround this issue, we create a new ruleset for each type.\nvar CreditCardRulesets = {\n  init() {\n    resource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n      this,\n      \"supportedTypes\",\n      \"extensions.formautofill.creditCards.heuristics.fathom.types\",\n      null,\n      null,\n      val => val.split(\",\")\n    );\n\n    for (const type of this.types) {\n      if (type) {\n        this[type] = makeRuleset([...coefficients[type]], biases);\n      }\n    }\n  },\n\n  get types() {\n    return this.supportedTypes;\n  },\n};\n\nCreditCardRulesets.init();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CreditCardRulesets);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/EmptyModule.sys.mjs":
/*!*****************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/EmptyModule.sys.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// This function will create a proxy for each undefined property\n// This is useful when the accessed property name is unkonwn beforehand\nconst undefinedProxy = () =>\n  new Proxy(() => {}, {\n    get() {\n      return undefinedProxy();\n    },\n  });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (undefinedProxy());\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/EmptyModule.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs":
/*!******************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FieldDetail: () => (/* binding */ FieldDetail),\n/* harmony export */   FieldScanner: () => (/* binding */ FieldScanner),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  FormAutofill: \"resource://autofill/FormAutofill.sys.mjs\",\n  FormAutofillUtils: \"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\",\n  MLAutofill: \"resource://autofill/MLAutofill.sys.mjs\",\n});\n\n/**\n * Represents the detailed information about a form field, including\n * the inferred field name, the approach used for inferring, and additional metadata.\n */\nclass FieldDetail {\n  // Reference to the elemenet\n  elementWeakRef = null;\n\n  // The identifier generated via ContentDOMReference for the associated DOM element\n  // of this field\n  elementId = null;\n\n  // The identifier generated via ContentDOMReference for the root element of\n  // this field\n  rootElementId = null;\n\n  // If the element is an iframe, it is the id of the BrowsingContext of the iframe,\n  // Otherwise, it is the id of the BrowsingContext the element is in\n  browsingContextId = null;\n\n  // string with `${element.id}/{element.name}`. This is only used for debugging.\n  identifier = \"\";\n\n  // tag name attribute of the element\n  localName = null;\n\n  // The inferred field name for this element.\n  fieldName = null;\n\n  // The approach we use to infer the information for this element\n  // The possible values are \"autocomplete\", \"fathom\", and \"regex-heuristic\"\n  reason = null;\n\n  /*\n   * The \"section\", \"addressType\", and \"contactType\" values are\n   * used to identify the exact field when the serializable data is received\n   * from the backend.  There cannot be multiple fields which have\n   * the same exact combination of these values.\n   */\n\n  // Which section the field belongs to. The value comes from autocomplete attribute.\n  // See https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill-detail-tokens for more details\n  section = \"\";\n  addressType = \"\";\n  contactType = \"\";\n  credentialType = \"\";\n\n  // When a field is split into N fields, we use part to record which field it is\n  // For example, a credit card number field is split into 4 fields, the value of\n  // \"part\" for the first cc-number field is 1, for the last one is 4.\n  // If the field is not split, the value is null\n  part = null;\n\n  // Confidence value when the field name is inferred by \"fathom\"\n  confidence = null;\n\n  constructor(element) {\n    this.elementWeakRef = new WeakRef(element);\n  }\n\n  get element() {\n    return this.elementWeakRef.deref();\n  }\n\n  /**\n   * Convert FieldDetail class to an object that is suitable for\n   * sending over IPC. Avoid using this in other case.\n   */\n  toVanillaObject() {\n    const json = { ...this };\n    delete json.elementWeakRef;\n    return json;\n  }\n\n  static fromVanillaObject(obj) {\n    const element = lazy.FormAutofillUtils.getElementByIdentifier(\n      obj.elementId\n    );\n    return element ? Object.assign(new FieldDetail(element), obj) : null;\n  }\n\n  static create(\n    element,\n    form,\n    fieldName = null,\n    {\n      autocompleteInfo = null,\n      fathomLabel = null,\n      fathomConfidence = null,\n      isVisible = true,\n      mlHeaderInput = null,\n      mlButtonInput = null,\n    } = {}\n  ) {\n    const fieldDetail = new FieldDetail(element);\n\n    fieldDetail.elementId =\n      lazy.FormAutofillUtils.getElementIdentifier(element);\n    fieldDetail.rootElementId = lazy.FormAutofillUtils.getElementIdentifier(\n      form.rootElement\n    );\n    fieldDetail.identifier = `${element.id}/${element.name}`;\n    fieldDetail.localName = element.localName;\n\n    if (Array.isArray(fieldName)) {\n      fieldDetail.fieldName = fieldName[0] ?? \"\";\n      fieldDetail.alternativeFieldName = fieldName[1] ?? \"\";\n    } else {\n      fieldDetail.fieldName = fieldName;\n    }\n\n    if (!fieldDetail.fieldName) {\n      fieldDetail.reason = \"unknown\";\n    } else if (autocompleteInfo) {\n      fieldDetail.reason = \"autocomplete\";\n      fieldDetail.section = autocompleteInfo.section;\n      fieldDetail.addressType = autocompleteInfo.addressType;\n      fieldDetail.contactType = autocompleteInfo.contactType;\n      fieldDetail.credentialType = autocompleteInfo.credentialType;\n      fieldDetail.sectionName =\n        autocompleteInfo.section || autocompleteInfo.addressType;\n    } else if (fathomConfidence) {\n      fieldDetail.reason = \"fathom\";\n      fieldDetail.confidence = fathomConfidence;\n\n      // TODO: This should be removed once we support reference field info across iframe.\n      // Temporarily add an addtional \"the field is the only visible input\" constraint\n      // when determining whether a form has only a high-confidence cc-* field a valid\n      // credit card section. We can remove this restriction once we are confident\n      // about only using fathom.\n      fieldDetail.isOnlyVisibleFieldWithHighConfidence = false;\n      if (\n        fieldDetail.confidence >\n        lazy.FormAutofillUtils.ccFathomHighConfidenceThreshold\n      ) {\n        const root = element.form || element.ownerDocument;\n        const inputs = root.querySelectorAll(\"input:not([type=hidden])\");\n        if (inputs.length == 1 && inputs[0] == element) {\n          fieldDetail.isOnlyVisibleFieldWithHighConfidence = true;\n        }\n      }\n    } else {\n      fieldDetail.reason = \"regex-heuristic\";\n    }\n\n    try {\n      fieldDetail.browsingContextId =\n        element.localName == \"iframe\"\n          ? element.browsingContext.id\n          : BrowsingContext.getFromWindow(element.ownerGlobal).id;\n    } catch {\n      /* unit test doesn't have ownerGlobal */\n    }\n\n    fieldDetail.isVisible = isVisible;\n\n    // Info required by heuristics\n    fieldDetail.maxLength = element.maxLength;\n\n    if (\n      lazy.FormAutofill.isMLExperimentEnabled &&\n      [\"input\", \"select\"].includes(element.localName)\n    ) {\n      fieldDetail.mlinput = lazy.MLAutofill.getMLMarkup(fieldDetail.element);\n      fieldDetail.mlHeaderInput = mlHeaderInput;\n      fieldDetail.mlButtonInput = mlButtonInput;\n      fieldDetail.fathomLabel = fathomLabel;\n      fieldDetail.fathomConfidence = fathomConfidence;\n    }\n\n    return fieldDetail;\n  }\n}\n\n/**\n * A scanner for traversing all elements in a form. It also provides a\n * cursor (parsingIndex) to indicate which element is waiting for parsing.\n *\n * The scanner retrives the field detail by calling heuristics handlers\n * `inferFieldInfo` function.\n */\nclass FieldScanner {\n  #parsingIndex = 0;\n\n  #fieldDetails = [];\n\n  /**\n   * Create a FieldScanner based on form elements with the existing\n   * fieldDetails.\n   *\n   * @param {Array<FieldDetails>} fieldDetails\n   *        An array of fieldDetail object to be scanned.\n   */\n  constructor(fieldDetails) {\n    this.#fieldDetails = fieldDetails;\n  }\n\n  /**\n   * This cursor means the index of the element which is waiting for parsing.\n   *\n   * @returns {number}\n   *          The index of the element which is waiting for parsing.\n   */\n  get parsingIndex() {\n    return this.#parsingIndex;\n  }\n\n  get parsingFinished() {\n    return this.parsingIndex >= this.#fieldDetails.length;\n  }\n\n  /**\n   * Move the parsingIndex to the next elements. Any elements behind this index\n   * means the parsing tasks are finished.\n   *\n   * @param {number} index\n   *        The latest index of elements waiting for parsing.\n   */\n  set parsingIndex(index) {\n    if (index > this.#fieldDetails.length) {\n      throw new Error(\"The parsing index is out of range.\");\n    }\n    this.#parsingIndex = index;\n  }\n\n  /**\n   * Retrieve the field detail by the index. If the field detail is not ready,\n   * the elements will be traversed until matching the index.\n   *\n   * @param {number} index\n   *        The index of the element that you want to retrieve.\n   * @returns {object}\n   *          The field detail at the specific index.\n   */\n  getFieldDetailByIndex(index) {\n    if (index >= this.#fieldDetails.length) {\n      return null;\n    }\n\n    return this.#fieldDetails[index];\n  }\n\n  /**\n   * When a field detail should be changed its fieldName after parsing, use\n   * this function to update the fieldName which is at a specific index.\n   *\n   * @param {number} index\n   *        The index indicates a field detail to be updated.\n   * @param {string} fieldName\n   *        The new name of the field\n   * @param {boolean} [ignoreAutocomplete=false]\n   *        Whether to change the field name when the field name is determined by\n   *        autocomplete attribute\n   */\n  updateFieldName(index, fieldName, ignoreAutocomplete = false) {\n    if (index >= this.#fieldDetails.length) {\n      throw new Error(\"Try to update the non-existing field detail.\");\n    }\n\n    const fieldDetail = this.#fieldDetails[index];\n    if (fieldDetail.fieldName == fieldName) {\n      return;\n    }\n\n    if (!ignoreAutocomplete && fieldDetail.reason == \"autocomplete\") {\n      return;\n    }\n\n    fieldDetail.fieldName = fieldName;\n    fieldDetail.reason = \"update-heuristic\";\n  }\n\n  elementExisting(index) {\n    return index < this.#fieldDetails.length;\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FieldScanner);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs":
/*!**********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormAutofill: () => (/* reexport safe */ resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://autofill/FormAutofill.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\nresource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.defineLogGetter = (_scope, _logPrefix) => ({\n  // TODO: Bug 1828405. Explore how logging should be handled.\n  // Maybe it makes more sense to do it on swift side and have JS just send messages.\n  info: () => {},\n  error: () => {},\n  warn: () => {},\n  debug: () => {},\n});\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs":
/*!******************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormAutofill: () => (/* binding */ FormAutofill)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/Region.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs\");\n/* harmony import */ var resource_gre_modules_shared_AddressMetaDataLoader_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/AddressMetaDataLoader.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\n\nconst AUTOFILL_ADDRESSES_AVAILABLE_PREF =\n  \"extensions.formautofill.addresses.supported\";\n// This pref should be refactored after the migration of the old bool pref\nconst AUTOFILL_CREDITCARDS_AVAILABLE_PREF =\n  \"extensions.formautofill.creditCards.supported\";\nconst BROWSER_SEARCH_REGION_PREF = \"browser.search.region\";\nconst CREDITCARDS_AUTOFILL_SUPPORTED_COUNTRIES_PREF =\n  \"extensions.formautofill.creditCards.supportedCountries\";\nconst ENABLED_AUTOFILL_ADDRESSES_PREF =\n  \"extensions.formautofill.addresses.enabled\";\nconst ENABLED_AUTOFILL_ADDRESSES_CAPTURE_PREF =\n  \"extensions.formautofill.addresses.capture.enabled\";\nconst ENABLED_AUTOFILL_ADDRESSES_CAPTURE_REQUIRED_FIELDS_PREF =\n  \"extensions.formautofill.addresses.capture.requiredFields\";\nconst ENABLED_AUTOFILL_ADDRESSES_SUPPORTED_COUNTRIES_PREF =\n  \"extensions.formautofill.addresses.supportedCountries\";\nconst ENABLED_AUTOFILL_CREDITCARDS_PREF =\n  \"extensions.formautofill.creditCards.enabled\";\nconst AUTOFILL_CREDITCARDS_REAUTH_PREF =\n  \"extensions.formautofill.creditCards.reauth.optout\";\nconst AUTOFILL_CREDITCARDS_HIDE_UI_PREF =\n  \"extensions.formautofill.creditCards.hideui\";\nconst FORM_AUTOFILL_SUPPORT_RTL_PREF = \"extensions.formautofill.supportRTL\";\nconst AUTOFILL_CREDITCARDS_AUTOCOMPLETE_OFF_PREF =\n  \"extensions.formautofill.creditCards.ignoreAutocompleteOff\";\nconst AUTOFILL_ADDRESSES_AUTOCOMPLETE_OFF_PREF =\n  \"extensions.formautofill.addresses.ignoreAutocompleteOff\";\nconst ENABLED_AUTOFILL_CAPTURE_ON_FORM_REMOVAL_PREF =\n  \"extensions.formautofill.heuristics.captureOnFormRemoval\";\nconst ENABLED_AUTOFILL_CAPTURE_ON_PAGE_NAVIGATION_PREF =\n  \"extensions.formautofill.heuristics.captureOnPageNavigation\";\nconst ENABLED_AUTOFILL_SAME_ORIGIN_WITH_TOP =\n  \"extensions.formautofill.heuristics.autofillSameOriginWithTop\";\nconst ENABLED_AUTOFILL_DETECT_DYNAMIC_FORM_CHANGES_PREF =\n  \"extensions.formautofill.heuristics.detectDynamicFormChanges\";\nconst AUTOFILL_FILL_ON_DYNAMIC_FORM_CHANGES_TIMEOUT_PREF =\n  \"extensions.formautofill.heuristics.fillOnDynamicFormChanges.timeout\";\nconst AUTOFILL_FILL_ON_DYNAMIC_FORM_CHANGES_PREF =\n  \"extensions.formautofill.heuristics.fillOnDynamicFormChanges\";\n\nconst FormAutofill = {\n  ENABLED_AUTOFILL_ADDRESSES_PREF,\n  ENABLED_AUTOFILL_ADDRESSES_CAPTURE_PREF,\n  ENABLED_AUTOFILL_CAPTURE_ON_FORM_REMOVAL_PREF,\n  ENABLED_AUTOFILL_CAPTURE_ON_PAGE_NAVIGATION_PREF,\n  ENABLED_AUTOFILL_SAME_ORIGIN_WITH_TOP,\n  ENABLED_AUTOFILL_CREDITCARDS_PREF,\n  ENABLED_AUTOFILL_DETECT_DYNAMIC_FORM_CHANGES_PREF,\n  AUTOFILL_CREDITCARDS_REAUTH_PREF,\n  AUTOFILL_CREDITCARDS_AUTOCOMPLETE_OFF_PREF,\n  AUTOFILL_ADDRESSES_AUTOCOMPLETE_OFF_PREF,\n  AUTOFILL_FILL_ON_DYNAMIC_FORM_CHANGES_PREF,\n  AUTOFILL_FILL_ON_DYNAMIC_FORM_CHANGES_TIMEOUT_PREF,\n\n  _region: null,\n\n  get DEFAULT_REGION() {\n    return this._region || resource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.Region.home || \"US\";\n  },\n\n  set DEFAULT_REGION(region) {\n    this._region = region;\n  },\n\n  /**\n   * Determines if an autofill feature should be enabled based on the \"available\"\n   * and \"supportedCountries\" parameters.\n   *\n   * @param {string} available Available can be one of the following: \"on\", \"detect\", \"off\".\n   * \"on\" forces the particular Form Autofill feature on, while \"detect\" utilizes the supported countries\n   * to see if the feature should be available.\n   * @param {string[]} supportedCountries\n   * @returns {boolean} `true` if autofill feature is supported in the current browser search region\n   */\n  _isSupportedRegion(available, supportedCountries) {\n    if (available == \"on\") {\n      return true;\n    } else if (available == \"detect\") {\n      if (!FormAutofill.supportRTL && Services.locale.isAppLocaleRTL) {\n        return false;\n      }\n\n      return supportedCountries.includes(FormAutofill.browserSearchRegion);\n    }\n    return false;\n  },\n\n  /**\n   * Return true if address autofill is available for a specific country.\n   */\n  isAutofillAddressesAvailableInCountry(country) {\n    if (FormAutofill._isAutofillAddressesAvailableInExperiment) {\n      return true;\n    }\n\n    let available = FormAutofill._isAutofillAddressesAvailable;\n    if (country && available == \"detect\") {\n      return FormAutofill._addressAutofillSupportedCountries.includes(\n        country.toUpperCase()\n      );\n    }\n    return available == \"on\";\n  },\n  get isAutofillEnabled() {\n    return this.isAutofillAddressesEnabled || this.isAutofillCreditCardsEnabled;\n  },\n  /**\n   * Determines if the credit card autofill feature is available to use in the browser.\n   * If the feature is not available, then there are no user facing ways to enable it.\n   *\n   * @returns {boolean} `true` if credit card autofill is available\n   */\n  get isAutofillCreditCardsAvailable() {\n    return this._isSupportedRegion(\n      FormAutofill._isAutofillCreditCardsAvailable,\n      FormAutofill._creditCardAutofillSupportedCountries\n    );\n  },\n  /**\n   * Determines if the address autofill feature is available to use in the browser.\n   * If the feature is not available, then there are no user facing ways to enable it.\n   * Two conditions must be met for the autofill feature to be considered available:\n   *   1. Address autofill support is confirmed when:\n   *      - `extensions.formautofill.addresses.supported` is set to `on`.\n   *      - The user is located in a region supported by the feature\n   *        (`extensions.formautofill.creditCards.supportedCountries`).\n   *   2. Address autofill is enabled through a Nimbus experiment:\n   *      - The experiment pref `extensions.formautofill.addresses.experiments.enabled` is set to true.\n   *\n   * @returns {boolean} `true` if address autofill is available\n   */\n  get isAutofillAddressesAvailable() {\n    const isUserInSupportedRegion = this._isSupportedRegion(\n      FormAutofill._isAutofillAddressesAvailable,\n      FormAutofill._addressAutofillSupportedCountries\n    );\n    return (\n      isUserInSupportedRegion ||\n      FormAutofill._isAutofillAddressesAvailableInExperiment\n    );\n  },\n  /**\n   * Determines if the user has enabled or disabled credit card autofill.\n   *\n   * @returns {boolean} `true` if credit card autofill is enabled\n   */\n  get isAutofillCreditCardsEnabled() {\n    return (\n      this.isAutofillCreditCardsAvailable &&\n      FormAutofill._isAutofillCreditCardsEnabled\n    );\n  },\n  /**\n   * Determines if credit card autofill is locked by policy.\n   *\n   * @returns {boolean} `true` if credit card autofill is locked\n   */\n  get isAutofillCreditCardsLocked() {\n    return Services.prefs.prefIsLocked(ENABLED_AUTOFILL_CREDITCARDS_PREF);\n  },\n  /**\n   * Determines if the user has enabled or disabled address autofill.\n   *\n   * @returns {boolean} `true` if address autofill is enabled\n   */\n  get isAutofillAddressesEnabled() {\n    return (\n      this.isAutofillAddressesAvailable &&\n      FormAutofill._isAutofillAddressesEnabled\n    );\n  },\n  /**\n   * Determines if address autofill is locked by policy.\n   *\n   * @returns {boolean} `true` if address autofill is locked\n   */\n  get isAutofillAddressesLocked() {\n    return Services.prefs.prefIsLocked(ENABLED_AUTOFILL_ADDRESSES_PREF);\n  },\n\n  defineLogGetter(scope, logPrefix) {\n    // A logging helper for debug logging to avoid creating Console objects\n    // or triggering expensive JS -> C++ calls when debug logging is not\n    // enabled.\n    //\n    // Console objects, even natively-implemented ones, can consume a lot of\n    // memory, and since this code may run in every content process, that\n    // memory can add up quickly. And, even when debug-level messages are\n    // being ignored, console.debug() calls can be expensive.\n    //\n    // This helper avoids both of those problems by never touching the\n    // console object unless debug logging is enabled.\n    scope.debug = function debug() {\n      if (FormAutofill.logLevel.toLowerCase() == \"debug\") {\n        this.log.debug(...arguments);\n      }\n    };\n\n    let { ConsoleAPI } = ChromeUtils.importESModule(\n      \"resource://gre/modules/Console.sys.mjs\"\n    );\n    return new ConsoleAPI({\n      maxLogLevelPref: \"extensions.formautofill.loglevel\",\n      prefix: logPrefix,\n    });\n  },\n\n  get isMLExperimentEnabled() {\n    return FormAutofill._isMLEnabled && FormAutofill._isMLExperimentEnabled;\n  },\n};\n\n// TODO: Bug 1747284. Use Region.home instead of reading \"browser.serach.region\"\n// by default. However, Region.home doesn't observe preference change at this point,\n// we should also fix that issue.\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"browserSearchRegion\",\n  BROWSER_SEARCH_REGION_PREF,\n  FormAutofill.DEFAULT_REGION\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"logLevel\",\n  \"extensions.formautofill.loglevel\",\n  \"Warn\"\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_isAutofillAddressesAvailable\",\n  AUTOFILL_ADDRESSES_AVAILABLE_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_isAutofillAddressesEnabled\",\n  ENABLED_AUTOFILL_ADDRESSES_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"isAutofillAddressesCaptureEnabled\",\n  ENABLED_AUTOFILL_ADDRESSES_CAPTURE_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_isAutofillCreditCardsAvailable\",\n  AUTOFILL_CREDITCARDS_AVAILABLE_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_isAutofillCreditCardsEnabled\",\n  ENABLED_AUTOFILL_CREDITCARDS_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"isAutofillCreditCardsHideUI\",\n  AUTOFILL_CREDITCARDS_HIDE_UI_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_addressAutofillSupportedCountries\",\n  ENABLED_AUTOFILL_ADDRESSES_SUPPORTED_COUNTRIES_PREF,\n  null,\n  val => val.split(\",\")\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_creditCardAutofillSupportedCountries\",\n  CREDITCARDS_AUTOFILL_SUPPORTED_COUNTRIES_PREF,\n  null,\n  null,\n  val => val.split(\",\")\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"supportRTL\",\n  FORM_AUTOFILL_SUPPORT_RTL_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"creditCardsAutocompleteOff\",\n  AUTOFILL_CREDITCARDS_AUTOCOMPLETE_OFF_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"addressesAutocompleteOff\",\n  AUTOFILL_ADDRESSES_AUTOCOMPLETE_OFF_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"captureOnFormRemoval\",\n  ENABLED_AUTOFILL_CAPTURE_ON_FORM_REMOVAL_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"captureOnPageNavigation\",\n  ENABLED_AUTOFILL_CAPTURE_ON_PAGE_NAVIGATION_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"addressCaptureRequiredFields\",\n  ENABLED_AUTOFILL_ADDRESSES_CAPTURE_REQUIRED_FIELDS_PREF,\n  null,\n  null,\n  val => val?.split(\",\").filter(v => !!v)\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"autofillSameOriginWithTop\",\n  ENABLED_AUTOFILL_SAME_ORIGIN_WITH_TOP\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_isAutofillAddressesAvailableInExperiment\",\n  \"extensions.formautofill.addresses.experiments.enabled\"\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_isMLEnabled\",\n  \"browser.ml.enable\",\n  false\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_isMLExperimentEnabled\",\n  \"extensions.formautofill.ml.experiment.enabled\",\n  false\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"MLModelRevision\",\n  \"extensions.formautofill.ml.experiment.modelRevision\",\n  null\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"detectDynamicFormChanges\",\n  \"extensions.formautofill.heuristics.detectDynamicFormChanges\",\n  false\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"fillOnDynamicFormChanges\",\n  \"extensions.formautofill.heuristics.fillOnDynamicFormChanges\",\n  false\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"fillOnDynamicFormChangeTimeout\",\n  \"extensions.formautofill.heuristics.fillOnDynamicFormChanges.timeout\",\n  0\n);\n\nChromeUtils.defineLazyGetter(FormAutofill, \"countries\", () =>\n  resource_gre_modules_shared_AddressMetaDataLoader_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.AddressMetaDataLoader.getCountries()\n);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs":
/*!***************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormAutofillChild: () => (/* binding */ FormAutofillChild),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_shared_AddressRecord_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/shared/AddressRecord.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormAutofillHandler_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillHandler.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormAutofillHeuristics_sys_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillHeuristics.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormStateManager_sys_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! resource://gre/modules/shared/FormStateManager.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_CreditCardRecord_sys_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! resource://gre/modules/shared/CreditCardRecord.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillSection.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/* eslint-disable no-undef,mozilla/balanced-listeners */\n\n\n\n\n\n\n\n\nclass FormAutofillChild {\n  /**\n   * Creates an instance of FormAutofillChild.\n   *\n   * @param {object} callbacks - An object containing callback functions.\n   * @param {object} callbacks.address - Callbacks related to addresses.\n   * @param {Function} callbacks.address.autofill - Function called to autofill address fields.\n   * @param {Function} callbacks.address.submit - Function called on address form submission.\n   * @param {object} callbacks.creditCard - Callbacks related to credit cards.\n   * @param {Function} callbacks.creditCard.autofill - Function called to autofill credit card fields.\n   * @param {Function} callbacks.creditCard.submit - Function called on credit card form submission.\n   */\n  constructor(callbacks) {\n    this.onFocusIn = this.onFocusIn.bind(this);\n    this.onSubmit = this.onSubmit.bind(this);\n\n    this.callbacks = callbacks;\n\n    this.fieldDetailsManager = new resource_gre_modules_shared_FormStateManager_sys_mjs__WEBPACK_IMPORTED_MODULE_4__.FormStateManager(fieldDetail =>\n      // Collect field_modified telemetry\n      this.activeSection?.onFilledModified(fieldDetail.elementId)\n    );\n\n    try {\n      document.addEventListener(\"focusin\", this.onFocusIn);\n      document.addEventListener(\"submit\", this.onSubmit);\n    } catch {\n      // We don't have `document` when running in xpcshell-test\n    }\n  }\n\n  transformToFieldNamesWithValues(details) {\n    return details?.reduce(\n      (acc, field) => ({\n        ...acc,\n        [field.fieldName]: field.element.value,\n      }),\n      {}\n    );\n  }\n\n  identifyFieldsWhenFocused(element) {\n    if (this.#focusedElement == element) {\n      return;\n    }\n    this.#focusedElement = element;\n\n    if (!resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.FormAutofillUtils.isCreditCardOrAddressFieldType(element)) {\n      return;\n    }\n\n    // Find the autofill handler for this form and identify all the fields.\n    const handler = this.fieldDetailsManager.getOrCreateFormHandler(element);\n\n    if (!handler.hasIdentifiedFields() || handler.updateFormIfNeeded(element)) {\n      // If we found newly identified fields, run section classification heuristic\n      const detectedFields = resource_gre_modules_shared_FormAutofillHandler_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillHandler.collectFormFieldDetails(\n        handler.form\n      );\n\n      resource_gre_modules_shared_FormAutofillHeuristics_sys_mjs__WEBPACK_IMPORTED_MODULE_2__.FormAutofillHeuristics.parseAndUpdateFieldNamesParent(detectedFields);\n      handler.setIdentifiedFieldDetails(detectedFields);\n\n      this.#sections = resource_gre_modules_shared_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_6__.FormAutofillSection.classifySections(\n        handler.fieldDetails\n      );\n\n      // For telemetry\n      this.#sections.forEach(section => section.onDetected());\n    }\n  }\n\n  #focusedElement = null;\n\n  // This is a cache contains the classified section for the active form.\n  #sections = null;\n\n  get activeSection() {\n    const elementId = this.activeFieldDetail?.elementId;\n    return this.#sections?.find(section =>\n      section.getFieldDetailByElementId(elementId)\n    );\n  }\n\n  // active field detail only exists if we identified its field name\n  get activeFieldDetail() {\n    return this.activeHandler?.getFieldDetailByElement(this.#focusedElement);\n  }\n\n  get activeHandler() {\n    return this.fieldDetailsManager.getFormHandler(this.#focusedElement);\n  }\n\n  onFocusIn(evt) {\n    const element = evt.target;\n\n    if (element.shouldIgnoreAutofill) {\n      return;\n    }\n\n    this.identifyFieldsWhenFocused(element);\n\n    // Only ping swift if current field is either a cc or address field\n    if (!this.activeFieldDetail) {\n      return;\n    }\n\n    // Since iOS doesn't support cross frame autofill,\n    // we should only call the autofill callback if the section is valid.\n    // TODO(issam): This will change when we have cross frame fill support.\n    if (!this.activeSection?.isValidSection()) {\n      return;\n    }\n\n    const fieldNamesWithValues = this.transformToFieldNamesWithValues(\n      this.activeSection.fieldDetails\n    );\n\n    if (resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.FormAutofillUtils.isAddressField(this.activeFieldDetail.fieldName)) {\n      this.callbacks.address.autofill(fieldNamesWithValues);\n    } else if (\n      resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.FormAutofillUtils.isCreditCardField(this.activeFieldDetail.fieldName)\n    ) {\n      // Normalize record format so we always get a consistent\n      // credit card record format: {cc-number, cc-name, cc-exp-month, cc-exp-year}\n      resource_gre_modules_shared_CreditCardRecord_sys_mjs__WEBPACK_IMPORTED_MODULE_5__.CreditCardRecord.normalizeFields(fieldNamesWithValues);\n      this.callbacks.creditCard.autofill(fieldNamesWithValues);\n    }\n  }\n\n  onSubmit(_event) {\n    if (!this.activeHandler) {\n      return;\n    }\n\n    // Get filled value for the form\n    const formFilledData = this.activeHandler.collectFormFilledData();\n\n    // Should reference `_onFormSubmit` in `FormAutofillParent.sys.mjs`\n    const creditCard = [];\n\n    for (const section of this.#sections) {\n      const secRecord = section.createRecord(formFilledData);\n      if (!secRecord) {\n        continue;\n      }\n\n      if (section instanceof resource_gre_modules_shared_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_6__.FormAutofillAddressSection) {\n        // TODO(FXSP-133 Phase 3): Support address capture\n        // this.callbacks.address.submit();\n        continue;\n      } else if (section instanceof resource_gre_modules_shared_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_6__.FormAutofillCreditCardSection) {\n        creditCard.push(secRecord);\n      } else {\n        throw new Error(\"Unknown section type\");\n      }\n\n      section.onSubmitted(formFilledData);\n    }\n\n    if (creditCard.length) {\n      // Normalize record format so we always get a consistent\n      // credit card record format: {cc-number, cc-name, cc-exp-month, cc-exp-year}\n      const creditCardRecords = creditCard.map(entry => {\n        resource_gre_modules_shared_CreditCardRecord_sys_mjs__WEBPACK_IMPORTED_MODULE_5__.CreditCardRecord.normalizeFields(entry.record);\n        return entry.record;\n      });\n      this.callbacks.creditCard.submit(creditCardRecords);\n    }\n  }\n\n  fillFormFields(payload) {\n    // In iOS, we have access only to valid fields (https://github.com/mozilla/application-services/blob/9054db4bb5031881550ceab3448665ef6499a706/components/autofill/src/autofill.udl#L59-L76) for an address;\n    // all additional data must be computed. On Desktop, computed fields are handled in FormAutofillStorageBase.sys.mjs at the time of saving. Ideally, we should centralize\n    // all transformations, computations, and normalization processes within AddressRecord.sys.mjs to maintain a unified implementation across both platforms.\n    // This will be addressed in FXCM-810, aiming to simplify our data representation for both credit cards and addresses.\n\n    if (resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.FormAutofillUtils.isAddressField(this.activeFieldDetail?.fieldName)) {\n      resource_gre_modules_shared_AddressRecord_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.AddressRecord.computeFields(payload);\n    }\n\n    this.activeHandler.fillFields(\n      resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.FormAutofillUtils.getElementIdentifier(this.#focusedElement),\n      this.activeSection.fieldDetails.map(f => f.elementId),\n      payload\n    );\n\n    // For telemetry\n    const formFilledData = this.activeHandler.collectFormFilledData();\n    this.activeSection.onFilled(formFilledData);\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FormAutofillChild);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs":
/*!************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormAutofillExtras: () => (/* binding */ FormAutofillExtras),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nclass FormAutofillExtras {\n\n  isFocusable(element) {\n    let style = window.getComputedStyle(element);\n    return !(element.type === 'hidden' || element.offsetParent === null || style.visibility === 'hidden' || style.display === 'none' || style.opacity === '0' || element.hasAttribute('hidden'));\n  }\n\n  focusNextInputField() {\n    let inputFields = [...document.getElementsByTagName('input')];\n    inputFields = inputFields.filter(this.isFocusable);\n    const activeElement = document.activeElement;\n    const currentIndex = inputFields.indexOf(activeElement);\n    const inputFieldCount = inputFields.length - 1;\n\n    if (currentIndex < inputFieldCount) {\n      const nextField = inputFields[currentIndex + 1];\n      nextField.focus();\n    }\n  }\n\n  focusPreviousInputField() {\n    let inputFields = [...document.getElementsByTagName('input')];\n    inputFields = inputFields.filter(this.isFocusable);\n    const activeElement = document.activeElement;\n    const currentIndex = inputFields.indexOf(activeElement);\n\n    if (currentIndex > 0) {\n      const previousField = inputFields[currentIndex - 1];\n      previousField.focus();\n    }\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FormAutofillExtras);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs":
/*!*************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FORM_CHANGE_REASON: () => (/* binding */ FORM_CHANGE_REASON),\n/* harmony export */   FormAutofillHandler: () => (/* binding */ FormAutofillHandler)\n/* harmony export */ });\n/* harmony import */ var resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://autofill/FormAutofill.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  AddressParser: \"resource://gre/modules/shared/AddressParser.sys.mjs\",\n  AutofillFormFactory:\n    \"resource://gre/modules/shared/AutofillFormFactory.sys.mjs\",\n  CreditCard: \"resource://gre/modules/CreditCard.sys.mjs\",\n  FieldDetail: \"resource://gre/modules/shared/FieldScanner.sys.mjs\",\n  FormAutofillHeuristics:\n    \"resource://gre/modules/shared/FormAutofillHeuristics.sys.mjs\",\n  FormAutofillNameUtils:\n    \"resource://gre/modules/shared/FormAutofillNameUtils.sys.mjs\",\n  LabelUtils: \"resource://gre/modules/shared/LabelUtils.sys.mjs\",\n});\n\nconst { FIELD_STATES } = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils;\n\nconst FORM_CHANGE_REASON = {\n  NODES_ADDED: \"nodes-added\",\n  NODES_REMOVED: \"nodes-removed\",\n  ELEMENT_INVISIBLE: \"visible-element-became-invisible\",\n  ELEMENT_VISIBLE: \"invisible-element-became-visible\",\n};\n\n/**\n * Handles profile autofill for a DOM Form element.\n */\nclass FormAutofillHandler {\n  // The window to which this form belongs\n  window = null;\n\n  // DOM Form element to which this object is attached\n  form = null;\n\n  // Keeps track of filled state for all identified elements\n  #filledStateByElement = new WeakMap();\n\n  // An object that caches the current selected option, keyed by element.\n  #matchingSelectOption = null;\n\n  /**\n   * Array of collected data about relevant form fields.  Each item is an object\n   * storing the identifying details of the field and a reference to the\n   * originally associated element from the form.\n   *\n   * The \"section\", \"addressType\", \"contactType\", and \"fieldName\" values are\n   * used to identify the exact field when the serializable data is received\n   * from the backend.  There cannot be multiple fields which have\n   * the same exact combination of these values.\n   *\n   * A direct reference to the associated element cannot be sent to the user\n   * interface because processing may be done in the parent process.\n   */\n  #fieldDetails = null;\n\n  /**\n   * Flags if the MutationObserver (this.#formMutationObserver) that is observing\n   * node additions/removals for the root element has been set up\n   */\n  #isObservingFormMutations = false;\n\n  #formMutationObserver = null;\n\n  #visibilityStateObserverByElement = new WeakMap();\n\n  /**\n   *\n   * fillOnFormChangeData.isWithinDynamicFormChangeThreshold:\n   *              Flags if a \"form-change\" event is received within the timeout threshold\n   *              (see lazy.FormAutofill.fillOnDynamicFormChangeTimeout), that we set\n   *              in order to consider newly detected fields for filling.\n   * fillOnFormChangeData.previouslyUsedProfile\n   *              The previously used profile from the latest autocompletion.\n   * fillOnFormChangeData.previouslyFocusedId\n   *              The previously focused element id from the latest autocompletion\n   *\n   * This is used for any following form changes and is cleared after a time threshold\n   * set by lazy.FormAutofill.fillOnDynamicFormChangeTimeout.\n   */\n  #fillOnFormChangeData = new Map();\n\n  /**\n   * Flag to indicate whethere there is an ongoing autofilling/clearing process.\n   */\n  #isAutofillInProgress = false;\n\n  /**\n   * Initialize the form from `FormLike` object to handle the section or form\n   * operations.\n   *\n   * @param {FormLike} form Form that need to be auto filled\n   * @param {Function} onFilledModifiedCallback Function that can be invoked\n   *                   when we want to suggest autofill on a form.\n   */\n  constructor(form, onFilledModifiedCallback = () => {}) {\n    this._updateForm(form);\n\n    this.window = this.form.rootElement.ownerGlobal;\n\n    this.onFilledModifiedCallback = onFilledModifiedCallback;\n\n    // The identifier generated via ContentDOMReference for the root element.\n    this.rootElementId = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.getElementIdentifier(\n      form.rootElement\n    );\n\n    ChromeUtils.defineLazyGetter(this, \"log\", () =>\n      resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.defineLogGetter(this, \"FormAutofillHandler\")\n    );\n  }\n\n  get fillOnFormChangeData() {\n    return this.#fillOnFormChangeData;\n  }\n\n  clearFillOnFormChangeData() {\n    this.#fillOnFormChangeData = new Map();\n    this.#fillOnFormChangeData.isWithinDynamicFormChangeThreshold = false;\n  }\n\n  /**\n   * Retrieves the 'fieldDetails' property, ensuring it has been initialized by\n   * `setIdentifiedFieldDetails`. Throws an error if accessed before initialization.\n   *\n   * This is because 'fieldDetail'' contains information that need to be computed\n   * in the parent side first.\n   *\n   * @throws {Error} If `setIdentifiedFieldDetails` has not been called.\n   * @returns {Array<FieldDetail>}\n   *          The list of autofillable field details for this form.\n   */\n  get fieldDetails() {\n    if (!this.#fieldDetails) {\n      throw new Error(\n        `Should only use 'fieldDetails' after 'setIdentifiedFieldDetails' is called`\n      );\n    }\n    return this.#fieldDetails;\n  }\n\n  /**\n   * Sets the list of 'FieldDetail' objects for autofillable fields within the form.\n   *\n   * @param {Array<FieldDetail>} fieldDetails\n   *        An array of field details that has been computed on the parent side.\n   *        This method should be called before accessing `fieldDetails`.\n   */\n  setIdentifiedFieldDetails(fieldDetails) {\n    this.#fieldDetails = fieldDetails;\n  }\n\n  /**\n   * Determines whether 'setIdentifiedFieldDetails' has been called and the\n   * `fieldDetails` have been initialized.\n   *\n   * @returns {boolean}\n   *          True if 'fieldDetails' has been initialized; otherwise, False.\n   */\n  hasIdentifiedFields() {\n    return !!this.#fieldDetails;\n  }\n\n  get isAutofillInProgress() {\n    return this.#isAutofillInProgress;\n  }\n\n  handleEvent(event) {\n    switch (event.type) {\n      case \"input\": {\n        if (!event.isTrusted || this.isAutofillInProgress) {\n          return;\n        }\n\n        // This uses the #filledStateByElement map instead of\n        // autofillState as the state has already been cleared by the time\n        // the input event fires.\n        const fieldDetail = this.getFieldDetailByElement(event.target);\n        const previousState = this.getFilledStateByElement(event.target);\n        const newState = FIELD_STATES.NORMAL;\n\n        if (previousState != newState) {\n          this.changeFieldState(fieldDetail, newState);\n        }\n\n        this.onFilledModifiedCallback?.(fieldDetail, previousState, newState);\n      }\n    }\n  }\n\n  getFieldDetailByName(fieldName) {\n    return this.fieldDetails.find(detail => detail.fieldName == fieldName);\n  }\n\n  getFieldDetailByElement(element) {\n    return this.fieldDetails.find(detail => detail.element == element);\n  }\n\n  getFieldDetailByElementId(elementId) {\n    return this.fieldDetails.find(detail => detail.elementId == elementId);\n  }\n\n  /**\n   * Only use this API within handleEvent\n   */\n  getFilledStateByElement(element) {\n    return this.#filledStateByElement.get(element);\n  }\n\n  isVisiblityStateObserverSetUpByElement(element) {\n    return this.#visibilityStateObserverByElement.has(element);\n  }\n\n  setVisibilityStateObserverByElement(element, observer) {\n    this.#visibilityStateObserverByElement.set(element, observer);\n  }\n\n  clearVisibilityStateObserverByElement(element) {\n    if (this.isVisiblityStateObserverSetUpByElement(element)) {\n      const observer = this.#visibilityStateObserverByElement.get(element);\n      observer.disconnect();\n      this.#visibilityStateObserverByElement.delete(element);\n    }\n  }\n\n  /**\n   * Check the form is necessary to be updated. This function should be able to\n   * detect any changes including all control elements in the form.\n   *\n   * @param {HTMLElement} element The element supposed to be in the form.\n   * @returns {boolean} FormAutofillHandler.form is updated or not.\n   */\n  updateFormIfNeeded(element) {\n    // When the following condition happens, FormAutofillHandler.form should be\n    // updated:\n    // * The count of form controls is changed.\n    // * When the element can not be found in the current form.\n    //\n    // However, we should improve the function to detect the element changes.\n    // e.g. a tel field is changed from type=\"hidden\" to type=\"tel\".\n\n    let _formLike;\n    const getFormLike = () => {\n      if (!_formLike) {\n        _formLike = lazy.AutofillFormFactory.createFromField(element);\n      }\n      return _formLike;\n    };\n\n    const currentForm = getFormLike();\n    if (currentForm.elements.length != this.form.elements.length) {\n      this.log.debug(\"The count of form elements is changed.\");\n      this._updateForm(getFormLike());\n      return true;\n    }\n\n    if (!this.form.elements.includes(element)) {\n      this.log.debug(\"The element can not be found in the current form.\");\n      this._updateForm(getFormLike());\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Update the form with a new FormLike, and the related fields should be\n   * updated or clear to ensure the data consistency.\n   *\n   * @param {FormLike} form a new FormLike to replace the original one.\n   */\n  _updateForm(form) {\n    this.form = form;\n\n    this.#fieldDetails = null;\n  }\n\n  /**\n   * Collect <input>, <select>, and <iframe> elements from the specified form\n   * and return the correspond 'FieldDetail' objects.\n   *\n   * @param {formLike} formLike\n   *        The form that we collect information from.\n   * @param {boolean} includeIframe\n   *        True to add <iframe> to the returned FieldDetails array.\n   * @param {boolean} ignoreInvisibleInput\n   *        True to NOT run heuristics on invisible <input> fields.\n   *\n   * @returns {Array<FieldDeail>}\n   *        An array containing eligible fields for autofill, also\n   *        including iframe.\n   */\n  static collectFormFieldDetails(\n    formLike,\n    includeIframe,\n    ignoreInvisibleInput = true\n  ) {\n    const fieldDetails =\n      lazy.FormAutofillHeuristics.getFormInfo(formLike, ignoreInvisibleInput) ??\n      [];\n\n    // 'FormLike' only contains <input> & <select>, so in order to include <iframe>\n    // in the list of 'FieldDetails', we need to search for <iframe> in the form.\n    if (!includeIframe) {\n      return fieldDetails;\n    }\n\n    // Insert <iframe> elements into the fieldDetails array, maintaining the element order.\n    const elements = formLike.rootElement.querySelectorAll(\"iframe\");\n\n    let startIndex = 0;\n\n    // eslint-disable-next-line no-labels\n    outer: for (const element of elements) {\n      if (resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.isFieldVisible(element)) {\n        const iframeFd = lazy.FieldDetail.create(element, formLike, \"iframe\");\n\n        for (let index = startIndex; index < fieldDetails.length; index++) {\n          let position = element.compareDocumentPosition(\n            fieldDetails[index]?.element\n          );\n          if (\n            position &\n            (Node.DOCUMENT_POSITION_FOLLOWING |\n              Node.DOCUMENT_POSITION_CONTAINED_BY)\n          ) {\n            fieldDetails.splice(index, 0, iframeFd);\n            startIndex = index; // start from this index for later iframes\n            // eslint-disable-next-line no-labels\n            continue outer;\n          }\n        }\n\n        fieldDetails.push(iframeFd);\n      }\n    }\n\n    return fieldDetails;\n  }\n\n  /**\n   * Resetting the state element's fieldDetail after it was removed from the form\n   * Todo: We'll need to update this.filledResult in FormAutofillParent (Bug 1948077).\n   *\n   * @param {HTMLElement} element that was removed\n   */\n  resetFieldStateWhenRemoved(element) {\n    if (this.getFilledStateByElement(element) != FIELD_STATES.AUTO_FILLED) {\n      return;\n    }\n    const fieldDetail = this.getFieldDetailByElement(element);\n    this.#filledStateByElement.delete(fieldDetail);\n  }\n\n  /**\n   * Change the state of a field to correspond with different presentations.\n   *\n   * @param {object} fieldDetail\n   *        A fieldDetail of which its element is about to update the state.\n   * @param {string} state\n   *        The state to apply.\n   */\n  changeFieldState(fieldDetail, state) {\n    const element = fieldDetail.element;\n    if (!element) {\n      this.log.warn(\n        fieldDetail.fieldName,\n        \"is unreachable while changing state\"\n      );\n      return;\n    }\n\n    if (!Object.values(FIELD_STATES).includes(state)) {\n      this.log.warn(\n        fieldDetail.fieldName,\n        \"is trying to change to an invalid state\"\n      );\n      return;\n    }\n\n    element.autofillState = state;\n    this.#filledStateByElement.set(element, state);\n\n    if (state == FIELD_STATES.AUTO_FILLED) {\n      element.addEventListener(\"input\", this, { mozSystemGroup: true });\n    }\n  }\n\n  /**\n   * Populates result to the preview layers with given profile.\n   *\n   * @param {Array} elementIds\n   * @param {object} profile\n   *        A profile to be previewed with\n   */\n  previewFields(elementIds, profile) {\n    this.getAdaptedProfiles([profile]);\n\n    for (const fieldDetail of this.fieldDetails) {\n      const element = fieldDetail.element;\n\n      // Skip the field if it is null or readonly or disabled\n      if (\n        !elementIds.includes(fieldDetail.elementId) ||\n        !resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.isFieldAutofillable(element)\n      ) {\n        continue;\n      }\n\n      let value = this.getFilledValueFromProfile(fieldDetail, profile);\n      if (!value) {\n        this.changeFieldState(fieldDetail, FIELD_STATES.NORMAL);\n        continue;\n      }\n\n      if (resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.isTextControl(element)) {\n        if (element.value && element.value != element.defaultValue) {\n          // Skip the field if the user has already entered text and that text\n          // is not the site prefilled value.\n          continue;\n        }\n      } else if (HTMLSelectElement.isInstance(element)) {\n        // Unlike text input, select element is always previewed even if\n        // the option is already selected.\n        const option = this.matchSelectOptions(fieldDetail, profile);\n        value = option?.text ?? \"\";\n      } else {\n        continue;\n      }\n\n      element.previewValue = value?.toString().replaceAll(\"*\", \"•\");\n      this.changeFieldState(fieldDetail, FIELD_STATES.PREVIEW);\n    }\n  }\n\n  /**\n   * Processes form fields that can be autofilled, and populates them with the\n   * profile provided by backend.\n   *\n   * @param {string} focusedId\n   *        The id of the element that triggers autofilling.\n   * @param {Array} elementIds\n   *        An array of IDs for the elements that should be autofilled.\n   * @param {object} profile\n   *        The data profile containing the values to be autofilled into the form fields.\n   */\n  fillFields(focusedId, elementIds, profile) {\n    this.#isAutofillInProgress = true;\n    this.getAdaptedProfiles([profile]);\n\n    for (const fieldDetail of this.fieldDetails) {\n      const { element, elementId } = fieldDetail;\n\n      if (\n        !elementIds.includes(elementId) ||\n        !resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.isFieldAutofillable(element)\n      ) {\n        continue;\n      }\n\n      element.previewValue = \"\";\n\n      if (resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.isTextControl(element)) {\n        // Bug 1687679: Since profile appears to be presentation ready data, we need to utilize the \"x-formatted\" field\n        // that is generated when presentation ready data doesn't fit into the autofilling element.\n        // For example, autofilling expiration month into an input element will not work as expected if\n        // the month is less than 10, since the input is expected a zero-padded string.\n        // See Bug 1722941 for follow up.\n        const value = this.getFilledValueFromProfile(fieldDetail, profile);\n        if (!value) {\n          continue;\n        }\n\n        // For the focused input element, it will be filled with a valid value\n        // anyway.\n        // For the others, the fields should be only filled when their values are empty\n        // or their values are equal to the site prefill value\n        // or are the result of an earlier auto-fill.\n        if (\n          elementId == focusedId ||\n          !element.value ||\n          element.value == element.defaultValue ||\n          element.autofillState == FIELD_STATES.AUTO_FILLED\n        ) {\n          FormAutofillHandler.fillFieldValue(element, value);\n          this.changeFieldState(fieldDetail, FIELD_STATES.AUTO_FILLED);\n        }\n      } else if (HTMLSelectElement.isInstance(element)) {\n        const option = this.matchSelectOptions(fieldDetail, profile);\n        if (!option) {\n          continue;\n        }\n\n        // Do not change value or dispatch events if the option is already selected.\n        // Use case for multiple select is not considered here.\n        if (!option.selected) {\n          option.selected = true;\n          FormAutofillHandler.fillFieldValue(element, option.value);\n        }\n        // Autofill highlight appears regardless if value is changed or not\n        this.changeFieldState(fieldDetail, FIELD_STATES.AUTO_FILLED);\n      } else {\n        continue;\n      }\n    }\n\n    this.focusPreviouslyFocusedElement(focusedId);\n    this.#isAutofillInProgress = false;\n\n    this.registerFormChangeHandler();\n  }\n\n  registerFormChangeHandler() {\n    if (this.onChangeHandler) {\n      return;\n    }\n\n    this.log.debug(\"register change handler for filled form:\", this.form);\n\n    this.onChangeHandler = e => {\n      if (!e.isTrusted) {\n        return;\n      }\n      if (e.type == \"reset\") {\n        for (const fieldDetail of this.fieldDetails) {\n          const element = fieldDetail.element;\n          element.removeEventListener(\"input\", this, { mozSystemGroup: true });\n          this.changeFieldState(fieldDetail, FIELD_STATES.NORMAL);\n        }\n      }\n\n      // Unregister listeners once no field is in AUTO_FILLED state.\n      if (\n        this.fieldDetails.every(\n          detail => detail.element.autofillState != FIELD_STATES.AUTO_FILLED\n        )\n      ) {\n        this.form.rootElement.removeEventListener(\n          \"input\",\n          this.onChangeHandler,\n          {\n            mozSystemGroup: true,\n          }\n        );\n        this.form.rootElement.removeEventListener(\n          \"reset\",\n          this.onChangeHandler,\n          {\n            mozSystemGroup: true,\n          }\n        );\n        this.onChangeHandler = null;\n      }\n    };\n\n    // Handle the highlight style resetting caused by user's correction afterward.\n    this.form.rootElement.addEventListener(\"input\", this.onChangeHandler, {\n      mozSystemGroup: true,\n    });\n    this.form.rootElement.addEventListener(\"reset\", this.onChangeHandler, {\n      mozSystemGroup: true,\n    });\n  }\n\n  /**\n   * Listens for dynamic form changes by setting up two observer types:\n   *      1. IntersectionObserver(s) that observe(s) intersections between\n   *         (in-)visibile elements and an intersection target (the form/document of interest).\n   *         (see this.setUpElementVisibilityObserver)\n   *      2. MutationsObserver that observes child node additions and removals\n   *         in the form/document of interest (see this.setUpNodesObserver)\n   * If a form change is observed, a \"form-changed\" event gets dispatched transfering\n   * the changed fields and the reason for the form change (see FORM_CHANGE_REASON).\n   */\n  setUpDynamicFormChangeObserver() {\n    if (!resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.detectDynamicFormChanges) {\n      return;\n    }\n\n    this.setUpElementVisibilityObserver();\n    this.setUpFormNodesMutationObserver();\n  }\n\n  /**\n   * Iterates through handler.form.elements and sets up an IntersectionObserver for each (in-)visible\n   * address/cc input element that is not observed yet (see handler.#visibilityStateObserverByElement).\n   * The observer notifies of intersections between the (in-)visible element and the intersection target (handler.form).\n   * This is the case if e.g. a visible element becomes invisible or an invisible element becomes visible.\n   * If a visibility state change is observed, a \"form-changes\" event is dispatched.\n   */\n  setUpElementVisibilityObserver() {\n    const VISIBILITY_STATE = {\n      VISIBLE: true,\n      INVISIBLE: false,\n    };\n\n    // Setting up an observer for an element's changing visibility state\n    const setUpIntersectionObserver = (element, visibilityState) => {\n      const visibilityStateObserver = new this.window.IntersectionObserver(\n        (entries, observer) => {\n          entries.forEach(entry => {\n            if (entry.isIntersecting != visibilityState) {\n              return;\n            }\n            if (\n              entry.target.checkVisibility({\n                checkOpacity: true,\n                checkVisibilityCSS: true,\n              }) != visibilityState\n            ) {\n              // The observer notified that the element reached the intersection threshold\n              // (meaning the element's visibility state changed to either visible or invisible.\n              // But checkVisibility doesn't confirm that.\n              // For these mismatches we disconnect the observer to avoid an infinite loop.\n              observer.disconnect();\n              return;\n            }\n            const changes = {};\n            const reason =\n              visibilityState == VISIBILITY_STATE.VISIBLE\n                ? FORM_CHANGE_REASON.ELEMENT_VISIBLE\n                : FORM_CHANGE_REASON.ELEMENT_INVISIBLE;\n            changes[reason] = [entry.target];\n\n            const formChangedEvent = new CustomEvent(\"form-changed\", {\n              detail: {\n                form: this.form.rootElement,\n                changes,\n              },\n              bubbles: true,\n            });\n            this.form.ownerDocument.dispatchEvent(formChangedEvent);\n\n            this.clearVisibilityStateObserverByElement(element);\n            observer.disconnect();\n          });\n        },\n        {\n          root: this.form.rootElement,\n          // intersection reatio between 0.0 (invisible element) and 1.0 (visible element)\n          threshold: visibilityState === VISIBILITY_STATE.INVISIBLE ? 0 : 1,\n        }\n      );\n      visibilityStateObserver.observe(element);\n      this.setVisibilityStateObserverByElement(\n        element,\n        visibilityStateObserver\n      );\n    };\n\n    for (let element of this.form.elements) {\n      if (!resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.isCreditCardOrAddressFieldType(element)) {\n        continue;\n      }\n      if (this.isVisiblityStateObserverSetUpByElement(element)) {\n        continue;\n      }\n      if (resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.isFieldVisible(element)) {\n        // Setting up an observer that notifies when the visible element becomes invisible\n        setUpIntersectionObserver(element, VISIBILITY_STATE.INVISIBLE);\n      } else {\n        // Setting up an observer that notifies when the invisible element becomes visible\n        setUpIntersectionObserver(element, VISIBILITY_STATE.VISIBLE);\n      }\n    }\n  }\n\n  /**\n   * Sets up a MutationObserver for the form or document (if form-less) of interest\n   * in order to be notified about child nodes additions or removals.\n   * If any of the added/removed nodes (including the nodes in the node's subtree)\n   * are of an address of cc type, a \"form-changed\" event is dispatched.\n   */\n  setUpFormNodesMutationObserver() {\n    if (this.#isObservingFormMutations) {\n      return;\n    }\n\n    const mutationObserver = new this.window.MutationObserver(\n      (mutations, _) => {\n        const collectMutatedNodes = mutations => {\n          let removedNodes = [];\n          let addedNodes = [];\n          mutations.forEach(mutation => {\n            if (mutation.type == \"childList\") {\n              if (mutation.addedNodes.length) {\n                addedNodes.push(...mutation.addedNodes);\n              } else if (mutation.removedNodes.length) {\n                removedNodes.push(...mutation.removedNodes);\n              }\n            }\n          });\n          return [addedNodes, removedNodes];\n        };\n\n        const collectAllSubtreeElements = node => {\n          if (!node.childNodes.length) {\n            return node;\n          }\n          return Array.from(node.childNodes).flatMap(childNode =>\n            collectAllSubtreeElements(childNode)\n          );\n        };\n\n        const getCCAndAddressElements = nodes => {\n          return nodes\n            .flatMap(node => collectAllSubtreeElements(node))\n            .filter(element =>\n              resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.isCreditCardOrAddressFieldType(element)\n            );\n        };\n\n        let [addedNodes, removedNodes] = collectMutatedNodes(mutations);\n        let relevantAddedElements = getCCAndAddressElements(addedNodes);\n        // We only care about removed elements that might change the\n        // currently detected fieldDetails\n        let relevantRemovedElements = getCCAndAddressElements(\n          removedNodes\n        ).filter(\n          element =>\n            this.#fieldDetails && !!this.getFieldDetailByElement(element)\n        );\n\n        if (!relevantRemovedElements.length && !relevantAddedElements.length) {\n          return;\n        }\n\n        let changes = {};\n        if (relevantRemovedElements.length) {\n          changes[FORM_CHANGE_REASON.NODES_REMOVED] = relevantRemovedElements;\n        }\n        if (relevantAddedElements.length) {\n          changes[FORM_CHANGE_REASON.NODES_ADDED] = relevantAddedElements;\n        }\n\n        const formChangedEvent = new CustomEvent(\"form-changed\", {\n          detail: {\n            form: this.form.rootElement,\n            changes,\n          },\n          bubbles: true,\n        });\n        this.form.ownerDocument.dispatchEvent(formChangedEvent);\n      }\n    );\n    const config = { childList: true, subtree: true };\n    this.#formMutationObserver = mutationObserver;\n    this.#formMutationObserver.observe(this.form.rootElement, config);\n    this.#isObservingFormMutations = true;\n  }\n\n  /**\n   * After the form was submitted, disconnect all IntersectionObserver that\n   * are still observing form's elements and disconnect the MutationsOberver\n   * that is observing the form.\n   */\n  clearFormChangeObservers() {\n    if (!this.#isObservingFormMutations) {\n      return;\n    }\n    // Disconnect intersection observers\n    for (let element of this.form.elements) {\n      this.clearVisibilityStateObserverByElement(element);\n    }\n    // Disconnect mutation observer\n    this.#formMutationObserver.disconnect();\n    this.#isObservingFormMutations = false;\n  }\n\n  computeFillingValue(fieldDetail) {\n    const element = fieldDetail.element;\n    if (!element) {\n      return null;\n    }\n\n    let value = element.value.trim();\n    switch (fieldDetail.fieldName) {\n      case \"address-level1\":\n        if (HTMLSelectElement.isInstance(element)) {\n          // Don't save the record when the option value is empty *OR* there\n          // are multiple options being selected. The empty option is usually\n          // assumed to be default along with a meaningless text to users.\n          if (!value || element.selectedOptions.length != 1) {\n            // Keep the property and preserve more information for address updating\n            value = \"\";\n          } else {\n            const text = element.selectedOptions[0].text.trim();\n            value =\n              resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.getAbbreviatedSubregionName([value, text]) ||\n              text;\n          }\n        }\n        break;\n      case \"country\":\n        // This is a temporary fix. Ideally we should have either case-insensitive comparison of country codes\n        // or handle this elsewhere see Bug 1889234 for more context.\n        value = value.toUpperCase();\n        break;\n      case \"cc-type\":\n        if (\n          HTMLSelectElement.isInstance(element) &&\n          !lazy.CreditCard.isValidNetwork(value)\n        ) {\n          // Don't save the record when the option value is empty *OR* there\n          // are multiple options being selected. The empty option is usually\n          // assumed to be default along with a meaningless text to users.\n          if (value && element.selectedOptions.length == 1) {\n            const selectedOption = element.selectedOptions[0];\n            const networkType =\n              lazy.CreditCard.getNetworkFromName(selectedOption.text) ??\n              lazy.CreditCard.getNetworkFromName(selectedOption.value);\n            if (networkType) {\n              value = networkType;\n            }\n          }\n        }\n        break;\n    }\n\n    return value;\n  }\n\n  /*\n   * Apply both address and credit card related transformers.\n   *\n   * @param {Object} profile\n   *        A profile for adjusting credit card related value.\n   * @override\n   */\n  applyTransformers(profile) {\n    this.addressTransformer(profile);\n    this.telTransformer(profile);\n    this.creditCardExpiryDateTransformer(profile);\n    this.creditCardExpMonthAndYearTransformer(profile);\n    this.creditCardNameTransformer(profile);\n    this.adaptFieldMaxLength(profile);\n  }\n\n  getAdaptedProfiles(originalProfiles) {\n    for (let profile of originalProfiles) {\n      this.applyTransformers(profile);\n    }\n    return originalProfiles;\n  }\n\n  /**\n   * Match the select option for a field if we autofill with the given profile.\n   * This function caches the matching result in the `#matchingSelectionOption`\n   * variable.\n   *\n   * @param {FieldDetail} fieldDetail\n   *        The field information of the matching element.\n   * @param {object} profile\n   *        The profile used for autofill.\n   *\n   * @returns {Option}\n   *        The matched option, or undefined if no matching option is found.\n   */\n  matchSelectOptions(fieldDetail, profile) {\n    if (!this.#matchingSelectOption) {\n      this.#matchingSelectOption = new WeakMap();\n    }\n\n    const { element, fieldName } = fieldDetail;\n    if (!HTMLSelectElement.isInstance(element)) {\n      return undefined;\n    }\n\n    const cache = this.#matchingSelectOption.get(element) || {};\n    const value = profile[fieldName];\n\n    let option = cache[value]?.deref();\n    if (!option) {\n      option = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.findSelectOption(element, profile, fieldName);\n\n      if (option) {\n        cache[value] = new WeakRef(option);\n        this.#matchingSelectOption.set(element, cache);\n      } else if (cache[value]) {\n        delete cache[value];\n        this.#matchingSelectOption.set(element, cache);\n      }\n    }\n\n    return option;\n  }\n\n  adaptFieldMaxLength(profile) {\n    for (let key in profile) {\n      let detail = this.getFieldDetailByName(key);\n      if (!detail || detail.part) {\n        continue;\n      }\n\n      let element = detail.element;\n      if (!element) {\n        continue;\n      }\n\n      let maxLength = element.maxLength;\n      if (\n        maxLength === undefined ||\n        maxLength < 0 ||\n        profile[key].toString().length <= maxLength\n      ) {\n        continue;\n      }\n\n      if (maxLength) {\n        switch (typeof profile[key]) {\n          case \"string\":\n            // If this is an expiration field and our previous\n            // adaptations haven't resulted in a string that is\n            // short enough to satisfy the field length, and the\n            // field is constrained to a length of 4 or 5, then we\n            // assume it is intended to hold an expiration of the\n            // form \"MMYY\" or \"MM/YY\".\n            if (key == \"cc-exp\" && (maxLength == 4 || maxLength == 5)) {\n              const month2Digits = (\n                \"0\" + profile[\"cc-exp-month\"].toString()\n              ).slice(-2);\n              const year2Digits = profile[\"cc-exp-year\"].toString().slice(-2);\n              const separator = maxLength == 5 ? \"/\" : \"\";\n              profile[key] = `${month2Digits}${separator}${year2Digits}`;\n            } else if (key == \"cc-number\") {\n              // We want to show the last four digits of credit card so that\n              // the masked credit card previews correctly and appears correctly\n              // in the autocomplete menu\n              profile[key] = profile[key].substr(\n                profile[key].length - maxLength\n              );\n            } else {\n              profile[key] = profile[key].substr(0, maxLength);\n            }\n            break;\n          case \"number\":\n            // There's no way to truncate a number smaller than a\n            // single digit.\n            if (maxLength < 1) {\n              maxLength = 1;\n            }\n            // The only numbers we store are expiration month/year,\n            // and if they truncate, we want the final digits, not\n            // the initial ones.\n            profile[key] = profile[key] % Math.pow(10, maxLength);\n            break;\n          default:\n        }\n      } else {\n        delete profile[key];\n        delete profile[`${key}-formatted`];\n      }\n    }\n  }\n\n  /**\n   * Handles credit card expiry date transformation when\n   * the expiry date exists in a cc-exp field.\n   *\n   * @param {object} profile\n   */\n  creditCardExpiryDateTransformer(profile) {\n    if (!profile[\"cc-exp\"]) {\n      return;\n    }\n\n    const element = this.getFieldDetailByName(\"cc-exp\")?.element;\n    if (!element) {\n      return;\n    }\n\n    function updateExpiry(_string, _month, _year) {\n      // Bug 1687681: This is a short term fix to other locales having\n      // different characters to represent year.\n      // - FR locales may use \"A\" to represent year.\n      // - DE locales may use \"J\" to represent year.\n      // - PL locales may use \"R\" to represent year.\n      // This approach will not scale well and should be investigated in a follow up bug.\n      const monthChars = \"m\";\n      const yearChars = \"yy|aa|jj|rr\";\n      const expiryDateFormatRegex = (firstChars, secondChars) =>\n        new RegExp(\n          \"(?:\\\\b|^)((?:[\" +\n            firstChars +\n            \"]{2}){1,2})\\\\s*([\\\\-/])\\\\s*((?:[\" +\n            secondChars +\n            \"]{2}){1,2})(?:\\\\b|$)\",\n          \"i\"\n        );\n\n      // If the month first check finds a result, where placeholder is \"mm - yyyy\",\n      // the result will be structured as such: [\"mm - yyyy\", \"mm\", \"-\", \"yyyy\"]\n      let result = expiryDateFormatRegex(monthChars, yearChars).exec(_string);\n      if (result) {\n        return (\n          _month.padStart(result[1].length, \"0\") +\n          result[2] +\n          _year.substr(-1 * result[3].length)\n        );\n      }\n\n      // If the year first check finds a result, where placeholder is \"yyyy mm\",\n      // the result will be structured as such: [\"yyyy mm\", \"yyyy\", \" \", \"mm\"]\n      result = expiryDateFormatRegex(yearChars, monthChars).exec(_string);\n      if (result) {\n        return (\n          _year.substr(-1 * result[1].length) +\n          result[2] +\n          _month.padStart(result[3].length, \"0\")\n        );\n      }\n      return null;\n    }\n\n    let newExpiryString = null;\n    const month = profile[\"cc-exp-month\"].toString();\n    const year = profile[\"cc-exp-year\"].toString();\n    if (element.localName == \"input\") {\n      // Use the placeholder or label to determine the expiry string format.\n      const possibleExpiryStrings = [];\n      if (element.placeholder) {\n        possibleExpiryStrings.push(element.placeholder);\n      }\n      const labels = lazy.LabelUtils.findLabelElements(element);\n      if (labels) {\n        // Not consider multiple lable for now.\n        possibleExpiryStrings.push(element.labels[0]?.textContent);\n      }\n      if (element.previousElementSibling?.localName == \"label\") {\n        possibleExpiryStrings.push(element.previousElementSibling.textContent);\n      }\n\n      possibleExpiryStrings.some(string => {\n        newExpiryString = updateExpiry(string, month, year);\n        return !!newExpiryString;\n      });\n    }\n\n    // Bug 1688576: Change YYYY-MM to MM/YYYY since MM/YYYY is the\n    // preferred presentation format for credit card expiry dates.\n    profile[\"cc-exp\"] = newExpiryString ?? `${month.padStart(2, \"0\")}/${year}`;\n  }\n\n  /**\n   * Handles credit card expiry date transformation when the expiry date exists in\n   * the separate cc-exp-month and cc-exp-year fields\n   *\n   * @param {object} profile\n   */\n  creditCardExpMonthAndYearTransformer(profile) {\n    const getInputElementByField = (field, self) => {\n      if (!field) {\n        return null;\n      }\n      const detail = self.getFieldDetailByName(field);\n      if (!detail) {\n        return null;\n      }\n      const element = detail.element;\n      return element.localName === \"input\" ? element : null;\n    };\n    const month = getInputElementByField(\"cc-exp-month\", this);\n    if (month) {\n      // Transform the expiry month to MM since this is a common format needed for filling.\n      profile[\"cc-exp-month-formatted\"] = profile[\"cc-exp-month\"]\n        ?.toString()\n        .padStart(2, \"0\");\n    }\n    const year = getInputElementByField(\"cc-exp-year\", this);\n    // If the expiration year element is an input,\n    // then we examine any placeholder to see if we should format the expiration year\n    // as a zero padded string in order to autofill correctly.\n    if (year) {\n      const placeholder = year.placeholder;\n\n      // Checks for 'YY'|'AA'|'JJ'|'RR' placeholder and converts the year to a two digit string using the last two digits.\n      const result = /\\b(yy|aa|jj|rr)\\b/i.test(placeholder);\n      if (result) {\n        profile[\"cc-exp-year-formatted\"] = profile[\"cc-exp-year\"]\n          ?.toString()\n          .substring(2);\n      }\n    }\n  }\n\n  /**\n   * Handles credit card name transformation when the name exists in\n   * the separate cc-given-name, cc-middle-name, and cc-family name fields\n   *\n   * @param {object} profile\n   */\n  creditCardNameTransformer(profile) {\n    const name = profile[\"cc-name\"];\n    if (!name) {\n      return;\n    }\n\n    const given = this.getFieldDetailByName(\"cc-given-name\");\n    const middle = this.getFieldDetailByName(\"cc-middle-name\");\n    const family = this.getFieldDetailByName(\"cc-family-name\");\n    if (given || middle || family) {\n      const nameParts = lazy.FormAutofillNameUtils.splitName(name);\n      if (given && nameParts.given) {\n        profile[\"cc-given-name\"] = nameParts.given;\n      }\n      if (middle && nameParts.middle) {\n        profile[\"cc-middle-name\"] = nameParts.middle;\n      }\n      if (family && nameParts.family) {\n        profile[\"cc-family-name\"] = nameParts.family;\n      }\n    }\n  }\n\n  addressTransformer(profile) {\n    if (profile[\"street-address\"]) {\n      // \"-moz-street-address-one-line\" is used by the labels in\n      // ProfileAutoCompleteResult.\n      profile[\"-moz-street-address-one-line\"] =\n        resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.toOneLineAddress(profile[\"street-address\"]);\n      let streetAddressDetail = this.getFieldDetailByName(\"street-address\");\n      if (\n        streetAddressDetail &&\n        resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.isTextControl(streetAddressDetail.element)\n      ) {\n        profile[\"street-address\"] = profile[\"-moz-street-address-one-line\"];\n      }\n\n      let waitForConcat = [];\n      for (let f of [\"address-line3\", \"address-line2\", \"address-line1\"]) {\n        waitForConcat.unshift(profile[f]);\n        if (this.getFieldDetailByName(f)) {\n          if (waitForConcat.length > 1) {\n            profile[f] = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.toOneLineAddress(waitForConcat);\n          }\n          waitForConcat = [];\n        }\n      }\n    }\n\n    // If a house number field exists, split the address up into house number\n    // and street name.\n    if (this.getFieldDetailByName(\"address-housenumber\")) {\n      let address = lazy.AddressParser.parseStreetAddress(\n        profile[\"street-address\"]\n      );\n      if (address) {\n        profile[\"address-housenumber\"] = address.street_number;\n        let field = this.getFieldDetailByName(\"address-line1\")\n          ? \"address-line1\"\n          : \"street-address\";\n        profile[field] = address.street_name;\n      }\n    }\n  }\n\n  /**\n   * Replace tel with tel-national if tel violates the input element's\n   * restriction.\n   *\n   * @param {object} profile\n   *        A profile to be converted.\n   */\n  telTransformer(profile) {\n    if (!profile.tel || !profile[\"tel-national\"]) {\n      return;\n    }\n\n    let detail = this.getFieldDetailByName(\"tel\");\n    if (!detail) {\n      return;\n    }\n\n    let element = detail.element;\n    let _pattern;\n    let testPattern = str => {\n      if (!_pattern) {\n        // The pattern has to match the entire value.\n        _pattern = new RegExp(\"^(?:\" + element.pattern + \")$\", \"u\");\n      }\n      return _pattern.test(str);\n    };\n    if (element.pattern) {\n      if (testPattern(profile.tel)) {\n        return;\n      }\n    } else if (element.maxLength) {\n      if (\n        detail.reason == \"autocomplete\" &&\n        profile.tel.length <= element.maxLength\n      ) {\n        return;\n      }\n    }\n\n    if (detail.reason != \"autocomplete\") {\n      // Since we only target people living in US and using en-US websites in\n      // MVP, it makes more sense to fill `tel-national` instead of `tel`\n      // if the field is identified by heuristics and no other clues to\n      // determine which one is better.\n      // TODO: [Bug 1407545] This should be improved once more countries are\n      // supported.\n      profile.tel = profile[\"tel-national\"];\n    } else if (element.pattern) {\n      if (testPattern(profile[\"tel-national\"])) {\n        profile.tel = profile[\"tel-national\"];\n      }\n    } else if (element.maxLength) {\n      if (profile[\"tel-national\"].length <= element.maxLength) {\n        profile.tel = profile[\"tel-national\"];\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {object} fieldDetail A fieldDetail of the related element.\n   * @param {object} profile The profile to fill.\n   * @returns {string} The value to fill for the given field.\n   */\n  getFilledValueFromProfile(fieldDetail, profile) {\n    let value =\n      profile[`${fieldDetail.fieldName}-formatted`] ||\n      profile[fieldDetail.fieldName];\n\n    if (fieldDetail.fieldName == \"cc-number\" && fieldDetail.part != null) {\n      const part = fieldDetail.part;\n      return value.slice((part - 1) * 4, part * 4);\n    }\n    return value;\n  }\n  /**\n   * Fills the provided element with the specified value.\n   *\n   * @param {HTMLElement} element - The form field element to be filled.\n   * @param {string} value - The value to be filled into the form field.\n   */\n  static fillFieldValue(element, value) {\n    if (resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.focusOnAutofill) {\n      element.focus({ preventScroll: true });\n    }\n    if (resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.isTextControl(element)) {\n      element.setUserInput(value);\n    } else if (HTMLSelectElement.isInstance(element)) {\n      // Set the value of the select element so that web event handlers can react accordingly\n      element.value = value;\n      element.dispatchEvent(\n        new element.ownerGlobal.Event(\"input\", { bubbles: true })\n      );\n      element.dispatchEvent(\n        new element.ownerGlobal.Event(\"change\", { bubbles: true })\n      );\n    }\n  }\n\n  clearPreviewedFields(elementIds) {\n    for (const elementId of elementIds) {\n      const fieldDetail = this.getFieldDetailByElementId(elementId);\n      const element = fieldDetail?.element;\n      if (!element) {\n        this.log.warn(fieldDetail.fieldName, \"is unreachable\");\n        continue;\n      }\n\n      element.previewValue = \"\";\n      if (element.autofillState == FIELD_STATES.AUTO_FILLED) {\n        continue;\n      }\n      this.changeFieldState(fieldDetail, FIELD_STATES.NORMAL);\n    }\n  }\n\n  clearFilledFields(focusedId, elementIds) {\n    this.#isAutofillInProgress = true;\n    const fieldDetails = elementIds.map(id =>\n      this.getFieldDetailByElementId(id)\n    );\n    for (const fieldDetail of fieldDetails) {\n      const element = fieldDetail?.element;\n      if (!element) {\n        this.log.warn(fieldDetail?.fieldName, \"is unreachable\");\n        continue;\n      }\n\n      if (element.autofillState == FIELD_STATES.AUTO_FILLED) {\n        let value = \"\";\n        if (HTMLSelectElement.isInstance(element)) {\n          if (!element.options.length) {\n            continue;\n          }\n          // Resets a <select> element to its selected option or the first\n          // option if there is none selected.\n          const selected = [...element.options].find(option =>\n            option.hasAttribute(\"selected\")\n          );\n          value = selected ? selected.value : element.options[0].value;\n        }\n        FormAutofillHandler.fillFieldValue(element, value);\n        this.changeFieldState(fieldDetail, FIELD_STATES.NORMAL);\n      }\n    }\n\n    this.focusPreviouslyFocusedElement(focusedId);\n    this.#isAutofillInProgress = false;\n  }\n\n  focusPreviouslyFocusedElement(focusedId) {\n    let focusedElement = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.getElementByIdentifier(focusedId);\n    if (resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.focusOnAutofill && focusedElement) {\n      focusedElement.focus({ preventScroll: true });\n    }\n  }\n\n  /**\n   * Return the record that is keyed by element id and value is the normalized value\n   * done by computeFillingValue\n   *\n   * @returns {object} An object keyed by element id, and the value is\n   *                   an object that includes the following properties:\n   * filledState: The autofill state of the element\n   * filledvalue: The value of the element\n   */\n  collectFormFilledData() {\n    const filledData = new Map();\n\n    for (const fieldDetail of this.fieldDetails) {\n      const element = fieldDetail.element;\n      filledData.set(fieldDetail.elementId, {\n        filledState: element.autofillState,\n        filledValue: this.computeFillingValue(fieldDetail),\n      });\n    }\n    return filledData;\n  }\n\n  isFieldAutofillable(fieldDetail, profile) {\n    if (resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.isTextControl(fieldDetail.element)) {\n      return !!profile[fieldDetail.fieldName];\n    }\n    return !!this.matchSelectOptions(fieldDetail, profile);\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs":
/*!****************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormAutofillHeuristics: () => (/* binding */ FormAutofillHeuristics),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://autofill/FormAutofill.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_HeuristicsRegExp_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/HeuristicsRegExp.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  CreditCard: \"resource://gre/modules/CreditCard.sys.mjs\",\n  CreditCardRulesets: \"resource://gre/modules/shared/CreditCardRuleset.sys.mjs\",\n  FieldDetail: \"resource://gre/modules/shared/FieldScanner.sys.mjs\",\n  FieldScanner: \"resource://gre/modules/shared/FieldScanner.sys.mjs\",\n  FormAutofillUtils: \"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\",\n  LabelUtils: \"resource://gre/modules/shared/LabelUtils.sys.mjs\",\n  MLAutofill: \"resource://autofill/MLAutofill.sys.mjs\",\n});\n\n/**\n * To help us classify sections that can appear only N times in a row.\n * For example, the only time multiple cc-number fields are valid is when\n * there are four of these fields in a row.\n * Otherwise, multiple cc-number fields should be in separate sections.\n */\nconst MULTI_N_FIELD_NAMES = {\n  \"cc-number\": 4,\n};\n\nconst CC_TYPE = 1;\nconst ADDR_TYPE = 2;\n\n/**\n * Returns the autocomplete information of fields according to heuristics.\n */\nconst FormAutofillHeuristics = {\n  RULES: resource_gre_modules_shared_HeuristicsRegExp_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.HeuristicsRegExp.getRules(),\n  LABEL_RULES: resource_gre_modules_shared_HeuristicsRegExp_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.HeuristicsRegExp.getLabelRules(),\n\n  CREDIT_CARD_FIELDNAMES: [],\n  ADDRESS_FIELDNAMES: [],\n  /**\n   * Try to find a contiguous sub-array within an array.\n   *\n   * @param {Array} array\n   * @param {Array} subArray\n   *\n   * @returns {boolean}\n   *          Return whether subArray was found within the array or not.\n   */\n  _matchContiguousSubArray(array, subArray) {\n    return array.some((elm, i) =>\n      subArray.every((sElem, j) => sElem == array[i + j])\n    );\n  },\n\n  /**\n   * Try to find the field that is look like a month select.\n   *\n   * @param {DOMElement} element\n   * @returns {boolean}\n   *          Return true if we observe the trait of month select in\n   *          the current element.\n   */\n  _isExpirationMonthLikely(element) {\n    if (!HTMLSelectElement.isInstance(element)) {\n      return false;\n    }\n\n    const options = [...element.options];\n    const desiredValues = Array(12)\n      .fill(1)\n      .map((v, i) => v + i);\n\n    // The number of month options shouldn't be less than 12 or larger than 13\n    // including the default option.\n    if (options.length < 12 || options.length > 13) {\n      return false;\n    }\n\n    return (\n      this._matchContiguousSubArray(\n        options.map(e => +e.value),\n        desiredValues\n      ) ||\n      this._matchContiguousSubArray(\n        options.map(e => +e.label),\n        desiredValues\n      )\n    );\n  },\n\n  /**\n   * Try to find the field that is look like a year select.\n   *\n   * @param {DOMElement} element\n   * @returns {boolean}\n   *          Return true if we observe the trait of year select in\n   *          the current element.\n   */\n  _isExpirationYearLikely(element) {\n    if (!HTMLSelectElement.isInstance(element)) {\n      return false;\n    }\n\n    const options = [...element.options];\n    // A normal expiration year select should contain at least the last three years\n    // in the list.\n    const curYear = new Date().getFullYear();\n    const desiredValues = Array(3)\n      .fill(0)\n      .map((v, i) => v + curYear + i);\n\n    return (\n      this._matchContiguousSubArray(\n        options.map(e => +e.value),\n        desiredValues\n      ) ||\n      this._matchContiguousSubArray(\n        options.map(e => +e.label),\n        desiredValues\n      )\n    );\n  },\n\n  /**\n   * This function handles the case when two adjacent fields are incorrectly\n   * identified with the same field name. Currently, only given-name and\n   * family-name are handled as possible errors.\n   *\n   * @param {FieldScanner} scanner\n   *        The current parsing status for all elements\n   * @returns {boolean}\n   *        Return true if any field is recognized and updated, otherwise false.\n   */\n  _parseNameFieldsContent(scanner, fieldDetail) {\n    const TARGET_FIELDS = [\"given-name\", \"family-name\"];\n    if (!TARGET_FIELDS.includes(fieldDetail.fieldName)) {\n      return false;\n    }\n\n    let idx = scanner.parsingIndex;\n    const detailBefore = scanner.getFieldDetailByIndex(idx - 1);\n    if (fieldDetail.fieldName == detailBefore?.fieldName) {\n      let otherFieldName =\n        fieldDetail.fieldName == TARGET_FIELDS[0]\n          ? TARGET_FIELDS[1]\n          : TARGET_FIELDS[0];\n\n      // If the second field matches both field names, or both fields match\n      // both field names, then we change the second field, since the author\n      // was more likely to miscopy the second field from the first. However,\n      // if the earlier field only matches, then we change the first field.\n      if (\n        this._findMatchedFieldNames(fieldDetail.element, [otherFieldName])\n          .length\n      ) {\n        scanner.updateFieldName(idx, otherFieldName);\n      } else if (\n        this._findMatchedFieldNames(detailBefore.element, [otherFieldName])\n          .length\n      ) {\n        scanner.updateFieldName(idx - 1, otherFieldName);\n      }\n\n      scanner.parsingIndex++;\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * In some languages such French (nom) and German (Name), name can mean either family name or\n   * full name in a form, depending on the context. We want to be sure that if \"name\" is\n   * detected in the context of \"family-name\" or \"given-name\", it is updated accordingly.\n   *\n   * Look for \"given-name\", \"family-name\", and \"name\" fields. If any two of those fields are detected\n   * and one of them is \"name\", then replace \"name\" with \"family-name\" if \"name\" is accompanied by\n   * \"given-name\" or vise-versa.\n   *\n   * @param {FieldScanner} scanner\n   *        The current parsing status for all elements\n   * @returns {boolean}\n   *        Return true if any field is recognized and updated, otherwise false.\n   */\n  _parseNameFields(scanner, fieldDetail) {\n    const TARGET_FIELDS = [\"name\", \"given-name\", \"family-name\"];\n\n    if (!TARGET_FIELDS.includes(fieldDetail.fieldName)) {\n      return false;\n    }\n\n    const fields = [];\n    let nameIndex = -1;\n\n    for (let idx = scanner.parsingIndex; ; idx++) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n      if (!TARGET_FIELDS.includes(detail?.fieldName)) {\n        break;\n      }\n      if (detail.fieldName === \"name\") {\n        nameIndex = idx;\n      }\n      fields.push(detail);\n    }\n\n    if (nameIndex != -1 && fields.length == 2) {\n      //if name is detected and the other of the two fields detected is 'given-name'\n      //then update name to 'name' to 'family-name'\n      if (\n        fields[0].fieldName == \"given-name\" ||\n        fields[1].fieldName == \"given-name\"\n      ) {\n        scanner.updateFieldName(nameIndex, \"family-name\");\n        //if name is detected and the other of the two fields detected is 'family-name'\n        //then update name to 'name' to 'given-name'\n      } else if (\n        fields[0].fieldName == \"family-name\" ||\n        fields[1].fieldName == \"family-name\"\n      ) {\n        scanner.updateFieldName(nameIndex, \"given-name\");\n      } else {\n        return false;\n      }\n\n      scanner.parsingIndex += fields.length;\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * Try to match the telephone related fields to the grammar\n   * list to see if there is any valid telephone set and correct their\n   * field names.\n   *\n   * @param {FieldScanner} scanner\n   *        The current parsing status for all elements\n   * @returns {boolean}\n   *          Return true if there is any field can be recognized in the parser,\n   *          otherwise false.\n   */\n  _parsePhoneFields(scanner, _fieldDetail) {\n    let matchingResult;\n    const GRAMMARS = this.PHONE_FIELD_GRAMMARS;\n\n    function isGrammarSeparator(index) {\n      return !GRAMMARS[index][0];\n    }\n\n    const savedIndex = scanner.parsingIndex;\n    for (let ruleFrom = 0; ruleFrom < GRAMMARS.length; ) {\n      const detailStart = scanner.parsingIndex;\n      let ruleTo = ruleFrom;\n      for (let count = 0; ruleTo < GRAMMARS.length; ruleTo++, count++) {\n        // Bail out when reaching the end of the current set of grammars\n        // or there are no more elements to parse\n        if (\n          isGrammarSeparator(ruleTo) ||\n          !scanner.elementExisting(detailStart + count)\n        ) {\n          break;\n        }\n\n        const [category, , length] = GRAMMARS[ruleTo];\n        const detail = scanner.getFieldDetailByIndex(detailStart + count);\n\n        // If the field is not what this grammar rule is interested in, skip processing.\n        if (\n          !detail ||\n          detail.fieldName != category ||\n          detail.reason == \"autocomplete\"\n        ) {\n          break;\n        }\n\n        const element = detail.element;\n        if (length && (!element.maxLength || length < element.maxLength)) {\n          break;\n        }\n      }\n\n      // if we reach the grammar separator, that means all the previous rules are matched.\n      // Set the matchingResult so we update field names accordingly.\n      if (isGrammarSeparator(ruleTo)) {\n        matchingResult = { ruleFrom, ruleTo };\n        break;\n      }\n\n      // Fast forward to the next rule set.\n      for (; ruleFrom < GRAMMARS.length; ) {\n        if (isGrammarSeparator(ruleFrom++)) {\n          break;\n        }\n      }\n    }\n\n    if (matchingResult) {\n      const { ruleFrom, ruleTo } = matchingResult;\n      for (let i = ruleFrom; i < ruleTo; i++) {\n        scanner.updateFieldName(scanner.parsingIndex, GRAMMARS[i][1]);\n        scanner.parsingIndex++;\n      }\n    }\n\n    // If the previous parsed field is a \"tel\" field, run heuristic to see\n    // if the current field is a \"tel-extension\" field\n    const field = scanner.getFieldDetailByIndex(scanner.parsingIndex);\n    if (field && field.reason != \"autocomplete\") {\n      const prev = scanner.getFieldDetailByIndex(scanner.parsingIndex - 1);\n      if (\n        prev &&\n        lazy.FormAutofillUtils.getCategoryFromFieldName(prev.fieldName) == \"tel\"\n      ) {\n        const regExpTelExtension = new RegExp(\n          \"\\\\bext|ext\\\\b|extension|ramal\", // pt-BR, pt-PT\n          \"iug\"\n        );\n        if (this._matchRegexp(field.element, regExpTelExtension)) {\n          scanner.updateFieldName(scanner.parsingIndex, \"tel-extension\");\n          scanner.parsingIndex++;\n        }\n      }\n    }\n    return savedIndex != scanner.parsingIndex;\n  },\n\n  /**\n   * If this is a house number field and there is no address-line1 or\n   * street-address field, change the house number field to address-line1.\n   *\n   * @param {FieldScanner} scanner\n   *        The current parsing status for all elements\n   * @returns {boolean}\n   *          Return true if there is any field can be recognized in the parser,\n   *          otherwise false.\n   */\n  _parseHouseNumberFields(scanner, fieldDetail) {\n    if (fieldDetail?.fieldName == \"address-housenumber\") {\n      const savedIndex = scanner.parsingIndex;\n      for (let idx = 0; !scanner.parsingFinished; idx++) {\n        const detail = scanner.getFieldDetailByIndex(idx);\n        if (!detail) {\n          break;\n        }\n\n        if ([\"address-line1\", \"street-address\"].includes(detail?.fieldName)) {\n          return false;\n        }\n      }\n\n      // Return false so additional address handling still gets performed.\n      scanner.updateFieldName(savedIndex, \"street-address\");\n    }\n\n    return false;\n  },\n\n  /**\n   * Try to find the correct address-line[1-3] sequence and correct their field\n   * names.\n   *\n   * @param {FieldScanner} scanner\n   *        The current parsing status for all elements\n   * @returns {boolean}\n   *          Return true if there is any field can be recognized in the parser,\n   *          otherwise false.\n   */\n  _parseStreetAddressFields(scanner, _fieldDetail) {\n    const INTERESTED_FIELDS = [\n      \"street-address\",\n      \"address-line1\",\n      \"address-line2\",\n      \"address-line3\",\n    ];\n\n    // Store the index of fields that are recognized as 'address-housenumber'\n    let houseNumberFields = [];\n\n    // We need to build a list of the address fields. A list of the indicies\n    // is also needed as the fields with a given name can change positions\n    // during the update.\n    const fields = [];\n    const fieldIndicies = [];\n    for (let idx = scanner.parsingIndex; !scanner.parsingFinished; idx++) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n\n      // Skip over any house number fields. There should only be zero or one,\n      // but we'll skip over them all anyway.\n      if (\n        [detail?.fieldName, detail?.alternativeFieldName].includes(\n          \"address-housenumber\"\n        )\n      ) {\n        houseNumberFields.push(idx);\n        continue;\n      }\n\n      if (!INTERESTED_FIELDS.includes(detail?.fieldName)) {\n        break;\n      }\n      fields.push(detail);\n      fieldIndicies.push(idx);\n    }\n\n    if (!fields.length) {\n      return false;\n    }\n\n    switch (fields.length) {\n      case 1:\n        if (\n          fields[0].reason != \"autocomplete\" &&\n          [\"address-line2\", \"address-line3\"].includes(fields[0].fieldName)\n        ) {\n          // If an earlier address field was already found, ignore any\n          // address-related fields from the OTHER_ADDRESS_FIELDS\n          // list since those can appear in-between the address-level1\n          // and additional address info fields. If no address field\n          // exists, update the field to be address-line1.\n          const OTHER_ADDRESS_FIELDS = [\n            \"address-level1\",\n            \"address-level2\",\n            \"address-level3\",\n            \"postal-code\",\n            \"organization\",\n          ];\n          let canUpdate = true;\n\n          for (let idx = scanner.parsingIndex - 1; idx >= 0; idx--) {\n            const detail = scanner.getFieldDetailByIndex(idx);\n            if (\n              detail?.fieldName == \"street-address\" ||\n              detail?.fieldName == \"address-line1\" ||\n              detail?.fieldName == \"address-housenumber\"\n            ) {\n              canUpdate = false;\n              break;\n            }\n\n            if (!OTHER_ADDRESS_FIELDS.includes(detail?.fieldName)) {\n              break;\n            }\n          }\n\n          if (canUpdate) {\n            scanner.updateFieldName(fieldIndicies[0], \"address-line1\");\n          }\n        }\n        break;\n      case 2:\n        if (fields[0].reason == \"autocomplete\") {\n          if (\n            fields[0].fieldName == \"street-address\" &&\n            (fields[1].fieldName == \"address-line2\" ||\n              fields[1].reason != \"autocomplete\")\n          ) {\n            scanner.updateFieldName(fieldIndicies[0], \"address-line1\", true);\n          }\n        } else {\n          scanner.updateFieldName(fieldIndicies[0], \"address-line1\");\n        }\n        scanner.updateFieldName(fieldIndicies[1], \"address-line2\");\n        break;\n      case 3:\n      default:\n        scanner.updateFieldName(fieldIndicies[0], \"address-line1\");\n        scanner.updateFieldName(fieldIndicies[1], \"address-line2\");\n        scanner.updateFieldName(fieldIndicies[2], \"address-line3\");\n        break;\n    }\n\n    // 'address-housenumber' might be recognized alongside another field type\n    // (see `alternativeFieldName`). In this case, we should update the field\n    // name before advancing the parsing index.\n    for (const idx of houseNumberFields) {\n      scanner.updateFieldName(idx, \"address-housenumber\");\n    }\n    scanner.parsingIndex += fields.length + houseNumberFields.length;\n    return true;\n  },\n\n  _parseAddressFields(scanner, fieldDetail) {\n    const INTERESTED_FIELDS = [\"address-level1\", \"address-level2\"];\n\n    if (!INTERESTED_FIELDS.includes(fieldDetail.fieldName)) {\n      return false;\n    }\n\n    const fields = [];\n    for (let idx = scanner.parsingIndex; !scanner.parsingFinished; idx++) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n      if (!INTERESTED_FIELDS.includes(detail?.fieldName)) {\n        break;\n      }\n      fields.push(detail);\n    }\n\n    if (!fields.length) {\n      return false;\n    }\n\n    // State & City(address-level2)\n    if (fields.length == 1) {\n      if (fields[0].fieldName == \"address-level2\") {\n        const prev = scanner.getFieldDetailByIndex(scanner.parsingIndex - 1);\n        if (prev && !prev.fieldName && prev.localName == \"select\") {\n          scanner.updateFieldName(scanner.parsingIndex - 1, \"address-level1\");\n          scanner.parsingIndex += 1;\n          return true;\n        }\n        const next = scanner.getFieldDetailByIndex(scanner.parsingIndex + 1);\n        if (next && !next.fieldName && next.localName == \"select\") {\n          scanner.updateFieldName(scanner.parsingIndex + 1, \"address-level1\");\n          scanner.parsingIndex += 2;\n          return true;\n        }\n      }\n    }\n\n    scanner.parsingIndex += fields.length;\n    return true;\n  },\n\n  /**\n   * Try to look for expiration date fields and revise the field names if needed.\n   *\n   * @param {FieldScanner} scanner\n   *        The current parsing status for all elements\n   * @returns {boolean}\n   *          Return true if there is any field can be recognized in the parser,\n   *          otherwise false.\n   */\n  _parseCreditCardExpiryFields(scanner, fieldDetail) {\n    const INTERESTED_FIELDS = [\"cc-exp\", \"cc-exp-month\", \"cc-exp-year\"];\n\n    if (!INTERESTED_FIELDS.includes(fieldDetail.fieldName)) {\n      return false;\n    }\n\n    const fields = [];\n    for (let idx = scanner.parsingIndex; ; idx++) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n      if (!INTERESTED_FIELDS.includes(detail?.fieldName)) {\n        break;\n      }\n      fields.push(detail);\n    }\n\n    // Don't process the fields if expiration month and expiration year are already\n    // matched by regex in correct order.\n    if (\n      (fields.length == 1 && fields[0].fieldName == \"cc-exp\") ||\n      (fields.length == 2 &&\n        fields[0].fieldName == \"cc-exp-month\" &&\n        fields[1].fieldName == \"cc-exp-year\")\n    ) {\n      scanner.parsingIndex += fields.length;\n      return true;\n    }\n\n    const prevCCFields = new Set();\n    for (let idx = scanner.parsingIndex - 1; ; idx--) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n      if (\n        lazy.FormAutofillUtils.getCategoryFromFieldName(detail?.fieldName) !=\n        \"creditCard\"\n      ) {\n        break;\n      }\n      prevCCFields.add(detail.fieldName);\n    }\n    // We update the \"cc-exp-*\" fields to correct \"cc-ex-*\" fields order when\n    // the following conditions are met:\n    // 1. The previous elements are identified as credit card fields and\n    //    cc-number is in it\n    // 2. There is no \"cc-exp-*\" fields in the previous credit card elements\n    if (\n      [\"cc-number\", \"cc-name\"].some(f => prevCCFields.has(f)) &&\n      ![\"cc-exp\", \"cc-exp-month\", \"cc-exp-year\"].some(f => prevCCFields.has(f))\n    ) {\n      if (fields.length == 1) {\n        scanner.updateFieldName(scanner.parsingIndex, \"cc-exp\");\n      } else if (fields.length == 2) {\n        scanner.updateFieldName(scanner.parsingIndex, \"cc-exp-month\");\n        scanner.updateFieldName(scanner.parsingIndex + 1, \"cc-exp-year\");\n      }\n      scanner.parsingIndex += fields.length;\n      return true;\n    }\n\n    // Set field name to null as it failed to match any patterns.\n    for (let idx = 0; idx < fields.length; idx++) {\n      scanner.updateFieldName(scanner.parsingIndex + idx, null);\n    }\n    return false;\n  },\n\n  _parseCreditCardNumberFields(scanner, fieldDetail) {\n    const INTERESTED_FIELDS = [\"cc-number\"];\n\n    if (!INTERESTED_FIELDS.includes(fieldDetail.fieldName)) {\n      return false;\n    }\n\n    const fieldDetails = [];\n    for (let idx = scanner.parsingIndex; ; idx++) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n      if (!INTERESTED_FIELDS.includes(detail?.fieldName)) {\n        break;\n      }\n      fieldDetails.push(detail);\n    }\n\n    // This rule only applies when all the fields are visible\n    if (fieldDetails.some(field => !field.isVisible)) {\n      scanner.parsingIndex += fieldDetails.length;\n      return true;\n    }\n\n    // This is the heuristic to handle special cases where we can have multiple\n    // fields in one section, but only if the field has appeared N times in a row.\n    // For example, websites can use 4 consecutive 4-digit `cc-number` fields\n    // instead of one 16-digit `cc-number` field.\n    const N = MULTI_N_FIELD_NAMES[\"cc-number\"];\n    if (fieldDetails.length == N) {\n      fieldDetails.forEach((fd, index) => {\n        // part starts with 1\n        fd.part = index + 1;\n      });\n      scanner.parsingIndex += fieldDetails.length;\n      return true;\n    }\n\n    return false;\n  },\n  /**\n   * Look for cc-*-name fields when *-name field is present\n   *\n   * @param {FieldScanner} scanner\n   *        The current parsing status for all elements\n   * @returns {boolean}\n   *          Return true if there is any field can be recognized in the parser,\n   *          otherwise false.\n   */\n  _parseCreditCardNameFields(scanner, fieldDetail) {\n    const INTERESTED_FIELDS = [\n      \"name\",\n      \"given-name\",\n      \"additional-name\",\n      \"family-name\",\n    ];\n\n    if (!INTERESTED_FIELDS.includes(fieldDetail.fieldName)) {\n      return false;\n    }\n\n    const fields = [];\n    for (let idx = scanner.parsingIndex; ; idx++) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n      if (!INTERESTED_FIELDS.includes(detail?.fieldName)) {\n        break;\n      }\n      fields.push(detail);\n    }\n\n    const prevCCFields = new Set();\n    for (let idx = scanner.parsingIndex - 1; ; idx--) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n      if (\n        lazy.FormAutofillUtils.getCategoryFromFieldName(detail?.fieldName) !=\n        \"creditCard\"\n      ) {\n        break;\n      }\n      prevCCFields.add(detail.fieldName);\n    }\n\n    const subsequentCCFields = new Set();\n\n    for (let idx = scanner.parsingIndex + fields.length; ; idx++) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n      if (\n        // For updates we only check subsequent fields that are not of type address or do not have an\n        // alternative field name that is of type address, to avoid falsely updating address\n        // form name fields to cc-*-name.\n        lazy.FormAutofillUtils.getCategoryFromFieldName(detail?.fieldName) !=\n          \"creditCard\" ||\n        (detail?.alternativeFieldName !== undefined &&\n          lazy.FormAutofillUtils.getCategoryFromFieldName(\n            detail?.alternativeFieldName\n          ) != \"creditCard\")\n      ) {\n        break;\n      }\n      subsequentCCFields.add(detail.fieldName);\n    }\n\n    const isLastField =\n      scanner.getFieldDetailByIndex(scanner.parsingIndex + 1) === null;\n\n    // We update the \"name\" fields to \"cc-name\" fields when the following\n    // conditions are met:\n    // 1. The preceding fields are identified as credit card fields and\n    //    contain the \"cc-number\" field.\n    // 2. No \"cc-name-*\" field is found among the preceding credit card fields.\n    // 3. The \"cc-csc\" field is either not present among the preceding credit card fields,\n    //    or the current field is the last field in the form. This condition is in place\n    //    because \"cc-csc\" is often the last field in a credit card form, and we want to\n    //    avoid mistakenly updating fields in subsequent address forms.\n    if (\n      ([\"cc-number\"].some(f => prevCCFields.has(f)) &&\n        ![\"cc-name\", \"cc-given-name\", \"cc-family-name\"].some(f =>\n          prevCCFields.has(f)\n        ) &&\n        (isLastField || !prevCCFields.has(\"cc-csc\"))) || // 4. Or we update when current name field is followed by\n      //    creditcard form fields that contain cc-number\n      //    and no cc-*-name field is detected\n      ([\"cc-number\"].some(f => subsequentCCFields.has(f)) &&\n        ![\"cc-name\", \"cc-given-name\", \"cc-family-name\"].some(f =>\n          subsequentCCFields.has(f)\n        ))\n    ) {\n      // If there is only one field, assume the name field a `cc-name` field\n      if (fields.length == 1) {\n        scanner.updateFieldName(scanner.parsingIndex, `cc-name`);\n        scanner.parsingIndex += 1;\n      } else {\n        // update *-name to cc-*-name\n        for (const field of fields) {\n          scanner.updateFieldName(\n            scanner.parsingIndex,\n            `cc-${field.fieldName}`\n          );\n          scanner.parsingIndex += 1;\n        }\n      }\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * If the given field is of a different type than the previous\n   * field, use the alternate field name instead.\n   */\n  _checkForAlternateField(scanner, fieldDetail) {\n    if (fieldDetail.alternativeFieldName) {\n      const previousField = scanner.getFieldDetailByIndex(\n        scanner.parsingIndex - 1\n      );\n      if (previousField) {\n        const preIsCC = lazy.FormAutofillUtils.isCreditCardField(\n          previousField.fieldName\n        );\n        const curIsCC = lazy.FormAutofillUtils.isCreditCardField(\n          fieldDetail.fieldName\n        );\n\n        // If the current type is different from the previous element's type, use\n        // the alternative fieldname instead.\n        if (preIsCC != curIsCC) {\n          fieldDetail.fieldName = fieldDetail.alternativeFieldName;\n          fieldDetail.reason = \"update-heuristic-alternate\";\n        }\n      }\n    }\n  },\n\n  /**\n   * This function should provide all field details of a form which are placed\n   * in the belonging section. The details contain the autocomplete info\n   * (e.g. fieldName, section, etc).\n   *\n   * @param {formLike} formLike\n   *        the elements in this form to be predicted the field info.\n   * @param {boolean} ignoreInvisibleInput\n   *        True to NOT run heuristics on invisible <input> fields.\n   * @returns {Array<FormSection>}\n   *        all sections within its field details in the form.\n   */\n  getFormInfo(formLike, ignoreInvisibleInput) {\n    const elements = Array.from(formLike.elements).filter(element =>\n      lazy.FormAutofillUtils.isCreditCardOrAddressFieldType(element)\n    );\n\n    let closestHeaders;\n    let closestButtons;\n    if (resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.isMLExperimentEnabled && elements.length) {\n      closestHeaders = lazy.MLAutofill.closestHeaderAbove(elements);\n      closestButtons = lazy.MLAutofill.closestButtonBelow(elements);\n    }\n\n    const fieldDetails = [];\n    for (let idx = 0; idx < elements.length; idx++) {\n      const element = elements[idx];\n      // Ignore invisible <input>, we still keep invisible <select> since\n      // some websites implements their custom dropdown and use invisible <select>\n      // to store the value.\n      const isVisible = lazy.FormAutofillUtils.isFieldVisible(element);\n      if (\n        !HTMLSelectElement.isInstance(element) &&\n        !isVisible &&\n        ignoreInvisibleInput &&\n        // Include invisible but previously autocompleted inputs in order\n        // keep track of them. This way they will also be cleared on a form clearing action.\n        element.autofillState != lazy.FormAutofillUtils.FIELD_STATES.AUTO_FILLED\n      ) {\n        continue;\n      }\n\n      const [fieldName, inferInfo] = this.inferFieldInfo(element, elements);\n\n      // For cases where the heuristic has determined the field name without\n      // running Fathom, still run Fathom so we can compare the results between\n      // Fathom and the ML model. Note that this is only enabled when the ML experiment\n      // is enabled.\n      if (\n        resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.isMLExperimentEnabled &&\n        inferInfo.fathomConfidence == undefined\n      ) {\n        let fields = this._getPossibleFieldNames(element);\n        fields = fields.filter(r => lazy.CreditCardRulesets.types.includes(r));\n        const [label, score] = this.getFathomField(element, fields, elements);\n        inferInfo.fathomLabel = label;\n        inferInfo.fathomConfidence = score;\n      }\n\n      fieldDetails.push(\n        lazy.FieldDetail.create(element, formLike, fieldName, {\n          autocompleteInfo: inferInfo.autocompleteInfo,\n          fathomLabel: inferInfo.fathomLabel,\n          fathomConfidence: inferInfo.fathomConfidence,\n          isVisible,\n          mlHeaderInput: closestHeaders?.[idx] ?? null,\n          mlButtonInput: closestButtons?.[idx] ?? null,\n        })\n      );\n    }\n\n    this.parseAndUpdateFieldNamesContent(fieldDetails);\n\n    lazy.LabelUtils.clearLabelMap();\n\n    return fieldDetails;\n  },\n\n  /**\n   * Similar to `parseAndUpdateFieldNamesParent`. The difference is that\n   * the parsing heuristics used in this function are based on information\n   * not currently passed to the parent process. For example,\n   * text strings from associated labels.\n   *\n   * Note that the heuristics run in this function will not be able\n   * to reference field information across frames.\n   *\n   * @param {Array<FieldDetail>} fieldDetails\n   *        An array of the identified fields.\n   */\n  parseAndUpdateFieldNamesContent(fieldDetails) {\n    const scanner = new lazy.FieldScanner(fieldDetails);\n\n    while (!scanner.parsingFinished) {\n      const savedIndex = scanner.parsingIndex;\n\n      // First, we get the inferred field info\n      const fieldDetail = scanner.getFieldDetailByIndex(scanner.parsingIndex);\n\n      if (\n        this._parseNameFieldsContent(scanner, fieldDetail) ||\n        this._parsePhoneFields(scanner, fieldDetail)\n      ) {\n        continue;\n      }\n\n      if (savedIndex == scanner.parsingIndex) {\n        scanner.parsingIndex++;\n      }\n    }\n  },\n\n  /**\n   * Iterates through the field details and updates the field names\n   * based on surrounding field information, using various parsing functions.\n   *\n   * @param {Array<FieldDetail>} fieldDetails\n   *        An array of the identified fields.\n   */\n  parseAndUpdateFieldNamesParent(fieldDetails) {\n    const scanner = new lazy.FieldScanner(fieldDetails);\n\n    while (!scanner.parsingFinished) {\n      const savedIndex = scanner.parsingIndex;\n\n      const fieldDetail = scanner.getFieldDetailByIndex(scanner.parsingIndex);\n\n      this._checkForAlternateField(scanner, fieldDetail);\n\n      // Attempt to parse the field using different parsers.\n      if (\n        this._parseNameFields(scanner, fieldDetail) ||\n        this._parseHouseNumberFields(scanner, fieldDetail) ||\n        this._parseStreetAddressFields(scanner, fieldDetail) ||\n        this._parseAddressFields(scanner, fieldDetail) ||\n        this._parseCreditCardExpiryFields(scanner, fieldDetail) ||\n        this._parseCreditCardNameFields(scanner, fieldDetail) ||\n        this._parseCreditCardNumberFields(scanner, fieldDetail)\n      ) {\n        continue;\n      }\n\n      // Move the parsing cursor forward if no parser was applied.\n      if (savedIndex == scanner.parsingIndex) {\n        scanner.parsingIndex++;\n      }\n    }\n  },\n\n  _getPossibleFieldNames(element) {\n    let fieldNames = [];\n    const isAutoCompleteOff =\n      element.autocomplete == \"off\" || element.form?.autocomplete == \"off\";\n    if (!isAutoCompleteOff || resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.creditCardsAutocompleteOff) {\n      fieldNames.push(...this.CREDIT_CARD_FIELDNAMES);\n    }\n    if (!isAutoCompleteOff || resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.addressesAutocompleteOff) {\n      fieldNames.push(...this.ADDRESS_FIELDNAMES);\n    }\n\n    if (HTMLInputElement.isInstance(element) && element.type == \"search\") {\n      const FIELDNAMES_FOR_SEARCH_TYPE = [\n        \"address-level1\",\n        \"address-level2\",\n        \"address-line1\",\n        \"address-line2\",\n        \"address-line3\",\n        \"street-address\",\n        \"postal-code\",\n      ];\n      fieldNames = fieldNames.filter(name =>\n        FIELDNAMES_FOR_SEARCH_TYPE.includes(name)\n      );\n    } else if (HTMLSelectElement.isInstance(element)) {\n      const FIELDNAMES_FOR_SELECT_ELEMENT = [\n        \"address-level1\",\n        \"address-level2\",\n        \"country\",\n        \"cc-exp-month\",\n        \"cc-exp-year\",\n        \"cc-exp\",\n        \"cc-type\",\n        \"tel-country-code\",\n      ];\n      fieldNames = fieldNames.filter(name =>\n        FIELDNAMES_FOR_SELECT_ELEMENT.includes(name)\n      );\n    } else if (HTMLTextAreaElement.isInstance(element)) {\n      const FIELDNAMES_FOR_TEXT_AREA_ELEMENT = [\"street-address\"];\n      fieldNames = fieldNames.filter(name =>\n        FIELDNAMES_FOR_TEXT_AREA_ELEMENT.includes(name)\n      );\n    }\n\n    return fieldNames;\n  },\n\n  /**\n   * Get inferred information about an input element using autocomplete info, fathom and regex-based heuristics.\n   *\n   * @param {HTMLElement} element - The input element to infer information about.\n   * @param {Array<HTMLElement>} elements - See `getFathomField` for details\n   * @returns {Array} - An array containing:\n   *                    [0]the inferred field name\n   *                    [1]information collected during the inference process. The possible values includes:\n   *                       'autocompleteInfo', 'fathomLabel', and 'fathomConfidence'.\n   */\n  inferFieldInfo(element, elements = []) {\n    const inferredInfo = {};\n    const autocompleteInfo = element.getAutocompleteInfo();\n\n    // An input[autocomplete=\"on\"] will not be early return here since it stll\n    // needs to find the field name.\n    if (\n      autocompleteInfo?.fieldName &&\n      ![\"on\", \"off\"].includes(autocompleteInfo.fieldName)\n    ) {\n      inferredInfo.autocompleteInfo = autocompleteInfo;\n      return [autocompleteInfo.fieldName, inferredInfo];\n    }\n\n    const fields = this._getPossibleFieldNames(element);\n\n    // \"email\" type of input is accurate for heuristics to determine its Email\n    // field or not. However, \"tel\" type is used for ZIP code for some web site\n    // (e.g. HomeDepot, BestBuy), so \"tel\" type should be not used for \"tel\"\n    // prediction.\n    if (element.type == \"email\" && fields.includes(\"email\")) {\n      return [\"email\", inferredInfo];\n    }\n\n    if (lazy.FormAutofillUtils.isFathomCreditCardsEnabled()) {\n      // We don't care fields that are not supported by fathom\n      const fathomFields = fields.filter(r =>\n        lazy.CreditCardRulesets.types.includes(r)\n      );\n      const [matchedFieldName, confidence] = this.getFathomField(\n        element,\n        fathomFields,\n        elements\n      );\n      if (confidence != null) {\n        inferredInfo.fathomLabel = matchedFieldName;\n        inferredInfo.fathomConfidence = confidence;\n      }\n      // At this point, use fathom's recommendation if it has one\n      if (matchedFieldName) {\n        return [matchedFieldName, inferredInfo];\n      }\n\n      // Continue to run regex-based heuristics even when fathom doesn't recognize\n      // the field. Since the regex-based heuristic has good search coverage but\n      // has a worse precision. We use it in conjunction with fathom to maximize\n      // our search coverage. For example, when a <input> is not considered cc-name\n      // by fathom but is considered cc-name by regex-based heuristic, if the form\n      // also contains a cc-number identified by fathom, we will treat the form as a\n      // valid cc form; hence both cc-number & cc-name are identified.\n    }\n\n    // Check every select for options that\n    // match credit card network names in value or label.\n    if (HTMLSelectElement.isInstance(element)) {\n      if (this._isExpirationMonthLikely(element)) {\n        return [\"cc-exp-month\", inferredInfo];\n      } else if (this._isExpirationYearLikely(element)) {\n        return [\"cc-exp-year\", inferredInfo];\n      }\n\n      const options = Array.from(element.querySelectorAll(\"option\"));\n      if (\n        options.find(\n          option =>\n            lazy.CreditCard.getNetworkFromName(option.value) ||\n            lazy.CreditCard.getNetworkFromName(option.text)\n        )\n      ) {\n        return [\"cc-type\", inferredInfo];\n      }\n\n      // At least two options match the country name, otherwise some state name might\n      // also match a country name, ex, Georgia. We check the last two\n      // options rather than the first, as selects often start with a non-country display option.\n      const countryDisplayNames = Array.from(resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.countries.values());\n      if (\n        options.length >= 2 &&\n        options\n          .slice(-2)\n          .every(\n            option =>\n              countryDisplayNames.includes(option.value) ||\n              countryDisplayNames.includes(option.text)\n          )\n      ) {\n        return [\"country\", inferredInfo];\n      }\n    }\n\n    // Find a matched field name using regexp-based heuristics\n    const matchedFieldNames = this._findMatchedFieldNames(element, fields);\n\n    return [matchedFieldNames, inferredInfo];\n  },\n\n  /**\n   * Using Fathom, say what kind of CC field an element is most likely to be.\n   * This function deoesn't only run fathom on the passed elements. It also\n   * runs fathom for all elements in the FieldScanner for optimization purpose.\n   *\n   * @param {HTMLElement} element\n   * @param {Array} fields\n   * @param {Array<HTMLElement>} elements - All other eligible elements in the same form. This is mainly used as an\n   *                                        optimization approach to run fathom model on all eligible elements\n   *                                        once instead of one by one\n   * @returns {Array} A tuple of [field name, probability] describing the\n   *   highest-confidence classification\n   */\n  getFathomField(element, fields, elements = []) {\n    if (!fields.length) {\n      return [null, null];\n    }\n\n    if (!this._fathomConfidences?.get(element)) {\n      this._fathomConfidences = new Map();\n\n      // This should not throw unless we run into an OOM situation, at which\n      // point we have worse problems and this failing is not a big deal.\n      elements = elements.includes(element) ? elements : [element];\n      const confidences = this.getFormAutofillConfidences(elements);\n\n      for (let i = 0; i < elements.length; i++) {\n        this._fathomConfidences.set(elements[i], confidences[i]);\n      }\n    }\n\n    const elementConfidences = this._fathomConfidences.get(element);\n    if (!elementConfidences) {\n      return [null, null];\n    }\n\n    let highestField = null;\n    let highestConfidence = lazy.FormAutofillUtils.ccFathomConfidenceThreshold; // Start with a threshold of 0.5\n    for (let [key, value] of Object.entries(elementConfidences)) {\n      if (!fields.includes(key)) {\n        // ignore field that we don't care\n        continue;\n      }\n\n      if (value > highestConfidence) {\n        highestConfidence = value;\n        highestField = key;\n      }\n    }\n\n    if (!highestField) {\n      return [null, null];\n    }\n\n    // Used by test ONLY! This ensure testcases always get the same confidence\n    if (lazy.FormAutofillUtils.ccFathomTestConfidence > 0) {\n      highestConfidence = lazy.FormAutofillUtils.ccFathomTestConfidence;\n    }\n\n    return [highestField, highestConfidence];\n  },\n\n  /**\n   * @param {Array} elements Array of elements that we want to get result from fathom cc rules\n   * @returns {object} Fathom confidence keyed by field-type.\n   */\n  getFormAutofillConfidences(elements) {\n    if (\n      lazy.FormAutofillUtils.ccHeuristicsMode ==\n      lazy.FormAutofillUtils.CC_FATHOM_NATIVE\n    ) {\n      const confidences = ChromeUtils.getFormAutofillConfidences(elements);\n      return confidences.map(c => {\n        let result = {};\n        for (let [fieldName, confidence] of Object.entries(c)) {\n          let type =\n            lazy.FormAutofillUtils.formAutofillConfidencesKeyToCCFieldType(\n              fieldName\n            );\n          result[type] = confidence;\n        }\n        return result;\n      });\n    }\n\n    return elements.map(element => {\n      /**\n       * Return how confident our ML model is that `element` is a field of the\n       * given type.\n       *\n       * @param {string} fieldName The Fathom type to check against. This is\n       *   conveniently the same as the autocomplete attribute value that means\n       *   the same thing.\n       * @returns {number} Confidence in range [0, 1]\n       */\n      function confidence(fieldName) {\n        const ruleset = lazy.CreditCardRulesets[fieldName];\n        const fnodes = ruleset.against(element).get(fieldName);\n\n        // fnodes is either 0 or 1 item long, since we ran the ruleset\n        // against a single element:\n        return fnodes.length ? fnodes[0].scoreFor(fieldName) : 0;\n      }\n\n      // Bang the element against the ruleset for every type of field:\n      const confidences = {};\n      lazy.CreditCardRulesets.types.map(fieldName => {\n        confidences[fieldName] = confidence(fieldName);\n      });\n\n      return confidences;\n    });\n  },\n\n  /**\n   * @typedef ElementStrings\n   * @type {object}\n   * @yields {string} id - element id.\n   * @yields {string} name - element name.\n   * @yields {Array<string>} labels - extracted labels.\n   */\n\n  /**\n   * Extract all the signature strings of an element.\n   *\n   * @param {HTMLElement} element\n   * @returns {Array<string>}\n   */\n  _getElementStrings(element) {\n    return [element.id, element.name, element.placeholder?.trim()];\n  },\n\n  /**\n   * Extract all the label strings associated with an element.\n   *\n   * @param {HTMLElement} element\n   * @returns {ElementStrings}\n   */\n  _getElementLabelStrings(element) {\n    return {\n      *[Symbol.iterator]() {\n        const labels = lazy.LabelUtils.findLabelElements(element);\n        for (let label of labels) {\n          yield* lazy.LabelUtils.extractLabelStrings(label);\n        }\n\n        const ariaLabels = element.getAttribute(\"aria-label\");\n        if (ariaLabels) {\n          yield* [ariaLabels];\n        }\n      },\n    };\n  },\n\n  // In order to support webkit we need to avoid usage of negative lookbehind due to low support\n  // First safari version with support is 16.4 (Release Date: 27th March 2023)\n  // https://caniuse.com/js-regexp-lookbehind\n  // We can mimic the behaviour of negative lookbehinds by using a named capture group\n  // (?<!not)word -> (?<neg>notword)|word\n  // TODO: Bug 1829583\n  testRegex(regex, string) {\n    const matches = string?.matchAll(regex);\n    if (!matches) {\n      return false;\n    }\n\n    const excludeNegativeCaptureGroups = [];\n\n    for (const match of matches) {\n      excludeNegativeCaptureGroups.push(\n        ...match.filter(m => m !== match?.groups?.neg).filter(Boolean)\n      );\n    }\n    return excludeNegativeCaptureGroups?.length > 0;\n  },\n\n  /**\n   * Find matching field names from a given list of field names\n   * that matches an HTML element.\n   *\n   * The function first tries to match the element against a set of\n   * pre-defined regular expression rules. If no match is found, it\n   * then checks for label-specific rules, if they exist.\n   *\n   * The return value can contain a maximum of two field names, the\n   * first item the first match found, and the second an alternate field\n   * name always of a different type, where the two type are credit card\n   * and address.\n   *\n   * Note: For label rules, the keyword is often more general\n   * (e.g., \"^\\\\W*address\"), hence they are only searched within labels\n   * to reduce the occurrence of false positives.\n   *\n   * @param {HTMLElement} element The element to match.\n   * @param {Array<string>} fieldNames An array of field names to compare against.\n   * @returns {Array} An array of the matching field names.\n   */\n  _findMatchedFieldNames(element, fieldNames) {\n    if (!fieldNames.length) {\n      return [];\n    }\n\n    // The first element is the field name, and the second element is the type.\n    let fields = fieldNames.map(name => [\n      name,\n      lazy.FormAutofillUtils.isCreditCardField(name) ? CC_TYPE : ADDR_TYPE,\n    ]);\n\n    let foundType;\n    let attribute = true;\n    let matchedFieldNames = [];\n\n    // Check RULES first, and only check LABEL_RULES if no match is found.\n    for (let rules of [this.RULES, this.LABEL_RULES]) {\n      // Attempt to match the element against the default set of rules.\n      if (\n        fields.find(field => {\n          const [fieldName, type] = field;\n\n          // The same type has been found already, so skip.\n          if (foundType == type) {\n            return false;\n          }\n\n          if (!this._matchRegexp(element, rules[fieldName], { attribute })) {\n            return false;\n          }\n\n          foundType = type;\n          matchedFieldNames.push(fieldName);\n\n          return matchedFieldNames.length == 2;\n        })\n      ) {\n        break;\n      }\n\n      // Don't match attributes for label rules.\n      attribute = false;\n    }\n\n    return matchedFieldNames;\n  },\n\n  /**\n   * Determine whether the regexp can match any of element strings.\n   *\n   * @param {HTMLElement} element The HTML element to match.\n   * @param {RegExp} regexp       The regular expression to match against.\n   * @param {object} [options]    Optional parameters for matching.\n   * @param {boolean} [options.attribute=true]\n   *                              Whether to match against the element's attributes.\n   * @param {boolean} [options.label=true]\n   *                              Whether to match against the element's labels.\n   * @returns {boolean} True if a match is found, otherwise false.\n   */\n  _matchRegexp(element, regexp, { attribute = true, label = true } = {}) {\n    if (!regexp) {\n      return false;\n    }\n\n    if (attribute) {\n      const elemStrings = this._getElementStrings(element);\n      if (elemStrings.find(s => this.testRegex(regexp, s?.toLowerCase()))) {\n        return true;\n      }\n    }\n\n    if (label) {\n      const elementLabelStrings = this._getElementLabelStrings(element);\n      for (const s of elementLabelStrings) {\n        if (this.testRegex(regexp, s?.toLowerCase())) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * Phone field grammars - first matched grammar will be parsed. Grammars are\n   * separated by { REGEX_SEPARATOR, FIELD_NONE, 0 }. Suffix and extension are\n   * parsed separately unless they are necessary parts of the match.\n   * The following notation is used to describe the patterns:\n   * <cc> - country code field.\n   * <ac> - area code field.\n   * <phone> - phone or prefix.\n   * <suffix> - suffix.\n   * <ext> - extension.\n   * :N means field is limited to N characters, otherwise it is unlimited.\n   * (pattern <field>)? means pattern is optional and matched separately.\n   *\n   * This grammar list from Chromium will be enabled partially once we need to\n   * support more cases of Telephone fields.\n   */\n  PHONE_FIELD_GRAMMARS: [\n    // Country code: <cc> Area Code: <ac> Phone: <phone> (- <suffix>\n\n    // (Ext: <ext>)?)?\n    // {REGEX_COUNTRY, FIELD_COUNTRY_CODE, 0},\n    // {REGEX_AREA, FIELD_AREA_CODE, 0},\n    // {REGEX_PHONE, FIELD_PHONE, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // \\( <ac> \\) <phone>:3 <suffix>:4 (Ext: <ext>)?\n    // {REGEX_AREA_NOTEXT, FIELD_AREA_CODE, 3},\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 3},\n    // {REGEX_PHONE, FIELD_SUFFIX, 4},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <cc> <ac>:3 - <phone>:3 - <suffix>:4 (Ext: <ext>)?\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\n    // {REGEX_PHONE, FIELD_AREA_CODE, 3},\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 3},\n    // {REGEX_SUFFIX_SEPARATOR, FIELD_SUFFIX, 4},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <cc>:3 <ac>:3 <phone>:3 <suffix>:4 (Ext: <ext>)?\n    [\"tel\", \"tel-country-code\", 3],\n    [\"tel\", \"tel-area-code\", 3],\n    [\"tel\", \"tel-local-prefix\", 3],\n    [\"tel\", \"tel-local-suffix\", 4],\n    [null, null, 0],\n\n    // Area Code: <ac> Phone: <phone> (- <suffix> (Ext: <ext>)?)?\n    // {REGEX_AREA, FIELD_AREA_CODE, 0},\n    // {REGEX_PHONE, FIELD_PHONE, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <ac> <phone>:3 <suffix>:4 (Ext: <ext>)?\n    // {REGEX_PHONE, FIELD_AREA_CODE, 0},\n    // {REGEX_PHONE, FIELD_PHONE, 3},\n    // {REGEX_PHONE, FIELD_SUFFIX, 4},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <cc> \\( <ac> \\) <phone> (- <suffix> (Ext: <ext>)?)?\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\n    // {REGEX_AREA_NOTEXT, FIELD_AREA_CODE, 0},\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: \\( <ac> \\) <phone> (- <suffix> (Ext: <ext>)?)?\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\n    // {REGEX_AREA_NOTEXT, FIELD_AREA_CODE, 0},\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <cc> - <ac> - <phone> - <suffix> (Ext: <ext>)?\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\n    // {REGEX_PREFIX_SEPARATOR, FIELD_AREA_CODE, 0},\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 0},\n    // {REGEX_SUFFIX_SEPARATOR, FIELD_SUFFIX, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Area code: <ac>:3 Prefix: <prefix>:3 Suffix: <suffix>:4 (Ext: <ext>)?\n    // {REGEX_AREA, FIELD_AREA_CODE, 3},\n    // {REGEX_PREFIX, FIELD_PHONE, 3},\n    // {REGEX_SUFFIX, FIELD_SUFFIX, 4},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <ac> Prefix: <phone> Suffix: <suffix> (Ext: <ext>)?\n    // {REGEX_PHONE, FIELD_AREA_CODE, 0},\n    // {REGEX_PREFIX, FIELD_PHONE, 0},\n    // {REGEX_SUFFIX, FIELD_SUFFIX, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <ac> - <phone>:3 - <suffix>:4 (Ext: <ext>)?\n    [\"tel\", \"tel-area-code\", 0],\n    [\"tel\", \"tel-local-prefix\", 3],\n    [\"tel\", \"tel-local-suffix\", 4],\n    [null, null, 0],\n\n    // Phone: <cc> - <ac> - <phone> (Ext: <ext>)?\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\n    // {REGEX_PREFIX_SEPARATOR, FIELD_AREA_CODE, 0},\n    // {REGEX_SUFFIX_SEPARATOR, FIELD_PHONE, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <ac> - <phone> (Ext: <ext>)?\n    // {REGEX_AREA, FIELD_AREA_CODE, 0},\n    // {REGEX_PHONE, FIELD_PHONE, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <cc>:3 - <phone>:10 (Ext: <ext>)?\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 3},\n    // {REGEX_PHONE, FIELD_PHONE, 10},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Ext: <ext>\n    // {REGEX_EXTENSION, FIELD_EXTENSION, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <phone> (Ext: <ext>)?\n    // {REGEX_PHONE, FIELD_PHONE, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n  ],\n};\n\nChromeUtils.defineLazyGetter(\n  FormAutofillHeuristics,\n  \"CREDIT_CARD_FIELDNAMES\",\n  () =>\n    Object.keys(FormAutofillHeuristics.RULES).filter(name =>\n      lazy.FormAutofillUtils.isCreditCardField(name)\n    )\n);\n\nChromeUtils.defineLazyGetter(FormAutofillHeuristics, \"ADDRESS_FIELDNAMES\", () =>\n  Object.keys(FormAutofillHeuristics.RULES).filter(name =>\n    lazy.FormAutofillUtils.isAddressField(name)\n  )\n);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FormAutofillHeuristics);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs":
/*!***************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormAutofillNameUtils: () => (/* binding */ FormAutofillNameUtils)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// FormAutofillNameUtils is initially translated from\n// https://cs.chromium.org/chromium/src/components/autofill/core/browser/autofill_data_util.cc?rcl=b861deff77abecff11ae6a9f6946e9cc844b9817\nvar FormAutofillNameUtils = {\n  NAME_PREFIXES: [\n    \"1lt\",\n    \"1st\",\n    \"2lt\",\n    \"2nd\",\n    \"3rd\",\n    \"admiral\",\n    \"capt\",\n    \"captain\",\n    \"col\",\n    \"cpt\",\n    \"dr\",\n    \"gen\",\n    \"general\",\n    \"lcdr\",\n    \"lt\",\n    \"ltc\",\n    \"ltg\",\n    \"ltjg\",\n    \"maj\",\n    \"major\",\n    \"mg\",\n    \"mr\",\n    \"mrs\",\n    \"ms\",\n    \"pastor\",\n    \"prof\",\n    \"rep\",\n    \"reverend\",\n    \"rev\",\n    \"sen\",\n    \"st\",\n  ],\n\n  NAME_SUFFIXES: [\n    \"b.a\",\n    \"ba\",\n    \"d.d.s\",\n    \"dds\",\n    \"i\",\n    \"ii\",\n    \"iii\",\n    \"iv\",\n    \"ix\",\n    \"jr\",\n    \"m.a\",\n    \"m.d\",\n    \"ma\",\n    \"md\",\n    \"ms\",\n    \"ph.d\",\n    \"phd\",\n    \"sr\",\n    \"v\",\n    \"vi\",\n    \"vii\",\n    \"viii\",\n    \"x\",\n  ],\n\n  FAMILY_NAME_PREFIXES: [\n    \"d'\",\n    \"de\",\n    \"del\",\n    \"der\",\n    \"di\",\n    \"la\",\n    \"le\",\n    \"mc\",\n    \"san\",\n    \"st\",\n    \"ter\",\n    \"van\",\n    \"von\",\n  ],\n\n  // The common and non-ambiguous CJK surnames (last names) that have more than\n  // one character.\n  COMMON_CJK_MULTI_CHAR_SURNAMES: [\n    // Korean, taken from the list of surnames:\n    // https://ko.wikipedia.org/wiki/%ED%95%9C%EA%B5%AD%EC%9D%98_%EC%84%B1%EC%94%A8_%EB%AA%A9%EB%A1%9D\n    \"남궁\",\n    \"사공\",\n    \"서문\",\n    \"선우\",\n    \"제갈\",\n    \"황보\",\n    \"독고\",\n    \"망절\",\n\n    // Chinese, taken from the top 10 Chinese 2-character surnames:\n    // https://zh.wikipedia.org/wiki/%E8%A4%87%E5%A7%93#.E5.B8.B8.E8.A6.8B.E7.9A.84.E8.A4.87.E5.A7.93\n    // Simplified Chinese (mostly mainland China)\n    \"欧阳\",\n    \"令狐\",\n    \"皇甫\",\n    \"上官\",\n    \"司徒\",\n    \"诸葛\",\n    \"司马\",\n    \"宇文\",\n    \"呼延\",\n    \"端木\",\n    // Traditional Chinese (mostly Taiwan)\n    \"張簡\",\n    \"歐陽\",\n    \"諸葛\",\n    \"申屠\",\n    \"尉遲\",\n    \"司馬\",\n    \"軒轅\",\n    \"夏侯\",\n  ],\n\n  // All Korean surnames that have more than one character, even the\n  // rare/ambiguous ones.\n  KOREAN_MULTI_CHAR_SURNAMES: [\n    \"강전\",\n    \"남궁\",\n    \"독고\",\n    \"동방\",\n    \"망절\",\n    \"사공\",\n    \"서문\",\n    \"선우\",\n    \"소봉\",\n    \"어금\",\n    \"장곡\",\n    \"제갈\",\n    \"황목\",\n    \"황보\",\n  ],\n\n  // The whitespace definition based on\n  // https://cs.chromium.org/chromium/src/base/strings/string_util_constants.cc?l=9&rcl=b861deff77abecff11ae6a9f6946e9cc844b9817\n  WHITESPACE: [\n    \"\\u0009\", // CHARACTER TABULATION\n    \"\\u000A\", // LINE FEED (LF)\n    \"\\u000B\", // LINE TABULATION\n    \"\\u000C\", // FORM FEED (FF)\n    \"\\u000D\", // CARRIAGE RETURN (CR)\n    \"\\u0020\", // SPACE\n    \"\\u0085\", // NEXT LINE (NEL)\n    \"\\u00A0\", // NO-BREAK SPACE\n    \"\\u1680\", // OGHAM SPACE MARK\n    \"\\u2000\", // EN QUAD\n    \"\\u2001\", // EM QUAD\n    \"\\u2002\", // EN SPACE\n    \"\\u2003\", // EM SPACE\n    \"\\u2004\", // THREE-PER-EM SPACE\n    \"\\u2005\", // FOUR-PER-EM SPACE\n    \"\\u2006\", // SIX-PER-EM SPACE\n    \"\\u2007\", // FIGURE SPACE\n    \"\\u2008\", // PUNCTUATION SPACE\n    \"\\u2009\", // THIN SPACE\n    \"\\u200A\", // HAIR SPACE\n    \"\\u2028\", // LINE SEPARATOR\n    \"\\u2029\", // PARAGRAPH SEPARATOR\n    \"\\u202F\", // NARROW NO-BREAK SPACE\n    \"\\u205F\", // MEDIUM MATHEMATICAL SPACE\n    \"\\u3000\", // IDEOGRAPHIC SPACE\n  ],\n\n  // The middle dot is used as a separator for foreign names in Japanese.\n  MIDDLE_DOT: [\n    \"\\u30FB\", // KATAKANA MIDDLE DOT\n    \"\\u00B7\", // A (common?) typo for \"KATAKANA MIDDLE DOT\"\n  ],\n\n  // The Unicode range is based on Wiki:\n  // https://en.wikipedia.org/wiki/CJK_Unified_Ideographs\n  // https://en.wikipedia.org/wiki/Hangul\n  // https://en.wikipedia.org/wiki/Japanese_writing_system\n  CJK_RANGE: [\n    \"\\u1100-\\u11FF\", // Hangul Jamo\n    \"\\u3040-\\u309F\", // Hiragana\n    \"\\u30A0-\\u30FF\", // Katakana\n    \"\\u3105-\\u312C\", // Bopomofo\n    \"\\u3130-\\u318F\", // Hangul Compatibility Jamo\n    \"\\u31F0-\\u31FF\", // Katakana Phonetic Extensions\n    \"\\u3200-\\u32FF\", // Enclosed CJK Letters and Months\n    \"\\u3400-\\u4DBF\", // CJK unified ideographs Extension A\n    \"\\u4E00-\\u9FFF\", // CJK Unified Ideographs\n    \"\\uA960-\\uA97F\", // Hangul Jamo Extended-A\n    \"\\uAC00-\\uD7AF\", // Hangul Syllables\n    \"\\uD7B0-\\uD7FF\", // Hangul Jamo Extended-B\n    \"\\uFF00-\\uFFEF\", // Halfwidth and Fullwidth Forms\n  ],\n\n  HANGUL_RANGE: [\n    \"\\u1100-\\u11FF\", // Hangul Jamo\n    \"\\u3130-\\u318F\", // Hangul Compatibility Jamo\n    \"\\uA960-\\uA97F\", // Hangul Jamo Extended-A\n    \"\\uAC00-\\uD7AF\", // Hangul Syllables\n    \"\\uD7B0-\\uD7FF\", // Hangul Jamo Extended-B\n  ],\n\n  _dataLoaded: false,\n\n  // Returns true if |set| contains |token|, modulo a final period.\n  _containsString(set, token) {\n    let target = token.replace(/\\.$/, \"\").toLowerCase();\n    return set.includes(target);\n  },\n\n  // Removes common name prefixes from |name_tokens|.\n  _stripPrefixes(nameTokens) {\n    for (let i in nameTokens) {\n      if (!this._containsString(this.NAME_PREFIXES, nameTokens[i])) {\n        return nameTokens.slice(i);\n      }\n    }\n    return [];\n  },\n\n  // Removes common name suffixes from |name_tokens|.\n  _stripSuffixes(nameTokens) {\n    for (let i = nameTokens.length - 1; i >= 0; i--) {\n      if (!this._containsString(this.NAME_SUFFIXES, nameTokens[i])) {\n        return nameTokens.slice(0, i + 1);\n      }\n    }\n    return [];\n  },\n\n  _isCJKName(name) {\n    // The name is considered to be a CJK name if it is only CJK characters,\n    // spaces, and \"middle dot\" separators, with at least one CJK character, and\n    // no more than 2 words.\n    //\n    // Chinese and Japanese names are usually spelled out using the Han\n    // characters (logographs), which constitute the \"CJK Unified Ideographs\"\n    // block in Unicode, also referred to as Unihan. Korean names are usually\n    // spelled out in the Korean alphabet (Hangul), although they do have a Han\n    // equivalent as well.\n\n    if (!name) {\n      return false;\n    }\n\n    let previousWasCJK = false;\n    let wordCount = 0;\n\n    for (let c of name) {\n      let isMiddleDot = this.MIDDLE_DOT.includes(c);\n      let isCJK = !isMiddleDot && this.reCJK.test(c);\n      if (!isCJK && !isMiddleDot && !this.WHITESPACE.includes(c)) {\n        return false;\n      }\n      if (isCJK && !previousWasCJK) {\n        wordCount++;\n      }\n      previousWasCJK = isCJK;\n    }\n\n    return wordCount > 0 && wordCount < 3;\n  },\n\n  // Tries to split a Chinese, Japanese, or Korean name into its given name &\n  // surname parts. If splitting did not work for whatever reason, returns null.\n  _splitCJKName(nameTokens) {\n    // The convention for CJK languages is to put the surname (last name) first,\n    // and the given name (first name) second. In a continuous text, there is\n    // normally no space between the two parts of the name. When entering their\n    // name into a field, though, some people add a space to disambiguate. CJK\n    // names (almost) never have a middle name.\n\n    let reHangulName = new RegExp(\n      \"^[\" + this.HANGUL_RANGE.join(\"\") + this.WHITESPACE.join(\"\") + \"]+$\",\n      \"u\"\n    );\n    let nameParts = {\n      given: \"\",\n      middle: \"\",\n      family: \"\",\n    };\n\n    if (nameTokens.length == 1) {\n      // There is no space between the surname and given name. Try to infer\n      // where to separate between the two. Most Chinese and Korean surnames\n      // have only one character, but there are a few that have 2. If the name\n      // does not start with a surname from a known list, default to one\n      // character.\n      let name = nameTokens[0];\n      let isKorean = reHangulName.test(name);\n      let surnameLength = 0;\n\n      // 4-character Korean names are more likely to be 2/2 than 1/3, so use\n      // the full list of Korean 2-char surnames. (instead of only the common\n      // ones)\n      let multiCharSurnames =\n        isKorean && name.length > 3\n          ? this.KOREAN_MULTI_CHAR_SURNAMES\n          : this.COMMON_CJK_MULTI_CHAR_SURNAMES;\n\n      // Default to 1 character if the surname is not in the list.\n      surnameLength = multiCharSurnames.some(surname =>\n        name.startsWith(surname)\n      )\n        ? 2\n        : 1;\n\n      nameParts.family = name.substr(0, surnameLength);\n      nameParts.given = name.substr(surnameLength);\n    } else if (nameTokens.length == 2) {\n      // The user entered a space between the two name parts. This makes our job\n      // easier. Family name first, given name second.\n      nameParts.family = nameTokens[0];\n      nameParts.given = nameTokens[1];\n    } else {\n      return null;\n    }\n\n    return nameParts;\n  },\n\n  init() {\n    if (this._dataLoaded) {\n      return;\n    }\n    this._dataLoaded = true;\n\n    this.reCJK = new RegExp(\"[\" + this.CJK_RANGE.join(\"\") + \"]\", \"u\");\n  },\n\n  splitName(name) {\n    let nameParts = {\n      given: \"\",\n      middle: \"\",\n      family: \"\",\n    };\n\n    if (!name) {\n      return nameParts;\n    }\n\n    let nameTokens = name.trim().split(/[ ,\\u3000\\u30FB\\u00B7]+/);\n    nameTokens = this._stripPrefixes(nameTokens);\n\n    if (this._isCJKName(name)) {\n      let parts = this._splitCJKName(nameTokens);\n      if (parts) {\n        return parts;\n      }\n    }\n\n    // Don't assume \"Ma\" is a suffix in John Ma.\n    if (nameTokens.length > 2) {\n      nameTokens = this._stripSuffixes(nameTokens);\n    }\n\n    if (!nameTokens.length) {\n      // Bad things have happened; just assume the whole thing is a given name.\n      nameParts.given = name;\n      return nameParts;\n    }\n\n    // Only one token, assume given name.\n    if (nameTokens.length == 1) {\n      nameParts.given = nameTokens[0];\n      return nameParts;\n    }\n\n    // 2 or more tokens. Grab the family, which is the last word plus any\n    // recognizable family prefixes.\n    let familyTokens = [nameTokens.pop()];\n    while (nameTokens.length) {\n      let lastToken = nameTokens[nameTokens.length - 1];\n      if (!this._containsString(this.FAMILY_NAME_PREFIXES, lastToken)) {\n        break;\n      }\n      familyTokens.unshift(lastToken);\n      nameTokens.pop();\n    }\n    nameParts.family = familyTokens.join(\" \");\n\n    // Take the last remaining token as the middle name (if there are at least 2\n    // tokens).\n    if (nameTokens.length >= 2) {\n      nameParts.middle = nameTokens.pop();\n    }\n\n    // Remainder is given name.\n    nameParts.given = nameTokens.join(\" \");\n\n    return nameParts;\n  },\n\n  joinNameParts({ given, middle, family }) {\n    if (this._isCJKName(given) && this._isCJKName(family) && !middle) {\n      return family + given;\n    }\n    return [given, middle, family]\n      .filter(part => part && part.length)\n      .join(\" \");\n  },\n};\n\nFormAutofillNameUtils.init();\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs":
/*!*****************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormAutofillAddressSection: () => (/* reexport safe */ resource_autofill_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillAddressSection),\n/* harmony export */   FormAutofillCreditCardSection: () => (/* reexport safe */ resource_autofill_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillCreditCardSection),\n/* harmony export */   FormAutofillSection: () => (/* reexport safe */ resource_autofill_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillSection)\n/* harmony export */ });\n/* harmony import */ var resource_autofill_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://autofill/FormAutofillSection.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n// Since we are listening on focus events to ping swift,\n// focusing inputs before filling will cause an infinite loop\nresource_autofill_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillSection.SHOULD_FOCUS_ON_AUTOFILL = false;\n\n\n\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs":
/*!*************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormAutofillAddressSection: () => (/* binding */ FormAutofillAddressSection),\n/* harmony export */   FormAutofillCreditCardSection: () => (/* binding */ FormAutofillCreditCardSection),\n/* harmony export */   FormAutofillSection: () => (/* binding */ FormAutofillSection)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  AutofillTelemetry: \"resource://gre/modules/shared/AutofillTelemetry.sys.mjs\",\n  FormAutofillUtils: \"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\",\n  FormAutofill: \"resource://autofill/FormAutofill.sys.mjs\",\n  OSKeyStore: \"resource://gre/modules/OSKeyStore.sys.mjs\",\n});\n\nclass FormSection {\n  static ADDRESS = \"address\";\n  static CREDIT_CARD = \"creditCard\";\n\n  #fieldDetails = [];\n\n  #name = \"\";\n\n  constructor(fieldDetails) {\n    if (!fieldDetails.length) {\n      throw new TypeError(\"A section should contain at least one field\");\n    }\n\n    fieldDetails.forEach(field => this.addField(field));\n\n    for (const fieldDetail of fieldDetails) {\n      if (lazy.FormAutofillUtils.isAddressField(fieldDetail.fieldName)) {\n        this.type = FormSection.ADDRESS;\n        break;\n      } else if (\n        lazy.FormAutofillUtils.isCreditCardField(fieldDetail.fieldName)\n      ) {\n        this.type = FormSection.CREDIT_CARD;\n        break;\n      }\n    }\n\n    this.type ||= FormSection.ADDRESS;\n  }\n\n  get fieldDetails() {\n    return this.#fieldDetails;\n  }\n\n  get name() {\n    return this.#name;\n  }\n\n  addField(fieldDetail) {\n    this.#name ||= fieldDetail.sectionName;\n    this.#fieldDetails.push(fieldDetail);\n  }\n}\n\nclass FormAutofillSection {\n  /**\n   * Record information for fields that are in this section\n   */\n  #fieldDetails = [];\n\n  constructor(fieldDetails) {\n    this.#fieldDetails = fieldDetails;\n\n    ChromeUtils.defineLazyGetter(this, \"log\", () =>\n      lazy.FormAutofill.defineLogGetter(this, \"FormAutofillSection\")\n    );\n\n    // Identifier used to correlate events relating to the same form\n    this.flowId = Services.uuid.generateUUID().toString();\n    this.log.debug(\n      \"Creating new credit card section with flowId =\",\n      this.flowId\n    );\n  }\n\n  get fieldDetails() {\n    return this.#fieldDetails;\n  }\n\n  get allFieldNames() {\n    return this.fieldDetails.map(field => field.fieldName);\n  }\n\n  /*\n   * Examine the section is a valid section or not based on its fieldDetails or\n   * other information. This method must be overrided.\n   *\n   * @returns {boolean} True for a valid section, otherwise false\n   *\n   */\n  isValidSection() {\n    throw new TypeError(\"isValidSection method must be overrided\");\n  }\n\n  /*\n   * Examine the section is an enabled section type or not based on its\n   * preferences. This method must be overrided.\n   *\n   * @returns {boolean} True for an enabled section type, otherwise false\n   *\n   */\n  isEnabled() {\n    throw new TypeError(\"isEnabled method must be overrided\");\n  }\n\n  /*\n   * Examine the section is createable for storing the profile. This method\n   * must be overrided.\n   *\n   * @param {Object} _record The record for examining createable\n   * @returns {boolean} True for the record is createable, otherwise false\n   *\n   */\n  isRecordCreatable(_record) {\n    throw new TypeError(\"isRecordCreatable method must be overridden\");\n  }\n\n  /**\n   * Override this method if the profile is needed to be customized for\n   * previewing values.\n   *\n   * @param {object} _profile\n   *        A profile for pre-processing before previewing values.\n   * @returns {boolean} Whether the profile should be previewed.\n   */\n  preparePreviewProfile(_profile) {\n    return true;\n  }\n\n  /**\n   * Override this method if the profile is needed to be customized for filling\n   * values.\n   *\n   * @param {object} _profile\n   *        A profile for pre-processing before filling values.\n   * @returns {boolean} Whether the profile should be filled.\n   */\n  async prepareFillingProfile(_profile) {\n    return true;\n  }\n\n  /**\n   * The result is an array contains the sections with its belonging field details.\n   *\n   * @param   {Array<FieldDetails>} fieldDetails field detail array to be classified\n   * @param   {object} options\n   * @param   {boolean} [options.ignoreInvalidSection = false]\n   *          True to keep invalid section in the return array. Only used by tests now\n   * @param   {boolean} [options.ignoreUnknownField = true]\n   *          False to keep unknown field in a section. Only used by developer tools now\n   * @returns {Array<FormSection>} The array with the sections.\n   */\n  static classifySections(\n    fieldDetails,\n    { ignoreInvalidSection = false, ignoreUnknownField = true } = {}\n  ) {\n    const addressFields = [];\n    const creditCardFields = [];\n\n    // 'current' refers to the last list where an field was added to.\n    // It helps determine the appropriate list for unknown fields, defaulting to the address\n    // field list for simplicity\n    let current = addressFields;\n    for (const fieldDetail of fieldDetails) {\n      if (lazy.FormAutofillUtils.isAddressField(fieldDetail.fieldName)) {\n        current = addressFields;\n      } else if (\n        lazy.FormAutofillUtils.isCreditCardField(fieldDetail.fieldName)\n      ) {\n        current = creditCardFields;\n      } else if (ignoreUnknownField) {\n        continue;\n      }\n      current.push(fieldDetail);\n    }\n\n    const addressSections = FormAutofillSection.groupFields(addressFields);\n    const creditCardSections =\n      FormAutofillSection.groupFields(creditCardFields);\n\n    const sections = [...addressSections, ...creditCardSections].sort(\n      (a, b) =>\n        fieldDetails.indexOf(a.fieldDetails[0]) -\n        fieldDetails.indexOf(b.fieldDetails[0])\n    );\n\n    const autofillableSections = [];\n    for (const section of sections) {\n      if (!section.fieldDetails.length) {\n        continue;\n      }\n\n      const autofillableSection =\n        section.type == FormSection.ADDRESS\n          ? new FormAutofillAddressSection(section.fieldDetails)\n          : new FormAutofillCreditCardSection(section.fieldDetails);\n\n      if (ignoreInvalidSection && !autofillableSection.isValidSection()) {\n        continue;\n      }\n\n      autofillableSections.push(autofillableSection);\n    }\n    return autofillableSections;\n  }\n\n  /**\n   * Groups fields into sections based on:\n   * 1. Their `sectionName` attribute.\n   * 2. Whether the section already contains a field with the same `fieldName`,\n   *    If so, a new section is created.\n   *\n   * @param {Array} fieldDetails An array of field detail objects.\n   * @returns {Array} An array of FormSection objects.\n   */\n  static groupFields(fieldDetails) {\n    let sections = [];\n    for (let i = 0; i < fieldDetails.length; i++) {\n      const cur = fieldDetails[i];\n      const [currentSection] = sections.slice(-1);\n\n      // The section this field might be placed into.\n      let candidateSection = null;\n\n      // Use name group from autocomplete attribute (ex, section-xxx) to look for the section\n      // we might place this field into.\n      // If the field doesn't have a section name, the candidate section is the previous section.\n      if (!currentSection || !cur.sectionName) {\n        candidateSection = currentSection;\n      } else if (cur.sectionName) {\n        // If the field has a section name, the candidate section is the nearest section that\n        // either shares the same name or lacks a name.\n        for (let idx = sections.length - 1; idx >= 0; idx--) {\n          if (!sections[idx].name || sections[idx].name == cur.sectionName) {\n            candidateSection = sections[idx];\n            break;\n          }\n        }\n      }\n\n      if (candidateSection) {\n        // The field will still be placed in a new section if it is a duplicate of\n        // an existing field, unless it is a duplicate of the previous field. This\n        // allows for fields that might commonly appear twice such as a verification\n        // email field, an invisible field that appears next to the user-visible field,\n        // and simple cases where a page error where a field name is reused twice.\n        let dupIndex = candidateSection.fieldDetails.findIndex(\n          f => f.fieldName == cur.fieldName && f.isVisible && cur.isVisible\n        );\n        let isDuplicate = dupIndex != -1;\n\n        if (isDuplicate) {\n          const [last] = candidateSection.fieldDetails.slice(-1);\n          if (last.fieldName == cur.fieldName) {\n            isDuplicate = false;\n          } else if (\n            lazy.FormAutofillUtils.getCategoryFromFieldName(cur.fieldName) ==\n            \"name\"\n          ) {\n            // If the duplicate field is in the \"name\" category (e.g., family-name, given-name),\n            // we check whether all fields starting from the first duplicate also belong to the\n            // name category. If they do, we don't consider the field a duplicate, since name\n            // fields often appear in groups like family-name + given-name.\n            isDuplicate = !candidateSection.fieldDetails\n              .slice(dupIndex)\n              .every(\n                f =>\n                  lazy.FormAutofillUtils.getCategoryFromFieldName(\n                    f.fieldName\n                  ) === \"name\"\n              );\n          }\n        }\n\n        if (!isDuplicate) {\n          candidateSection.addField(cur);\n          continue;\n        }\n      }\n\n      // Create a new section\n      sections.push(new FormSection([cur]));\n    }\n\n    return sections;\n  }\n\n  /**\n   * Return the record that is converted from the element's value.\n   * The `valueByElementId` is passed by the child process.\n   *\n   * @returns {object} object keyed by field name, and values are field values.\n   */\n  createRecord(formFilledData) {\n    if (!this.fieldDetails.length) {\n      return {};\n    }\n\n    const data = {\n      flowId: this.flowId,\n      record: {},\n    };\n\n    for (const detail of this.fieldDetails) {\n      // Do not save security code.\n      if (detail.fieldName == \"cc-csc\") {\n        continue;\n      }\n      const { filledValue } = formFilledData.get(detail.elementId) ?? {};\n\n      if (\n        !filledValue ||\n        filledValue.length > lazy.FormAutofillUtils.MAX_FIELD_VALUE_LENGTH\n      ) {\n        // Keep the property and preserve more information for updating\n        data.record[detail.fieldName] = \"\";\n      } else if (detail.part > 1) {\n        // If there are multiple parts for the same field, concatenate the values.\n        // This is now used in cases where the credit card number field\n        // is split into multiple fields.\n        data.record[detail.fieldName] += filledValue;\n      } else {\n        data.record[detail.fieldName] = filledValue;\n      }\n    }\n\n    if (!this.isRecordCreatable(data.record)) {\n      return null;\n    }\n\n    return data;\n  }\n\n  /**\n   * Heuristics to determine which fields to autofill when a section contains\n   * multiple fields of the same type.\n   */\n  getAutofillFields() {\n    return this.fieldDetails.filter(fieldDetail => {\n      // We don't save security code, but if somehow the profile has securty code,\n      // make sure we don't autofill it.\n      if (fieldDetail.fieldName == \"cc-csc\") {\n        return false;\n      }\n\n      // When both visible and invisible elements exist, we only autofill the\n      // visible element.\n      if (!fieldDetail.isVisible) {\n        return !this.fieldDetails.some(\n          field => field.fieldName == fieldDetail.fieldName && field.isVisible\n        );\n      }\n      return true;\n    });\n  }\n\n  /*\n   * For telemetry\n   */\n  onDetected() {\n    if (!this.isValidSection()) {\n      return;\n    }\n\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\n      \"detected\",\n      this.flowId,\n      this.fieldDetails\n    );\n  }\n\n  onPopupOpened(elementId) {\n    const fieldDetail = this.getFieldDetailByElementId(elementId);\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\n      \"popup_shown\",\n      this.flowId,\n      [fieldDetail]\n    );\n  }\n\n  onFilled(filledResult) {\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\n      \"filled\",\n      this.flowId,\n      this.fieldDetails,\n      filledResult\n    );\n  }\n\n  onFilledOnFieldsUpdate(filledResult) {\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\n      \"filled_on_fields_update\",\n      this.flowId,\n      this.fieldDetails,\n      filledResult\n    );\n  }\n\n  onFilledModified(elementId) {\n    const fieldDetail = this.getFieldDetailByElementId(elementId);\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\n      \"filled_modified\",\n      this.flowId,\n      [fieldDetail]\n    );\n  }\n\n  onSubmitted(formFilledData) {\n    this.submitted = true;\n\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\n      \"submitted\",\n      this.flowId,\n      this.fieldDetails,\n      formFilledData\n    );\n  }\n\n  onCleared(elementId) {\n    const fieldDetail = this.getFieldDetailByElementId(elementId);\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\"cleared\", this.flowId, [\n      fieldDetail,\n    ]);\n  }\n\n  /**\n   * Utility functions\n   */\n  getFieldDetailByElementId(elementId) {\n    return this.fieldDetails.find(detail => detail.elementId == elementId);\n  }\n\n  /**\n   * Groups an array of field details by their browsing context IDs.\n   *\n   * @param {Array} fieldDetails\n   *        Array of fieldDetails object\n   *\n   * @returns {object}\n   *        An object keyed by BrowsingContext Id, value is an array that\n   *        contains all fieldDetails with the same BrowsingContext id.\n   */\n  static groupFieldDetailsByBrowsingContext(fieldDetails) {\n    const detailsByBC = {};\n    for (const fieldDetail of fieldDetails) {\n      const bcid = fieldDetail.browsingContextId;\n      if (detailsByBC[bcid]) {\n        detailsByBC[bcid].push(fieldDetail);\n      } else {\n        detailsByBC[bcid] = [fieldDetail];\n      }\n    }\n    return detailsByBC;\n  }\n}\n\nclass FormAutofillAddressSection extends FormAutofillSection {\n  isValidSection() {\n    const fields = new Set(this.fieldDetails.map(f => f.fieldName));\n    return fields.size >= lazy.FormAutofillUtils.AUTOFILL_FIELDS_THRESHOLD;\n  }\n\n  isEnabled() {\n    return lazy.FormAutofill.isAutofillAddressesEnabled;\n  }\n\n  isRecordCreatable(record) {\n    const country = lazy.FormAutofillUtils.identifyCountryCode(\n      record.country || record[\"country-name\"]\n    );\n    if (\n      country &&\n      !lazy.FormAutofill.isAutofillAddressesAvailableInCountry(country)\n    ) {\n      // We don't want to save data in the wrong fields due to not having proper\n      // heuristic regexes in countries we don't yet support.\n      this.log.warn(\n        \"isRecordCreatable: Country not supported:\",\n        record.country\n      );\n      return false;\n    }\n\n    // Multiple name or tel fields are treat as 1 field while countng whether\n    // the number of fields exceed the valid address secton threshold\n    const categories = Object.entries(record)\n      .filter(e => !!e[1])\n      .map(e => lazy.FormAutofillUtils.getCategoryFromFieldName(e[0]));\n\n    return (\n      categories.reduce(\n        (acc, category) =>\n          [\"name\", \"tel\"].includes(category) && acc.includes(category)\n            ? acc\n            : [...acc, category],\n        []\n      ).length >= lazy.FormAutofillUtils.AUTOFILL_FIELDS_THRESHOLD\n    );\n  }\n}\n\nclass FormAutofillCreditCardSection extends FormAutofillSection {\n  /**\n   * Determine whether a set of cc fields identified by our heuristics form a\n   * valid credit card section.\n   * There are 4 different cases when a field is considered a credit card field\n   * 1. Identified by autocomplete attribute. ex <input autocomplete=\"cc-number\">\n   * 2. Identified by fathom and fathom is pretty confident (when confidence\n   *    value is higher than `highConfidenceThreshold`)\n   * 3. Identified by fathom. Confidence value is between `fathom.confidenceThreshold`\n   *    and `fathom.highConfidenceThreshold`\n   * 4. Identified by regex-based heurstic. There is no confidence value in thise case.\n   *\n   * A form is considered a valid credit card form when one of the following condition\n   * is met:\n   * A. One of the cc field is identified by autocomplete (case 1)\n   * B. One of the cc field is identified by fathom (case 2 or 3), and there is also\n   *    another cc field found by any of our heuristic (case 2, 3, or 4)\n   * C. Only one cc field is found in the section, but fathom is very confident (Case 2).\n   *    Currently we add an extra restriction to this rule to decrease the false-positive\n   *    rate. See comments below for details.\n   *\n   * @returns {boolean} True for a valid section, otherwise false\n   */\n  isValidSection() {\n    let ccNumberDetail = null;\n    let ccNameDetail = null;\n    let ccExpiryDetail = null;\n\n    for (let detail of this.fieldDetails) {\n      switch (detail.fieldName) {\n        case \"cc-number\":\n          ccNumberDetail = detail;\n          break;\n        case \"cc-name\":\n        case \"cc-given-name\":\n        case \"cc-additional-name\":\n        case \"cc-family-name\":\n          ccNameDetail = detail;\n          break;\n        case \"cc-exp\":\n        case \"cc-exp-month\":\n        case \"cc-exp-year\":\n          ccExpiryDetail = detail;\n          break;\n      }\n    }\n\n    // Condition A. Always trust autocomplete attribute. A section is considered a valid\n    // cc section as long as a field has autocomplete=cc-number, cc-name or cc-exp*\n    if (\n      ccNumberDetail?.reason == \"autocomplete\" ||\n      ccNameDetail?.reason == \"autocomplete\" ||\n      ccExpiryDetail?.reason == \"autocomplete\"\n    ) {\n      return true;\n    }\n\n    // Condition B. One of the field is identified by fathom, if this section also\n    // contains another cc field found by our heuristic (Case 2, 3, or 4), we consider\n    // this section a valid credit card seciton\n    if (ccNumberDetail?.reason == \"fathom\") {\n      if (ccNameDetail || ccExpiryDetail) {\n        return true;\n      }\n    } else if (ccNameDetail?.reason == \"fathom\") {\n      if (ccNumberDetail || ccExpiryDetail) {\n        return true;\n      }\n    }\n\n    // Condition C.\n    if (\n      ccNumberDetail?.isOnlyVisibleFieldWithHighConfidence ||\n      ccNameDetail?.isOnlyVisibleFieldWithHighConfidence\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  isEnabled() {\n    return lazy.FormAutofill.isAutofillCreditCardsEnabled;\n  }\n\n  isRecordCreatable(record) {\n    return (\n      record[\"cc-number\"] &&\n      lazy.FormAutofillUtils.isCCNumber(record[\"cc-number\"])\n    );\n  }\n\n  /**\n   * Customize for previewing profile\n   *\n   * @param {object} profile\n   *        A profile for pre-processing before previewing values.\n   * @returns {boolean} Whether the profile should be filled.\n   * @override\n   */\n  preparePreviewProfile(profile) {\n    if (!profile) {\n      return true;\n    }\n\n    // Always show the decrypted credit card number when Master Password is\n    // disabled.\n    if (profile[\"cc-number-decrypted\"]) {\n      profile[\"cc-number\"] = profile[\"cc-number-decrypted\"];\n    } else if (!profile[\"cc-number\"].startsWith(\"****\")) {\n      // Show the previewed credit card as \"**** 4444\" which is\n      // needed when a credit card number field has a maxlength of four.\n      profile[\"cc-number\"] = \"****\" + profile[\"cc-number\"];\n    }\n\n    return true;\n  }\n\n  /**\n   * Customize for filling profile\n   *\n   * @param {object} profile\n   *        A profile for pre-processing before filling values.\n   * @returns {boolean} Whether the profile should be filled.\n   * @override\n   */\n  async prepareFillingProfile(profile) {\n    // Prompt the OS login dialog to get the decrypted credit card number.\n    if (profile[\"cc-number-encrypted\"]) {\n      const promptMessage = lazy.FormAutofillUtils.reauthOSPromptMessage(\n        \"autofill-use-payment-method-os-prompt-macos\",\n        \"autofill-use-payment-method-os-prompt-windows\",\n        \"autofill-use-payment-method-os-prompt-other\"\n      );\n      let decrypted;\n      let result;\n      try {\n        decrypted = await this.getDecryptedString(\n          profile[\"cc-number-encrypted\"],\n          promptMessage\n        );\n        result = decrypted ? \"success\" : \"fail_user_canceled\";\n      } catch (ex) {\n        result = \"fail_error\";\n        throw ex;\n      } finally {\n        Glean.formautofill.promptShownOsReauth.record({\n          trigger: \"autofill\",\n          result,\n        });\n      }\n      if (!decrypted) {\n        // Early return if the decrypted is empty or undefined\n        return false;\n      }\n      profile[\"cc-number\"] = decrypted;\n    }\n    return true;\n  }\n\n  async getDecryptedString(cipherText, reauth) {\n    if (\n      !lazy.FormAutofillUtils.getOSAuthEnabled(\n        lazy.FormAutofill.AUTOFILL_CREDITCARDS_REAUTH_PREF\n      )\n    ) {\n      this.log.debug(\"Reauth is disabled\");\n      reauth = false;\n    }\n    let string;\n    let errorResult = 0;\n    try {\n      string = await lazy.OSKeyStore.decrypt(cipherText, reauth);\n    } catch (e) {\n      errorResult = e.result;\n      if (e.result != Cr.NS_ERROR_ABORT) {\n        throw e;\n      }\n      this.log.warn(\"User canceled encryption login\");\n    } finally {\n      Glean.creditcard.osKeystoreDecrypt.record({\n        isDecryptSuccess: errorResult === 0,\n        errorResult,\n        trigger: \"autofill\",\n      });\n    }\n    return string;\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs":
/*!***********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormAutofillUtils: () => (/* binding */ FormAutofillUtils)\n/* harmony export */ });\n/* harmony import */ var resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://autofill/FormAutofill.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs\");\n/* harmony import */ var resource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/AppConstants.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  ContentDOMReference: \"resource://gre/modules/ContentDOMReference.sys.mjs\",\n  CreditCard: \"resource://gre/modules/CreditCard.sys.mjs\",\n  FormAutofillNameUtils:\n    \"resource://gre/modules/shared/FormAutofillNameUtils.sys.mjs\",\n  OSKeyStore: \"resource://gre/modules/OSKeyStore.sys.mjs\",\n  AddressMetaDataLoader:\n    \"resource://gre/modules/shared/AddressMetaDataLoader.sys.mjs\",\n});\n\nChromeUtils.defineLazyGetter(\n  lazy,\n  \"l10n\",\n  () =>\n    new Localization(\n      [\"toolkit/formautofill/formAutofill.ftl\", \"branding/brand.ftl\"],\n      true\n    )\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyServiceGetter(\n  lazy,\n  \"Crypto\",\n  \"@mozilla.org/login-manager/crypto/SDR;1\",\n  \"nsILoginManagerCrypto\"\n);\n\nlet FormAutofillUtils;\n\nconst ADDRESSES_COLLECTION_NAME = \"addresses\";\nconst CREDITCARDS_COLLECTION_NAME = \"creditCards\";\nconst AUTOFILL_CREDITCARDS_REAUTH_PREF =\n  resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.AUTOFILL_CREDITCARDS_REAUTH_PREF;\nconst MANAGE_ADDRESSES_L10N_IDS = [\n  \"autofill-add-address-title\",\n  \"autofill-manage-addresses-title\",\n];\nconst EDIT_ADDRESS_L10N_IDS = [\n  \"autofill-address-name\",\n  \"autofill-address-organization\",\n  \"autofill-address-street\",\n  \"autofill-address-state\",\n  \"autofill-address-province\",\n  \"autofill-address-city\",\n  \"autofill-address-country\",\n  \"autofill-address-zip\",\n  \"autofill-address-postal-code\",\n  \"autofill-address-email\",\n  \"autofill-address-tel\",\n  \"autofill-edit-address-title\",\n  \"autofill-address-neighborhood\",\n  \"autofill-address-village-township\",\n  \"autofill-address-island\",\n  \"autofill-address-townland\",\n  \"autofill-address-district\",\n  \"autofill-address-county\",\n  \"autofill-address-post-town\",\n  \"autofill-address-suburb\",\n  \"autofill-address-parish\",\n  \"autofill-address-prefecture\",\n  \"autofill-address-area\",\n  \"autofill-address-do-si\",\n  \"autofill-address-department\",\n  \"autofill-address-emirate\",\n  \"autofill-address-oblast\",\n  \"autofill-address-pin\",\n  \"autofill-address-eircode\",\n  \"autofill-address-country-only\",\n  \"autofill-cancel-button\",\n  \"autofill-save-button\",\n];\nconst MANAGE_CREDITCARDS_L10N_IDS = [\n  \"autofill-add-card-title\",\n  \"autofill-manage-payment-methods-title\",\n];\nconst EDIT_CREDITCARD_L10N_IDS = [\n  \"autofill-card-number\",\n  \"autofill-card-name-on-card\",\n  \"autofill-card-expires-month\",\n  \"autofill-card-expires-year\",\n  \"autofill-card-network\",\n];\nconst FIELD_STATES = {\n  NORMAL: \"\",\n  AUTO_FILLED: \"autofill\",\n  PREVIEW: \"preview\",\n};\nconst FORM_SUBMISSION_REASON = {\n  FORM_SUBMIT_EVENT: \"form-submit-event\",\n  FORM_REMOVAL_AFTER_FETCH: \"form-removal-after-fetch\",\n  IFRAME_PAGEHIDE: \"iframe-pagehide\",\n  PAGE_NAVIGATION: \"page-navigation\",\n};\n\nconst ELIGIBLE_ELEMENT_TYPES = [\"input\", \"select\", \"textarea\"];\nconst ELIGIBLE_INPUT_TYPES = [\n  \"text\",\n  \"email\",\n  \"tel\",\n  \"number\",\n  \"month\",\n  \"search\",\n];\n\n// The maximum length of data to be saved in a single field for preventing DoS\n// attacks that fill the user's hard drive(s).\nconst MAX_FIELD_VALUE_LENGTH = 200;\n\nFormAutofillUtils = {\n  get AUTOFILL_FIELDS_THRESHOLD() {\n    return 3;\n  },\n\n  ADDRESSES_COLLECTION_NAME,\n  CREDITCARDS_COLLECTION_NAME,\n  AUTOFILL_CREDITCARDS_REAUTH_PREF,\n  MANAGE_ADDRESSES_L10N_IDS,\n  EDIT_ADDRESS_L10N_IDS,\n  MANAGE_CREDITCARDS_L10N_IDS,\n  EDIT_CREDITCARD_L10N_IDS,\n  MAX_FIELD_VALUE_LENGTH,\n  FIELD_STATES,\n  FORM_SUBMISSION_REASON,\n  ELIGIBLE_ELEMENT_TYPES,\n  ELIGIBLE_INPUT_TYPES,\n\n  _fieldNameInfo: {\n    name: \"name\",\n    \"given-name\": \"name\",\n    \"additional-name\": \"name\",\n    \"family-name\": \"name\",\n    organization: \"organization\",\n    \"street-address\": \"address\",\n    \"address-line1\": \"address\",\n    \"address-line2\": \"address\",\n    \"address-line3\": \"address\",\n    \"address-level1\": \"address\",\n    \"address-level2\": \"address\",\n    \"address-level3\": \"address\",\n    // DE addresses are often split into street name and house number;\n    // combined they form address-line1\n    \"address-streetname\": \"address\",\n    \"address-housenumber\": \"address\",\n    \"postal-code\": \"address\",\n    country: \"address\",\n    \"country-name\": \"address\",\n    tel: \"tel\",\n    \"tel-country-code\": \"tel\",\n    \"tel-national\": \"tel\",\n    \"tel-area-code\": \"tel\",\n    \"tel-local\": \"tel\",\n    \"tel-local-prefix\": \"tel\",\n    \"tel-local-suffix\": \"tel\",\n    \"tel-extension\": \"tel\",\n    email: \"email\",\n    \"cc-name\": \"creditCard\",\n    \"cc-given-name\": \"creditCard\",\n    \"cc-additional-name\": \"creditCard\",\n    \"cc-family-name\": \"creditCard\",\n    \"cc-number\": \"creditCard\",\n    \"cc-exp-month\": \"creditCard\",\n    \"cc-exp-year\": \"creditCard\",\n    \"cc-exp\": \"creditCard\",\n    \"cc-type\": \"creditCard\",\n    \"cc-csc\": \"creditCard\",\n  },\n\n  _collators: {},\n  _reAlternativeCountryNames: {},\n\n  isAddressField(fieldName) {\n    return (\n      !!this._fieldNameInfo[fieldName] && !this.isCreditCardField(fieldName)\n    );\n  },\n\n  isCreditCardField(fieldName) {\n    return this._fieldNameInfo?.[fieldName] == \"creditCard\";\n  },\n\n  isCCNumber(ccNumber) {\n    return ccNumber && lazy.CreditCard.isValidNumber(ccNumber);\n  },\n\n  isTextControl(element) {\n    return (\n      HTMLInputElement.isInstance(element) ||\n      HTMLTextAreaElement.isInstance(element)\n    );\n  },\n\n  queryEligibleElements(element, includeIframe = false) {\n    const types = includeIframe\n      ? [...ELIGIBLE_ELEMENT_TYPES, \"iframe\"]\n      : ELIGIBLE_ELEMENT_TYPES;\n    return Array.from(element.querySelectorAll(types.join(\",\")));\n  },\n\n  /**\n   * Get the decrypted value for a string pref.\n   *\n   * @param {string} prefName -> The pref whose value is needed.\n   * @param {string} safeDefaultValue -> Value to be returned incase the pref is not yet set.\n   * @returns {string}\n   */\n  getSecurePref(prefName, safeDefaultValue) {\n    if (Services.prefs.getBoolPref(\"security.nocertdb\", false)) {\n      return false;\n    }\n    try {\n      const encryptedValue = Services.prefs.getStringPref(prefName, \"\");\n      return encryptedValue === \"\"\n        ? safeDefaultValue\n        : lazy.Crypto.decrypt(encryptedValue);\n    } catch {\n      return safeDefaultValue;\n    }\n  },\n\n  /**\n   * Set the pref to the encrypted form of the value.\n   *\n   * @param {string} prefName -> The pref whose value is to be set.\n   * @param {string} value -> The value to be set in its encrypted form.\n   */\n  setSecurePref(prefName, value) {\n    if (Services.prefs.getBoolPref(\"security.nocertdb\", false)) {\n      return;\n    }\n    if (value) {\n      const encryptedValue = lazy.Crypto.encrypt(value);\n      Services.prefs.setStringPref(prefName, encryptedValue);\n    } else {\n      Services.prefs.clearUserPref(prefName);\n    }\n  },\n\n  /**\n   * Get whether the OSAuth is enabled or not.\n   *\n   * @param {string} prefName -> The name of the pref (creditcards or addresses)\n   * @returns {boolean}\n   */\n  getOSAuthEnabled(prefName) {\n    return (\n      lazy.OSKeyStore.canReauth() &&\n      this.getSecurePref(prefName, \"\") !== \"opt out\"\n    );\n  },\n\n  /**\n   * Set whether the OSAuth is enabled or not.\n   *\n   * @param {string} prefName -> The pref to encrypt.\n   * @param {boolean} enable -> Whether the pref is to be enabled.\n   */\n  setOSAuthEnabled(prefName, enable) {\n    this.setSecurePref(prefName, enable ? null : \"opt out\");\n  },\n\n  async verifyUserOSAuth(\n    prefName,\n    promptMessage,\n    captionDialog = \"\",\n    parentWindow = null,\n    generateKeyIfNotAvailable = true\n  ) {\n    if (!this.getOSAuthEnabled(prefName)) {\n      promptMessage = false;\n    }\n    try {\n      return (\n        await lazy.OSKeyStore.ensureLoggedIn(\n          promptMessage,\n          captionDialog,\n          parentWindow,\n          generateKeyIfNotAvailable\n        )\n      ).authenticated;\n    } catch (ex) {\n      // Since Win throws an exception whereas Mac resolves to false upon cancelling.\n      if (ex.result !== Cr.NS_ERROR_FAILURE) {\n        throw ex;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Get the array of credit card network ids (\"types\") we expect and offer as valid choices\n   *\n   * @returns {Array}\n   */\n  getCreditCardNetworks() {\n    return lazy.CreditCard.getSupportedNetworks();\n  },\n\n  getCategoryFromFieldName(fieldName) {\n    return this._fieldNameInfo[fieldName];\n  },\n\n  getCategoriesFromFieldNames(fieldNames) {\n    let categories = new Set();\n    for (let fieldName of fieldNames) {\n      let info = this.getCategoryFromFieldName(fieldName);\n      if (info) {\n        categories.add(info);\n      }\n    }\n    return Array.from(categories);\n  },\n\n  getCollectionNameFromFieldName(fieldName) {\n    return this.isCreditCardField(fieldName)\n      ? CREDITCARDS_COLLECTION_NAME\n      : ADDRESSES_COLLECTION_NAME;\n  },\n\n  getAddressSeparator() {\n    // The separator should be based on the L10N address format, and using a\n    // white space is a temporary solution.\n    return \" \";\n  },\n\n  /**\n   * Get address display label. It should display information separated\n   * by a comma.\n   *\n   * @param  {object} address\n   * @returns {string}\n   */\n  getAddressLabel(address) {\n    // TODO: Implement a smarter way for deciding what to display\n    //       as option text. Possibly improve the algorithm in\n    //       ProfileAutoCompleteResult.sys.mjs and reuse it here.\n    let fieldOrder = [\n      \"name\",\n      \"-moz-street-address-one-line\", // Street address\n      \"address-level3\", // Townland / Neighborhood / Village\n      \"address-level2\", // City/Town\n      \"organization\", // Company or organization name\n      \"address-level1\", // Province/State (Standardized code if possible)\n      \"country\", // Country name\n      \"postal-code\", // Postal code\n      \"tel\", // Phone number\n      \"email\", // Email address\n    ];\n\n    address = { ...address };\n    let parts = [];\n    if (address[\"street-address\"]) {\n      address[\"-moz-street-address-one-line\"] = this.toOneLineAddress(\n        address[\"street-address\"]\n      );\n    }\n\n    if (!(\"name\" in address)) {\n      address.name = lazy.FormAutofillNameUtils.joinNameParts({\n        given: address[\"given-name\"],\n        middle: address[\"additional-name\"],\n        family: address[\"family-name\"],\n      });\n    }\n\n    for (const fieldName of fieldOrder) {\n      let string = address[fieldName];\n      if (string) {\n        parts.push(string);\n      }\n    }\n    return parts.join(\", \");\n  },\n\n  /**\n   * Internal method to split an address to multiple parts per the provided delimiter,\n   * removing blank parts.\n   *\n   * @param {string} address The address the split\n   * @param {string} [delimiter] The separator that is used between lines in the address\n   * @returns {string[]}\n   */\n  _toStreetAddressParts(address, delimiter = \"\\n\") {\n    let array = typeof address == \"string\" ? address.split(delimiter) : address;\n\n    if (!Array.isArray(array)) {\n      return [];\n    }\n    return array.map(s => (s ? s.trim() : \"\")).filter(s => s);\n  },\n\n  /**\n   * Converts a street address to a single line, removing linebreaks marked by the delimiter\n   *\n   * @param {string} address The address the convert\n   * @param {string} [delimiter] The separator that is used between lines in the address\n   * @returns {string}\n   */\n  toOneLineAddress(address, delimiter = \"\\n\") {\n    let addressParts = this._toStreetAddressParts(address, delimiter);\n    return addressParts.join(this.getAddressSeparator());\n  },\n\n  /**\n   * Returns false if an address is written <number> <street>\n   * and true if an address is written <street> <number>. In the future, this\n   * can be expanded to format an address\n   */\n  getAddressReversed(region) {\n    return this.getCountryAddressData(region).address_reversed;\n  },\n\n  /**\n   * In-place concatenate tel-related components into a single \"tel\" field and\n   * delete unnecessary fields.\n   *\n   * @param {object} address An address record.\n   */\n  compressTel(address) {\n    let telCountryCode = address[\"tel-country-code\"] || \"\";\n    let telAreaCode = address[\"tel-area-code\"] || \"\";\n\n    if (!address.tel) {\n      if (address[\"tel-national\"]) {\n        address.tel = telCountryCode + address[\"tel-national\"];\n      } else if (address[\"tel-local\"]) {\n        address.tel = telCountryCode + telAreaCode + address[\"tel-local\"];\n      } else if (address[\"tel-local-prefix\"] && address[\"tel-local-suffix\"]) {\n        address.tel =\n          telCountryCode +\n          telAreaCode +\n          address[\"tel-local-prefix\"] +\n          address[\"tel-local-suffix\"];\n      }\n    }\n\n    for (let field in address) {\n      if (field != \"tel\" && this.getCategoryFromFieldName(field) == \"tel\") {\n        delete address[field];\n      }\n    }\n  },\n\n  /**\n   * Determines if an element can be autofilled or not.\n   *\n   * @param {HTMLElement} element\n   * @returns {boolean} true if the element can be autofilled\n   */\n  isFieldAutofillable(element) {\n    return element && !element.readOnly && !element.disabled;\n  },\n\n  /**\n   * Determines if an element is visually hidden or not.\n   *\n   * @param {HTMLElement} element\n   * @param {boolean} visibilityCheck true to run visiblity check against\n   *                  element.checkVisibility API. Otherwise, test by only checking\n   *                  `hidden` and `display` attributes\n   * @returns {boolean} true if the element is visible\n   */\n  isFieldVisible(element, visibilityCheck = true) {\n    if (\n      visibilityCheck &&\n      element.checkVisibility &&\n      !FormAutofillUtils.ignoreVisibilityCheck\n    ) {\n      if (\n        !element.checkVisibility({\n          checkOpacity: true,\n          checkVisibilityCSS: true,\n        })\n      ) {\n        return false;\n      }\n    } else if (element.hidden || element.style.display == \"none\") {\n      return false;\n    }\n\n    return element.getAttribute(\"aria-hidden\") != \"true\";\n  },\n\n  /**\n   * Determines if an element is eligible to be used by credit card or address autofill.\n   *\n   * @param {HTMLElement} element\n   * @returns {boolean} true if element can be used by credit card or address autofill\n   */\n  isCreditCardOrAddressFieldType(element) {\n    if (!element) {\n      return false;\n    }\n\n    if (HTMLInputElement.isInstance(element)) {\n      // `element.type` can be recognized as `text`, if it's missing or invalid.\n      return ELIGIBLE_INPUT_TYPES.includes(element.type);\n    }\n\n    if (HTMLTextAreaElement.isInstance(element)) {\n      return true;\n    }\n\n    return HTMLSelectElement.isInstance(element);\n  },\n\n  loadDataFromScript(url, sandbox = {}) {\n    Services.scriptloader.loadSubScript(url, sandbox);\n    return sandbox;\n  },\n\n  /**\n   * Get country address data and fallback to US if not found.\n   * See AddressMetaDataLoader.#loadData for more details of addressData structure.\n   *\n   * @param {string} [country=FormAutofill.DEFAULT_REGION]\n   *        The country code for requesting specific country's metadata. It'll be\n   *        default region if parameter is not set.\n   * @param {string} [level1=null]\n   *        Return address level 1/level 2 metadata if parameter is set.\n   * @returns {object|null}\n   *          Return metadata of specific region with default locale and other supported\n   *          locales. We need to return a default country metadata for layout format\n   *          and collator, but for sub-region metadata we'll just return null if not found.\n   */\n  getCountryAddressRawData(\n    country = resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.DEFAULT_REGION,\n    level1 = null\n  ) {\n    let metadata = lazy.AddressMetaDataLoader.getData(country, level1);\n    if (!metadata) {\n      if (level1) {\n        return null;\n      }\n      // Fallback to default region if we couldn't get data from given country.\n      if (country != resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.DEFAULT_REGION) {\n        metadata = lazy.AddressMetaDataLoader.getData(\n          resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.DEFAULT_REGION\n        );\n      }\n    }\n\n    // TODO: Now we fallback to US if we couldn't get data from default region,\n    //       but it could be removed in bug 1423464 if it's not necessary.\n    if (!metadata) {\n      metadata = lazy.AddressMetaDataLoader.getData(\"US\");\n    }\n    return metadata;\n  },\n\n  /**\n   * Get country address data with default locale.\n   *\n   * @param {string} country\n   * @param {string} level1\n   * @returns {object|null} Return metadata of specific region with default locale.\n   *          NOTE: The returned data may be for a default region if the\n   *          specified one cannot be found. Callers who only want the specific\n   *          region should check the returned country code.\n   */\n  getCountryAddressData(country, level1) {\n    let metadata = this.getCountryAddressRawData(country, level1);\n    return metadata && metadata.defaultLocale;\n  },\n\n  /**\n   * Get country address data with all locales.\n   *\n   * @param {string} country\n   * @param {string} level1\n   * @returns {Array<object> | null}\n   *          Return metadata of specific region with all the locales.\n   *          NOTE: The returned data may be for a default region if the\n   *          specified one cannot be found. Callers who only want the specific\n   *          region should check the returned country code.\n   */\n  getCountryAddressDataWithLocales(country, level1) {\n    let metadata = this.getCountryAddressRawData(country, level1);\n    return metadata && [metadata.defaultLocale, ...metadata.locales];\n  },\n\n  /**\n   * Get the collators based on the specified country.\n   *\n   * @param {string}  country The specified country.\n   * @param {object}  [options = {}] a list of options for this method\n   * @param {boolean} [options.ignorePunctuation = true] Whether punctuation should be ignored.\n   * @param {string}  [options.sensitivity = 'base'] Which differences in the strings should lead to non-zero result values\n   * @param {string}  [options.usage = 'search'] Whether the comparison is for sorting or for searching for matching strings\n   * @returns {Array} An array containing several collator objects.\n   */\n  getSearchCollators(\n    country,\n    { ignorePunctuation = true, sensitivity = \"base\", usage = \"search\" } = {}\n  ) {\n    // TODO: Only one language should be used at a time per country. The locale\n    //       of the page should be taken into account to do this properly.\n    //       We are going to support more countries in bug 1370193 and this\n    //       should be addressed when we start to implement that bug.\n\n    if (!this._collators[country]) {\n      let dataset = this.getCountryAddressData(country);\n      let languages = dataset.languages || [dataset.lang];\n      let options = {\n        ignorePunctuation,\n        sensitivity,\n        usage,\n      };\n      this._collators[country] = languages.map(\n        lang => new Intl.Collator(lang, options)\n      );\n    }\n    return this._collators[country];\n  },\n\n  // Based on the list of fields abbreviations in\n  // https://github.com/googlei18n/libaddressinput/wiki/AddressValidationMetadata\n  FIELDS_LOOKUP: {\n    N: \"name\",\n    O: \"organization\",\n    A: \"street-address\",\n    S: \"address-level1\",\n    C: \"address-level2\",\n    D: \"address-level3\",\n    Z: \"postal-code\",\n    n: \"newLine\",\n  },\n\n  /**\n   * Parse a country address format string and outputs an array of fields.\n   * Spaces, commas, and other literals are ignored in this implementation.\n   * For example, format string \"%A%n%C, %S\" should return:\n   * [\n   *   {fieldId: \"street-address\", newLine: true},\n   *   {fieldId: \"address-level2\"},\n   *   {fieldId: \"address-level1\"},\n   * ]\n   *\n   * @param   {string} fmt Country address format string\n   * @returns {Array<object>} List of fields\n   */\n  parseAddressFormat(fmt) {\n    if (!fmt) {\n      throw new Error(\"fmt string is missing.\");\n    }\n\n    return fmt.match(/%[^%]/g).reduce((parsed, part) => {\n      // Take the first letter of each segment and try to identify it\n      let fieldId = this.FIELDS_LOOKUP[part[1]];\n      // Early return if cannot identify part.\n      if (!fieldId) {\n        return parsed;\n      }\n      // If a new line is detected, add an attribute to the previous field.\n      if (fieldId == \"newLine\") {\n        let size = parsed.length;\n        if (size) {\n          parsed[size - 1].newLine = true;\n        }\n        return parsed;\n      }\n      return parsed.concat({ fieldId });\n    }, []);\n  },\n\n  /**\n   * Used to populate dropdowns in the UI (e.g. FormAutofill preferences).\n   * Use findAddressSelectOption for matching a value to a region.\n   *\n   * @param {string[]} subKeys An array of regionCode strings\n   * @param {string[]} subIsoids An array of ISO ID strings, if provided will be preferred over the key\n   * @param {string[]} subNames An array of regionName strings\n   * @param {string[]} subLnames An array of latinised regionName strings\n   * @returns {Map?} Returns null if subKeys or subNames are not truthy.\n   *                   Otherwise, a Map will be returned mapping keys -> names.\n   */\n  buildRegionMapIfAvailable(subKeys, subIsoids, subNames, subLnames) {\n    // Not all regions have sub_keys. e.g. DE\n    if (\n      !subKeys ||\n      !subKeys.length ||\n      (!subNames && !subLnames) ||\n      (subNames && subKeys.length != subNames.length) ||\n      (subLnames && subKeys.length != subLnames.length)\n    ) {\n      return null;\n    }\n\n    // Overwrite subKeys with subIsoids, when available\n    if (subIsoids && subIsoids.length && subIsoids.length == subKeys.length) {\n      for (let i = 0; i < subIsoids.length; i++) {\n        if (subIsoids[i]) {\n          subKeys[i] = subIsoids[i];\n        }\n      }\n    }\n\n    // Apply sub_lnames if sub_names does not exist\n    let names = subNames || subLnames;\n    return new Map(subKeys.map((key, index) => [key, names[index]]));\n  },\n\n  /**\n   * Parse a require string and outputs an array of fields.\n   * Spaces, commas, and other literals are ignored in this implementation.\n   * For example, a require string \"ACS\" should return:\n   * [\"street-address\", \"address-level2\", \"address-level1\"]\n   *\n   * @param   {string} requireString Country address require string\n   * @returns {Array<string>} List of fields\n   */\n  parseRequireString(requireString) {\n    if (!requireString) {\n      throw new Error(\"requireString string is missing.\");\n    }\n\n    return requireString.split(\"\").map(fieldId => this.FIELDS_LOOKUP[fieldId]);\n  },\n\n  /**\n   * Use address data and alternative country name list to identify a country code from a\n   * specified country name.\n   *\n   * @param   {string} countryName A country name to be identified\n   * @param   {string} [countrySpecified] A country code indicating that we only\n   *                                      search its alternative names if specified.\n   * @returns {string} The matching country code.\n   */\n  identifyCountryCode(countryName, countrySpecified) {\n    if (!countryName) {\n      return null;\n    }\n\n    if (lazy.AddressMetaDataLoader.getData(countryName)) {\n      return countryName;\n    }\n\n    const countries = countrySpecified\n      ? [countrySpecified]\n      : [...resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.countries.keys()];\n\n    for (const country of countries) {\n      let collators = this.getSearchCollators(country);\n      let metadata = this.getCountryAddressData(country);\n      if (country != metadata.key) {\n        // We hit the fallback logic in getCountryAddressRawData so ignore it as\n        // it's not related to `country` and use the name from l10n instead.\n        metadata = {\n          id: `data/${country}`,\n          key: country,\n          name: resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.countries.get(country),\n        };\n      }\n      let alternativeCountryNames = metadata.alternative_names || [\n        metadata.name,\n      ];\n      let reAlternativeCountryNames = this._reAlternativeCountryNames[country];\n      if (!reAlternativeCountryNames) {\n        reAlternativeCountryNames = this._reAlternativeCountryNames[country] =\n          [];\n      }\n\n      if (countryName.length == 3) {\n        if (this.strCompare(metadata.alpha_3_code, countryName, collators)) {\n          return country;\n        }\n      }\n\n      for (let i = 0; i < alternativeCountryNames.length; i++) {\n        let name = alternativeCountryNames[i];\n        let reName = reAlternativeCountryNames[i];\n        if (!reName) {\n          reName = reAlternativeCountryNames[i] = new RegExp(\n            \"\\\\b\" + this.escapeRegExp(name) + \"\\\\b\",\n            \"i\"\n          );\n        }\n\n        if (\n          this.strCompare(name, countryName, collators) ||\n          reName.test(countryName)\n        ) {\n          return country;\n        }\n      }\n    }\n\n    return null;\n  },\n\n  findSelectOption(selectEl, record, fieldName) {\n    if (this.isAddressField(fieldName)) {\n      return this.findAddressSelectOption(selectEl.options, record, fieldName);\n    }\n    if (this.isCreditCardField(fieldName)) {\n      return this.findCreditCardSelectOption(selectEl, record, fieldName);\n    }\n    return null;\n  },\n\n  /**\n   * Try to find the abbreviation of the given sub-region name\n   *\n   * @param   {string[]} subregionValues A list of inferable sub-region values.\n   * @param   {string} [country] A country name to be identified.\n   * @returns {string} The matching sub-region abbreviation.\n   */\n  getAbbreviatedSubregionName(subregionValues, country) {\n    let values = Array.isArray(subregionValues)\n      ? subregionValues\n      : [subregionValues];\n\n    let collators = this.getSearchCollators(country);\n    for (let metadata of this.getCountryAddressDataWithLocales(country)) {\n      let {\n        sub_keys: subKeys,\n        sub_names: subNames,\n        sub_lnames: subLnames,\n        sub_isoids: subIsoids,\n      } = metadata;\n      if (!subKeys) {\n        // Not all regions have sub_keys. e.g. DE\n        continue;\n      }\n      // Apply sub_lnames if sub_names does not exist\n      subNames = subNames || subLnames;\n\n      let speculatedSubIndexes = [];\n      for (const val of values) {\n        let identifiedValue = this.identifyValue(\n          subKeys,\n          subNames,\n          subIsoids,\n          val,\n          collators\n        );\n        if (identifiedValue) {\n          return identifiedValue;\n        }\n\n        // Predict the possible state by partial-matching if no exact match.\n        [subKeys, subNames].forEach(sub => {\n          speculatedSubIndexes.push(\n            sub.findIndex(token => {\n              let pattern = new RegExp(\n                \"\\\\b\" + this.escapeRegExp(token) + \"\\\\b\"\n              );\n\n              return pattern.test(val);\n            })\n          );\n        });\n      }\n      let subKey = subKeys[speculatedSubIndexes.find(i => !!~i)];\n      if (subKey) {\n        return subKey;\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Find the option element from select element.\n   * 1. Try to find the locale using the country from address.\n   * 2. First pass try to find exact match.\n   * 3. Second pass try to identify values from address value and options,\n   *    and look for a match.\n   *\n   * @param   {Array<{text: string, value: string}>} options\n   * @param   {object} address\n   * @param   {string} fieldName\n   * @returns {DOMElement}\n   */\n  findAddressSelectOption(options, address, fieldName) {\n    if (options.length > 512) {\n      // Allow enough space for all countries (roughly 300 distinct values) and all\n      // timezones (roughly 400 distinct values), plus some extra wiggle room.\n      return null;\n    }\n    let value = address[fieldName];\n    if (!value) {\n      return null;\n    }\n\n    let collators = this.getSearchCollators(address.country);\n\n    for (const option of options) {\n      if (\n        this.strCompare(value, option.value, collators) ||\n        this.strCompare(value, option.text, collators)\n      ) {\n        return option;\n      }\n    }\n\n    switch (fieldName) {\n      case \"address-level1\": {\n        let { country } = address;\n        let identifiedValue = this.getAbbreviatedSubregionName(\n          [value],\n          country\n        );\n        // No point going any further if we cannot identify value from address level 1\n        if (!identifiedValue) {\n          return null;\n        }\n        for (let dataset of this.getCountryAddressDataWithLocales(country)) {\n          let keys = dataset.sub_keys;\n          if (!keys) {\n            // Not all regions have sub_keys. e.g. DE\n            continue;\n          }\n          // Apply sub_lnames if sub_names does not exist\n          let names = dataset.sub_names || dataset.sub_lnames;\n          let isoids = dataset.sub_isoids;\n\n          // Go through options one by one to find a match.\n          // Also check if any option contain the address-level1 key.\n          let pattern = new RegExp(\n            \"\\\\b\" + this.escapeRegExp(identifiedValue) + \"\\\\b\",\n            \"i\"\n          );\n          for (const option of options) {\n            let optionValue = this.identifyValue(\n              keys,\n              names,\n              isoids,\n              option.value,\n              collators\n            );\n            let optionText = this.identifyValue(\n              keys,\n              names,\n              isoids,\n              option.text,\n              collators,\n              true\n            );\n            if (\n              identifiedValue === optionValue ||\n              identifiedValue === optionText ||\n              pattern.test(option.value)\n            ) {\n              return option;\n            }\n          }\n        }\n        break;\n      }\n      case \"country\": {\n        if (this.getCountryAddressData(value)) {\n          for (const option of options) {\n            if (\n              this.identifyCountryCode(option.text, value) ||\n              this.identifyCountryCode(option.value, value)\n            ) {\n              return option;\n            }\n          }\n        }\n        break;\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Find the option element from xul menu popups, as used in address capture\n   * doorhanger.\n   *\n   * This is a proxy to `findAddressSelectOption`, which expects HTML select\n   * DOM nodes and operates on options instead of xul menuitems.\n   *\n   * NOTE: This is a temporary solution until Bug 1886949 is landed. This\n   * method will then be removed `findAddressSelectOption` will be used\n   * directly.\n   *\n   * @param   {XULPopupElement} menupopup\n   * @param   {object} address\n   * @param   {string} fieldName\n   * @returns {XULElement}\n   */\n  findAddressSelectOptionWithMenuPopup(menupopup, address, fieldName) {\n    const options = Array.from(menupopup.childNodes).map(menuitem => ({\n      text: menuitem.label,\n      value: menuitem.value,\n      menuitem,\n    }));\n\n    return this.findAddressSelectOption(options, address, fieldName)?.menuitem;\n  },\n\n  findCreditCardSelectOption(selectEl, creditCard, fieldName) {\n    let oneDigitMonth = creditCard[\"cc-exp-month\"]\n      ? creditCard[\"cc-exp-month\"].toString()\n      : null;\n    let twoDigitsMonth = oneDigitMonth ? oneDigitMonth.padStart(2, \"0\") : null;\n    let fourDigitsYear = creditCard[\"cc-exp-year\"]\n      ? creditCard[\"cc-exp-year\"].toString()\n      : null;\n    let twoDigitsYear = fourDigitsYear ? fourDigitsYear.substr(2, 2) : null;\n    let options = Array.from(selectEl.options);\n\n    switch (fieldName) {\n      case \"cc-exp-month\": {\n        if (!oneDigitMonth) {\n          return null;\n        }\n        for (let option of options) {\n          if (\n            [option.text, option.label, option.value].some(s => {\n              let result = /[1-9]\\d*/.exec(s);\n              return result && result[0] == oneDigitMonth;\n            })\n          ) {\n            return option;\n          }\n        }\n        break;\n      }\n      case \"cc-exp-year\": {\n        if (!fourDigitsYear) {\n          return null;\n        }\n        for (let option of options) {\n          if (\n            [option.text, option.label, option.value].some(\n              s => s == twoDigitsYear || s == fourDigitsYear\n            )\n          ) {\n            return option;\n          }\n        }\n        break;\n      }\n      case \"cc-exp\": {\n        if (!oneDigitMonth || !fourDigitsYear) {\n          return null;\n        }\n        let patterns = [\n          oneDigitMonth + \"/\" + twoDigitsYear, // 8/22\n          oneDigitMonth + \"/\" + fourDigitsYear, // 8/2022\n          twoDigitsMonth + \"/\" + twoDigitsYear, // 08/22\n          twoDigitsMonth + \"/\" + fourDigitsYear, // 08/2022\n          oneDigitMonth + \"-\" + twoDigitsYear, // 8-22\n          oneDigitMonth + \"-\" + fourDigitsYear, // 8-2022\n          twoDigitsMonth + \"-\" + twoDigitsYear, // 08-22\n          twoDigitsMonth + \"-\" + fourDigitsYear, // 08-2022\n          twoDigitsYear + \"-\" + twoDigitsMonth, // 22-08\n          fourDigitsYear + \"-\" + twoDigitsMonth, // 2022-08\n          fourDigitsYear + \"/\" + oneDigitMonth, // 2022/8\n          twoDigitsMonth + twoDigitsYear, // 0822\n          twoDigitsYear + twoDigitsMonth, // 2208\n        ];\n\n        for (let option of options) {\n          if (\n            [option.text, option.label, option.value].some(str =>\n              patterns.some(pattern => str.includes(pattern))\n            )\n          ) {\n            return option;\n          }\n        }\n        break;\n      }\n      case \"cc-type\": {\n        let network = creditCard[\"cc-type\"] || \"\";\n        for (let option of options) {\n          if (\n            [option.text, option.label, option.value].some(\n              s => lazy.CreditCard.getNetworkFromName(s) == network\n            )\n          ) {\n            return option;\n          }\n        }\n        break;\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Try to match value with keys and names, but always return the key.\n   * If inexactMatch is true, then a substring match is performed, otherwise\n   * the string must match exactly.\n   *\n   * @param   {Array<string>} keys\n   * @param   {Array<string>} names\n   * @param   {Array<string>} isoids\n   * @param   {string} value\n   * @param   {Array} collators\n   * @param   {bool} inexactMatch\n   * @returns {string}\n   */\n  identifyValue(keys, names, isoids, value, collators, inexactMatch = false) {\n    if (!value) {\n      return null;\n    }\n\n    let resultKey = keys.find(key => this.strCompare(value, key, collators));\n    if (resultKey) {\n      return resultKey;\n    }\n\n    let index = names.findIndex(name =>\n      inexactMatch\n        ? this.strInclude(value, name, collators)\n        : this.strCompare(value, name, collators)\n    );\n    if (index === -1) {\n      index = isoids.findIndex(isoid =>\n        inexactMatch\n          ? this.strInclude(value, isoid, collators)\n          : this.strCompare(value, isoid, collators)\n      );\n    }\n\n    return index !== -1 ? keys[index] : null;\n  },\n\n  /**\n   * Compare if two strings are the same.\n   *\n   * @param   {string} a\n   * @param   {string} b\n   * @param   {Array} collators\n   * @returns {boolean}\n   */\n  strCompare(a = \"\", b = \"\", collators) {\n    return collators.some(collator => !collator.compare(a, b));\n  },\n\n  /**\n   * Determine whether one string(b) may be found within another string(a)\n   *\n   * @param   {string} a\n   * @param   {string} b\n   * @param   {Array} collators\n   * @returns {boolean} True if the string is found\n   */\n  strInclude(a = \"\", b = \"\", collators) {\n    const len = a.length - b.length;\n    for (let i = 0; i <= len; i++) {\n      if (this.strCompare(a.substring(i, i + b.length), b, collators)) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Escaping user input to be treated as a literal string within a regular\n   * expression.\n   *\n   * @param   {string} string\n   * @returns {string}\n   */\n  escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  },\n\n  /**\n   * Get formatting information of a given country\n   *\n   * @param   {string} country\n   * @returns {object}\n   *         {\n   *           {string} addressLevel3L10nId\n   *           {string} addressLevel2L10nId\n   *           {string} addressLevel1L10nId\n   *           {string} postalCodeL10nId\n   *           {object} fieldsOrder\n   *           {string} postalCodePattern\n   *         }\n   */\n  getFormFormat(country) {\n    let dataset = this.getCountryAddressData(country);\n    // We hit a country fallback in `getCountryAddressRawData` but it's not relevant here.\n    if (country != dataset.key) {\n      // Use a sparse object so the below default values take effect.\n      dataset = {\n        /**\n         * Even though data/ZZ only has address-level2, include the other levels\n         * in case they are needed for unknown countries. Users can leave the\n         * unnecessary fields blank which is better than forcing users to enter\n         * the data in incorrect fields.\n         */\n        fmt: \"%N%n%O%n%A%n%C %S %Z\",\n      };\n    }\n    return {\n      // When particular values are missing for a country, the\n      // data/ZZ value should be used instead:\n      // https://chromium-i18n.appspot.com/ssl-aggregate-address/data/ZZ\n      addressLevel3L10nId: this.getAddressFieldL10nId(\n        dataset.sublocality_name_type || \"suburb\"\n      ),\n      addressLevel2L10nId: this.getAddressFieldL10nId(\n        dataset.locality_name_type || \"city\"\n      ),\n      addressLevel1L10nId: this.getAddressFieldL10nId(\n        dataset.state_name_type || \"province\"\n      ),\n      addressLevel1Options: this.buildRegionMapIfAvailable(\n        dataset.sub_keys,\n        dataset.sub_isoids,\n        dataset.sub_names,\n        dataset.sub_lnames\n      ),\n      countryRequiredFields: this.parseRequireString(dataset.require || \"AC\"),\n      fieldsOrder: this.parseAddressFormat(dataset.fmt || \"%N%n%O%n%A%n%C\"),\n      postalCodeL10nId: this.getAddressFieldL10nId(\n        dataset.zip_name_type || \"postal-code\"\n      ),\n      postalCodePattern: dataset.zip,\n    };\n  },\n  /**\n   * Converts a Map to an array of objects with `value` and `text` properties ( option like).\n   *\n   * @param {Map} optionsMap\n   * @returns {Array<{ value: string, text: string }>|null}\n   */\n  optionsMapToArray(optionsMap) {\n    return optionsMap?.size\n      ? [...optionsMap].map(([value, text]) => ({ value, text }))\n      : null;\n  },\n\n  /**\n   * Get flattened form layout information of a given country\n   * TODO(Bug 1891730): Remove getFormFormat and use this instead.\n   *\n   * @param {object} record - An object containing at least the 'country' property.\n   * @returns {Array} Flattened array with the address fiels in order.\n   */\n  getFormLayout(record) {\n    const formFormat = this.getFormFormat(record.country);\n    let fieldsInOrder = formFormat.fieldsOrder;\n\n    // Add missing fields that are always present but not in the .fmt of addresses\n    // TODO: extend libaddress later to support this if possible\n    fieldsInOrder = [\n      ...fieldsInOrder,\n      {\n        fieldId: \"country\",\n        options: this.optionsMapToArray(resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.countries),\n        required: true,\n      },\n      { fieldId: \"tel\", type: \"tel\" },\n      { fieldId: \"email\", type: \"email\" },\n    ];\n\n    const addressLevel1Options = this.optionsMapToArray(\n      formFormat.addressLevel1Options\n    );\n\n    const addressLevel1SelectedValue = addressLevel1Options\n      ? this.findAddressSelectOption(\n          addressLevel1Options,\n          record,\n          \"address-level1\"\n        )?.value\n      : record[\"address-level1\"];\n\n    for (const field of fieldsInOrder) {\n      const flattenedObject = {\n        fieldId: field.fieldId,\n        newLine: field.newLine,\n        l10nId: this.getAddressFieldL10nId(field.fieldId),\n        required: formFormat.countryRequiredFields.includes(field.fieldId),\n        value: record[field.fieldId] ?? \"\",\n        ...(field.fieldId === \"street-address\" && {\n          l10nId: \"autofill-address-street\",\n          multiline: true,\n        }),\n        ...(field.fieldId === \"address-level1\" && {\n          l10nId: formFormat.addressLevel1L10nId,\n          options: addressLevel1Options,\n          value: addressLevel1SelectedValue,\n        }),\n        ...(field.fieldId === \"address-level2\" && {\n          l10nId: formFormat.addressLevel2L10nId,\n        }),\n        ...(field.fieldId === \"address-level3\" && {\n          l10nId: formFormat.addressLevel3L10nId,\n        }),\n        ...(field.fieldId === \"postal-code\" && {\n          pattern: formFormat.postalCodePattern,\n          l10nId: formFormat.postalCodeL10nId,\n        }),\n      };\n      Object.assign(field, flattenedObject);\n    }\n\n    return fieldsInOrder;\n  },\n\n  getAddressFieldL10nId(type) {\n    return \"autofill-address-\" + type.replace(/_/g, \"-\");\n  },\n\n  CC_FATHOM_NONE: 0,\n  CC_FATHOM_JS: 1,\n  CC_FATHOM_NATIVE: 2,\n  isFathomCreditCardsEnabled() {\n    return this.ccHeuristicsMode != this.CC_FATHOM_NONE;\n  },\n\n  /**\n   * Transform the key in FormAutofillConfidences (defined in ChromeUtils.webidl)\n   * to fathom recognized field type.\n   *\n   * @param {string} key key from FormAutofillConfidences dictionary\n   * @returns {string} fathom field type\n   */\n  formAutofillConfidencesKeyToCCFieldType(key) {\n    const MAP = {\n      ccNumber: \"cc-number\",\n      ccName: \"cc-name\",\n      ccType: \"cc-type\",\n      ccExp: \"cc-exp\",\n      ccExpMonth: \"cc-exp-month\",\n      ccExpYear: \"cc-exp-year\",\n    };\n    return MAP[key];\n  },\n  /**\n   * Generates the localized os dialog message that\n   * prompts the user to reauthenticate\n   *\n   * @param {string} msgMac fluent message id for macos clients\n   * @param {string} msgWin fluent message id for windows clients\n   * @param {string} msgOther fluent message id for other clients\n   * @param {string} msgLin (optional) fluent message id for linux clients\n   * @returns {string} localized os prompt message\n   */\n  reauthOSPromptMessage(msgMac, msgWin, msgOther, msgLin = null) {\n    const platform = resource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.AppConstants.platform;\n    let messageID;\n\n    switch (platform) {\n      case \"win\":\n        messageID = msgWin;\n        break;\n      case \"macosx\":\n        messageID = msgMac;\n        break;\n      case \"linux\":\n        messageID = msgLin ?? msgOther;\n        break;\n      default:\n        messageID = msgOther;\n    }\n    return lazy.l10n.formatValueSync(messageID);\n  },\n\n  /**\n   * Retrieves a unique identifier for a given DOM element.\n   * Note that the identifier generated by ContentDOMReference is an object but\n   * this API serializes it to string to make lookup easier.\n   *\n   * @param {Element} element The DOM element from which to generate an identifier.\n   * @returns {string} A unique identifier for the element.\n   */\n  getElementIdentifier(element) {\n    let id;\n    try {\n      id = JSON.stringify(lazy.ContentDOMReference.get(element));\n    } catch {\n      // This is needed because when running in xpc-shell test, we don't have\n      const entry = Object.entries(this._elementByElementId).find(\n        e => e[1] == element\n      );\n      if (entry) {\n        id = entry[0];\n      } else {\n        id = Services.uuid.generateUUID().toString();\n        this._elementByElementId[id] = element;\n      }\n    }\n    return id;\n  },\n\n  /**\n   * Maps element identifiers to their corresponding DOM elements.\n   * Only used when we can't get the identifier via ContentDOMReference,\n   * for example, xpcshell test.\n   */\n  _elementByElementId: {},\n\n  /**\n   * Retrieves the DOM element associated with the specific identifier.\n   * The identifier should be generated with the `getElementIdentifier` API\n   *\n   * @param {string} elementId The identifier of the element.\n   * @returns {Element} The DOM element associated with the given identifier.\n   */\n  getElementByIdentifier(elementId) {\n    let element;\n    try {\n      element = lazy.ContentDOMReference.resolve(JSON.parse(elementId));\n    } catch {\n      element = this._elementByElementId[elementId];\n    }\n    return element;\n  },\n\n  /**\n   * This function is used to determine the frames that can also be autofilled\n   * when users trigger autofill on the focusd frame.\n   *\n   * Currently we also autofill when for frames that\n   * 1. is top-level.\n   * 2. is same origin with the top-level.\n   * 3. is same origin with the frame that triggers autofill.\n   *\n   * @param {BrowsingContext} browsingContext\n   *        frame to be checked whether we can also autofill\n   */\n  isBCSameOriginWithTop(browsingContext) {\n    return (\n      browsingContext.top == browsingContext ||\n      browsingContext.currentWindowGlobal.documentPrincipal.equals(\n        browsingContext.top.currentWindowGlobal.documentPrincipal\n      )\n    );\n  },\n};\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofillUtils,\n  \"_reauthEnabledByUser\",\n  \"extensions.formautofill.reauth.enabled\",\n  false\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofillUtils,\n  \"ccHeuristicsMode\",\n  \"extensions.formautofill.creditCards.heuristics.mode\",\n  0\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofillUtils,\n  \"ccFathomConfidenceThreshold\",\n  \"extensions.formautofill.creditCards.heuristics.fathom.confidenceThreshold\",\n  null,\n  null,\n  pref => parseFloat(pref)\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofillUtils,\n  \"ccFathomHighConfidenceThreshold\",\n  \"extensions.formautofill.creditCards.heuristics.fathom.highConfidenceThreshold\",\n  null,\n  null,\n  pref => parseFloat(pref)\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofillUtils,\n  \"ccFathomTestConfidence\",\n  \"extensions.formautofill.creditCards.heuristics.fathom.testConfidence\",\n  null,\n  null,\n  pref => parseFloat(pref)\n);\n\n// This is only used in iOS\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofillUtils,\n  \"focusOnAutofill\",\n  \"extensions.formautofill.focusOnAutofill\",\n  true\n);\n\n// This is only used for testing\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofillUtils,\n  \"ignoreVisibilityCheck\",\n  \"extensions.formautofill.test.ignoreVisibilityCheck\",\n  false\n);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs":
/*!*********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormLikeFactory: () => (/* binding */ FormLikeFactory)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * A factory to generate FormLike objects that represent a set of related fields\n * which aren't necessarily marked up with a <form> element. FormLike's emulate\n * the properties of an HTMLFormElement which are relevant to form tasks.\n */\nlet FormLikeFactory = {\n  _propsFromForm: [\"action\", \"autocomplete\", \"ownerDocument\"],\n\n  /**\n   * Create a FormLike object from a <form>.\n   *\n   * @param {HTMLFormElement} aForm\n   * @return {FormLike}\n   * @throws Error if aForm isn't an HTMLFormElement\n   */\n  createFromForm(aForm) {\n    if (!HTMLFormElement.isInstance(aForm)) {\n      throw new Error(\"createFromForm: aForm must be a HTMLFormElement\");\n    }\n\n    let formLike = {\n      elements: this.gatherFormElements(aForm),\n      rootElement: aForm,\n    };\n\n    for (let prop of this._propsFromForm) {\n      formLike[prop] = aForm[prop];\n    }\n\n    this._addToJSONProperty(formLike);\n\n    return formLike;\n  },\n\n  gatherFormElements(aForm) {\n    // If there is no nested <form> element, just return the form's elements.\n    if (!aForm.querySelector(\"form\")) {\n      return [...aForm.elements];\n    }\n\n    // Get all of the child input and select elements from the form. Nested\n    // forms are normally removed during markup parsing, but could be created\n    // if the document is modified later. Consider all of the elements that\n    // are descendants of the form or within the form's .elements list to be\n    // part of the form, except those with a form attribute set to a different\n    // form. These are all added in document order.\n    let childElements = [...aForm.querySelectorAll(\"input, select\")];\n    childElements = childElements.filter(\n      e => !e.getAttribute(\"form\") || e.form == aForm\n    );\n\n    // Add the element into the child elements list in document order.\n    let index = 0;\n    for (const formElement of aForm.elements) {\n      if (!childElements.includes(formElement)) {\n        // Insert elements that appear before the <form> at the beginning and\n        // other elements at the end.\n        let position = aForm.compareDocumentPosition(formElement);\n        if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n          childElements.splice(index++, 0, formElement);\n          continue;\n        } else {\n          childElements.push(formElement);\n        }\n      }\n    }\n\n    return childElements;\n  },\n\n  /**\n   * Create a FormLike object from an element that is the root of the document\n   *\n   * Currently all <input> not in a <form> are one LoginForm but this\n   * shouldn't be relied upon as the heuristics may change to detect multiple\n   * \"forms\" (e.g. registration and login) on one page with a <form>.\n   *\n   * @param {HTMLElement} aDocumentRoot\n   * @param {Object} aOptions\n   * @param {boolean} [aOptions.ignoreForm = false]\n   *        True to always use owner document as the `form`\n   * @return {formLike}\n   * @throws Error if aDocumentRoot is null\n   */\n  createFromDocumentRoot(aDocumentRoot, aOptions = {}) {\n    if (!aDocumentRoot) {\n      throw new Error(\"createFromDocumentRoot: aDocumentRoot is null\");\n    }\n\n    let formLike = {\n      action: aDocumentRoot.baseURI,\n      autocomplete: \"on\",\n      ownerDocument: aDocumentRoot.ownerDocument,\n      rootElement: aDocumentRoot,\n    };\n\n    // FormLikes can be created when fields are inserted into the DOM. When\n    // many, many fields are inserted one after the other, we create many\n    // FormLikes, and computing the elements list becomes more and more\n    // expensive. Making the elements list lazy means that it'll only\n    // be computed when it's eventually needed (if ever).\n    ChromeUtils.defineLazyGetter(formLike, \"elements\", function () {\n      let elements = [];\n      for (let el of aDocumentRoot.querySelectorAll(\n        \"input, select, textarea\"\n      )) {\n        // Exclude elements inside the rootElement that are already in a <form> as\n        // they will be handled by their own FormLike.\n        if (!el.form || aOptions.ignoreForm) {\n          elements.push(el);\n        }\n      }\n\n      return elements;\n    });\n\n    this._addToJSONProperty(formLike);\n    return formLike;\n  },\n\n  /**\n   * Create a FormLike object from an <input>/<select> in a document.\n   *\n   * If the field is in a <form>, construct the FormLike from the form.\n   * Otherwise, create a FormLike with a rootElement (wrapper) according to\n   * heuristics. Currently all <input>/<select> not in a <form> are one FormLike\n   * but this shouldn't be relied upon as the heuristics may change to detect\n   * multiple \"forms\" (e.g. registration and login) on one page with a <form>.\n   *\n   * Note that two FormLikes created from the same field won't return the same FormLike object.\n   * Use the `rootElement` property on the FormLike as a key instead.\n   *\n   * @param {HTMLInputElement|HTMLSelectElement} aField\n   *        an <input>, <select> or <iframe> field in a document\n   * @param {Object} aOptions\n   * @param {boolean} [aOptions.ignoreForm = false]\n   *        True to always use owner document as the `form`\n   * @return {FormLike}\n   * @throws Error if aField isn't a password or username field in a document\n   */\n  createFromField(aField, aOptions = {}) {\n    if (\n      (!HTMLInputElement.isInstance(aField) &&\n        !HTMLIFrameElement.isInstance(aField) &&\n        !HTMLSelectElement.isInstance(aField) &&\n        !HTMLTextAreaElement.isInstance(aField)) ||\n      !aField.ownerDocument\n    ) {\n      throw new Error(\"createFromField requires a field in a document\");\n    }\n\n    const rootElement = this.findRootForField(aField, aOptions);\n    return HTMLFormElement.isInstance(rootElement)\n      ? this.createFromForm(rootElement)\n      : this.createFromDocumentRoot(rootElement, aOptions);\n  },\n\n  /**\n   * Find the closest <form> if any when aField is inside a ShadowRoot.\n   *\n   * @param {HTMLInputElement} aField - a password or username field in a document\n   * @return {HTMLFormElement|null}\n   */\n  closestFormIgnoringShadowRoots(aField) {\n    let form = aField.closest(\"form\");\n    let current = aField;\n    while (!form) {\n      let shadowRoot = current.getRootNode();\n      if (!ShadowRoot.isInstance(shadowRoot)) {\n        break;\n      }\n      let host = shadowRoot.host;\n      form = host.closest(\"form\");\n      current = host;\n    }\n    return form;\n  },\n\n  /**\n   * Determine the Element that encapsulates the related fields. For example, if\n   * a page contains a login form and a checkout form which are \"submitted\"\n   * separately, and the username field is passed in, ideally this would return\n   * an ancestor Element of the username and password fields which doesn't\n   * include any of the checkout fields.\n   *\n   * @param {HTMLInputElement|HTMLSelectElement} aField\n   *        a field in a document\n   * @return {HTMLElement} - the root element surrounding related fields\n   */\n  findRootForField(aField, { ignoreForm = false } = {}) {\n    if (!ignoreForm) {\n      let form = aField.form || this.closestFormIgnoringShadowRoots(aField);\n      if (form) {\n        // If a <form> appears inside another form, use the outermost <form> element.\n        let parent = form;\n        while ((parent = parent.parentNode)) {\n          if (HTMLFormElement.isInstance(parent)) {\n            form = parent;\n          }\n        }\n        return form;\n      }\n    }\n\n    return aField.ownerDocument.documentElement;\n  },\n\n  /**\n   * Add a `toJSON` property to a FormLike so logging which ends up going\n   * through dump doesn't include usless garbage from DOM objects.\n   */\n  _addToJSONProperty(aFormLike) {\n    function prettyElementOutput(aElement) {\n      let idText = aElement.id ? \"#\" + aElement.id : \"\";\n      let classText = \"\";\n      for (let className of aElement.classList) {\n        classText += \".\" + className;\n      }\n      return `<${aElement.nodeName + idText + classText}>`;\n    }\n\n    Object.defineProperty(aFormLike, \"toJSON\", {\n      value: () => {\n        let cleansed = {};\n        for (let key of Object.keys(aFormLike)) {\n          let value = aFormLike[key];\n          let cleansedValue = value;\n\n          switch (key) {\n            case \"elements\": {\n              cleansedValue = [];\n              for (let element of value) {\n                cleansedValue.push(prettyElementOutput(element));\n              }\n              break;\n            }\n\n            case \"ownerDocument\": {\n              cleansedValue = {\n                location: {\n                  href: value.location.href,\n                },\n              };\n              break;\n            }\n\n            case \"rootElement\": {\n              cleansedValue = prettyElementOutput(value);\n              break;\n            }\n          }\n\n          cleansed[key] = cleansedValue;\n        }\n        return cleansed;\n      },\n    });\n  },\n};\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs":
/*!**********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormStateManager: () => (/* binding */ FormStateManager),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  AutofillFormFactory:\n    \"resource://gre/modules/shared/AutofillFormFactory.sys.mjs\",\n  FormAutofillHandler:\n    \"resource://gre/modules/shared/FormAutofillHandler.sys.mjs\",\n  FormAutofillUtils: \"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\",\n});\n\nclass FormStateManager {\n  #formHandlerByElement = new WeakMap();\n  #formHandlerByRootElement = new WeakMap();\n  #formHandlerByRootId = new Map();\n\n  constructor(onFilledModifiedCallback) {\n    /**\n     * @type {WeakMap} mapping FormLike root HTML elements to FormAutofillHandler objects.\n     */\n\n    this.onFilledModifiedCallback = onFilledModifiedCallback;\n  }\n\n  getWeakIdentifiedForms() {\n    return ChromeUtils.nondeterministicGetWeakMapKeys(\n      this.#formHandlerByRootElement\n    );\n  }\n\n  /**\n   * Get the form handler for the specified input element.\n   *\n   * @param {HTMLElement} element\n   *        Focused input which triggered profile searching\n   * @returns {FormAutofillHandler | null}\n   *        The form handler associated with the specified input element.\n   */\n  getFormHandler(element) {\n    if (!element) {\n      return null;\n    }\n\n    let handler = this.#formHandlerByElement.get(element);\n    if (handler) {\n      return handler;\n    }\n\n    const rootElement = lazy.AutofillFormFactory.findRootForField(element);\n    return this.#formHandlerByRootElement.get(rootElement);\n  }\n\n  /**\n   * Get the form handler for the specified root element.\n   *\n   * @param {string} rootElementId\n   *        the id of the root element\n   * @returns {FormAutofillHandler | null}\n   *        The form handler associated with the specified input element.\n   */\n  getFormHandlerByRootElementId(rootElementId) {\n    return this.#formHandlerByRootId.get(rootElementId);\n  }\n\n  /**\n   * Get the form handler for the specified input element. If no handler exists\n   * in the cache, this function creates a new one.\n   *\n   * @param {HTMLElement} element\n   *        Focused input which triggered profile searching\n   * @returns {FormAutofillHandler}\n   *        The form handler associated with the specified input element.\n   */\n  getOrCreateFormHandler(element) {\n    let handler = this.getFormHandler(element);\n    if (!handler) {\n      handler = new lazy.FormAutofillHandler(\n        lazy.AutofillFormFactory.createFromField(element),\n        this.onFilledModifiedCallback\n      );\n\n      const root = handler.form.rootElement;\n      const rootElementId = lazy.FormAutofillUtils.getElementIdentifier(root);\n      this.#formHandlerByRootId.set(rootElementId, handler);\n      this.#formHandlerByRootElement.set(root, handler);\n    }\n    return handler;\n  }\n\n  removeFormHandlerByElementEntries(handler) {\n    handler.form.elements.forEach(element =>\n      this.#formHandlerByElement.delete(element)\n    );\n  }\n\n  addFormHandlerByElementEntries(handler) {\n    handler.form.elements.forEach(element => {\n      if (!this.#formHandlerByElement.has(element, handler)) {\n        this.#formHandlerByElement.set(element, handler);\n      }\n    });\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FormStateManager);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs":
/*!*************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppConstants: () => (/* reexport safe */ resource_gre_modules_shared_Constants_ios_mjs__WEBPACK_IMPORTED_MODULE_0__.IOSAppConstants),\n/* harmony export */   ChromeUtils: () => (/* binding */ ChromeUtils),\n/* harmony export */   OSKeyStore: () => (/* binding */ OSKeyStore),\n/* harmony export */   Region: () => (/* binding */ Region),\n/* harmony export */   Services: () => (/* binding */ Services),\n/* harmony export */   XPCOMUtils: () => (/* binding */ XPCOMUtils)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_shared_Constants_ios_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/shared/Constants.ios.mjs */ \"./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs\");\n/* harmony import */ var resource_gre_modules_Overrides_ios_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/Overrides.ios.js */ \"./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js\");\n/* harmony import */ var resource_gre_modules_Overrides_ios_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(resource_gre_modules_Overrides_ios_js__WEBPACK_IMPORTED_MODULE_1__);\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\nconst EMPTY_MODULE_PATH = \"EmptyModule.sys.mjs\";\n\n/* eslint mozilla/use-isInstance: 0 */\nHTMLSelectElement.isInstance = element => element instanceof HTMLSelectElement;\nHTMLInputElement.isInstance = element => element instanceof HTMLInputElement;\nHTMLTextAreaElement.isInstance = element =>\n  element instanceof HTMLTextAreaElement;\nHTMLIFrameElement.isInstance = element => element instanceof HTMLIFrameElement;\nHTMLFormElement.isInstance = element => element instanceof HTMLFormElement;\nShadowRoot.isInstance = element => element instanceof ShadowRoot;\n\nHTMLElement.prototype.ownerGlobal = window;\n\n// We cannot mock this in WebKit because we lack access to low-level APIs.\n// For completeness, we simply return true when the input type is \"password\".\n// NOTE: Since now we also include this file for password generator, it might be included multiple times\n// which causes the defineProperty to throw. Allowing it to be overwritten for now is fine, since\n// our code runs in a sandbox and only firefox code can overwrite it.\nObject.defineProperty(HTMLInputElement.prototype, \"hasBeenTypePassword\", {\n  get() {\n    return this.type === \"password\";\n  },\n  configurable: true,\n});\n\nObject.defineProperty(HTMLInputElement.prototype, \"nodePrincipal\", {\n  get() {\n    return { isNullPrincipal: false };\n  },\n  configurable: true,\n});\n\nfunction setUserInput(value) {\n  this.value = value;\n\n  // In React apps, setting .value may not always work reliably.\n  // We dispatch change, input as a workaround.\n  // There are other more \"robust\" solutions:\n  // - Dispatching keyboard events and comparing the value after setting it\n  //   (https://github.com/fmeum/browserpass-extension/blob/5efb1f9de6078b509904a83847d370c8e92fc097/src/inject.js#L412-L440)\n  // - Using the native setter\n  //   (https://github.com/facebook/react/issues/10135#issuecomment-401496776)\n  // These are a bit more bloated. We can consider using these later if we encounter any further issues.\n  [\"input\", \"change\"].forEach(eventName => {\n    this.dispatchEvent(new Event(eventName, { bubbles: true }));\n  });\n\n  this.dispatchEvent(new Event(\"blur\", { bubbles: true }));\n}\n\nHTMLInputElement.prototype.setUserInput = setUserInput;\nHTMLTextAreaElement.prototype.setUserInput = setUserInput;\n\n// Mimic the behavior of .getAutocompleteInfo()\n// It should return an object with a fieldName property matching the autocomplete attribute\n// only if it's a valid value from this list https://searchfox.org/mozilla-central/source/dom/base/AutocompleteFieldList.h#89-149\n// Also found here: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete\nHTMLElement.prototype.getAutocompleteInfo = function () {\n  const autocomplete = this.getAttribute(\"autocomplete\");\n\n  return {\n    fieldName: resource_gre_modules_shared_Constants_ios_mjs__WEBPACK_IMPORTED_MODULE_0__.IOSAppConstants.validAutocompleteFields.includes(autocomplete)\n      ? autocomplete\n      : \"\",\n  };\n};\n\n// This function  helps us debug better when an error occurs because a certain mock is missing\nconst withNotImplementedError = obj =>\n  new Proxy(obj, {\n    get(target, prop) {\n      if (!Object.keys(target).includes(prop)) {\n        throw new Error(\n          `Not implemented: ${prop} doesn't exist in mocked object `\n        );\n      }\n      return Reflect.get(...arguments);\n    },\n  });\n\n// This function will create a proxy for each undefined property\n// This is useful when the accessed property name is unkonwn beforehand\nconst undefinedProxy = () =>\n  new Proxy(() => {}, {\n    get() {\n      return undefinedProxy();\n    },\n  });\n\n// Webpack needs to be able to statically analyze require statements in order to build the dependency graph\n// In order to require modules dynamically at runtime, we use require.context() to create a dynamic require\n// that is still able to be parsed by Webpack at compile time. The \"./\" and \".mjs\" tells webpack that files\n// in the current directory ending with .mjs might be needed and should be added to the dependency graph.\n// NOTE: This can't handle circular dependencies. A static import can be used in this case.\n// https://webpack.js.org/guides/dependency-management/\nconst internalModuleResolvers = {\n  resolveModule(moduleURI) {\n    // eslint-disable-next-line no-undef\n    const moduleResolver = __webpack_require__(\"./firefox-ios/Client/Assets/CC_Script sync .mjs$\");\n    // Desktop code uses uris for importing modules of the form resource://gre/modules/<module_path>\n    // We only need the filename here\n    const moduleName = moduleURI.split(\"/\").pop();\n    const modulePath =\n      \"./\" + ((resource_gre_modules_Overrides_ios_js__WEBPACK_IMPORTED_MODULE_1___default().ModuleOverrides)[moduleName] ?? moduleName);\n    return { module: moduleResolver(modulePath), path: modulePath };\n  },\n\n  resolveModules(obj, modules) {\n    for (const [exportName, moduleURI] of Object.entries(modules)) {\n      const resolvedModule = this.resolveModule(moduleURI);\n      obj[exportName] = resolvedModule.path.includes(EMPTY_MODULE_PATH)\n        ? resolvedModule.module?.default\n        : resolvedModule.module?.[exportName];\n    }\n  },\n};\n\n// Define mock for XPCOMUtils\nconst XPCOMUtils = withNotImplementedError({\n  defineLazyPreferenceGetter: (\n    obj,\n    prop,\n    pref,\n    defaultValue = null,\n    onUpdate,\n    transform = val => val\n  ) => {\n    const value = resource_gre_modules_shared_Constants_ios_mjs__WEBPACK_IMPORTED_MODULE_0__.IOSAppConstants.prefs[pref] ?? defaultValue;\n    // Explicitly check for undefined since null, false, \"\" and 0 are valid values\n    if (value === undefined) {\n      throw Error(\n        `Pref ${pref} is not defined and no valid default value was provided.`\n      );\n    }\n    obj[prop] = transform(value);\n  },\n  defineLazyServiceGetter() {\n    // Don't do anything\n    // We need this for OS Auth fixes for formautofill.\n    // TODO(issam, Bug 1894967): Move os auth to separate module and remove this.\n  },\n});\n\n// eslint-disable-next-line no-shadow\nconst ChromeUtils = withNotImplementedError({\n  defineLazyGetter: (obj, prop, getFn) => {\n    const callback = prop === \"log\" ? genericLogger : getFn;\n    obj[prop] = callback?.call(obj);\n  },\n  defineESModuleGetters(obj, modules) {\n    internalModuleResolvers.resolveModules(obj, modules);\n  },\n  importESModule(moduleURI) {\n    return internalModuleResolvers.resolveModule(moduleURI)?.module;\n  },\n});\nwindow.ChromeUtils = ChromeUtils;\n\n// Define mock for Region.sys.mjs\nconst Region = withNotImplementedError({\n  home: \"US\",\n});\n\n// Define mock for OSKeyStore.sys.mjs\nconst OSKeyStore = withNotImplementedError({\n  ensureLoggedIn: () => true,\n});\n\n// Define mock for Services\n// NOTE: Services is a global so we need to attach it to the window\n// eslint-disable-next-line no-shadow\nconst Services = withNotImplementedError({\n  locale: withNotImplementedError({ isAppLocaleRTL: false }),\n  prefs: withNotImplementedError({ prefIsLocked: () => false }),\n  strings: withNotImplementedError({\n    createBundle: () =>\n      withNotImplementedError({\n        GetStringFromName: () => \"\",\n        formatStringFromName: () => \"\",\n      }),\n  }),\n  // TODO(FXCM-936): we should use crypto.randomUUID() instead of Services.uuid.generateUUID() in our codebase\n  // Underneath crypto.randomUUID() uses the same implementation as generateUUID()\n  // https://searchfox.org/mozilla-central/rev/d405168c4d3c0fb900a7354ae17bb34e939af996/dom/base/Crypto.cpp#96\n  // The only limitation is that it's not available in insecure contexts, which should be fine for both iOS and Desktop\n  // since we only autofill in secure contexts\n  uuid: withNotImplementedError({ generateUUID: () => crypto.randomUUID() }),\n});\nwindow.Services = Services;\n\n// Define mock for Localization\nwindow.Localization = function () {\n  return { formatValueSync: () => \"\" };\n};\n\n// TODO(issam, FXCM-935): In order to create create a universal mock for glean that\n// dispatches telemetry messages to the iOS, we need to modify typedefs in swift. For now, we map the telemetry events\n// to the expected shape. FXCM-935 will tackle cleaning this up.\nwindow.Glean = {\n  // While moving away from Legacy Telemetry to Glean, the automated script generated the additional categories\n  // `creditcard` and `address`. After bug 1933961 all probes will have moved to category formautofillCreditcards and formautofillAddresses.\n  formautofillCreditcards: undefinedProxy(),\n  formautofill: undefinedProxy(),\n  creditcard: undefinedProxy(),\n  _mapGleanToLegacy: (eventName, { value, ...extra }) => {\n    const eventMapping = {\n      filledModifiedAddressForm: {\n        method: \"filled_modified\",\n        object: \"address_form\",\n      },\n      filledAddressForm: { method: \"filled\", object: \"address_form\" },\n      detectedAddressForm: { method: \"detected\", object: \"address_form\" },\n      filledModifiedAddressFormExt: {\n        method: \"filled_modified\",\n        object: \"address_form_ext\",\n      },\n      filledAddressFormExt: { method: \"filled\", object: \"address_form_ext\" },\n      detectedAddressFormExt: {\n        method: \"detected\",\n        object: \"address_form_ext\",\n      },\n    };\n    // eslint-disable-next-line no-undef\n    webkit.messageHandlers.addressFormTelemetryMessageHandler.postMessage(\n      JSON.stringify({\n        type: \"event\",\n        category: \"address\",\n        ...eventMapping[eventName],\n        value,\n        extra,\n      })\n    );\n  },\n  address: new Proxy(\n    {},\n    {\n      get(_target, prop) {\n        return {\n          record: extras => Glean._mapGleanToLegacy(prop, extras),\n        };\n      },\n    }\n  ),\n  // Keeping unused category formautofillAddresses here, because Bug 1933961\n  // will move probes from the glean category address to formautofillAddresses\n  formautofillAddresses: undefinedProxy(),\n};\n\nconst genericLogger = () =>\n  withNotImplementedError({\n    info: () => {},\n    error: () => {},\n    warn: () => {},\n    debug: () => {},\n  });\n\n\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs":
/*!**********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HeuristicsRegExp: () => (/* binding */ HeuristicsRegExp),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* eslint-disable no-useless-concat */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// prettier-ignore\nconst HeuristicsRegExp = {\n  RULES: {\n    email: undefined,\n    tel: undefined,\n    \"tel-country-code\" : undefined,\n    \"address-housenumber\": undefined,\n    \"street-address\": undefined,\n    \"address-line1\": undefined,\n    \"address-line2\": undefined,\n    \"address-line3\": undefined,\n    \"postal-code\": undefined,\n    \"address-level3\": undefined,\n    \"address-level2\": undefined,\n    \"address-level1\": undefined,\n    // Note: We place the `organization` field after the `address` fields, to\n    // ensure that all address-related fields that might contain organization \n    // info are matched as address fields first.\n    organization: undefined,\n    country: undefined,\n    // Note: We place the `cc-name` field for Credit Card first, because\n    // it is more specific than the `name` field below and we want to check\n    // for it before we catch the more generic one.\n    \"cc-name\": undefined,\n    name: undefined,\n    \"given-name\": undefined,\n    \"additional-name\": undefined,\n    \"family-name\": undefined,\n    \"cc-csc\": undefined,\n    \"cc-number\": undefined,\n    \"cc-exp-month\": undefined,\n    \"cc-exp-year\": undefined,\n    \"cc-exp\": undefined,\n    \"cc-type\": undefined,\n  },\n\n  // regular expressions that only apply to label\n  LABEL_RULES: {\n    \"address-line1\": undefined,\n    \"address-line2\": undefined,\n  },\n\n  RULE_SETS: [\n    //=========================================================================\n    // Firefox-specific rules\n    {\n      \"address-line1\": \"addrline1|address_1|addl1\",\n      \"address-line2\":\n        \"addrline2|address_2|addl2\" +\n        \"|landmark\", // common in IN\n      \"address-line3\": \"addrline3|address_3|addl3\",\n      \"address-level2\": \"città\", // it-IT\n      \"address-housenumber\":\n        \"house\\\\s*number|hausnummer|haus|house[a-z\\-]*n(r|o)\",\n      \"address-level3\":\n        \"(^address-?level-?3$)\" +\n        \"|neighbou*rhood|barrio|bairro|colonia|suburb\", // en/es/pt/mx/au/nz\n      \"postal-code\": \"^PLZ(\\\\b|\\\\*)\", // de-DE\n      \"additional-name\": \"apellido.?materno|lastlastname\",\n      \"cc-name\":\n        \"accountholdername\" +\n        \"|titulaire\", // fr-FR\n      \"cc-number\":\n        \"(cc|kk)nr\",    // de-DE\n      \"cc-exp\":\n        \"ważna.*do\" +        // pl-PL\n        \"|data.*ważności\" +  // pl-PL\n        \"|mm\\\\s*[\\\\-\\\\/]\\\\s*yy\" +  // en-US\n        \"|mm\\\\s*[\\\\-\\\\/]\\\\s*aa\" +  // es-ES\n        \"|mm\\\\s*[\\\\-\\\\/]\\\\s*jj\" +  // de-AT\n        \"|vervaldatum\",            // nl-NL\n      \"cc-exp-month\":\n        \"month\" +\n        \"|(cc|kk)month\" +    // de-DE\n        \"|miesiąc\" +         // pl-PL\n        \"|mes\" +             // es-ES\n        \"|maand\",            // nl-NL\n      \"cc-exp-year\":\n        \"year\" +\n        \"|(cc|kk)year\" +     // de-DE\n        \"|rok\" +             // pl-PL\n        \"|(anno|año)\" +      // es-ES\n        \"|jaar\",             // nl-NL\n      \"cc-type\":\n        \"(cc|card).*(type)\" +\n        \"|kartenmarke\" +     // de-DE\n        \"|typ.*karty\",       // pl-PL\n      \"cc-csc\":\n        \"(\\\\bcvn\\\\b|\\\\bcvv\\\\b|\\\\bcvc\\\\b|\\\\bcsc\\\\b|\\\\bcvd\\\\b|\\\\bcid\\\\b|\\\\bccv\\\\b)\",\n      \"tel-country-code\":\n        \"phone.*country|country.*phone\" +\n        \"tel.*country|country.*tel\",\n    },\n\n    //=========================================================================\n    // These are the rules used by Bitwarden [0], converted into RegExp form.\n    // [0] https://github.com/bitwarden/browser/blob/c2b8802201fac5e292d55d5caf3f1f78088d823c/src/services/autofill.service.ts#L436\n    {\n      email: \"(^e-?mail$)|(^email-?address$)\",\n\n      tel:\n        \"(^phone$)\" +\n        \"|(^mobile$)\" +\n        \"|(^mobile-?phone$)\" +\n        \"|(^tel$)\" +\n        \"|(^telephone$)\" +\n        \"|(^phone-?number$)\",\n\n      organization:\n        \"(^company$)\" +\n        \"|(^company-?name$)\" +\n        \"|(^organization$)\" +\n        \"|(^organization-?name$)\",\n\n      \"street-address\":\n        \"(^address$)\" +\n        \"|(^street-?address$)\" +\n        \"|(^addr$)\" +\n        \"|(^street$)\" +\n        \"|(^mailing-?addr(ess)?$)\" + // Modified to not grab lines, below\n        \"|(^billing-?addr(ess)?$)\" + // Modified to not grab lines, below\n        \"|(^mail-?addr(ess)?$)\" + // Modified to not grab lines, below\n        \"|(^bill-?addr(ess)?$)\", // Modified to not grab lines, below\n\n      \"address-line1\":\n        \"(^address-?1$)\" +\n        \"|(^address-?line-?1$)\" +\n        \"|(^addr-?1$)\" +\n        \"|(^street-?1$)\",\n\n      \"address-line2\":\n        \"(^address-?2$)\" +\n        \"|(^address-?line-?2$)\" +\n        \"|(^addr-?2$)\" +\n        \"|(^street-?2$)\",\n\n      \"address-line3\":\n        \"(^address-?3$)\" +\n        \"|(^address-?line-?3$)\" +\n        \"|(^addr-?3$)\" +\n        \"|(^street-?3$)\",\n\n      \"address-level2\":\n        \"(^city$)\" +\n        \"|(^town$)\" +\n        \"|(^address-?level-?2$)\" +\n        \"|(^address-?city$)\" +\n        \"|(^address-?town$)\",\n\n      \"address-level1\":\n        \"(^state$)\" +\n        \"|(^province$)\" +\n        \"|(^provence$)\" +\n        \"|(^address-?level-?1$)\" +\n        \"|(^address-?state$)\" +\n        \"|(^address-?province$)\",\n\n      \"postal-code\":\n        \"(^postal$)\" +\n        \"|(^zip$)\" +\n        \"|(^zip2$)\" +\n        \"|(^zip-?code$)\" +\n        \"|(^postal-?code$)\" +\n        \"|(^post-?code$)\" +\n        \"|(^address-?zip$)\" +\n        \"|(^address-?postal$)\" +\n        \"|(^address-?code$)\" +\n        \"|(^address-?postal-?code$)\" +\n        \"|(^address-?zip-?code$)\",\n\n      country:\n        \"(^country$)\" +\n        \"|(^country-?code$)\" +\n        \"|(^country-?name$)\" +\n        \"|(^address-?country$)\" +\n        \"|(^address-?country-?name$)\" +\n        \"|(^address-?country-?code$)\",\n\n      name: \"(^name$)|full-?name|your-?name\",\n\n      \"given-name\":\n        \"(^f-?name$)\" +\n        \"|(^first-?name$)\" +\n        \"|(^given-?name$)\" +\n        \"|(^first-?n$)\",\n\n      \"additional-name\":\n        \"(^m-?name$)\" +\n        \"|(^middle-?name$)\" +\n        \"|(^additional-?name$)\" +\n        \"|(^middle-?initial$)\" +\n        \"|(^middle-?n$)\" +\n        \"|(^middle-?i$)\",\n\n      \"family-name\":\n        \"(^l-?name$)\" +\n        \"|(^last-?name$)\" +\n        \"|(^s-?name$)\" +\n        \"|(^surname$)\" +\n        \"|(^family-?name$)\" +\n        \"|(^family-?n$)\" +\n        \"|(^last-?n$)\",\n\n      \"cc-name\":\n        \"cc-?name\" +\n        \"|card-?name\" +\n        \"|cardholder-?name\" +\n        \"|cardholder\",\n        // \"|(^name$)\" + // Removed to avoid overwriting \"name\", above.\n\n      \"cc-number\":\n        \"cc-?number\" +\n        \"|cc-?num\" +\n        \"|card-?number\" +\n        \"|card-?num\" +\n        \"|(^number$)\" +\n        \"|(^cc$)\" +\n        \"|cc-?no\" +\n        \"|card-?no\" +\n        \"|(^credit-?card$)\" +\n        \"|numero-?carte\" +\n        \"|(^carte$)\" +\n        \"|(^carte-?credit$)\" +\n        \"|num-?carte\" +\n        \"|cb-?num\",\n\n      \"cc-exp\":\n        \"(^cc-?exp$)\" +\n        \"|(^card-?exp$)\" +\n        \"|(^cc-?expiration$)\" +\n        \"|(^card-?expiration$)\" +\n        \"|(^cc-?ex$)\" +\n        \"|(^card-?ex$)\" +\n        \"|(^card-?expire$)\" +\n        \"|(^card-?expiry$)\" +\n        \"|(^validite$)\" +\n        \"|(^expiration$)\" +\n        \"|(^expiry$)\" +\n        \"|mm-?yy\" +\n        \"|mm-?yyyy\" +\n        \"|yy-?mm\" +\n        \"|yyyy-?mm\" +\n        \"|expiration-?date\" +\n        \"|payment-?card-?expiration\" +\n        \"|(^payment-?cc-?date$)\",\n\n      \"cc-exp-month\":\n        \"(^exp-?month$)\" +\n        \"|(^cc-?exp-?month$)\" +\n        \"|(^cc-?month$)\" +\n        \"|(^card-?month$)\" +\n        \"|(^cc-?mo$)\" +\n        \"|(^card-?mo$)\" +\n        \"|(^exp-?mo$)\" +\n        \"|(^card-?exp-?mo$)\" +\n        \"|(^cc-?exp-?mo$)\" +\n        \"|(^card-?expiration-?month$)\" +\n        \"|(^expiration-?month$)\" +\n        \"|(^cc-?mm$)\" +\n        \"|(^cc-?m$)\" +\n        \"|(^card-?mm$)\" +\n        \"|(^card-?m$)\" +\n        \"|(^card-?exp-?mm$)\" +\n        \"|(^cc-?exp-?mm$)\" +\n        \"|(^exp-?mm$)\" +\n        \"|(^exp-?m$)\" +\n        \"|(^expire-?month$)\" +\n        \"|(^expire-?mo$)\" +\n        \"|(^expiry-?month$)\" +\n        \"|(^expiry-?mo$)\" +\n        \"|(^card-?expire-?month$)\" +\n        \"|(^card-?expire-?mo$)\" +\n        \"|(^card-?expiry-?month$)\" +\n        \"|(^card-?expiry-?mo$)\" +\n        \"|(^mois-?validite$)\" +\n        \"|(^mois-?expiration$)\" +\n        \"|(^m-?validite$)\" +\n        \"|(^m-?expiration$)\" +\n        \"|(^expiry-?date-?field-?month$)\" +\n        \"|(^expiration-?date-?month$)\" +\n        \"|(^expiration-?date-?mm$)\" +\n        \"|(^exp-?mon$)\" +\n        \"|(^validity-?mo$)\" +\n        \"|(^exp-?date-?mo$)\" +\n        \"|(^cb-?date-?mois$)\" +\n        \"|(^date-?m$)\",\n\n      \"cc-exp-year\":\n        \"(^exp-?year$)\" +\n        \"|(^cc-?exp-?year$)\" +\n        \"|(^cc-?year$)\" +\n        \"|(^card-?year$)\" +\n        \"|(^cc-?yr$)\" +\n        \"|(^card-?yr$)\" +\n        \"|(^exp-?yr$)\" +\n        \"|(^card-?exp-?yr$)\" +\n        \"|(^cc-?exp-?yr$)\" +\n        \"|(^card-?expiration-?year$)\" +\n        \"|(^expiration-?year$)\" +\n        \"|(^cc-?yy$)\" +\n        \"|(^cc-?y$)\" +\n        \"|(^card-?yy$)\" +\n        \"|(^card-?y$)\" +\n        \"|(^card-?exp-?yy$)\" +\n        \"|(^cc-?exp-?yy$)\" +\n        \"|(^exp-?yy$)\" +\n        \"|(^exp-?y$)\" +\n        \"|(^cc-?yyyy$)\" +\n        \"|(^card-?yyyy$)\" +\n        \"|(^card-?exp-?yyyy$)\" +\n        \"|(^cc-?exp-?yyyy$)\" +\n        \"|(^expire-?year$)\" +\n        \"|(^expire-?yr$)\" +\n        \"|(^expiry-?year$)\" +\n        \"|(^expiry-?yr$)\" +\n        \"|(^card-?expire-?year$)\" +\n        \"|(^card-?expire-?yr$)\" +\n        \"|(^card-?expiry-?year$)\" +\n        \"|(^card-?expiry-?yr$)\" +\n        \"|(^an-?validite$)\" +\n        \"|(^an-?expiration$)\" +\n        \"|(^annee-?validite$)\" +\n        \"|(^annee-?expiration$)\" +\n        \"|(^expiry-?date-?field-?year$)\" +\n        \"|(^expiration-?date-?year$)\" +\n        \"|(^cb-?date-?ann$)\" +\n        \"|(^expiration-?date-?yy$)\" +\n        \"|(^expiration-?date-?yyyy$)\" +\n        \"|(^validity-?year$)\" +\n        \"|(^exp-?date-?year$)\" +\n        \"|(^date-?y$)\",\n\n      \"cc-type\":\n        \"(^cc-?type$)\" +\n        \"|(^card-?type$)\" +\n        \"|(^card-?brand$)\" +\n        \"|(^cc-?brand$)\" +\n        \"|(^cb-?type$)\",\n    },\n\n    //=========================================================================\n    // These rules are from Chromium source codes [1]. Most of them\n    // converted to JS format have the same meaning with the original ones except\n    // the first line of \"address-level1\".\n    // [1] https://source.chromium.org/chromium/chromium/src/+/master:components/autofill/core/common/autofill_regex_constants.cc\n    {\n      // ==== Email ====\n      email:\n        \"e.?mail\" +\n        \"|courriel\" + // fr\n        \"|correo.*electr(o|ó)nico\" + // es-ES\n        \"|メールアドレス\" + // ja-JP\n        \"|Электронной.?Почты\" + // ru\n        \"|邮件|邮箱\" + // zh-CN\n        \"|電郵地址\" + // zh-TW\n        \"|ഇ-മെയില്‍|ഇലക്ട്രോണിക്.?\" +\n        \"മെയിൽ\" + // ml\n        \"|ایمیل|پست.*الکترونیک\" + // fa\n        \"|ईमेल|इलॅक्ट्रॉनिक.?मेल\" + // hi\n        \"|(\\\\b|_)eposta(\\\\b|_)\" + // tr\n        \"|(?:이메일|전자.?우편|[Ee]-?mail)(.?주소)?\", // ko-KR\n\n      // ==== Telephone ====\n      tel:\n        \"phone|mobile|contact.?number\" +\n        \"|telefonnummer\" + // de-DE\n        \"|telefono|teléfono\" + // es\n        \"|telfixe\" + // fr-FR\n        \"|電話\" + // ja-JP\n        \"|telefone|telemovel\" + // pt-BR, pt-PT\n        \"|телефон\" + // ru\n        \"|मोबाइल\" + // hi for mobile\n        \"|(\\\\b|_|\\\\*)telefon(\\\\b|_|\\\\*)\" + // tr\n        \"|电话\" + // zh-CN\n        \"|മൊബൈല്‍\" + // ml for mobile\n        \"|(?:전화|핸드폰|휴대폰|휴대전화)(?:.?번호)?\", // ko-KR\n\n      // ==== Address Fields ====\n      organization:\n        \"company|business|organization|organisation\" +\n        // In order to support webkit we convert all negative lookbehinds to a capture group\n        // (?<!not)word -> (?<neg>notword)|word\n        // TODO: Bug 1829583\n        \"|(?<neg>confirma)\" +\n        \"|firma|firmenname\" + // de-DE\n        \"|empresa\" + // es\n        \"|societe|société\" + // fr-FR\n        \"|ragione.?sociale\" + // it-IT\n        \"|会社\" + // ja-JP\n        \"|название.?компании\" + // ru\n        \"|单位|公司\" + // zh-CN\n        \"|شرکت\" + // fa\n        \"|회사|직장\", // ko-KR\n\n      \"street-address\": \"streetaddress|street-address\",\n      \"address-line1\":\n        \"^address$|address[_-]?line(one)?|address1|addr1|street\" +\n        \"|(?:shipping|billing)address$\" +\n        \"|strasse|straße\" + // de-DE\n        \"|house.?name\" + // en-GB\n        \"|direccion|dirección\" + // es\n        \"|adresse\" + // fr-FR\n        \"|indirizzo\" + // it-IT\n        \"|^住所$|住所1\" + // ja-JP\n        \"|morada\" + // pt-BR, pt-PT\n        // In order to support webkit we convert all negative lookbehinds to a capture group\n        // (?<!not)word -> (?<neg>notword)|word\n        // TODO: Bug 1829583\n        \"|(?<neg>identificação do endereço)\" +\n        \"|(endereço)\" + // pt-BR, pt-PT\n        \"|Адрес\" + // ru\n        \"|地址\" + // zh-CN\n        \"|(\\\\b|_)adres(?! (başlığı(nız)?|tarifi))(\\\\b|_)\" + // tr\n        \"|^주소.?$|주소.?1\", // ko-KR\n\n      \"address-line2\":\n        \"address[_-]?line(2|two)|address2|addr2|street|suite|unit(?!e)\" + // Firefox adds `(?!e)` to unit to skip `United State`\n        \"|adresszusatz|ergänzende.?angaben\" + // de-DE\n        \"|direccion2|colonia|adicional\" + // es\n        \"|addresssuppl|complementnom|appartement\" + // fr-FR\n        \"|indirizzo2\" + // it-IT\n        \"|住所2\" + // ja-JP\n        \"|complemento|addrcomplement\" + // pt-BR, pt-PT\n        \"|Улица\" + // ru\n        \"|地址2\" + // zh-CN\n        \"|주소.?2\", // ko-KR\n\n      \"address-line3\":\n        \"address[_-]?line(3|three)|address3|addr3|street|suite|unit(?!e)\" + // Firefox adds `(?!e)` to unit to skip `United State`\n        \"|adresszusatz|ergänzende.?angaben\" + // de-DE\n        \"|direccion3|colonia|adicional\" + // es\n        \"|addresssuppl|complementnom|appartement\" + // fr-FR\n        \"|indirizzo3\" + // it-IT\n        \"|住所3\" + // ja-JP\n        \"|complemento|addrcomplement\" + // pt-BR, pt-PT\n        \"|Улица\" + // ru\n        \"|地址3\" + // zh-CN\n        \"|주소.?3\", // ko-KR\n\n      \"address-level2\":\n        \"city|town\" +\n        \"|\\\\bort\\\\b|stadt\" + // de-DE\n        \"|suburb\" + // en-AU\n        \"|ciudad|provincia|localidad|poblacion\" + // es\n        \"|ville|commune\" + // fr-FR\n        \"|localita\" + // it-IT\n        \"|市区町村\" + // ja-JP\n        \"|cidade\" + // pt-BR, pt-PT\n        \"|Город\" + // ru\n        \"|市\" + // zh-CN\n        \"|分區\" + // zh-TW\n        \"|شهر\" + // fa\n        \"|शहर\" + // hi for city\n        \"|ग्राम|गाँव\" + // hi for village\n        \"|നഗരം|ഗ്രാമം\" + // ml for town|village\n        \"|((\\\\b|_|\\\\*)([İii̇]l[cç]e(miz|niz)?)(\\\\b|_|\\\\*))\" + // tr\n        \"|^시[^도·・]|시[·・]?군[·・]?구\", // ko-KR\n\n      \"address-level1\":\n        // In order to support webkit we convert all negative lookbehinds to a capture group\n        // (?<!not)word -> (?<neg>notword)|word\n        // TODO: Bug 1829583\n        \"(?<neg>united?.state|hist?.state|history?.state)\" +\n        \"|state|county|region|province\" +\n        \"|principality\" + // en-UK\n        \"|都道府県\" + // ja-JP\n        \"|estado|provincia\" + // pt-BR, pt-PT\n        \"|область\" + // ru\n        \"|省\" + // zh-CN\n        \"|地區\" + // zh-TW\n        \"|സംസ്ഥാനം\" + // ml\n        \"|استان\" + // fa\n        \"|राज्य\" + // hi\n        \"|((\\\\b|_|\\\\*)(eyalet|[şs]ehir|[İii̇]l(imiz)?|kent)(\\\\b|_|\\\\*))\" + // tr\n        \"|^시[·・]?도\", // ko-KR\n\n      \"postal-code\":\n        \"zip|postal|post.*code|pcode\" +\n        \"|pin.?code\" + // en-IN\n        \"|postleitzahl\" + // de-DE\n        \"|\\\\bcp\\\\b\" + // es\n        \"|\\\\bcdp\\\\b\" + // fr-FR\n        \"|\\\\bcap\\\\b\" + // it-IT\n        \"|郵便番号\" + // ja-JP\n        \"|codigo|codpos|\\\\bcep\\\\b\" + // pt-BR, pt-PT\n        \"|Почтовый.?Индекс\" + // ru\n        \"|पिन.?कोड\" + // hi\n        \"|പിന്‍കോഡ്\" + // ml\n        \"|邮政编码|邮编\" + // zh-CN\n        \"|郵遞區號\" + // zh-TW\n        \"|(\\\\b|_)posta kodu(\\\\b|_)\" + // tr\n        \"|우편.?번호\", // ko-KR\n\n      country:\n        \"country|countries\" +\n        \"|país|pais\" + // es\n        \"|(\\\\b|_)land(\\\\b|_)(?!.*(mark.*))\" + // de-DE landmark is a type in india.\n        // In order to support webkit we convert all negative lookbehinds to a capture group\n        // (?<!not)word -> (?<neg>notword)|word\n        // TODO: Bug 1829583\n        \"|(?<neg>入国|出国)\" +\n        \"|国\" + // ja-JP\n        \"|国家\" + // zh-CN\n        \"|국가|나라\" + // ko-KR\n        \"|(\\\\b|_)(ülke|ulce|ulke)(\\\\b|_)\" + // tr\n        \"|کشور\", // fa\n\n      // ==== Name Fields ====\n      \"cc-name\":\n        \"card.?(?:holder|owner)|name.*(\\\\b)?on(\\\\b)?.*card\" +\n        \"|^(credit[-\\\\s]?card|card).*name|cc.?full.?name\" +\n        \"|karteninhaber\" + // de-DE\n        \"|nombre.*tarjeta\" + // es\n        \"|nom.*carte\" + // fr-FR\n        \"|nome.*cart\" + // it-IT\n        \"|名前\" + // ja-JP\n        \"|Имя.*карты\" + // ru\n        \"|信用卡开户名|开户名|持卡人姓名\" + // zh-CN\n        \"|持卡人姓名\", // zh-TW\n\n      name:\n        \"^name|full.?name|your.?name|customer.?name|bill.?name|ship.?name\" +\n        \"|name.*first.*last|firstandlastname\" +\n        \"|nombre.*y.*apellidos\" + // es\n        \"|^nom(?!bre)\" + // fr-FR\n        \"|お名前|氏名\" + // ja-JP\n        \"|^nome\" + // pt-BR, pt-PT\n        \"|نام.*نام.*خانوادگی\" + // fa\n        \"|姓名\" + // zh-CN\n        \"|(\\\\b|_|\\\\*)ad[ı]? soyad[ı]?(\\\\b|_|\\\\*)\" + // tr\n        \"|성명\", // ko-KR\n\n      \"given-name\":\n        \"first.*name|initials|fname|first$|given.*name\" +\n        \"|vorname\" + // de-DE\n        \"|nombre\" + // es\n        \"|forename|prénom|prenom\" + // fr-FR\n        \"|名\" + // ja-JP\n        \"|nome\" + // pt-BR, pt-PT\n        \"|Имя\" + // ru\n        \"|نام\" + // fa\n        \"|이름\" + // ko-KR\n        \"|പേര്\" + // ml\n        \"|(\\\\b|_|\\\\*)(isim|ad|ad(i|ı|iniz|ınız)?)(\\\\b|_|\\\\*)\" + // tr\n        \"|नाम\", // hi\n\n      \"additional-name\":\n        \"middle.*name|mname|middle$|middle.*initial|m\\\\.i\\\\.|mi$|\\\\bmi\\\\b\",\n\n      \"family-name\":\n        \"last.*name|lname|surname|last$|secondname|family.*name\" +\n        \"|nachname\" + // de-DE\n        \"|apellidos?\" + // es\n        \"|famille|^nom(?!bre)\" + // fr-FR\n        \"|cognome\" + // it-IT\n        \"|姓\" + // ja-JP\n        \"|apelidos|surename|sobrenome\" + // pt-BR, pt-PT\n        \"|Фамилия\" + // ru\n        \"|نام.*خانوادگی\" + // fa\n        \"|उपनाम\" + // hi\n        \"|മറുപേര്\" + // ml\n        \"|(\\\\b|_|\\\\*)(soyisim|soyad(i|ı|iniz|ınız)?)(\\\\b|_|\\\\*)\" + // tr\n        \"|\\\\b성(?:[^명]|\\\\b)\", // ko-KR\n\n      // ==== Credit Card Fields ====\n      // Note: `cc-name` expression has been moved up, above `name`, in\n      // order to handle specialization through ordering.\n      \"cc-number\":\n        \"(add)?(?:card|cc|acct).?(?:number|#|no|num|field(?!s)|pan)\" +\n        // In order to support webkit we convert all negative lookbehinds to a capture group\n        // (?<!not)word -> (?<neg>notword)|word\n        // TODO: Bug 1829583\n        \"|(?<neg>telefonnummer|hausnummer|personnummer|fødselsnummer)\" + // de-DE, sv-SE, no\n        \"|nummer\" +\n        \"|カード番号\" + // ja-JP\n        \"|Номер.*карты\" + // ru\n        \"|信用卡号|信用卡号码\" + // zh-CN\n        \"|信用卡卡號\" + // zh-TW\n        \"|카드\" + // ko-KR\n        // es/pt/fr\n        \"|(numero|número|numéro)(?!.*(document|fono|phone|réservation))\",\n\n      \"cc-exp-month\":\n        \"expir|exp.*mo|exp.*date|ccmonth|cardmonth|addmonth\" +\n        \"|gueltig|gültig|monat\" + // de-DE\n        \"|fecha\" + // es\n        \"|date.*exp\" + // fr-FR\n        \"|scadenza\" + // it-IT\n        \"|有効期限\" + // ja-JP\n        \"|validade\" + // pt-BR, pt-PT\n        \"|Срок действия карты\" + // ru\n        \"|月\", // zh-CN\n\n      \"cc-exp-year\":\n        \"exp|^/|(add)?year\" +\n        \"|ablaufdatum|gueltig|gültig|jahr\" + // de-DE\n        \"|fecha\" + // es\n        \"|scadenza\" + // it-IT\n        \"|有効期限\" + // ja-JP\n        \"|validade\" + // pt-BR, pt-PT\n        \"|Срок действия карты\" + // ru\n        \"|年|有效期\", // zh-CN\n\n      \"cc-exp\":\n        \"expir|exp.*date|^expfield$\" +\n        \"|gueltig|gültig\" + // de-DE\n        \"|fecha\" + // es\n        \"|date.*exp\" + // fr-FR\n        \"|scadenza\" + // it-IT\n        \"|有効期限\" + // ja-JP\n        \"|validade\" + // pt-BR, pt-PT\n        \"|Срок действия карты\", // ru\n\n      \"cc-csc\":\n        \"verification|card.?identification|security.?code|card.?code\" +\n        \"|security.?value\" +\n        \"|security.?number|card.?pin|c-v-v\" +\n        // We omit this regexp in favor of being less generic.\n        // See \"Firefox-specific\" rules for cc-csc\n        // \"|(cvn|cvv|cvc|csc|cvd|cid|ccv)(field)?\" +\n        \"|\\\\bcid\\\\b\",\n    },\n  ],\n\n  LABEL_RULE_SETS: [\n    {\n      \"address-line1\":\n        \"(^\\\\W*address)\" +\n        \"|(address\\\\W*$)\" +\n        \"|(?:shipping|billing|mailing|pick.?up|drop.?off|delivery|sender|postal|\" +\n        \"recipient|home|work|office|school|business|mail)[\\\\s\\\\-]+address\" +\n        \"|address\\\\s+(of|for|to|from)\" +\n        \"|adresse\" +                         // fr-FR\n        \"|indirizzo\" +                       // it-IT\n        \"|住所\" +                            // ja-JP\n        \"|地址\" +                            // zh-CN\n        \"|(\\\\b|_)adres(?! tarifi)(\\\\b|_)\" +  // tr\n        \"|주소\" +                            // ko-KR\n        \"|^alamat\" +                         // id\n        // Should contain street and any other address component, in any order\n        \"|street.*(house|building|apartment|floor)\" +  // en\n        \"|(house|building|apartment|floor).*street\" +\n        \"|(sokak|cadde).*(apartman|bina|daire|mahalle)\" +  // tr\n        \"|(apartman|bina|daire|mahalle).*(sokak|cadde)\" +\n        \"|улиц.*(дом|корпус|квартир|этаж)|(дом|корпус|квартир|этаж).*улиц\",  // ru\n    },\n    {\n      \"address-line2\":\n        \"address|line\" +\n        \"|house|building|apartment|floor\" +    // de-DE\n        \"|adresse\" +      // fr-FR\n        \"|indirizzo\" +    // it-IT\n        \"|地址\" +         // zh-CN\n        \"|주소\",          // ko-KR\n    },\n  ],\n\n  _getRules(rules, rulesets) {\n    function computeRule(name) {\n      let regexps = [];\n      rulesets.forEach(set => {\n        if (set[name]) {\n          // Add the rule.\n          // We make the regex lower case so that we can match it against the\n          // lower-cased field name and get a rough equivalent of a case-insensitive\n          // match. This avoids a performance cliff with the \"iu\" flag on regular\n          // expressions.\n          regexps.push(`(${set[name].toLowerCase()})`.normalize(\"NFKC\"));\n        }\n      });\n\n      const value = new RegExp(regexps.join(\"|\"), \"gu\");\n\n      Object.defineProperty(rules, name, { get: undefined });\n      Object.defineProperty(rules, name, { value });\n      return value;\n    }\n\n    Object.keys(rules).forEach(field =>\n      Object.defineProperty(rules, field, {\n        get() {\n          return computeRule(field);\n        },\n      })\n    );\n\n    return rules;\n  },\n\n  getLabelRules() {\n    return this._getRules(this.LABEL_RULES, this.LABEL_RULE_SETS);\n  },\n\n  getRules() {\n    return this._getRules(this.RULES, this.RULE_SETS);\n  },\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HeuristicsRegExp);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs":
/*!****************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LabelUtils: () => (/* binding */ LabelUtils),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  FormAutofillUtils: \"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\",\n});\n\n/**\n * This is a utility object to work with HTML labels in web pages,\n * including finding label elements and label text extraction.\n */\nconst LabelUtils = {\n  // The tag name list is from Chromium except for \"STYLE\":\n  // eslint-disable-next-line max-len\n  // https://cs.chromium.org/chromium/src/components/autofill/content/renderer/form_autofill_util.cc?l=216&rcl=d33a171b7c308a64dc3372fac3da2179c63b419e\n  EXCLUDED_TAGS: [\"SCRIPT\", \"NOSCRIPT\", \"OPTION\", \"STYLE\"],\n\n  // A map object, whose keys are the id's of form fields and each value is an\n  // array consisting of label elements correponding to the id. This map only\n  // contains those labels with an id that matches a form element.\n  // @type {Map<string, array>}\n  _mappedLabels: null,\n\n  // An array consisting of label elements whose correponding form field doesn't\n  // have an id attribute.\n  // @type {Array<[HTMLLabelElement, HTMLElement]>}\n  _unmappedLabelControls: null,\n\n  // A weak map consisting of label element and extracted strings pairs.\n  // @type {WeakMap<HTMLLabelElement, array>}\n  _labelStrings: null,\n\n  /**\n   * Extract all strings of an element's children to an array.\n   * \"element.textContent\" is a string which is merged of all children nodes,\n   * and this function provides an array of the strings contains in an element.\n   *\n   * @param  {object} element\n   *         A DOM element to be extracted.\n   * @returns {Array}\n   *          All strings in an element.\n   */\n  extractLabelStrings(element) {\n    if (this._labelStrings.has(element)) {\n      return this._labelStrings.get(element);\n    }\n    let strings = [];\n    let _extractLabelStrings = el => {\n      if (this.EXCLUDED_TAGS.includes(el.tagName)) {\n        return;\n      }\n\n      if (el.nodeType == el.TEXT_NODE || !el.childNodes.length) {\n        let trimmedText = el.textContent.trim();\n        if (trimmedText) {\n          strings.push(trimmedText);\n        }\n        return;\n      }\n\n      for (let node of el.childNodes) {\n        let nodeType = node.nodeType;\n        if (nodeType != node.ELEMENT_NODE && nodeType != node.TEXT_NODE) {\n          continue;\n        }\n        _extractLabelStrings(node);\n      }\n    };\n    _extractLabelStrings(element);\n    this._labelStrings.set(element, strings);\n    return strings;\n  },\n\n  /**\n   * From a starting label element, find a nearby input or select element\n   * by traversing the nodes in document order, but don't search past another\n   * related element or outside the form.\n   */\n  findAdjacentControl(labelElement, potentialLabels) {\n    // First, look for an form element after the label.\n    let foundElementAfter = this.findNextFormControl(\n      labelElement,\n      false,\n      potentialLabels\n    );\n\n    // If the control has the same parent as the label, return it.\n    if (foundElementAfter?.parentNode == labelElement.parentNode) {\n      return foundElementAfter;\n    }\n\n    // Otherwise, look for a form control with the same parent backwards\n    // in the document.\n    let foundElementBefore = this.findNextFormControl(\n      labelElement,\n      true,\n      potentialLabels\n    );\n    if (foundElementBefore?.parentNode == labelElement.parentNode) {\n      return foundElementBefore;\n    }\n\n    // If there is no form control with the same parent forward or backward,\n    // return the form control nearest forward, if any, even though it doesn't\n    // have the same parent.\n    return foundElementAfter;\n  },\n\n  /**\n   * Find the next form control in the document tree after a starting label that\n   * could correspond to the label. If the form control is in potentialLabels, then\n   * it has already been possibly matched to another label so should be ignored.\n   *\n   *   @param {HTMLLabelElement} element\n   *          starting <label> element\n   *   @param {boolean} reverse\n   *          true to search backwards or false to search forwards\n   *   @param {Map} potentialLabels\n   *           map of form controls that have already potentially matched\n   */\n  findNextFormControl(element, reverse, potentialLabels) {\n    // Ignore elements and stop searching for elements that are already potentially\n    // labelled or are form elements that cannot be autofilled.\n    while ((element = this.nextElementInOrder(element, reverse))) {\n      if (potentialLabels.has(element)) {\n        break;\n      } else if (\n        lazy.FormAutofillUtils.isCreditCardOrAddressFieldType(element)\n      ) {\n        return element;\n      } else if (\n        [\n          \"button\",\n          \"input\",\n          \"label\",\n          \"meter\",\n          \"output\",\n          \"progress\",\n          \"select\",\n          \"textarea\",\n        ].includes(element.localName)\n      ) {\n        break;\n      }\n    }\n\n    return null;\n  },\n\n  nextElementInOrder(element, reverse) {\n    let result = reverse ? element.lastElementChild : element.firstElementChild;\n    if (result) {\n      return result;\n    }\n\n    while (element) {\n      result = reverse\n        ? element.previousElementSibling\n        : element.nextElementSibling;\n      if (result) {\n        return result;\n      }\n\n      element = element.parentNode;\n      if (\n        !element ||\n        element.localName == \"form\" ||\n        element.localName == \"fieldset\"\n      ) {\n        break;\n      }\n    }\n\n    return null;\n  },\n\n  generateLabelMap(doc) {\n    this._mappedLabels = new Map();\n    this._unmappedLabelControls = [];\n    this._labelStrings = new WeakMap();\n\n    // A map of potential label -> control for labels that don't have an id or\n    // control associated with them. Labels that have ids or associated controls\n    // will be placed in _mappedLabels.\n    let potentialLabels = new Map();\n\n    for (let label of doc.querySelectorAll(\"label\")) {\n      let id = label.htmlFor;\n      let control;\n      if (!id) {\n        control = label.control;\n        if (!control) {\n          // If the label has no control, look for the next input or select\n          // element in the document and add that to the potentialLabels list.\n          control = this.findAdjacentControl(label, potentialLabels);\n          if (control) {\n            potentialLabels.set(control, label);\n          } else {\n            continue;\n          }\n        }\n        id = control.id;\n      }\n      if (id) {\n        let labels = this._mappedLabels.get(id);\n        if (labels) {\n          labels.push(label);\n        } else {\n          this._mappedLabels.set(id, [label]);\n        }\n      } else {\n        // control must be non-empty here\n        this._unmappedLabelControls.push({ label, control });\n      }\n    }\n\n    // Now check the potentialLabels list. If any of the labels match form controls\n    // that are not bound to a label, add them. This allows a label to match a form\n    // control that is nearby even when it has no for attribute or doesn't match an id.\n    if (potentialLabels.size) {\n      for (let label of potentialLabels) {\n        if (\n          !this._unmappedLabelControls.some(e => e.control == label[0]) &&\n          (!label[1].id || !this._mappedLabels.has(label[1].id))\n        ) {\n          this._unmappedLabelControls.push({\n            label: label[1],\n            control: label[0],\n          });\n        }\n      }\n    }\n  },\n\n  clearLabelMap() {\n    this._mappedLabels = null;\n    this._unmappedLabelControls = null;\n    this._labelStrings = null;\n  },\n\n  findLabelElements(element) {\n    if (!this._mappedLabels) {\n      this.generateLabelMap(element.ownerDocument);\n    }\n\n    let id = element.id;\n    if (!id) {\n      return this._unmappedLabelControls\n        .filter(lc => lc.control == element)\n        .map(lc => lc.label);\n    }\n    return this._mappedLabels.get(id) || [];\n  },\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LabelUtils);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/LoginFormFactory.sys.mjs":
/*!**********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/LoginFormFactory.sys.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LoginFormFactory: () => (/* binding */ LoginFormFactory)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * A factory to generate LoginForm objects that represent a set of login fields\n * which aren't necessarily marked up with a <form> element.\n */\n\nconst lazy = {};\n\nChromeUtils.defineESModuleGetters(lazy, {\n  FormLikeFactory: \"resource://gre/modules/FormLikeFactory.sys.mjs\",\n  LoginHelper: \"resource://gre/modules/LoginHelper.sys.mjs\",\n  Logic: \"resource://gre/modules/LoginManager.shared.sys.mjs\",\n});\n\nChromeUtils.defineLazyGetter(lazy, \"log\", () => {\n  return lazy.LoginHelper.createLogger(\"LoginFormFactory\");\n});\n\nconst LoginFormFactory = {\n  /**\n   * WeakMap of the root element of a LoginForm to the LoginForm representing its fields.\n   *\n   * This is used to be able to lookup an existing LoginForm for a given root element since multiple\n   * calls to LoginFormFactory.createFrom* won't give the exact same object. When batching fills we don't always\n   * want to use the most recent list of elements for a LoginForm since we may end up doing multiple\n   * fills for the same set of elements when a field gets added between arming and running the\n   * DeferredTask.\n   *\n   * @type {WeakMap}\n   */\n  _loginFormsByRootElement: new WeakMap(),\n\n  /**\n   * Maps all DOM content documents in this content process, including those in\n   * frames, to a WeakSet of LoginForm.rootElement for the document.\n   */\n  _loginFormRootElementsByDocument: new WeakMap(),\n\n  /**\n   * Create a LoginForm object from a <form>.\n   *\n   * @param {HTMLFormElement} aForm\n   * @return {LoginForm}\n   * @throws Error if aForm isn't an HTMLFormElement\n   */\n  createFromForm(aForm) {\n    let formLike = lazy.FormLikeFactory.createFromForm(aForm);\n    formLike.action = lazy.Logic.getFormActionOrigin(aForm);\n\n    this._addLoginFormToRootElementsSet(formLike);\n\n    return formLike;\n  },\n\n  /**\n   * Create a LoginForm object from an elememt that is the root of the document\n   *\n   * Currently all <input> not in a <form> are one LoginForm but this\n   * shouldn't be relied upon as the heuristics may change to detect multiple\n   * \"forms\" (e.g. registration and login) on one page with a <form>.\n   *\n   * @param {HTMLElement} aDocumentRoot\n   * @return {LoginForm}\n   * @throws Error if aDocumentRoot is null\n   */\n  createFromDocumentRoot(aDocumentRoot) {\n    const formLike = lazy.FormLikeFactory.createFromDocumentRoot(aDocumentRoot);\n    formLike.action = lazy.Logic.getLoginOrigin(aDocumentRoot.baseURI);\n\n    lazy.log.debug(\n      \"Created non-form LoginForm for rootElement:\",\n      aDocumentRoot\n    );\n\n    this._addLoginFormToRootElementsSet(formLike);\n\n    return formLike;\n  },\n\n  /**\n   * Create a LoginForm object from a password or username field.\n   *\n   * If the field is in a <form>, construct the LoginForm from the form.\n   * Otherwise, create a LoginForm with a rootElement (wrapper) according to\n   * heuristics. Currently all <input> not in a <form> are one LoginForm but this\n   * shouldn't be relied upon as the heuristics may change to detect multiple\n   * \"forms\" (e.g. registration and login) on one page with a <form>.\n   *\n   * Note that two LoginForms created from the same field won't return the same LoginForm object.\n   * Use the `rootElement` property on the LoginForm as a key instead.\n   *\n   * @param {HTMLInputElement} aField - a password or username field in a document\n   * @return {LoginForm}\n   * @throws Error if aField isn't a password or username field in a document\n   */\n  createFromField(aField) {\n    if (\n      !HTMLInputElement.isInstance(aField) ||\n      (!aField.hasBeenTypePassword &&\n        !lazy.Logic.isUsernameFieldType(aField)) ||\n      !aField.ownerDocument\n    ) {\n      throw new Error(\n        \"createFromField requires a password or username field in a document\"\n      );\n    }\n\n    let form =\n      aField.form ||\n      lazy.FormLikeFactory.closestFormIgnoringShadowRoots(aField);\n    if (form) {\n      return this.createFromForm(form);\n    } else if (aField.hasAttribute(\"form\")) {\n      lazy.log.debug(\n        \"createFromField: field has form attribute but no form: \",\n        aField.getAttribute(\"form\")\n      );\n    }\n\n    let formLike = lazy.FormLikeFactory.createFromField(aField);\n    formLike.action = lazy.Logic.getLoginOrigin(aField.ownerDocument.baseURI);\n    lazy.log.debug(\n      \"Created non-form LoginForm for rootElement:\",\n      aField.ownerDocument.documentElement\n    );\n\n    this._addLoginFormToRootElementsSet(formLike);\n    return formLike;\n  },\n\n  getRootElementsWeakSetForDocument(aDocument) {\n    let rootElementsSet = this._loginFormRootElementsByDocument.get(aDocument);\n    if (!rootElementsSet) {\n      rootElementsSet = new WeakSet();\n      this._loginFormRootElementsByDocument.set(aDocument, rootElementsSet);\n    }\n    return rootElementsSet;\n  },\n\n  getForRootElement(aRootElement) {\n    return this._loginFormsByRootElement.get(aRootElement);\n  },\n\n  setForRootElement(aRootElement, aLoginForm) {\n    return this._loginFormsByRootElement.set(aRootElement, aLoginForm);\n  },\n\n  _addLoginFormToRootElementsSet(formLike) {\n    let rootElementsSet = this.getRootElementsWeakSetForDocument(\n      formLike.ownerDocument\n    );\n    rootElementsSet.add(formLike.rootElement);\n    lazy.log.debug(\n      \"adding\",\n      formLike.rootElement,\n      \"to root elements for\",\n      formLike.ownerDocument\n    );\n\n    this._loginFormsByRootElement.set(formLike.rootElement, formLike);\n  },\n};\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/LoginFormFactory.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/LoginFormState.sys.mjs":
/*!********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/LoginFormState.sys.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AUTOFILL_STATE: () => (/* binding */ AUTOFILL_STATE),\n/* harmony export */   LoginFormState: () => (/* binding */ LoginFormState),\n/* harmony export */   WeakFieldSet: () => (/* binding */ WeakFieldSet)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_LoginManager_shared_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/LoginManager.shared.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.sys.mjs\");\n\n\nconst lazy = {};\n\nChromeUtils.defineESModuleGetters(lazy, {\n  FormLikeFactory: \"resource://gre/modules/FormLikeFactory.sys.mjs\",\n  LoginFormFactory: \"resource://gre/modules/shared/LoginFormFactory.sys.mjs\",\n  LoginHelper: \"resource://gre/modules/LoginHelper.sys.mjs\",\n  LoginRecipesContent: \"resource://gre/modules/LoginRecipes.sys.mjs\",\n});\n\nconst AUTOFILL_STATE = \"autofill\";\n\n// Events on pages with Shadow DOM could return the shadow host element\n// (aEvent.target) rather than the actual username or password field\n// (aEvent.composedTarget).\n// Only allow input elements (can be extended later) to avoid false negatives.\nclass WeakFieldSet extends WeakSet {\n  add(value) {\n    if (!HTMLInputElement.isInstance(value)) {\n      throw new Error(\"Non-field type added to a WeakFieldSet\");\n    }\n    super.add(value);\n  }\n}\n\n/**\n * Logic of Capture and Filling.\n *\n * This class will be shared with Firefox iOS and should have no references to\n * Gecko internals. See Bug 1774208.\n */\nclass LoginFormState {\n  /**\n   * Keeps track of filled fields and values.\n   */\n  fillsByRootElement = new WeakMap();\n  /**\n   * Keeps track of fields we've filled with generated passwords\n   */\n  generatedPasswordFields = new WeakFieldSet();\n  /**\n   * Keeps track of logins that were last submitted.\n   */\n  lastSubmittedValuesByRootElement = new WeakMap();\n  fieldModificationsByRootElement = new WeakMap();\n  /**\n   * Anything entered into an <input> that we think might be a username\n   */\n  possibleUsernames = new Set();\n  /**\n   * Anything entered into an <input> that we think might be a password\n   */\n  possiblePasswords = new Set();\n\n  /**\n   * Keeps track of the formLike of nodes (form or formless password field)\n   * that we are watching when they are removed from DOM.\n   */\n  formLikeByObservedNode = new WeakMap();\n\n  /**\n   * Keeps track of all formless password fields that have been\n   * updated by the user.\n   */\n  formlessModifiedPasswordFields = new WeakFieldSet();\n\n  /**\n   * Caches the results of the username heuristics\n   */\n  #cachedIsInferredUsernameField = new WeakMap();\n  #cachedIsInferredEmailField = new WeakMap();\n  #cachedIsInferredLoginForm = new WeakMap();\n\n  /**\n   * Records the mock username field when its associated form is submitted.\n   */\n  mockUsernameOnlyField = null;\n\n  /**\n   * Records the number of possible username event received for this document.\n   */\n  numFormHasPossibleUsernameEvent = 0;\n\n  captureLoginTimeStamp = 0;\n\n  // Scenarios detected on this page\n  #scenariosByRoot = new WeakMap();\n\n  constructor(logger = () => {}, observer = () => {}) {\n    LoginFormState.logger = logger;\n    this.observer = observer;\n  }\n\n  getScenario(inputElement) {\n    const formLikeRoot = lazy.FormLikeFactory.findRootForField(inputElement);\n    return this.#scenariosByRoot.get(formLikeRoot);\n  }\n\n  setScenario(formLikeRoot, scenario) {\n    this.#scenariosByRoot.set(formLikeRoot, scenario);\n  }\n\n  storeUserInput(field) {\n    if (field.value && lazy.LoginHelper.captureInputChanges) {\n      if (resource_gre_modules_LoginManager_shared_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.Logic.isPasswordFieldType(field)) {\n        this.possiblePasswords.add(field.value);\n      } else if (resource_gre_modules_LoginManager_shared_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.Logic.isUsernameFieldType(field)) {\n        this.possibleUsernames.add(field.value);\n      }\n    }\n  }\n\n  /**\n   * Returns true if the input field is considered an email field by\n   * 'LoginHelper.isInferredEmailField'.\n   *\n   * @param {Element} element the field to check.\n   * @returns {boolean} True if the element is likely an email field\n   */\n  isProbablyAnEmailField(inputElement) {\n    if (!inputElement) {\n      return false;\n    }\n\n    let result = this.#cachedIsInferredEmailField.get(inputElement);\n    if (result === undefined) {\n      result = resource_gre_modules_LoginManager_shared_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.Logic.isInferredEmailField(inputElement);\n      this.#cachedIsInferredEmailField.set(inputElement, result);\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns true if the input field is considered a username field by\n   * 'LoginHelper.isInferredUsernameField'. The main purpose of this method\n   * is to cache the result because _getFormFields has many call sites and we\n   * want to avoid applying the heuristic every time.\n   *\n   * @param {Element} element the field to check.\n   * @returns {boolean} True if the element is likely a username field\n   */\n  isProbablyAUsernameField(inputElement) {\n    let result = this.#cachedIsInferredUsernameField.get(inputElement);\n    if (result === undefined) {\n      result = resource_gre_modules_LoginManager_shared_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.Logic.isInferredUsernameField(inputElement);\n      this.#cachedIsInferredUsernameField.set(inputElement, result);\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns true if the form is considered a username login form if\n   * 1. The input element looks like a username field or the form looks\n   *    like a login form\n   * 2. The input field doesn't match keywords that indicate the username\n   *    is not used for login (ex, search) or the login form is not use\n   *    a username to sign-in (ex, authentication code)\n   *\n   * @param {Element} element the form to check.\n   * @returns {boolean} True if the element is likely a login form\n   */\n  #isProbablyAUsernameLoginForm(formElement, inputElement) {\n    let result = this.#cachedIsInferredLoginForm.get(formElement);\n    if (result === undefined) {\n      // We should revisit these rules after we collect more positive or negative\n      // cases for username-only forms. Right now, if-else-based rules are good\n      // enough to cover the sites we know, but if we find out defining \"weight\" for each\n      // rule is necessary to improve the heuristic, we should consider switching\n      // this with Fathom.\n\n      result = false;\n      // Check whether the input field looks like a username field or the\n      // form looks like a sign-in or sign-up form.\n      if (\n        this.isProbablyAUsernameField(inputElement) ||\n        resource_gre_modules_LoginManager_shared_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.Logic.isInferredLoginForm(formElement)\n      ) {\n        // This is where we collect hints that indicate this is not a username\n        // login form.\n        if (!resource_gre_modules_LoginManager_shared_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.Logic.isInferredNonUsernameField(inputElement)) {\n          result = true;\n        }\n      }\n      this.#cachedIsInferredLoginForm.set(formElement, result);\n    }\n\n    return result;\n  }\n\n  /**\n   * Given a field, determine whether that field was last filled as a username\n   * field AND whether the username is still filled in with the username AND\n   * whether the associated password field has the matching password.\n   *\n   * @note This could possibly be unified with getFieldContext but they have\n   * slightly different use cases. getFieldContext looks up recipes whereas this\n   * method doesn't need to since it's only returning a boolean based upon the\n   * recipes used for the last fill (in _fillForm).\n   *\n   * @param {HTMLInputElement} aUsernameField element contained in a LoginForm\n   *                                          cached in LoginFormFactory.\n   * @returns {Boolean} whether the username and password fields still have the\n   *                    last-filled values, if previously filled.\n   */\n  #isLoginAlreadyFilled(aUsernameField) {\n    let formLikeRoot = lazy.FormLikeFactory.findRootForField(aUsernameField);\n    // Look for the existing LoginForm.\n    let existingLoginForm =\n      lazy.LoginFormFactory.getForRootElement(formLikeRoot);\n    if (!existingLoginForm) {\n      throw new Error(\n        \"#isLoginAlreadyFilled called with a username field with \" +\n          \"no rootElement LoginForm\"\n      );\n    }\n\n    let { login: filledLogin } =\n      this.fillsByRootElement.get(formLikeRoot) || {};\n    if (!filledLogin) {\n      return false;\n    }\n\n    // Unpack the weak references.\n    let autoFilledUsernameField = filledLogin.usernameField?.get();\n    let autoFilledPasswordField = filledLogin.passwordField?.get();\n\n    // Check username and password values match what was filled.\n    if (\n      !autoFilledUsernameField ||\n      autoFilledUsernameField != aUsernameField ||\n      autoFilledUsernameField.value != filledLogin.username ||\n      (autoFilledPasswordField &&\n        autoFilledPasswordField.value != filledLogin.password)\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  _togglePasswordFieldMasking(passwordField, unmask) {\n    let { editor } = passwordField;\n\n    if (passwordField.type != \"password\") {\n      // The type may have been changed by the website.\n      LoginFormState.logger(\"Field isn't type=password.\");\n      return;\n    }\n\n    if (!unmask && !editor) {\n      // It hasn't been created yet but the default is to be masked anyways.\n      return;\n    }\n\n    if (unmask) {\n      editor.unmask(0);\n      return;\n    }\n\n    if (editor.autoMaskingEnabled) {\n      return;\n    }\n    editor.mask();\n  }\n\n  /**\n   * Track a form field as has having been filled with a generated password. This adds explicit\n   * focus & blur handling to unmask & mask the value, and enables special handling of edits to\n   * generated password values (see the observer's input event handler.)\n   *\n   * @param {HTMLInputElement} passwordField\n   */\n  _treatAsGeneratedPasswordField(passwordField) {\n    this.generatedPasswordFields.add(passwordField);\n\n    // blur/focus: listen for focus changes to we can mask/unmask generated passwords\n    for (let eventType of [\"blur\", \"focus\"]) {\n      passwordField.addEventListener(eventType, this.observer, {\n        capture: true,\n        mozSystemGroup: true,\n      });\n    }\n    if (passwordField.ownerDocument.activeElement == passwordField) {\n      // Unmask the password field\n      this._togglePasswordFieldMasking(passwordField, true);\n    }\n  }\n\n  _formHasModifiedFields(form) {\n    const doc = form.rootElement.ownerDocument;\n    let userHasInteracted;\n    const testOnlyUserHasInteracted =\n      lazy.LoginHelper.testOnlyUserHasInteractedWithDocument;\n    if (Cu.isInAutomation && testOnlyUserHasInteracted !== null) {\n      userHasInteracted = testOnlyUserHasInteracted;\n    } else {\n      userHasInteracted =\n        !lazy.LoginHelper.userInputRequiredToCapture ||\n        this.captureLoginTimeStamp != doc.lastUserGestureTimeStamp;\n    }\n\n    LoginFormState.logger(\n      `_formHasModifiedFields: userHasInteracted: ${userHasInteracted}.`\n    );\n\n    // Skip if user didn't interact with the page since last call or ever\n    if (!userHasInteracted) {\n      return false;\n    }\n\n    // check for user inputs to the form fields\n    let fieldsModified = this.fieldModificationsByRootElement.get(\n      form.rootElement\n    );\n    // also consider a form modified if there's a difference between fields' .value and .defaultValue\n    if (!fieldsModified) {\n      fieldsModified = Array.from(form.elements).some(\n        field =>\n          field.defaultValue !== undefined && field.value !== field.defaultValue\n      );\n    }\n    return fieldsModified;\n  }\n\n  _stopTreatingAsGeneratedPasswordField(passwordField) {\n    this.generatedPasswordFields.delete(passwordField);\n\n    // Remove all the event listeners added in _passwordEditedOrGenerated\n    for (let eventType of [\"blur\", \"focus\"]) {\n      passwordField.removeEventListener(eventType, this.observer, {\n        capture: true,\n        mozSystemGroup: true,\n      });\n    }\n\n    // Mask the password field\n    this._togglePasswordFieldMasking(passwordField, false);\n  }\n\n  onFocus(field, focusedField, onUsernameFocus) {\n    if (field.hasBeenTypePassword && this.generatedPasswordFields.has(field)) {\n      // Used to unmask fields with filled generated passwords when focused.\n      this._togglePasswordFieldMasking(field, true);\n      return;\n    }\n\n    if (this.#isLoginAlreadyFilled(focusedField)) {\n      LoginFormState.logger(\"Login already filled.\");\n      return;\n    }\n\n    // Only used for username fields.\n    onUsernameFocus(focusedField);\n  }\n\n  /** Remove login field highlight when its value is cleared or overwritten.\n   */\n  static #removeFillFieldHighlight(event) {\n    event.target.autofillState = \"\";\n  }\n\n  /**\n   * Highlight login fields on autocomplete or autofill on page load.\n   * @param {Node} element that needs highlighting.\n   */\n  static _highlightFilledField(element) {\n    element.autofillState = AUTOFILL_STATE;\n    // Remove highlighting when the field is changed.\n    element.addEventListener(\n      \"input\",\n      LoginFormState.#removeFillFieldHighlight,\n      {\n        mozSystemGroup: true,\n        once: true,\n      }\n    );\n  }\n\n  /**\n   * Returns the username field of the passed form if the form is a\n   * username-only form.\n   * A form is considered a username-only form only if it meets all the\n   * following conditions:\n   * 1. Does not have any password field,\n   * 2. Only contains one input field whose type is username compatible.\n   * 3. The username compatible input field looks like a username field\n   *    or the form itself looks like a sign-in or sign-up form.\n   * Additionally, if an input is formless and its autocomplete attribute is\n   * set to 'username' (this check is done in the DOM to avoid firing excessive events),\n   * we construct a FormLike object using this input and perform the same logic\n   * described above to determine if the new FormLike object is username-only.\n   *\n   * @param {FormLike} form\n   *                  the form to check.\n   * @param {Object}  recipe=null\n   *                  A relevant field override recipe to use.\n   * @returns {Element} The username field or null (if the form is not a\n   *                    username-only form).\n   */\n  getUsernameFieldFromUsernameOnlyForm(form, recipe = null) {\n    let candidate = null;\n    for (let element of form.elements) {\n      // We are looking for a username-only form, so if there is a password\n      // field in the form, this is NOT a username-only form.\n      if (element.hasBeenTypePassword) {\n        return null;\n      }\n\n      // Ignore input fields whose type are not username compatiable, ex, hidden.\n      if (!resource_gre_modules_LoginManager_shared_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.Logic.isUsernameFieldType(element)) {\n        continue;\n      }\n\n      if (\n        recipe?.notUsernameSelector &&\n        element.matches(recipe.notUsernameSelector)\n      ) {\n        continue;\n      }\n\n      // If there are more than two input fields whose type is username\n      // compatiable, this is NOT a username-only form.\n      if (candidate) {\n        return null;\n      }\n      candidate = element;\n    }\n    if (\n      candidate &&\n      this.#isProbablyAUsernameLoginForm(form.rootElement, candidate)\n    ) {\n      return candidate;\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {LoginForm} form - the LoginForm to look for password fields in.\n   * @param {Object} options\n   * @param {bool} [options.skipEmptyFields=false] - Whether to ignore password fields with no value.\n   *                                                 Used at capture time since saving empty values isn't\n   *                                                 useful.\n   * @param {Object} [options.fieldOverrideRecipe=null] - A relevant field override recipe to use.\n   * @return {Array|null} Array of password field elements for the specified form.\n   *                      If no pw fields are found, or if more than 5 are found, then null\n   *                      is returned.\n   */\n  static _getPasswordFields(\n    form,\n    {\n      fieldOverrideRecipe = null,\n      minPasswordLength = 0,\n      ignoreConnect = false,\n    } = {}\n  ) {\n    // Locate the password fields in the form.\n    let pwFields = [];\n    for (let i = 0; i < form.elements.length; i++) {\n      let element = form.elements[i];\n      if (\n        !HTMLInputElement.isInstance(element) ||\n        !element.hasBeenTypePassword ||\n        (!element.isConnected && !ignoreConnect)\n      ) {\n        continue;\n      }\n\n      // Exclude ones matching a `notPasswordSelector`, if specified.\n      if (\n        fieldOverrideRecipe?.notPasswordSelector &&\n        element.matches(fieldOverrideRecipe.notPasswordSelector)\n      ) {\n        LoginFormState.logger(\n          `Skipping password field with id: ${element.id}, name: ${element.name} due to recipe ${fieldOverrideRecipe}.`\n        );\n        continue;\n      }\n\n      // XXX: Bug 780449 tracks our handling of emoji and multi-code-point characters in\n      // password fields. To avoid surprises, we should be consistent with the visual\n      // representation of the masked password\n      if (\n        minPasswordLength &&\n        element.value.trim().length < minPasswordLength\n      ) {\n        LoginFormState.logger(\n          `Skipping password field with id: ${element.id}, name: ${element.name} as value is too short.`\n        );\n        continue; // Ignore empty or too-short passwords fields\n      }\n\n      pwFields[pwFields.length] = {\n        index: i,\n        element,\n      };\n    }\n\n    // If too few or too many fields, bail out.\n    if (!pwFields.length) {\n      LoginFormState.logger(\"Form ignored, no password fields.\");\n      return null;\n    }\n\n    if (pwFields.length > 5) {\n      LoginFormState.logger(\n        `Form ignored, too many password fields:  ${pwFields.length}.`\n      );\n      return null;\n    }\n\n    return pwFields;\n  }\n\n  /**\n   * Stores passed arguments, and returns whether or not they match the args given the last time\n   * this method was called with the same [formLikeRoot]. This is used to avoid sending duplicate\n   * messages to the parent.\n   *\n   * @param {Element} formLikeRoot\n   * @param {string} usernameValue\n   * @param {string} passwordValue\n   * @param {boolean?} [dismissed=false]\n   * @param {boolean?} [triggeredByFillingGenerated=false] whether or not this call was triggered by a generated\n   *        password being filled into a form-like element.\n   *\n   * @returns {boolean} true if args match the most recently passed values\n   */\n  compareAndUpdatePreviouslySentValues(\n    formLikeRoot,\n    usernameValue,\n    passwordValue,\n    dismissed = false,\n    triggeredByFillingGenerated = false\n  ) {\n    const lastSentValues =\n      this.lastSubmittedValuesByRootElement.get(formLikeRoot);\n    if (lastSentValues) {\n      if (dismissed && !lastSentValues.dismissed) {\n        // preserve previous dismissed value if it was false (i.e. shown/open)\n        dismissed = false;\n      }\n      if (\n        lastSentValues.username == usernameValue &&\n        lastSentValues.password == passwordValue &&\n        lastSentValues.dismissed == dismissed &&\n        lastSentValues.triggeredByFillingGenerated ==\n          triggeredByFillingGenerated\n      ) {\n        LoginFormState.logger(\n          \"compareAndUpdatePreviouslySentValues: values are equivalent, returning true.\"\n        );\n        return true;\n      }\n    }\n\n    // Save the last submitted values so we don't prompt twice for the same values using\n    // different capture methods e.g. a form submit event and upon navigation.\n    this.lastSubmittedValuesByRootElement.set(formLikeRoot, {\n      username: usernameValue,\n      password: passwordValue,\n      dismissed,\n      triggeredByFillingGenerated,\n    });\n    LoginFormState.logger(\n      \"compareAndUpdatePreviouslySentValues: values not equivalent, returning false.\"\n    );\n    return false;\n  }\n\n  fillConfirmFieldWithGeneratedPassword(passwordField) {\n    const form = lazy.LoginFormFactory.createFromField(passwordField);\n    const previousGeneratedPasswordField = form.elements.some(\n      inp => inp !== passwordField && this.generatedPasswordFields.has(inp)\n    );\n    if (previousGeneratedPasswordField) {\n      LoginFormState.logger(\n        \"Previously-filled generated password input found.\"\n      );\n      return;\n    }\n\n    const confirmPasswordInput = resource_gre_modules_LoginManager_shared_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.Logic.findConfirmationField(\n      passwordField,\n      lazy.LoginFormFactory\n    );\n\n    if (confirmPasswordInput && !confirmPasswordInput.value) {\n      this._treatAsGeneratedPasswordField(confirmPasswordInput);\n      confirmPasswordInput.setUserInput(passwordField.value);\n      LoginFormState._highlightFilledField(confirmPasswordInput);\n    }\n  }\n\n  /**\n   * Returns the username and password fields found in the form.\n   * Can handle complex forms by trying to figure out what the\n   * relevant fields are.\n   *\n   * @param {LoginForm} form\n   * @param {bool} isSubmission\n   * @param {Set} recipes\n   * @param {Object} options\n   * @param {bool} [options.ignoreConnect] - Whether to ignore checking isConnected\n   *                                         of the element.\n   * @return {Object} {usernameField, newPasswordField, oldPasswordField, confirmPasswordField}\n   *\n   * usernameField may be null.\n   * newPasswordField may be null. If null, this is a username-only form.\n   * oldPasswordField may be null. If null, newPasswordField is just\n   * \"theLoginField\". If not null, the form is apparently a\n   * change-password field, with oldPasswordField containing the password\n   * that is being changed.\n   *\n   * Note that even though we can create a LoginForm from a text field,\n   * this method will only return a non-null usernameField if the\n   * LoginForm has a password field.\n   */\n  _getFormFields(form, isSubmission, recipes, { ignoreConnect = false } = {}) {\n    let usernameField = null;\n    let newPasswordField = null;\n    let oldPasswordField = null;\n    let confirmPasswordField = null;\n    let emptyResult = {\n      usernameField: null,\n      newPasswordField: null,\n      oldPasswordField: null,\n      confirmPasswordField: null,\n    };\n\n    let pwFields = null;\n    let fieldOverrideRecipe = lazy.LoginRecipesContent.getFieldOverrides(\n      recipes,\n      form\n    );\n    if (fieldOverrideRecipe) {\n      LoginFormState.logger(\"fieldOverrideRecipe found \", fieldOverrideRecipe);\n      let pwOverrideField = lazy.LoginRecipesContent.queryLoginField(\n        form,\n        fieldOverrideRecipe.passwordSelector\n      );\n      if (pwOverrideField) {\n        LoginFormState.logger(\"pwOverrideField found \", pwOverrideField);\n        // The field from the password override may be in a different LoginForm.\n        let formLike = lazy.LoginFormFactory.createFromField(pwOverrideField);\n        pwFields = [\n          {\n            index: [...formLike.elements].indexOf(pwOverrideField),\n            element: pwOverrideField,\n          },\n        ];\n      }\n\n      let usernameOverrideField = lazy.LoginRecipesContent.queryLoginField(\n        form,\n        fieldOverrideRecipe.usernameSelector\n      );\n      if (usernameOverrideField) {\n        usernameField = usernameOverrideField;\n      }\n    }\n\n    if (!pwFields) {\n      // Locate the password field(s) in the form. Up to 5 supported.\n      // If there's no password field, there's nothing for us to do.\n      const minSubmitPasswordLength = 2;\n      pwFields = LoginFormState._getPasswordFields(form, {\n        fieldOverrideRecipe,\n        minPasswordLength: isSubmission ? minSubmitPasswordLength : 0,\n        ignoreConnect,\n      });\n    }\n\n    // Check whether this is a username-only form when the form doesn't have\n    // a password field. Note that recipes are not supported in username-only\n    // forms currently (Bug 1708455).\n    if (!pwFields) {\n      if (!lazy.LoginHelper.usernameOnlyFormEnabled) {\n        return emptyResult;\n      }\n\n      usernameField = this.getUsernameFieldFromUsernameOnlyForm(\n        form,\n        fieldOverrideRecipe\n      );\n\n      if (usernameField) {\n        LoginFormState.logger(\n          `Found username field with name: ${usernameField.name}.`\n        );\n      }\n\n      return {\n        ...emptyResult,\n        usernameField,\n      };\n    }\n\n    if (!usernameField) {\n      // Searching backwards from the first password field until we find a field\n      // that looks like a \"username\" field. If no \"username\" field is found,\n      // consider an email-like field a username field, if any.\n      // If neither a username-like or an email-like field exists, assume the\n      // first text field before the password field is the username.\n      // We might not find a username field if the user is already logged in to the site.\n      //\n      // Note: We only search fields precede the first password field because we\n      // don't see sites putting a username field after a password field. We can\n      // extend searching to all fields in the form if this turns out not to be the case.\n\n      for (let i = pwFields[0].index - 1; i >= 0; i--) {\n        let element = form.elements[i];\n        if (!resource_gre_modules_LoginManager_shared_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.Logic.isUsernameFieldType(element, { ignoreConnect })) {\n          continue;\n        }\n\n        if (\n          fieldOverrideRecipe?.notUsernameSelector &&\n          element.matches(fieldOverrideRecipe.notUsernameSelector)\n        ) {\n          continue;\n        }\n\n        // Assume the first text field is the username by default.\n        // It will be replaced if we find a likely username field afterward.\n        if (!usernameField) {\n          usernameField = element;\n        }\n\n        if (this.isProbablyAUsernameField(element)) {\n          // An username field is found, we are done.\n          usernameField = element;\n          break;\n        } else if (this.isProbablyAnEmailField(element)) {\n          // An email field is found, consider it a username field but continue\n          // to search for an \"username\" field.\n          // In current implementation, if another email field is found during\n          // the process, we will use the new one.\n          usernameField = element;\n        }\n      }\n    }\n\n    if (!usernameField) {\n      LoginFormState.logger(\"No username field found.\");\n    } else {\n      LoginFormState.logger(\n        `Found username field with name: ${usernameField.name}.`\n      );\n    }\n\n    let pwGeneratedFields = pwFields.filter(pwField =>\n      this.generatedPasswordFields.has(pwField.element)\n    );\n    if (pwGeneratedFields.length) {\n      // we have at least the newPasswordField\n      [newPasswordField, confirmPasswordField] = pwGeneratedFields.map(\n        pwField => pwField.element\n      );\n      // if the user filled a field with a generated password,\n      // a field immediately previous to that is most likely the old password field\n      let idx = pwFields.findIndex(\n        pwField => pwField.element === newPasswordField\n      );\n      if (idx > 0) {\n        oldPasswordField = pwFields[idx - 1].element;\n      }\n      return {\n        ...emptyResult,\n        usernameField,\n        newPasswordField,\n        oldPasswordField: oldPasswordField || null,\n        confirmPasswordField: confirmPasswordField || null,\n      };\n    }\n\n    // If we're not submitting a form (it's a page load), there are no\n    // password field values for us to use for identifying fields. So,\n    // just assume the first password field is the one to be filled in.\n    if (!isSubmission || pwFields.length == 1) {\n      let passwordField = pwFields[0].element;\n      LoginFormState.logger(\n        `Found Password field with name: ${passwordField.name}.`\n      );\n      return {\n        ...emptyResult,\n        usernameField,\n        newPasswordField: passwordField,\n        oldPasswordField: null,\n      };\n    }\n\n    // We're looking for both new and old password field\n    // Try to figure out what is in the form based on the password values.\n    let pw1 = pwFields[0].element.value;\n    let pw2 = pwFields[1] ? pwFields[1].element.value : null;\n    let pw3 = pwFields[2] ? pwFields[2].element.value : null;\n\n    if (pwFields.length == 3) {\n      // Look for two identical passwords, that's the new password\n\n      if (pw1 == pw2 && pw2 == pw3) {\n        // All 3 passwords the same? Weird! Treat as if 1 pw field.\n        newPasswordField = pwFields[0].element;\n        oldPasswordField = null;\n      } else if (pw1 == pw2) {\n        newPasswordField = pwFields[0].element;\n        oldPasswordField = pwFields[2].element;\n      } else if (pw2 == pw3) {\n        oldPasswordField = pwFields[0].element;\n        newPasswordField = pwFields[2].element;\n      } else if (pw1 == pw3) {\n        // A bit odd, but could make sense with the right page layout.\n        newPasswordField = pwFields[0].element;\n        oldPasswordField = pwFields[1].element;\n      } else {\n        // We can't tell which of the 3 passwords should be saved.\n        LoginFormState.logger(`Form ignored -- all 3 pw fields differ.`);\n        return emptyResult;\n      }\n    } else if (pw1 == pw2) {\n      // pwFields.length == 2\n      // Treat as if 1 pw field\n      newPasswordField = pwFields[0].element;\n      oldPasswordField = null;\n    } else {\n      // Just assume that the 2nd password is the new password\n      oldPasswordField = pwFields[0].element;\n      newPasswordField = pwFields[1].element;\n    }\n    LoginFormState.logger(\n      `New Password field id: ${newPasswordField.id}, name: ${newPasswordField.name}.`\n    );\n\n    LoginFormState.logger(\n      oldPasswordField\n        ? `Old Password field id: ${oldPasswordField.id}, name: ${oldPasswordField.name}.`\n        : \"No Old password field.\"\n    );\n    return {\n      ...emptyResult,\n      usernameField,\n      newPasswordField,\n      oldPasswordField,\n    };\n  }\n\n  /**\n   * Returns the username and password fields found in the form by input\n   * element into form.\n   *\n   * @param {HTMLInputElement} aField\n   *                           A form field\n   * @return {Array} [usernameField, newPasswordField, oldPasswordField]\n   *\n   * Details of these values are the same as _getFormFields.\n   */\n  getUserNameAndPasswordFields(aField) {\n    const noResult = [null, null, null];\n    if (!HTMLInputElement.isInstance(aField)) {\n      throw new Error(\"getUserNameAndPasswordFields: input element required\");\n    }\n\n    if (aField.nodePrincipal.isNullPrincipal || !aField.isConnected) {\n      return noResult;\n    }\n\n    // If the element is not a login form field, return all null.\n    if (!aField.hasBeenTypePassword && !resource_gre_modules_LoginManager_shared_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.Logic.isUsernameFieldType(aField)) {\n      return noResult;\n    }\n\n    const form = lazy.LoginFormFactory.createFromField(aField);\n    const doc = aField.ownerDocument;\n    const formOrigin = resource_gre_modules_LoginManager_shared_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.Logic.getLoginOrigin(doc.documentURI);\n    const recipes = lazy.LoginRecipesContent.getRecipes(\n      formOrigin,\n      doc.defaultView\n    );\n    const { usernameField, newPasswordField, oldPasswordField } =\n      this._getFormFields(form, false, recipes);\n\n    return [usernameField, newPasswordField, oldPasswordField];\n  }\n\n  /**\n   * Verify if a field is a valid login form field and\n   * returns some information about it's LoginForm.\n   *\n   * @param {Element} aField\n   *                  A form field we want to verify.\n   *\n   * @returns {Object} an object with information about the\n   *                   LoginForm username and password field\n   *                   or null if the passed field is invalid.\n   */\n  getFieldContext(aField) {\n    // If the element is not a proper form field, return null.\n    if (\n      !HTMLInputElement.isInstance(aField) ||\n      (!aField.hasBeenTypePassword && !resource_gre_modules_LoginManager_shared_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.Logic.isUsernameFieldType(aField)) ||\n      aField.nodePrincipal.isNullPrincipal ||\n      aField.nodePrincipal.schemeIs(\"about\") ||\n      !aField.ownerDocument\n    ) {\n      return null;\n    }\n    let { hasBeenTypePassword } = aField;\n\n    // This array provides labels that correspond to the return values from\n    // `getUserNameAndPasswordFields` so we can know which one aField is.\n    const LOGIN_FIELD_ORDER = [\"username\", \"new-password\", \"current-password\"];\n    let usernameAndPasswordFields = this.getUserNameAndPasswordFields(aField);\n    let fieldNameHint;\n    let indexOfFieldInUsernameAndPasswordFields =\n      usernameAndPasswordFields.indexOf(aField);\n    if (indexOfFieldInUsernameAndPasswordFields == -1) {\n      // For fields in the form that are neither username nor password,\n      // set fieldNameHint to \"other\". Right now, in contextmenu, we treat both\n      // \"username\" and \"other\" field as username fields.\n      fieldNameHint = hasBeenTypePassword ? \"current-password\" : \"other\";\n    } else {\n      fieldNameHint =\n        LOGIN_FIELD_ORDER[indexOfFieldInUsernameAndPasswordFields];\n    }\n    let [, newPasswordField] = usernameAndPasswordFields;\n\n    return {\n      activeField: {\n        disabled: aField.disabled || aField.readOnly,\n        fieldNameHint,\n      },\n      // `passwordField` may be the same as `activeField`.\n      passwordField: {\n        found: !!newPasswordField,\n        disabled:\n          newPasswordField &&\n          (newPasswordField.disabled || newPasswordField.readOnly),\n      },\n    };\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/LoginFormState.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.sys.mjs":
/*!*************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.sys.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Logic: () => (/* binding */ Logic)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/XPCOMUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs\");\n/* harmony import */ var resource_gre_modules_shared_NewPasswordModel_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/NewPasswordModel.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/NewPasswordModel.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * Code that we can share across Firefox Desktop, Firefox Android and Firefox iOS.\n */\n\n\n\n\nclass Logic {\n  static inputTypeIsCompatibleWithUsername(input) {\n    const fieldType = input.getAttribute(\"type\")?.toLowerCase() || input.type;\n    return (\n      [\"text\", \"email\", \"url\", \"tel\", \"number\", \"search\"].includes(fieldType) ||\n      fieldType?.includes(\"user\")\n    );\n  }\n\n  /**\n   * Test whether the element has the keyword in its attributes.\n   * The tested attributes include id, name, className, and placeholder.\n   */\n  static elementAttrsMatchRegex(element, regex) {\n    if (\n      regex.test(element.id) ||\n      regex.test(element.name) ||\n      regex.test(element.className)\n    ) {\n      return true;\n    }\n\n    const placeholder = element.getAttribute(\"placeholder\");\n    return placeholder && regex.test(placeholder);\n  }\n\n  /**\n   * Infer whether a form is a sign-in form by searching keywords\n   * in its attributes\n   *\n   * @param {Element} element\n   *                  the form we want to check.\n   *\n   * @returns {boolean} True if any of the rules matches\n   */\n  static isInferredLoginForm(formElement) {\n    // This is copied from 'loginFormAttrRegex' in NewPasswordModel.sys.mjs\n    const loginExpr =\n      /login|log in|log on|log-on|sign in|sigin|sign\\/in|sign-in|sign on|sign-on/i;\n\n    if (Logic.elementAttrsMatchRegex(formElement, loginExpr)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Search for keywords that indicates the input field is not likely a\n   * field of a username login form.\n   *\n   * @param {Element} element\n   *                  the input field we want to check.\n   *\n   * @returns {boolean} True if any of the rules matches\n   */\n  static isInferredNonUsernameField(element) {\n    const expr = /\\b(search|code|add)\\b/i;\n\n    if (\n      Logic.elementAttrsMatchRegex(element, expr) ||\n      Logic.hasLabelMatchingRegex(element, expr)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Infer whether an input field is a username field by searching\n   * 'username' keyword in its attributes\n   *\n   * @param {Element} element\n   *                  the field we want to check.\n   *\n   * @returns {boolean} True if any of the rules matches\n   */\n  static isInferredUsernameField(element) {\n    const expr = /username/i;\n\n    let ac = element.getAutocompleteInfo()?.fieldName;\n    if (ac && ac == \"username\") {\n      return true;\n    }\n\n    if (\n      Logic.elementAttrsMatchRegex(element, expr) ||\n      Logic.hasLabelMatchingRegex(element, expr)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Infer whether an input field is an email field by searching\n   * 'email' keyword in its attributes.\n   *\n   * @param {Element} element\n   *                  the field we want to check.\n   *\n   * @returns {boolean} True if any of the rules matches\n   */\n  static isInferredEmailField(element) {\n    const expr = /email|邮箱/i;\n\n    if (element.type == \"email\") {\n      return true;\n    }\n\n    let ac = element.getAutocompleteInfo()?.fieldName;\n    if (ac && ac == \"email\") {\n      return true;\n    }\n\n    if (\n      Logic.elementAttrsMatchRegex(element, expr) ||\n      Logic.hasLabelMatchingRegex(element, expr)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Test whether associated labels of the element have the keyword.\n   * This is a simplified rule of hasLabelMatchingRegex in NewPasswordModel.sys.mjs\n   */\n  static hasLabelMatchingRegex(element, regex) {\n    return regex.test(element.labels?.[0]?.textContent);\n  }\n\n  /**\n   * Get the parts of the URL we want for identification.\n   * Strip out things like the userPass portion and handle javascript:.\n   */\n  static getLoginOrigin(uriString, allowJS = false) {\n    try {\n      const mozProxyRegex = /^moz-proxy:\\/\\//i;\n      if (mozProxyRegex.test(uriString)) {\n        // Special handling for moz-proxy URIs\n        const uri = new URL(uriString.replace(mozProxyRegex, \"https://\"));\n        return `moz-proxy://${uri.host}`;\n      }\n\n      const uri = new URL(uriString);\n      if (uri.protocol === \"javascript:\") {\n        return allowJS ? \"javascript:\" : null;\n      }\n\n      // Ensure the URL has a host\n      // Execption: file URIs See Bug 1651186\n      return uri.host || uri.protocol === \"file:\"\n        ? `${uri.protocol}//${uri.host}`\n        : null;\n    } catch {\n      return null;\n    }\n  }\n\n  static getFormActionOrigin(form) {\n    let uriString = form.action;\n\n    // A blank or missing action submits to where it came from.\n    if (uriString == \"\") {\n      // ala bug 297761\n      uriString = form.baseURI;\n    }\n\n    return this.getLoginOrigin(uriString, true);\n  }\n\n  /**\n   * Checks if a field type is username compatible.\n   *\n   * @param {Element} element\n   *                  the field we want to check.\n   * @param {Object} options\n   * @param {bool} [options.ignoreConnect] - Whether to ignore checking isConnected\n   *                                         of the element.\n   *\n   * @returns {Boolean} true if the field type is one\n   *                    of the username types.\n   */\n  static isUsernameFieldType(element, { ignoreConnect = false } = {}) {\n    if (!HTMLInputElement.isInstance(element)) {\n      return false;\n    }\n\n    if (!element.isConnected && !ignoreConnect) {\n      // If the element isn't connected then it isn't visible to the user so\n      // shouldn't be considered. It must have been connected in the past.\n      return false;\n    }\n\n    if (element.hasBeenTypePassword) {\n      return false;\n    }\n\n    if (!Logic.inputTypeIsCompatibleWithUsername(element)) {\n      return false;\n    }\n\n    let acFieldName = element.getAutocompleteInfo().fieldName;\n    if (\n      !(\n        acFieldName == \"username\" ||\n        acFieldName == \"webauthn\" ||\n        // Bug 1540154: Some sites use tel/email on their username fields.\n        acFieldName == \"email\" ||\n        acFieldName == \"tel\" ||\n        acFieldName == \"tel-national\" ||\n        acFieldName == \"off\" ||\n        acFieldName == \"on\" ||\n        acFieldName == \"\"\n      )\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Checks if a field type is password compatible.\n   *\n   * @param {Element} element\n   *                  the field we want to check.\n   * @param {Object} options\n   * @param {bool} [options.ignoreConnect] - Whether to ignore checking isConnected\n   *                                         of the element.\n   *\n   * @returns {Boolean} true if the field can\n   *                    be treated as a password input\n   */\n  static isPasswordFieldType(element, { ignoreConnect = false } = {}) {\n    if (!HTMLInputElement.isInstance(element)) {\n      return false;\n    }\n\n    if (!element.isConnected && !ignoreConnect) {\n      // If the element isn't connected then it isn't visible to the user so\n      // shouldn't be considered. It must have been connected in the past.\n      return false;\n    }\n\n    if (!element.hasBeenTypePassword) {\n      return false;\n    }\n\n    // Ensure the element is of a type that could have autocomplete.\n    // These include the types with user-editable values. If not, even if it used to be\n    // a type=password, we can't treat it as a password input now\n    let acInfo = element.getAutocompleteInfo();\n    if (!acInfo) {\n      return false;\n    }\n\n    return true;\n  }\n\n  static #cachedNewPasswordScore = new WeakMap();\n\n  static isProbablyANewPasswordField(inputElement) {\n    const autocompleteInfo = inputElement.getAutocompleteInfo();\n    if (autocompleteInfo.fieldName === \"new-password\") {\n      return true;\n    }\n\n    if (Logic.newPasswordFieldFathomThreshold == -1) {\n      // Fathom is disabled\n      return false;\n    }\n\n    let score = this.#cachedNewPasswordScore.get(inputElement);\n    if (score) {\n      return score >= Logic.newPasswordFieldFathomThreshold;\n    }\n\n    const { rules, type } = resource_gre_modules_shared_NewPasswordModel_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.NewPasswordModel;\n    const results = rules.against(inputElement);\n    score = results.get(inputElement).scoreFor(type);\n    this.#cachedNewPasswordScore.set(inputElement, score);\n    return score >= Logic.newPasswordFieldFathomThreshold;\n  }\n\n  static findConfirmationField(passwordField, formFactory) {\n    const form = formFactory.createFromField(passwordField);\n    let confirmPasswordInput = null;\n    const MAX_CONFIRM_PASSWORD_DISTANCE = 3;\n\n    const startIndex = form.elements.indexOf(passwordField);\n    if (startIndex === -1) {\n      throw new Error(\n        \"Password field is not in the form's elements collection\"\n      );\n    }\n\n    // Get a list of input fields to search in.\n    // Pre-filter type=hidden fields; they don't count against the distance threshold\n    const afterFields = form.elements\n      .slice(startIndex + 1)\n      .filter(elem => elem.type !== \"hidden\");\n\n    const acFieldName = passwordField.getAutocompleteInfo()?.fieldName;\n\n    // Match same autocomplete values first\n    if (acFieldName === \"new-password\") {\n      const matchIndex = afterFields.findIndex(\n        elem =>\n          Logic.isPasswordFieldType(elem) &&\n          elem.getAutocompleteInfo().fieldName === acFieldName &&\n          !elem.disabled &&\n          !elem.readOnly\n      );\n      if (matchIndex >= 0 && matchIndex < MAX_CONFIRM_PASSWORD_DISTANCE) {\n        confirmPasswordInput = afterFields[matchIndex];\n      }\n    }\n\n    if (!confirmPasswordInput) {\n      for (\n        let idx = 0;\n        idx < Math.min(MAX_CONFIRM_PASSWORD_DISTANCE, afterFields.length);\n        idx++\n      ) {\n        if (\n          Logic.isPasswordFieldType(afterFields[idx]) &&\n          !afterFields[idx].disabled &&\n          !afterFields[idx].readOnly\n        ) {\n          confirmPasswordInput = afterFields[idx];\n          break;\n        }\n      }\n    }\n\n    return confirmPasswordInput;\n  }\n\n  /**\n   * Transforms the parsed rules returned from PasswordRulesParser into a Map for easier access.\n   * The returned Map could have the following keys: \"allowed\", \"required\", \"maxlength\", \"minlength\", and \"max-consecutive\"\n   * @example\n   * // Returns a Map with a key-value pair of \"allowed\": \"ascii-printable\"\n   * transformRulesToMap([{ _name: \"allowed\", value: [{ _name: \"ascii-printable\" }] }])\n   * @param {Object[]} rules rules from PasswordRulesParser.parsePasswordRules\n   * @return {Map} mapped rules\n   */\n  static transformRulesToMap(rules) {\n    let map = new Map();\n    for (let rule of rules) {\n      let { _name, value } = rule;\n      if (\n        _name === \"minlength\" ||\n        _name === \"maxlength\" ||\n        _name === \"max-consecutive\"\n      ) {\n        map.set(_name, value);\n      } else {\n        let _value = [];\n        if (map.get(_name)) {\n          _value = map.get(_name);\n        }\n        for (let _class of value) {\n          let { _name: _className } = _class;\n          if (_className) {\n            _value.push(_className);\n          } else {\n            let { _characters } = _class;\n            _value.push(_characters);\n          }\n        }\n        map.set(_name, _value);\n      }\n    }\n    return map;\n  }\n}\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  Logic,\n  \"newPasswordFieldFathomThreshold\",\n  \"signon.generation.confidenceThreshold\",\n  null,\n  null,\n  pref => parseFloat(pref)\n);\n\n\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/NewPasswordModel.sys.mjs":
/*!**********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/NewPasswordModel.sys.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NewPasswordModel: () => (/* binding */ NewPasswordModel)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/third_party/fathom/fathom.mjs */ \"./firefox-ios/Client/Assets/CC_Script/fathom.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * Machine learning model for identifying new password input elements\n * using Fathom.\n */\n\n\n\nlet { identity, isVisible, min, setDefault } = resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.utils;\nlet { euclidean } = resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.clusters;\n\n/**\n * ----- Start of model -----\n *\n * Everything below this comment up to the \"End of model\" comment is copied from:\n * https://github.com/mozilla-services/fathom-login-forms/blob/78d4bf8f301b5aa6d62c06b45e826a0dd9df1afa/new-password/rulesets.js#L14-L613\n * Deviations from that file:\n *   - Remove import statements, instead using ``ChromeUtils.defineModuleGetter`` and destructuring assignments above.\n *   - Set ``DEVELOPMENT`` constant to ``false``.\n */\n\n// Whether this is running in the Vectorizer, rather than in-application, in a\n// privileged Chrome context\nconst DEVELOPMENT = false;\n\n// Run me with confidence cutoff = 0.75.\nconst coefficients = {\n  new: [\n    [\"hasNewLabel\", 2.9195094108581543],\n    [\"hasConfirmLabel\", 2.1672143936157227],\n    [\"hasCurrentLabel\", -2.1813206672668457],\n    [\"closestLabelMatchesNew\", 2.965045213699341],\n    [\"closestLabelMatchesConfirm\", 2.698647975921631],\n    [\"closestLabelMatchesCurrent\", -2.147423505783081],\n    [\"hasNewAriaLabel\", 2.8312134742736816],\n    [\"hasConfirmAriaLabel\", 1.5153108835220337],\n    [\"hasCurrentAriaLabel\", -4.368860244750977],\n    [\"hasNewPlaceholder\", 1.4374250173568726],\n    [\"hasConfirmPlaceholder\", 1.717592477798462],\n    [\"hasCurrentPlaceholder\", -1.9401700496673584],\n    [\"forgotPasswordInFormLinkTextContent\", -0.6736700534820557],\n    [\"forgotPasswordInFormLinkHref\", -1.3025357723236084],\n    [\"forgotPasswordInFormLinkTitle\", -2.9019577503204346],\n    [\"forgotInFormLinkTextContent\", -1.2455425262451172],\n    [\"forgotInFormLinkHref\", 0.4884686768054962],\n    [\"forgotPasswordInFormButtonTextContent\", -0.8015769720077515],\n    [\"forgotPasswordOnPageLinkTextContent\", 0.04422328248620033],\n    [\"forgotPasswordOnPageLinkHref\", -1.0331494808197021],\n    [\"forgotPasswordOnPageLinkTitle\", -0.08798415213823318],\n    [\"forgotPasswordOnPageButtonTextContent\", -1.5396910905838013],\n    [\"elementAttrsMatchNew\", 2.8492355346679688],\n    [\"elementAttrsMatchConfirm\", 1.9043376445770264],\n    [\"elementAttrsMatchCurrent\", -2.056903839111328],\n    [\"elementAttrsMatchPassword1\", 1.5833512544631958],\n    [\"elementAttrsMatchPassword2\", 1.3928000926971436],\n    [\"elementAttrsMatchLogin\", 1.738782525062561],\n    [\"formAttrsMatchRegister\", 2.1345033645629883],\n    [\"formHasRegisterAction\", 1.9337323904037476],\n    [\"formButtonIsRegister\", 3.0930404663085938],\n    [\"formAttrsMatchLogin\", -0.5816961526870728],\n    [\"formHasLoginAction\", -0.18886367976665497],\n    [\"formButtonIsLogin\", -2.332860231399536],\n    [\"hasAutocompleteCurrentPassword\", -0.029974736273288727],\n    [\"formHasRememberMeCheckbox\", 0.8600837588310242],\n    [\"formHasRememberMeLabel\", 0.06663893908262253],\n    [\"formHasNewsletterCheckbox\", -1.4851698875427246],\n    [\"formHasNewsletterLabel\", 2.416919231414795],\n    [\"closestHeaderAboveIsLoginy\", -2.0047383308410645],\n    [\"closestHeaderAboveIsRegistery\", 2.19451642036438],\n    [\"nextInputIsConfirmy\", 2.5344431400299072],\n    [\"formHasMultipleVisibleInput\", 2.81270694732666],\n    [\"firstFieldInFormWithThreePasswordFields\", -2.8964080810546875],\n  ],\n};\n\nconst biases = [[\"new\", -1.3525885343551636]];\n\nconst passwordStringRegex =\n  /password|passwort|رمز عبور|mot de passe|パスワード|비밀번호|암호|wachtwoord|senha|Пароль|parol|密码|contraseña|heslo|كلمة السر|kodeord|Κωδικός|pass code|Kata sandi|hasło|รหัสผ่าน|Şifre/i;\nconst passwordAttrRegex = /pw|pwd|passwd|pass/i;\nconst newStringRegex =\n  /new|erstellen|create|choose|設定|신규|Créer|Nouveau|baru|nouă|nieuw/i;\nconst newAttrRegex = /new/i;\nconst confirmStringRegex =\n  /wiederholen|wiederholung|confirm|repeat|confirmation|verify|retype|repite|確認|の確認|تکرار|re-enter|확인|bevestigen|confirme|Повторите|tassyklamak|再次输入|ještě jednou|gentag|re-type|confirmar|Répéter|conferma|Repetaţi|again|reenter|再入力|재입력|Ulangi|Bekræft/i;\nconst confirmAttrRegex = /confirm|retype/i;\nconst currentAttrAndStringRegex =\n  /current|old|aktuelles|derzeitiges|当前|Atual|actuel|curentă|sekarang/i;\nconst forgotStringRegex =\n  /vergessen|vergeten|forgot|oublié|dimenticata|Esqueceu|esqueci|Забыли|忘记|找回|Zapomenuté|lost|忘れた|忘れられた|忘れの方|재설정|찾기|help|فراموشی| را فراموش کرده اید|Восстановить|Unuttu|perdus|重新設定|reset|recover|change|remind|find|request|restore|trouble/i;\nconst forgotHrefRegex =\n  /forgot|reset|recover|change|lost|remind|find|request|restore/i;\nconst password1Regex =\n  /pw1|pwd1|pass1|passwd1|password1|pwone|pwdone|passone|passwdone|passwordone|pwfirst|pwdfirst|passfirst|passwdfirst|passwordfirst/i;\nconst password2Regex =\n  /pw2|pwd2|pass2|passwd2|password2|pwtwo|pwdtwo|passtwo|passwdtwo|passwordtwo|pwsecond|pwdsecond|passsecond|passwdsecond|passwordsecond/i;\nconst loginRegex =\n  /login|log in|log on|log-on|Войти|sign in|sigin|sign\\/in|sign-in|sign on|sign-on|ورود|登录|Přihlásit se|Přihlaste|Авторизоваться|Авторизация|entrar|ログイン|로그인|inloggen|Συνδέσου|accedi|ログオン|Giriş Yap|登入|connecter|connectez-vous|Connexion|Вход/i;\nconst loginFormAttrRegex =\n  /login|log in|log on|log-on|sign in|sigin|sign\\/in|sign-in|sign on|sign-on/i;\nconst registerStringRegex =\n  /create[a-zA-Z\\s]+account|activate[a-zA-Z\\s]+account|Zugang anlegen|Angaben prüfen|Konto erstellen|register|sign up|ثبت نام|登録|注册|cadastr|Зарегистрироваться|Регистрация|Bellige alynmak|تسجيل|ΕΓΓΡΑΦΗΣ|Εγγραφή|Créer mon compte|Créer un compte|Mendaftar|가입하기|inschrijving|Zarejestruj się|Deschideți un cont|Создать аккаунт|ร่วม|Üye Ol|registr|new account|ساخت حساب کاربری|Schrijf je|S'inscrire/i;\nconst registerActionRegex =\n  /register|signup|sign-up|create-account|account\\/create|join|new_account|user\\/create|sign\\/up|membership\\/create/i;\nconst registerFormAttrRegex =\n  /signup|join|register|regform|registration|new_user|AccountCreate|create_customer|CreateAccount|CreateAcct|create-account|reg-form|newuser|new-reg|new-form|new_membership/i;\nconst rememberMeAttrRegex =\n  /remember|auto_login|auto-login|save_mail|save-mail|ricordami|manter|mantenha|savelogin|auto login/i;\nconst rememberMeStringRegex =\n  /remember me|keep me logged in|keep me signed in|save email address|save id|stay signed in|ricordami|次回からログオンIDの入力を省略する|メールアドレスを保存する|を保存|아이디저장|아이디 저장|로그인 상태 유지|lembrar|manter conectado|mantenha-me conectado|Запомни меня|запомнить меня|Запомните меня|Не спрашивать в следующий раз|下次自动登录|记住我/i;\nconst newsletterStringRegex = /newsletter|ニュースレター/i;\nconst passwordStringAndAttrRegex = new RegExp(\n  passwordStringRegex.source + \"|\" + passwordAttrRegex.source,\n  \"i\"\n);\n\nfunction makeRuleset(coeffs, biases) {\n  // HTMLElement => (selector => Array<HTMLElement>) nested map to cache querySelectorAll calls.\n  let elementToSelectors;\n  // We want to clear the cache each time the model is executed to get the latest DOM snapshot\n  // for each classification.\n  function clearCache() {\n    // WeakMaps do not have a clear method\n    elementToSelectors = new WeakMap();\n  }\n\n  function hasLabelMatchingRegex(element, regex) {\n    // Check element.labels\n    const labels = element.labels;\n    // TODO: Should I be concerned with multiple labels?\n    if (labels !== null && labels.length) {\n      return regex.test(labels[0].textContent);\n    }\n\n    // Check element.aria-labelledby\n    let labelledBy = element.getAttribute(\"aria-labelledby\");\n    if (labelledBy !== null) {\n      labelledBy = labelledBy\n        .split(\" \")\n        .map(id => element.getRootNode().getElementById(id))\n        .filter(el => el);\n      if (labelledBy.length === 1) {\n        return regex.test(labelledBy[0].textContent);\n      } else if (labelledBy.length > 1) {\n        return regex.test(\n          min(labelledBy, node => euclidean(node, element)).textContent\n        );\n      }\n    }\n\n    const parentElement = element.parentElement;\n    // Bug 1634819: element.parentElement is null if element.parentNode is a ShadowRoot\n    if (!parentElement) {\n      return false;\n    }\n    // Check if the input is in a <td>, and, if so, check the textContent of the containing <tr>\n    if (parentElement.tagName === \"TD\" && parentElement.parentElement) {\n      // TODO: How bad is the assumption that the <tr> won't be the parent of the <td>?\n      return regex.test(parentElement.parentElement.textContent);\n    }\n\n    // Check if the input is in a <dd>, and, if so, check the textContent of the preceding <dt>\n    if (\n      parentElement.tagName === \"DD\" &&\n      // previousElementSibling can be null\n      parentElement.previousElementSibling\n    ) {\n      return regex.test(parentElement.previousElementSibling.textContent);\n    }\n    return false;\n  }\n\n  function closestLabelMatchesRegex(element, regex) {\n    const previousElementSibling = element.previousElementSibling;\n    if (\n      previousElementSibling !== null &&\n      previousElementSibling.tagName === \"LABEL\"\n    ) {\n      return regex.test(previousElementSibling.textContent);\n    }\n\n    const nextElementSibling = element.nextElementSibling;\n    if (nextElementSibling !== null && nextElementSibling.tagName === \"LABEL\") {\n      return regex.test(nextElementSibling.textContent);\n    }\n\n    const closestLabelWithinForm = closestSelectorElementWithinElement(\n      element,\n      element.form,\n      \"label\"\n    );\n    return containsRegex(\n      regex,\n      closestLabelWithinForm,\n      closestLabelWithinForm => closestLabelWithinForm.textContent\n    );\n  }\n\n  function containsRegex(regex, thingOrNull, thingToString = identity) {\n    return thingOrNull !== null && regex.test(thingToString(thingOrNull));\n  }\n\n  function closestSelectorElementWithinElement(\n    toElement,\n    withinElement,\n    querySelector\n  ) {\n    if (withinElement !== null) {\n      let nodeList = Array.from(withinElement.querySelectorAll(querySelector));\n      if (nodeList.length) {\n        return min(nodeList, node => euclidean(node, toElement));\n      }\n    }\n    return null;\n  }\n\n  function hasAriaLabelMatchingRegex(element, regex) {\n    return containsRegex(regex, element.getAttribute(\"aria-label\"));\n  }\n\n  function hasPlaceholderMatchingRegex(element, regex) {\n    return containsRegex(regex, element.getAttribute(\"placeholder\"));\n  }\n\n  function testRegexesAgainstAnchorPropertyWithinElement(\n    property,\n    element,\n    ...regexes\n  ) {\n    return hasSomeMatchingPredicateForSelectorWithinElement(\n      element,\n      \"a\",\n      anchor => {\n        const propertyValue = anchor[property];\n        return regexes.every(regex => regex.test(propertyValue));\n      }\n    );\n  }\n\n  function testFormButtonsAgainst(element, stringRegex) {\n    const form = element.form;\n    if (form !== null) {\n      let inputs = Array.from(\n        form.querySelectorAll(\"input[type=submit],input[type=button]\")\n      );\n      inputs = inputs.filter(input => {\n        return stringRegex.test(input.value);\n      });\n      if (inputs.length) {\n        return true;\n      }\n\n      return hasSomeMatchingPredicateForSelectorWithinElement(\n        form,\n        \"button\",\n        button => {\n          return (\n            stringRegex.test(button.value) ||\n            stringRegex.test(button.textContent) ||\n            stringRegex.test(button.id) ||\n            stringRegex.test(button.title)\n          );\n        }\n      );\n    }\n    return false;\n  }\n\n  function hasAutocompleteCurrentPassword(fnode) {\n    return fnode.element.autocomplete === \"current-password\";\n  }\n\n  // Check cache before calling querySelectorAll on element\n  function getElementDescendants(element, selector) {\n    // Use the element to look up the selector map:\n    const selectorToDescendants = setDefault(\n      elementToSelectors,\n      element,\n      () => new Map()\n    );\n\n    // Use the selector to grab the descendants:\n    return setDefault(selectorToDescendants, selector, () =>\n      Array.from(element.querySelectorAll(selector))\n    );\n  }\n\n  /**\n   * Return whether the form element directly after this one looks like a\n   * confirm-password input.\n   */\n  function nextInputIsConfirmy(fnode) {\n    const form = fnode.element.form;\n    const me = fnode.element;\n    if (form !== null) {\n      let afterMe = false;\n      for (const formEl of form.elements) {\n        if (formEl === me) {\n          afterMe = true;\n        } else if (afterMe) {\n          if (\n            formEl.type === \"password\" &&\n            !formEl.disabled &&\n            formEl.getAttribute(\"aria-hidden\") !== \"true\"\n          ) {\n            // Now we're looking at a passwordy, visible input[type=password]\n            // directly after me.\n            return elementAttrsMatchRegex(formEl, confirmAttrRegex);\n            // We could check other confirmy smells as well. Balance accuracy\n            // against time and complexity.\n          }\n          // We look only at the very next element, so we may be thrown off by\n          // Hide buttons and such.\n          break;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns true when the number of visible input found in the form is over\n   * the given threshold.\n   *\n   * Since the idea in the signal is based on the fact that registration pages\n   * often have multiple inputs, this rule only selects inputs whose type is\n   * either email, password, text, tel or empty, which are more likely a input\n   * field for users to fill their information.\n   */\n  function formHasMultipleVisibleInput(element, selector, threshold) {\n    let form = element.form;\n    if (!form) {\n      // For password fields that don't have an associated form, we apply a heuristic\n      // to find a \"form\" for it. The heuristic works as follow:\n      // 1. Locate the closest preceding input.\n      // 2. Find the lowest common ancestor of the password field and the closet\n      //    preceding input.\n      // 3. Assume the common ancestor is the \"form\" of the password input.\n      const previous = closestElementAbove(element, selector);\n      if (!previous) {\n        return false;\n      }\n      form = findLowestCommonAncestor(previous, element);\n      if (!form) {\n        return false;\n      }\n    }\n    const inputs = Array.from(form.querySelectorAll(selector));\n    for (const input of inputs) {\n      // don't need to check visibility for the element we're testing against\n      if (element === input || isVisible(input)) {\n        threshold--;\n        if (threshold === 0) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns true when there are three password fields in the form and the passed\n   * element is the first one.\n   *\n   * The signal is based on that change-password forms with 3 password fields often\n   * have the \"current password\", \"new password\", and \"confirm password\" pattern.\n   */\n  function firstFieldInFormWithThreePasswordFields(fnode) {\n    const element = fnode.element;\n    const form = element.form;\n    if (form) {\n      let elements = form.querySelectorAll(\n        \"input[type=password]:not([disabled], [aria-hidden=true])\"\n      );\n      // Only care forms with three password fields. If there are more than three password\n      // fields found, probably we include some hidden fields, so just ignore it.\n      if (elements.length == 3 && elements[0] == element) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function hasSomeMatchingPredicateForSelectorWithinElement(\n    element,\n    selector,\n    matchingPredicate\n  ) {\n    if (element === null) {\n      return false;\n    }\n    const elements = getElementDescendants(element, selector);\n    return elements.some(matchingPredicate);\n  }\n\n  function textContentMatchesRegexes(element, ...regexes) {\n    const textContent = element.textContent;\n    return regexes.every(regex => regex.test(textContent));\n  }\n\n  function closestHeaderAboveMatchesRegex(element, regex) {\n    const closestHeader = closestElementAbove(\n      element,\n      \"h1,h2,h3,h4,h5,h6,div[class*=heading],div[class*=header],div[class*=title],legend\"\n    );\n    if (closestHeader !== null) {\n      return regex.test(closestHeader.textContent);\n    }\n    return false;\n  }\n\n  function closestElementAbove(element, selector) {\n    let elements = Array.from(element.ownerDocument.querySelectorAll(selector));\n    for (let i = elements.length - 1; i >= 0; --i) {\n      if (\n        element.compareDocumentPosition(elements[i]) &\n        Node.DOCUMENT_POSITION_PRECEDING\n      ) {\n        return elements[i];\n      }\n    }\n    return null;\n  }\n\n  function findLowestCommonAncestor(elementA, elementB) {\n    // Walk up the ancestor chain of both elements and compare whether the\n    // ancestors in the depth are the same. If they are not the same, the\n    // ancestor in the previous run is the lowest common ancestor.\n    function getAncestorChain(element) {\n      let ancestors = [];\n      let p = element.parentNode;\n      while (p) {\n        ancestors.push(p);\n        p = p.parentNode;\n      }\n      return ancestors;\n    }\n\n    let aAncestors = getAncestorChain(elementA);\n    let bAncestors = getAncestorChain(elementB);\n    let posA = aAncestors.length - 1;\n    let posB = bAncestors.length - 1;\n    for (; posA >= 0 && posB >= 0; posA--, posB--) {\n      if (aAncestors[posA] != bAncestors[posB]) {\n        return aAncestors[posA + 1];\n      }\n    }\n    return null;\n  }\n\n  function elementAttrsMatchRegex(element, regex) {\n    if (element !== null) {\n      return (\n        regex.test(element.id) ||\n        regex.test(element.name) ||\n        regex.test(element.className)\n      );\n    }\n    return false;\n  }\n\n  /**\n   * Let us compactly represent a collection of rules that all take a single\n   * type with no .when() clause and have only a score() call on the right-hand\n   * side.\n   */\n  function* simpleScoringRulesTakingType(inType, ruleMap) {\n    for (const [name, scoringCallback] of Object.entries(ruleMap)) {\n      yield (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(inType), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.score)(scoringCallback), { name });\n    }\n  }\n\n  return (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.ruleset)(\n    [\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)(\n        DEVELOPMENT\n          ? (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.dom)(\n              \"input[type=password]:not([disabled], [aria-hidden=true])\"\n            ).when(isVisible)\n          : (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.element)(\"input\"),\n        (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"new\").note(clearCache)\n      ),\n      ...simpleScoringRulesTakingType(\"new\", {\n        hasNewLabel: fnode =>\n          hasLabelMatchingRegex(fnode.element, newStringRegex),\n        hasConfirmLabel: fnode =>\n          hasLabelMatchingRegex(fnode.element, confirmStringRegex),\n        hasCurrentLabel: fnode =>\n          hasLabelMatchingRegex(fnode.element, currentAttrAndStringRegex),\n        closestLabelMatchesNew: fnode =>\n          closestLabelMatchesRegex(fnode.element, newStringRegex),\n        closestLabelMatchesConfirm: fnode =>\n          closestLabelMatchesRegex(fnode.element, confirmStringRegex),\n        closestLabelMatchesCurrent: fnode =>\n          closestLabelMatchesRegex(fnode.element, currentAttrAndStringRegex),\n        hasNewAriaLabel: fnode =>\n          hasAriaLabelMatchingRegex(fnode.element, newStringRegex),\n        hasConfirmAriaLabel: fnode =>\n          hasAriaLabelMatchingRegex(fnode.element, confirmStringRegex),\n        hasCurrentAriaLabel: fnode =>\n          hasAriaLabelMatchingRegex(fnode.element, currentAttrAndStringRegex),\n        hasNewPlaceholder: fnode =>\n          hasPlaceholderMatchingRegex(fnode.element, newStringRegex),\n        hasConfirmPlaceholder: fnode =>\n          hasPlaceholderMatchingRegex(fnode.element, confirmStringRegex),\n        hasCurrentPlaceholder: fnode =>\n          hasPlaceholderMatchingRegex(fnode.element, currentAttrAndStringRegex),\n        forgotPasswordInFormLinkTextContent: fnode =>\n          testRegexesAgainstAnchorPropertyWithinElement(\n            \"textContent\",\n            fnode.element.form,\n            passwordStringRegex,\n            forgotStringRegex\n          ),\n        forgotPasswordInFormLinkHref: fnode =>\n          testRegexesAgainstAnchorPropertyWithinElement(\n            \"href\",\n            fnode.element.form,\n            passwordStringAndAttrRegex,\n            forgotHrefRegex\n          ),\n        forgotPasswordInFormLinkTitle: fnode =>\n          testRegexesAgainstAnchorPropertyWithinElement(\n            \"title\",\n            fnode.element.form,\n            passwordStringRegex,\n            forgotStringRegex\n          ),\n        forgotInFormLinkTextContent: fnode =>\n          testRegexesAgainstAnchorPropertyWithinElement(\n            \"textContent\",\n            fnode.element.form,\n            forgotStringRegex\n          ),\n        forgotInFormLinkHref: fnode =>\n          testRegexesAgainstAnchorPropertyWithinElement(\n            \"href\",\n            fnode.element.form,\n            forgotHrefRegex\n          ),\n        forgotPasswordInFormButtonTextContent: fnode =>\n          hasSomeMatchingPredicateForSelectorWithinElement(\n            fnode.element.form,\n            \"button\",\n            button =>\n              textContentMatchesRegexes(\n                button,\n                passwordStringRegex,\n                forgotStringRegex\n              )\n          ),\n        forgotPasswordOnPageLinkTextContent: fnode =>\n          testRegexesAgainstAnchorPropertyWithinElement(\n            \"textContent\",\n            fnode.element.ownerDocument,\n            passwordStringRegex,\n            forgotStringRegex\n          ),\n        forgotPasswordOnPageLinkHref: fnode =>\n          testRegexesAgainstAnchorPropertyWithinElement(\n            \"href\",\n            fnode.element.ownerDocument,\n            passwordStringAndAttrRegex,\n            forgotHrefRegex\n          ),\n        forgotPasswordOnPageLinkTitle: fnode =>\n          testRegexesAgainstAnchorPropertyWithinElement(\n            \"title\",\n            fnode.element.ownerDocument,\n            passwordStringRegex,\n            forgotStringRegex\n          ),\n        forgotPasswordOnPageButtonTextContent: fnode =>\n          hasSomeMatchingPredicateForSelectorWithinElement(\n            fnode.element.ownerDocument,\n            \"button\",\n            button =>\n              textContentMatchesRegexes(\n                button,\n                passwordStringRegex,\n                forgotStringRegex\n              )\n          ),\n        elementAttrsMatchNew: fnode =>\n          elementAttrsMatchRegex(fnode.element, newAttrRegex),\n        elementAttrsMatchConfirm: fnode =>\n          elementAttrsMatchRegex(fnode.element, confirmAttrRegex),\n        elementAttrsMatchCurrent: fnode =>\n          elementAttrsMatchRegex(fnode.element, currentAttrAndStringRegex),\n        elementAttrsMatchPassword1: fnode =>\n          elementAttrsMatchRegex(fnode.element, password1Regex),\n        elementAttrsMatchPassword2: fnode =>\n          elementAttrsMatchRegex(fnode.element, password2Regex),\n        elementAttrsMatchLogin: fnode =>\n          elementAttrsMatchRegex(fnode.element, loginRegex),\n        formAttrsMatchRegister: fnode =>\n          elementAttrsMatchRegex(fnode.element.form, registerFormAttrRegex),\n        formHasRegisterAction: fnode =>\n          containsRegex(\n            registerActionRegex,\n            fnode.element.form,\n            form => form.action\n          ),\n        formButtonIsRegister: fnode =>\n          testFormButtonsAgainst(fnode.element, registerStringRegex),\n        formAttrsMatchLogin: fnode =>\n          elementAttrsMatchRegex(fnode.element.form, loginFormAttrRegex),\n        formHasLoginAction: fnode =>\n          containsRegex(loginRegex, fnode.element.form, form => form.action),\n        formButtonIsLogin: fnode =>\n          testFormButtonsAgainst(fnode.element, loginRegex),\n        hasAutocompleteCurrentPassword,\n        formHasRememberMeCheckbox: fnode =>\n          hasSomeMatchingPredicateForSelectorWithinElement(\n            fnode.element.form,\n            \"input[type=checkbox]\",\n            checkbox =>\n              rememberMeAttrRegex.test(checkbox.id) ||\n              rememberMeAttrRegex.test(checkbox.name)\n          ),\n        formHasRememberMeLabel: fnode =>\n          hasSomeMatchingPredicateForSelectorWithinElement(\n            fnode.element.form,\n            \"label\",\n            label => rememberMeStringRegex.test(label.textContent)\n          ),\n        formHasNewsletterCheckbox: fnode =>\n          hasSomeMatchingPredicateForSelectorWithinElement(\n            fnode.element.form,\n            \"input[type=checkbox]\",\n            checkbox =>\n              checkbox.id.includes(\"newsletter\") ||\n              checkbox.name.includes(\"newsletter\")\n          ),\n        formHasNewsletterLabel: fnode =>\n          hasSomeMatchingPredicateForSelectorWithinElement(\n            fnode.element.form,\n            \"label\",\n            label => newsletterStringRegex.test(label.textContent)\n          ),\n        closestHeaderAboveIsLoginy: fnode =>\n          closestHeaderAboveMatchesRegex(fnode.element, loginRegex),\n        closestHeaderAboveIsRegistery: fnode =>\n          closestHeaderAboveMatchesRegex(fnode.element, registerStringRegex),\n        nextInputIsConfirmy,\n        formHasMultipleVisibleInput: fnode =>\n          formHasMultipleVisibleInput(\n            fnode.element,\n            \"input[type=email],input[type=password],input[type=text],input[type=tel]\",\n            3\n          ),\n        firstFieldInFormWithThreePasswordFields,\n      }),\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"new\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.out)(\"new\")),\n    ],\n    coeffs,\n    biases\n  );\n}\n\n/*\n * ----- End of model -----\n */\n\nconst NewPasswordModel = {\n  type: \"new\",\n  rules: makeRuleset([...coefficients.new], biases),\n};\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/NewPasswordModel.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js":
/*!**************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n// This array defines overrides that webpack will use when bundling the JS on iOS\n// in order to load the right modules\nconst ModuleOverrides = {\n  \"AppConstants.sys.mjs\": \"Helpers.ios.mjs\",\n  \"XPCOMUtils.sys.mjs\": \"Helpers.ios.mjs\",\n  \"Region.sys.mjs\": \"Helpers.ios.mjs\",\n  \"OSKeyStore.sys.mjs\": \"Helpers.ios.mjs\",\n  \"ContentDOMReference.sys.mjs\": \"Helpers.ios.mjs\",\n  \"FormAutofill.sys.mjs\": \"FormAutofill.ios.sys.mjs\",\n  \"EntryFile.sys.mjs\": \"FormAutofillChild.ios.sys.mjs\",\n  \"LoginHelper.sys.mjs\": \"EmptyModule.sys.mjs\",\n  \"MLAutofill.sys.mjs\": \"EmptyModule.sys.mjs\",\n  \"LoginRecipes.sys.mjs\": \"EmptyModule.sys.mjs\",\n  \"Timer.sys.mjs\": \"TranslationsHelpers.ios.mjs\",\n};\n\n// We need this because not all webpack libraries used in iOS are ES Modules\n// Hence we defer to CommonJS.\n// eslint-disable-next-line no-undef\nmodule.exports = { ModuleOverrides };\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/PasswordGenerator.sys.mjs":
/*!***********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/PasswordGenerator.sys.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PasswordGenerator: () => (/* binding */ PasswordGenerator)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n * You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * This file is a port of a subset of Chromium's implementation from\n * https://cs.chromium.org/chromium/src/components/password_manager/core/browser/generation/password_generator.cc?l=93&rcl=a896a3ac4ea731b5ab3d2ab5bd76a139885d5c4f\n * which is Copyright 2018 The Chromium Authors. All rights reserved.\n */\n\nconst DEFAULT_PASSWORD_LENGTH = 15;\nconst MAX_UINT8 = Math.pow(2, 8) - 1;\nconst MAX_UINT32 = Math.pow(2, 32) - 1;\n\n// Some characters are removed due to visual similarity:\nconst LOWER_CASE_ALPHA = \"abcdefghijkmnpqrstuvwxyz\"; // no 'l' or 'o'\nconst UPPER_CASE_ALPHA = \"ABCDEFGHJKLMNPQRSTUVWXYZ\"; // no 'I' or 'O'\nconst DIGITS = \"23456789\"; // no '1' or '0'\nconst SPECIAL_CHARACTERS = \"-~!@#$%^&*_+=)}:;\\\"'>,.?]\";\n\nconst REQUIRED_CHARACTER_CLASSES = [\n  LOWER_CASE_ALPHA,\n  UPPER_CASE_ALPHA,\n  DIGITS,\n  SPECIAL_CHARACTERS,\n];\n\n// Consts for different password rules\nconst REQUIRED = \"required\";\nconst MAX_LENGTH = \"maxlength\";\nconst MIN_LENGTH = \"minlength\";\nconst MAX_CONSECUTIVE = \"max-consecutive\";\nconst UPPER = \"upper\";\nconst LOWER = \"lower\";\nconst DIGIT = \"digit\";\nconst SPECIAL = \"special\";\n\n// Default password rules\nconst DEFAULT_RULES = new Map();\nDEFAULT_RULES.set(MIN_LENGTH, REQUIRED_CHARACTER_CLASSES.length);\nDEFAULT_RULES.set(MAX_LENGTH, MAX_UINT8);\nDEFAULT_RULES.set(REQUIRED, [UPPER, LOWER, DIGIT, SPECIAL]);\n\nconst PasswordGenerator = {\n  /**\n   * @param {Object} options\n   * @param {number} options.length - length of the generated password if there are no rules that override the length\n   * @param {Map} options.rules - map of password rules\n   * @returns {string} password that was generated\n   * @throws Error if `length` is invalid\n   * @copyright 2018 The Chromium Authors. All rights reserved.\n   * @see https://cs.chromium.org/chromium/src/components/password_manager/core/browser/generation/password_generator.cc?l=93&rcl=a896a3ac4ea731b5ab3d2ab5bd76a139885d5c4f\n   */\n  generatePassword({\n    length = DEFAULT_PASSWORD_LENGTH,\n    rules = DEFAULT_RULES,\n    inputMaxLength,\n  }) {\n    rules = new Map([...DEFAULT_RULES, ...rules]);\n    if (rules.get(MIN_LENGTH) > length) {\n      length = rules.get(MIN_LENGTH);\n    }\n    if (rules.get(MAX_LENGTH) < length) {\n      length = rules.get(MAX_LENGTH);\n    }\n    if (inputMaxLength > 0 && inputMaxLength < length) {\n      length = inputMaxLength;\n    }\n\n    let password = \"\";\n    let requiredClasses = [];\n    let allRequiredCharacters = \"\";\n\n    // Generate one character of each required class and/or required character list from the rules\n    this._addRequiredClassesAndCharacters(rules, requiredClasses);\n\n    // Generate one of each required class\n    for (const charClassString of requiredClasses) {\n      password +=\n        charClassString[this._randomUInt8Index(charClassString.length)];\n      if (Array.isArray(charClassString)) {\n        // Convert array into single string so that commas aren't\n        // concatenated with each character in the arbitrary character array.\n        allRequiredCharacters += charClassString.join(\"\");\n      } else {\n        allRequiredCharacters += charClassString;\n      }\n    }\n\n    // Now fill the rest of the password with random characters.\n    while (password.length < length) {\n      password +=\n        allRequiredCharacters[\n          this._randomUInt8Index(allRequiredCharacters.length)\n        ];\n    }\n\n    // So far the password contains the minimally required characters at the\n    // the beginning. Therefore, we create a random permutation.\n    password = this._shuffleString(password);\n\n    // Make sure the password passes the \"max-consecutive\" rule, if the rule exists\n    if (rules.has(MAX_CONSECUTIVE)) {\n      // Ensures that a password isn't shuffled an infinite number of times.\n      const DEFAULT_NUMBER_OF_SHUFFLES = 15;\n      let shuffleCount = 0;\n      let consecutiveFlag = this._checkConsecutiveCharacters(\n        password,\n        rules.get(MAX_CONSECUTIVE)\n      );\n      while (!consecutiveFlag) {\n        password = this._shuffleString(password);\n        consecutiveFlag = this._checkConsecutiveCharacters(\n          password,\n          rules.get(MAX_CONSECUTIVE)\n        );\n        ++shuffleCount;\n        if (shuffleCount === DEFAULT_NUMBER_OF_SHUFFLES) {\n          consecutiveFlag = true;\n        }\n      }\n    }\n\n    return password;\n  },\n\n  /**\n   * Adds special characters and/or other required characters to the requiredCharacters array.\n   * @param {Map} rules\n   * @param {string[]} requiredClasses\n   */\n  _addRequiredClassesAndCharacters(rules, requiredClasses) {\n    for (const charClass of rules.get(REQUIRED)) {\n      if (charClass === UPPER) {\n        requiredClasses.push(UPPER_CASE_ALPHA);\n      } else if (charClass === LOWER) {\n        requiredClasses.push(LOWER_CASE_ALPHA);\n      } else if (charClass === DIGIT) {\n        requiredClasses.push(DIGITS);\n      } else if (charClass === SPECIAL) {\n        requiredClasses.push(SPECIAL_CHARACTERS);\n      } else {\n        requiredClasses.push(charClass);\n      }\n    }\n  },\n\n  /**\n   * @param range to generate the number in\n   * @returns a random number in range [0, range).\n   * @copyright 2018 The Chromium Authors. All rights reserved.\n   * @see https://cs.chromium.org/chromium/src/base/rand_util.cc?l=58&rcl=648a59893e4ed5303b5c381b03ce0c75e4165617\n   */\n  _randomUInt8Index(range) {\n    if (range > MAX_UINT8) {\n      throw new Error(\"`range` cannot fit into uint8\");\n    }\n    // We must discard random results above this number, as they would\n    // make the random generator non-uniform (consider e.g. if\n    // MAX_UINT64 was 7 and |range| was 5, then a result of 1 would be twice\n    // as likely as a result of 3 or 4).\n    // See https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#Modulo_bias\n    const MAX_ACCEPTABLE_VALUE = Math.floor(MAX_UINT8 / range) * range - 1;\n\n    const randomValueArr = new Uint8Array(1);\n    do {\n      crypto.getRandomValues(randomValueArr);\n    } while (randomValueArr[0] > MAX_ACCEPTABLE_VALUE);\n    return randomValueArr[0] % range;\n  },\n\n  /**\n   * Shuffle the order of characters in a string.\n   * @param {string} str to shuffle\n   * @returns {string} shuffled string\n   */\n  _shuffleString(str) {\n    let arr = Array.from(str);\n    // Generate all the random numbers that will be needed.\n    const randomValues = new Uint32Array(arr.length - 1);\n    crypto.getRandomValues(randomValues);\n\n    // Fisher-Yates Shuffle\n    // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor((randomValues[i - 1] / MAX_UINT32) * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr.join(\"\");\n  },\n\n  /**\n   * Determine the number of consecutive characters in a string.\n   * This is primarily used to validate the \"max-consecutive\" rule\n   * of a generated password.\n   * @param {string} generatedPassword\n   * @param {number} value the number of consecutive characters allowed\n   * @return {boolean} `true` if the generatePassword has less than the value argument number of characters, `false` otherwise\n   */\n  _checkConsecutiveCharacters(generatedPassword, value) {\n    let max = 0;\n    for (let start = 0, end = 1; end < generatedPassword.length; ) {\n      if (generatedPassword[end] === generatedPassword[start]) {\n        if (max < end - start + 1) {\n          max = end - start + 1;\n          if (max > value) {\n            return false;\n          }\n        }\n        end++;\n      } else {\n        start = end++;\n      }\n    }\n    return true;\n  },\n  _getUpperCaseCharacters() {\n    return UPPER_CASE_ALPHA;\n  },\n  _getLowerCaseCharacters() {\n    return LOWER_CASE_ALPHA;\n  },\n  _getDigits() {\n    return DIGITS;\n  },\n  _getSpecialCharacters() {\n    return SPECIAL_CHARACTERS;\n  },\n};\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PasswordGenerator.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/PasswordRulesParser.sys.mjs":
/*!*************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/PasswordRulesParser.sys.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PasswordRulesParser: () => (/* binding */ PasswordRulesParser)\n/* harmony export */ });\n// Sourced from https://github.com/apple/password-manager-resources/blob/5f6da89483e75cdc4165a6fc4756796e0ced7a21/tools/PasswordRulesParser.js\n// Copyright (c) 2019 - 2020 Apple Inc. Licensed under MIT License.\n\nconst PasswordRulesParser = {\n  parsePasswordRules,\n};\n\nconst Identifier = {\n  ASCII_PRINTABLE: \"ascii-printable\",\n  DIGIT: \"digit\",\n  LOWER: \"lower\",\n  SPECIAL: \"special\",\n  UNICODE: \"unicode\",\n  UPPER: \"upper\",\n};\n\nconst RuleName = {\n  ALLOWED: \"allowed\",\n  MAX_CONSECUTIVE: \"max-consecutive\",\n  REQUIRED: \"required\",\n  MIN_LENGTH: \"minlength\",\n  MAX_LENGTH: \"maxlength\",\n};\n\nconst CHARACTER_CLASS_START_SENTINEL = \"[\";\nconst CHARACTER_CLASS_END_SENTINEL = \"]\";\nconst PROPERTY_VALUE_SEPARATOR = \",\";\nconst PROPERTY_SEPARATOR = \";\";\nconst PROPERTY_VALUE_START_SENTINEL = \":\";\n\nconst SPACE_CODE_POINT = \" \".codePointAt(0);\n\nconst SHOULD_NOT_BE_REACHED = \"Should not be reached\";\n\nclass Rule {\n  constructor(name, value) {\n    this._name = name;\n    this.value = value;\n  }\n  get name() {\n    return this._name;\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n}\n\nclass NamedCharacterClass {\n  constructor(name) {\n    console.assert(_isValidRequiredOrAllowedPropertyValueIdentifier(name));\n    this._name = name;\n  }\n  get name() {\n    return this._name.toLowerCase();\n  }\n  toString() {\n    return this._name;\n  }\n  toHTMLString() {\n    return this._name;\n  }\n}\n\nclass CustomCharacterClass {\n  constructor(characters) {\n    console.assert(characters instanceof Array);\n    this._characters = characters;\n  }\n  get characters() {\n    return this._characters;\n  }\n  toString() {\n    return `[${this._characters.join(\"\")}]`;\n  }\n  toHTMLString() {\n    return `[${this._characters.join(\"\").replace('\"', \"&quot;\")}]`;\n  }\n}\n\n// MARK: Lexer functions\n\nfunction _isIdentifierCharacter(c) {\n  console.assert(c.length === 1);\n  return (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\") || c === \"-\";\n}\n\nfunction _isASCIIDigit(c) {\n  console.assert(c.length === 1);\n  return c >= \"0\" && c <= \"9\";\n}\n\nfunction _isASCIIPrintableCharacter(c) {\n  console.assert(c.length === 1);\n  return c >= \" \" && c <= \"~\";\n}\n\nfunction _isASCIIWhitespace(c) {\n  console.assert(c.length === 1);\n  return c === \" \" || c === \"\\f\" || c === \"\\n\" || c === \"\\r\" || c === \"\\t\";\n}\n\n// MARK: ASCII printable character bit set and canonicalization functions\n\nfunction _bitSetIndexForCharacter(c) {\n  console.assert(c.length == 1);\n  return c.codePointAt(0) - SPACE_CODE_POINT;\n}\n\nfunction _characterAtBitSetIndex(index) {\n  return String.fromCodePoint(index + SPACE_CODE_POINT);\n}\n\nfunction _markBitsForNamedCharacterClass(bitSet, namedCharacterClass) {\n  console.assert(bitSet instanceof Array);\n  console.assert(namedCharacterClass.name !== Identifier.UNICODE);\n  console.assert(namedCharacterClass.name !== Identifier.ASCII_PRINTABLE);\n  if (namedCharacterClass.name === Identifier.UPPER) {\n    bitSet.fill(\n      true,\n      _bitSetIndexForCharacter(\"A\"),\n      _bitSetIndexForCharacter(\"Z\") + 1\n    );\n  } else if (namedCharacterClass.name === Identifier.LOWER) {\n    bitSet.fill(\n      true,\n      _bitSetIndexForCharacter(\"a\"),\n      _bitSetIndexForCharacter(\"z\") + 1\n    );\n  } else if (namedCharacterClass.name === Identifier.DIGIT) {\n    bitSet.fill(\n      true,\n      _bitSetIndexForCharacter(\"0\"),\n      _bitSetIndexForCharacter(\"9\") + 1\n    );\n  } else if (namedCharacterClass.name === Identifier.SPECIAL) {\n    bitSet.fill(\n      true,\n      _bitSetIndexForCharacter(\" \"),\n      _bitSetIndexForCharacter(\"/\") + 1\n    );\n    bitSet.fill(\n      true,\n      _bitSetIndexForCharacter(\":\"),\n      _bitSetIndexForCharacter(\"@\") + 1\n    );\n    bitSet.fill(\n      true,\n      _bitSetIndexForCharacter(\"[\"),\n      _bitSetIndexForCharacter(\"`\") + 1\n    );\n    bitSet.fill(\n      true,\n      _bitSetIndexForCharacter(\"{\"),\n      _bitSetIndexForCharacter(\"~\") + 1\n    );\n  } else {\n    console.assert(false, SHOULD_NOT_BE_REACHED, namedCharacterClass);\n  }\n}\n\nfunction _markBitsForCustomCharacterClass(bitSet, customCharacterClass) {\n  for (let character of customCharacterClass.characters) {\n    bitSet[_bitSetIndexForCharacter(character)] = true;\n  }\n}\n\nfunction _canonicalizedPropertyValues(\n  propertyValues,\n  keepCustomCharacterClassFormatCompliant\n) {\n  let asciiPrintableBitSet = new Array(\n    \"~\".codePointAt(0) - \" \".codePointAt(0) + 1\n  );\n\n  for (let propertyValue of propertyValues) {\n    if (propertyValue instanceof NamedCharacterClass) {\n      if (propertyValue.name === Identifier.UNICODE) {\n        return [new NamedCharacterClass(Identifier.UNICODE)];\n      }\n\n      if (propertyValue.name === Identifier.ASCII_PRINTABLE) {\n        return [new NamedCharacterClass(Identifier.ASCII_PRINTABLE)];\n      }\n\n      _markBitsForNamedCharacterClass(asciiPrintableBitSet, propertyValue);\n    } else if (propertyValue instanceof CustomCharacterClass) {\n      _markBitsForCustomCharacterClass(asciiPrintableBitSet, propertyValue);\n    }\n  }\n\n  let charactersSeen = [];\n\n  function checkRange(start, end) {\n    let temp = [];\n    for (\n      let i = _bitSetIndexForCharacter(start);\n      i <= _bitSetIndexForCharacter(end);\n      ++i\n    ) {\n      if (asciiPrintableBitSet[i]) {\n        temp.push(_characterAtBitSetIndex(i));\n      }\n    }\n\n    let result =\n      temp.length ===\n      _bitSetIndexForCharacter(end) - _bitSetIndexForCharacter(start) + 1;\n    if (!result) {\n      charactersSeen = charactersSeen.concat(temp);\n    }\n    return result;\n  }\n\n  let hasAllUpper = checkRange(\"A\", \"Z\");\n  let hasAllLower = checkRange(\"a\", \"z\");\n  let hasAllDigits = checkRange(\"0\", \"9\");\n\n  // Check for special characters, accounting for characters that are given special treatment (i.e. '-' and ']')\n  let hasAllSpecial = false;\n  let hasDash = false;\n  let hasRightSquareBracket = false;\n  let temp = [];\n  for (\n    let i = _bitSetIndexForCharacter(\" \");\n    i <= _bitSetIndexForCharacter(\"/\");\n    ++i\n  ) {\n    if (!asciiPrintableBitSet[i]) {\n      continue;\n    }\n\n    let character = _characterAtBitSetIndex(i);\n    if (keepCustomCharacterClassFormatCompliant && character === \"-\") {\n      hasDash = true;\n    } else {\n      temp.push(character);\n    }\n  }\n  for (\n    let i = _bitSetIndexForCharacter(\":\");\n    i <= _bitSetIndexForCharacter(\"@\");\n    ++i\n  ) {\n    if (asciiPrintableBitSet[i]) {\n      temp.push(_characterAtBitSetIndex(i));\n    }\n  }\n  for (\n    let i = _bitSetIndexForCharacter(\"[\");\n    i <= _bitSetIndexForCharacter(\"`\");\n    ++i\n  ) {\n    if (!asciiPrintableBitSet[i]) {\n      continue;\n    }\n\n    let character = _characterAtBitSetIndex(i);\n    if (keepCustomCharacterClassFormatCompliant && character === \"]\") {\n      hasRightSquareBracket = true;\n    } else {\n      temp.push(character);\n    }\n  }\n  for (\n    let i = _bitSetIndexForCharacter(\"{\");\n    i <= _bitSetIndexForCharacter(\"~\");\n    ++i\n  ) {\n    if (asciiPrintableBitSet[i]) {\n      temp.push(_characterAtBitSetIndex(i));\n    }\n  }\n\n  if (hasDash) {\n    temp.unshift(\"-\");\n  }\n  if (hasRightSquareBracket) {\n    temp.push(\"]\");\n  }\n\n  let numberOfSpecialCharacters =\n    _bitSetIndexForCharacter(\"/\") -\n    _bitSetIndexForCharacter(\" \") +\n    1 +\n    (_bitSetIndexForCharacter(\"@\") - _bitSetIndexForCharacter(\":\") + 1) +\n    (_bitSetIndexForCharacter(\"`\") - _bitSetIndexForCharacter(\"[\") + 1) +\n    (_bitSetIndexForCharacter(\"~\") - _bitSetIndexForCharacter(\"{\") + 1);\n  hasAllSpecial = temp.length === numberOfSpecialCharacters;\n  if (!hasAllSpecial) {\n    charactersSeen = charactersSeen.concat(temp);\n  }\n\n  let result = [];\n  if (hasAllUpper && hasAllLower && hasAllDigits && hasAllSpecial) {\n    return [new NamedCharacterClass(Identifier.ASCII_PRINTABLE)];\n  }\n  if (hasAllUpper) {\n    result.push(new NamedCharacterClass(Identifier.UPPER));\n  }\n  if (hasAllLower) {\n    result.push(new NamedCharacterClass(Identifier.LOWER));\n  }\n  if (hasAllDigits) {\n    result.push(new NamedCharacterClass(Identifier.DIGIT));\n  }\n  if (hasAllSpecial) {\n    result.push(new NamedCharacterClass(Identifier.SPECIAL));\n  }\n  if (charactersSeen.length) {\n    result.push(new CustomCharacterClass(charactersSeen));\n  }\n  return result;\n}\n\n// MARK: Parser functions\n\nfunction _indexOfNonWhitespaceCharacter(input, position = 0) {\n  console.assert(position >= 0);\n  console.assert(position <= input.length);\n\n  let length = input.length;\n  while (position < length && _isASCIIWhitespace(input[position])) {\n    ++position;\n  }\n\n  return position;\n}\n\nfunction _parseIdentifier(input, position) {\n  console.assert(position >= 0);\n  console.assert(position < input.length);\n  console.assert(_isIdentifierCharacter(input[position]));\n\n  let length = input.length;\n  let seenIdentifiers = [];\n  do {\n    let c = input[position];\n    if (!_isIdentifierCharacter(c)) {\n      break;\n    }\n\n    seenIdentifiers.push(c);\n    ++position;\n  } while (position < length);\n\n  return [seenIdentifiers.join(\"\"), position];\n}\n\nfunction _isValidRequiredOrAllowedPropertyValueIdentifier(identifier) {\n  return (\n    identifier && Object.values(Identifier).includes(identifier.toLowerCase())\n  );\n}\n\nfunction _parseCustomCharacterClass(input, position) {\n  console.assert(position >= 0);\n  console.assert(position < input.length);\n  console.assert(input[position] === CHARACTER_CLASS_START_SENTINEL);\n\n  let length = input.length;\n  ++position;\n  if (position >= length) {\n    console.error(\"Found end-of-line instead of character class character\");\n    return [null, position];\n  }\n\n  let initialPosition = position;\n  let result = [];\n  do {\n    let c = input[position];\n    if (!_isASCIIPrintableCharacter(c)) {\n      ++position;\n      continue;\n    }\n\n    if (c === \"-\" && position - initialPosition > 0) {\n      // FIXME: Should this be an error?\n      console.warn(\n        \"Ignoring '-'; a '-' may only appear as the first character in a character class\"\n      );\n      ++position;\n      continue;\n    }\n\n    result.push(c);\n    ++position;\n    if (c === CHARACTER_CLASS_END_SENTINEL) {\n      break;\n    }\n  } while (position < length);\n\n  if (\n    (position < length && input[position] !== CHARACTER_CLASS_END_SENTINEL) ||\n    (position == length && input[position - 1] == CHARACTER_CLASS_END_SENTINEL)\n  ) {\n    // Fix up result; we over consumed.\n    result.pop();\n    return [result, position];\n  }\n\n  if (position < length && input[position] == CHARACTER_CLASS_END_SENTINEL) {\n    return [result, position + 1];\n  }\n\n  console.error(\"Found end-of-line instead of end of character class\");\n  return [null, position];\n}\n\nfunction _parsePasswordRequiredOrAllowedPropertyValue(input, position) {\n  console.assert(position >= 0);\n  console.assert(position < input.length);\n\n  let length = input.length;\n  let propertyValues = [];\n  while (true) {\n    if (_isIdentifierCharacter(input[position])) {\n      let identifierStartPosition = position;\n      var [propertyValue, position] = _parseIdentifier(input, position);\n      if (!_isValidRequiredOrAllowedPropertyValueIdentifier(propertyValue)) {\n        console.error(\n          \"Unrecognized property value identifier: \" + propertyValue\n        );\n        return [null, identifierStartPosition];\n      }\n      propertyValues.push(new NamedCharacterClass(propertyValue));\n    } else if (input[position] == CHARACTER_CLASS_START_SENTINEL) {\n      var [propertyValue, position] = _parseCustomCharacterClass(\n        input,\n        position\n      );\n      if (propertyValue && propertyValue.length) {\n        propertyValues.push(new CustomCharacterClass(propertyValue));\n      }\n    } else {\n      console.error(\n        \"Failed to find start of property value: \" + input.substr(position)\n      );\n      return [null, position];\n    }\n\n    position = _indexOfNonWhitespaceCharacter(input, position);\n    if (position >= length || input[position] === PROPERTY_SEPARATOR) {\n      break;\n    }\n\n    if (input[position] === PROPERTY_VALUE_SEPARATOR) {\n      position = _indexOfNonWhitespaceCharacter(input, position + 1);\n      if (position >= length) {\n        console.error(\n          \"Found end-of-line instead of start of next property value\"\n        );\n        return [null, position];\n      }\n      continue;\n    }\n\n    console.error(\n      \"Failed to find start of next property or property value: \" +\n        input.substr(position)\n    );\n    return [null, position];\n  }\n  return [propertyValues, position];\n}\n\nfunction _parsePasswordRule(input, position) {\n  console.assert(position >= 0);\n  console.assert(position < input.length);\n  console.assert(_isIdentifierCharacter(input[position]));\n\n  let length = input.length;\n\n  let mayBeIdentifierStartPosition = position;\n  var [identifier, position] = _parseIdentifier(input, position);\n  if (!Object.values(RuleName).includes(identifier)) {\n    console.error(\"Unrecognized property name: \" + identifier);\n    return [null, mayBeIdentifierStartPosition];\n  }\n\n  if (position >= length) {\n    console.error(\"Found end-of-line instead of start of property value\");\n    return [null, position];\n  }\n\n  if (input[position] !== PROPERTY_VALUE_START_SENTINEL) {\n    console.error(\n      \"Failed to find start of property value: \" + input.substr(position)\n    );\n    return [null, position];\n  }\n\n  let property = { name: identifier, value: null };\n\n  position = _indexOfNonWhitespaceCharacter(input, position + 1);\n  // Empty value\n  if (position >= length || input[position] === PROPERTY_SEPARATOR) {\n    return [new Rule(property.name, property.value), position];\n  }\n\n  switch (identifier) {\n    case RuleName.ALLOWED:\n    case RuleName.REQUIRED: {\n      var [\n        propertyValue,\n        position,\n      ] = _parsePasswordRequiredOrAllowedPropertyValue(input, position);\n      if (propertyValue) {\n        property.value = propertyValue;\n      }\n      return [new Rule(property.name, property.value), position];\n    }\n    case RuleName.MAX_CONSECUTIVE: {\n      var [propertyValue, position] = _parseMaxConsecutivePropertyValue(\n        input,\n        position\n      );\n      if (propertyValue) {\n        property.value = propertyValue;\n      }\n      return [new Rule(property.name, property.value), position];\n    }\n    case RuleName.MIN_LENGTH:\n    case RuleName.MAX_LENGTH: {\n      var [propertyValue, position] = _parseMinLengthMaxLengthPropertyValue(\n        input,\n        position\n      );\n      if (propertyValue) {\n        property.value = propertyValue;\n      }\n      return [new Rule(property.name, property.value), position];\n    }\n  }\n  console.assert(false, SHOULD_NOT_BE_REACHED);\n}\n\nfunction _parseMinLengthMaxLengthPropertyValue(input, position) {\n  return _parseInteger(input, position);\n}\n\nfunction _parseMaxConsecutivePropertyValue(input, position) {\n  return _parseInteger(input, position);\n}\n\nfunction _parseInteger(input, position) {\n  console.assert(position >= 0);\n  console.assert(position < input.length);\n\n  if (!_isASCIIDigit(input[position])) {\n    console.error(\n      \"Failed to parse value of type integer; not a number: \" +\n        input.substr(position)\n    );\n    return [null, position];\n  }\n\n  let length = input.length;\n  let initialPosition = position;\n  let result = 0;\n  do {\n    result = 10 * result + parseInt(input[position], 10);\n    ++position;\n  } while (\n    position < length &&\n    input[position] !== PROPERTY_SEPARATOR &&\n    _isASCIIDigit(input[position])\n  );\n\n  if (position >= length || input[position] === PROPERTY_SEPARATOR) {\n    return [result, position];\n  }\n\n  console.error(\n    \"Failed to parse value of type integer; not a number: \" +\n      input.substr(initialPosition)\n  );\n  return [null, position];\n}\n\nfunction _parsePasswordRulesInternal(input) {\n  let parsedProperties = [];\n  let length = input.length;\n\n  var position = _indexOfNonWhitespaceCharacter(input);\n  while (position < length) {\n    if (!_isIdentifierCharacter(input[position])) {\n      console.warn(\n        \"Failed to find start of property: \" + input.substr(position)\n      );\n      return parsedProperties;\n    }\n\n    var [parsedProperty, position] = _parsePasswordRule(input, position);\n    if (parsedProperty && parsedProperty.value) {\n      parsedProperties.push(parsedProperty);\n    }\n\n    position = _indexOfNonWhitespaceCharacter(input, position);\n    if (position >= length) {\n      break;\n    }\n\n    if (input[position] === PROPERTY_SEPARATOR) {\n      position = _indexOfNonWhitespaceCharacter(input, position + 1);\n      if (position >= length) {\n        return parsedProperties;\n      }\n\n      continue;\n    }\n\n    console.error(\n      \"Failed to find start of next property: \" + input.substr(position)\n    );\n    return null;\n  }\n\n  return parsedProperties;\n}\n\nfunction parsePasswordRules(input, formatRulesForMinifiedVersion) {\n  let passwordRules = _parsePasswordRulesInternal(input) || [];\n\n  // When formatting rules for minified version, we should keep the formatted rules\n  // as similar to the input as possible. Avoid copying required rules to allowed rules.\n  let suppressCopyingRequiredToAllowed = formatRulesForMinifiedVersion;\n\n  let newPasswordRules = [];\n  let newAllowedValues = [];\n  let minimumMaximumConsecutiveCharacters = null;\n  let maximumMinLength = 0;\n  let minimumMaxLength = null;\n\n  for (let rule of passwordRules) {\n    switch (rule.name) {\n      case RuleName.MAX_CONSECUTIVE:\n        minimumMaximumConsecutiveCharacters = minimumMaximumConsecutiveCharacters\n          ? Math.min(rule.value, minimumMaximumConsecutiveCharacters)\n          : rule.value;\n        break;\n\n      case RuleName.MIN_LENGTH:\n        maximumMinLength = Math.max(rule.value, maximumMinLength);\n        break;\n\n      case RuleName.MAX_LENGTH:\n        minimumMaxLength = minimumMaxLength\n          ? Math.min(rule.value, minimumMaxLength)\n          : rule.value;\n        break;\n\n      case RuleName.REQUIRED:\n        rule.value = _canonicalizedPropertyValues(\n          rule.value,\n          formatRulesForMinifiedVersion\n        );\n        newPasswordRules.push(rule);\n        if (!suppressCopyingRequiredToAllowed) {\n          newAllowedValues = newAllowedValues.concat(rule.value);\n        }\n        break;\n\n      case RuleName.ALLOWED:\n        newAllowedValues = newAllowedValues.concat(rule.value);\n        break;\n    }\n  }\n\n  newAllowedValues = _canonicalizedPropertyValues(\n    newAllowedValues,\n    suppressCopyingRequiredToAllowed\n  );\n  if (!suppressCopyingRequiredToAllowed && !newAllowedValues.length) {\n    newAllowedValues = [new NamedCharacterClass(Identifier.ASCII_PRINTABLE)];\n  }\n  if (newAllowedValues.length) {\n    newPasswordRules.push(new Rule(RuleName.ALLOWED, newAllowedValues));\n  }\n\n  if (minimumMaximumConsecutiveCharacters !== null) {\n    newPasswordRules.push(\n      new Rule(RuleName.MAX_CONSECUTIVE, minimumMaximumConsecutiveCharacters)\n    );\n  }\n\n  if (maximumMinLength > 0) {\n    newPasswordRules.push(new Rule(RuleName.MIN_LENGTH, maximumMinLength));\n  }\n\n  if (minimumMaxLength !== null) {\n    newPasswordRules.push(new Rule(RuleName.MAX_LENGTH, minimumMaxLength));\n  }\n\n  return newPasswordRules;\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PasswordRulesParser.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs":
/*!*****************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhoneNumber: () => (/* binding */ PhoneNumber)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_shared_PhoneNumberMetaData_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/shared/PhoneNumberMetaData.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Apache License, Version\n * 2.0. If a copy of the Apache License was not distributed with this file, You\n * can obtain one at https://www.apache.org/licenses/LICENSE-2.0 */\n\n// This library came from https://github.com/andreasgal/PhoneNumber.js but will\n// be further maintained by our own in Form Autofill codebase.\n\n\n\nconst lazy = {};\n\nChromeUtils.defineESModuleGetters(lazy, {\n  PhoneNumberNormalizer:\n    \"resource://gre/modules/shared/PhoneNumberNormalizer.sys.mjs\",\n});\n\nvar PhoneNumber = (function (dataBase) {\n  const MAX_PHONE_NUMBER_LENGTH = 50;\n  const NON_ALPHA_CHARS = /[^a-zA-Z]/g;\n  const NON_DIALABLE_CHARS = /[^,#+\\*\\d]/g;\n  const NON_DIALABLE_CHARS_ONCE = new RegExp(NON_DIALABLE_CHARS.source);\n  const SPLIT_FIRST_GROUP = /^(\\d+)(.*)$/;\n  const LEADING_PLUS_CHARS_PATTERN = /^[+\\uFF0B]+/g;\n\n  // Format of the string encoded meta data. If the name contains \"^\" or \"$\"\n  // we will generate a regular expression from the value, with those special\n  // characters as prefix/suffix.\n  const META_DATA_ENCODING = [\n    \"region\",\n    \"^(?:internationalPrefix)\",\n    \"nationalPrefix\",\n    \"^(?:nationalPrefixForParsing)\",\n    \"nationalPrefixTransformRule\",\n    \"nationalPrefixFormattingRule\",\n    \"^possiblePattern$\",\n    \"^nationalPattern$\",\n    \"formats\",\n  ];\n\n  const FORMAT_ENCODING = [\n    \"^pattern$\",\n    \"nationalFormat\",\n    \"^leadingDigits\",\n    \"nationalPrefixFormattingRule\",\n    \"internationalFormat\",\n  ];\n\n  let regionCache = Object.create(null);\n\n  // Parse an array of strings into a convenient object. We store meta\n  // data as arrays since thats much more compact than JSON.\n  function ParseArray(array, encoding, obj) {\n    for (let n = 0; n < encoding.length; ++n) {\n      let value = array[n];\n      if (!value) {\n        continue;\n      }\n      let field = encoding[n];\n      let fieldAlpha = field.replace(NON_ALPHA_CHARS, \"\");\n      if (field != fieldAlpha) {\n        value = new RegExp(field.replace(fieldAlpha, value));\n      }\n      obj[fieldAlpha] = value;\n    }\n    return obj;\n  }\n\n  // Parse string encoded meta data into a convenient object\n  // representation.\n  function ParseMetaData(countryCode, md) {\n    let array = JSON.parse(md);\n    md = ParseArray(array, META_DATA_ENCODING, { countryCode });\n    regionCache[md.region] = md;\n    return md;\n  }\n\n  // Parse string encoded format data into a convenient object\n  // representation.\n  function ParseFormat(md) {\n    let formats = md.formats;\n    if (!formats) {\n      return;\n    }\n    // Bail if we already parsed the format definitions.\n    if (!Array.isArray(formats[0])) {\n      return;\n    }\n    for (let n = 0; n < formats.length; ++n) {\n      formats[n] = ParseArray(formats[n], FORMAT_ENCODING, {});\n    }\n  }\n\n  // Search for the meta data associated with a region identifier (\"US\") in\n  // our database, which is indexed by country code (\"1\"). Since we have\n  // to walk the entire database for this, we cache the result of the lookup\n  // for future reference.\n  function FindMetaDataForRegion(region) {\n    // Check in the region cache first. This will find all entries we have\n    // already resolved (parsed from a string encoding).\n    let md = regionCache[region];\n    if (md) {\n      return md;\n    }\n    for (let countryCode in dataBase) {\n      let entry = dataBase[countryCode];\n      // Each entry is a string encoded object of the form '[\"US..', or\n      // an array of strings. We don't want to parse the string here\n      // to save memory, so we just substring the region identifier\n      // and compare it. For arrays, we compare against all region\n      // identifiers with that country code. We skip entries that are\n      // of type object, because they were already resolved (parsed into\n      // an object), and their country code should have been in the cache.\n      if (Array.isArray(entry)) {\n        for (let n = 0; n < entry.length; n++) {\n          if (typeof entry[n] == \"string\" && entry[n].substr(2, 2) == region) {\n            if (n > 0) {\n              // Only the first entry has the formats field set.\n              // Parse the main country if we haven't already and use\n              // the formats field from the main country.\n              if (typeof entry[0] == \"string\") {\n                entry[0] = ParseMetaData(countryCode, entry[0]);\n              }\n              let formats = entry[0].formats;\n              let current = ParseMetaData(countryCode, entry[n]);\n              current.formats = formats;\n              entry[n] = current;\n              return entry[n];\n            }\n\n            entry[n] = ParseMetaData(countryCode, entry[n]);\n            return entry[n];\n          }\n        }\n        continue;\n      }\n      if (typeof entry == \"string\" && entry.substr(2, 2) == region) {\n        dataBase[countryCode] = ParseMetaData(countryCode, entry);\n        return dataBase[countryCode];\n      }\n    }\n  }\n\n  // Format a national number for a given region. The boolean flag \"intl\"\n  // indicates whether we want the national or international format.\n  function FormatNumber(regionMetaData, number, intl) {\n    // We lazily parse the format description in the meta data for the region,\n    // so make sure to parse it now if we haven't already done so.\n    ParseFormat(regionMetaData);\n    let formats = regionMetaData.formats;\n    if (!formats) {\n      return null;\n    }\n    for (let n = 0; n < formats.length; ++n) {\n      let format = formats[n];\n      // The leading digits field is optional. If we don't have it, just\n      // use the matching pattern to qualify numbers.\n      if (format.leadingDigits && !format.leadingDigits.test(number)) {\n        continue;\n      }\n      if (!format.pattern.test(number)) {\n        continue;\n      }\n      if (intl) {\n        // If there is no international format, just fall back to the national\n        // format.\n        let internationalFormat = format.internationalFormat;\n        if (!internationalFormat) {\n          internationalFormat = format.nationalFormat;\n        }\n        // Some regions have numbers that can't be dialed from outside the\n        // country, indicated by \"NA\" for the international format of that\n        // number format pattern.\n        if (internationalFormat == \"NA\") {\n          return null;\n        }\n        // Prepend \"+\" and the country code.\n        number =\n          \"+\" +\n          regionMetaData.countryCode +\n          \" \" +\n          number.replace(format.pattern, internationalFormat);\n      } else {\n        number = number.replace(format.pattern, format.nationalFormat);\n        // The region has a national prefix formatting rule, and it can be overwritten\n        // by each actual number format rule.\n        let nationalPrefixFormattingRule =\n          regionMetaData.nationalPrefixFormattingRule;\n        if (format.nationalPrefixFormattingRule) {\n          nationalPrefixFormattingRule = format.nationalPrefixFormattingRule;\n        }\n        if (nationalPrefixFormattingRule) {\n          // The prefix formatting rule contains two magic markers, \"$NP\" and \"$FG\".\n          // \"$NP\" will be replaced by the national prefix, and \"$FG\" with the\n          // first group of numbers.\n          let match = number.match(SPLIT_FIRST_GROUP);\n          if (match) {\n            let firstGroup = match[1];\n            let rest = match[2];\n            let prefix = nationalPrefixFormattingRule;\n            prefix = prefix.replace(\"$NP\", regionMetaData.nationalPrefix);\n            prefix = prefix.replace(\"$FG\", firstGroup);\n            number = prefix + rest;\n          }\n        }\n      }\n      return number == \"NA\" ? null : number;\n    }\n    return null;\n  }\n\n  function NationalNumber(regionMetaData, number) {\n    this.region = regionMetaData.region;\n    this.regionMetaData = regionMetaData;\n    this.number = number;\n  }\n\n  // NationalNumber represents the result of parsing a phone number. We have\n  // three getters on the prototype that format the number in national and\n  // international format. Once called, the getters put a direct property\n  // onto the object, caching the result.\n  NationalNumber.prototype = {\n    // +1 949-726-2896\n    get internationalFormat() {\n      let value = FormatNumber(this.regionMetaData, this.number, true);\n      Object.defineProperty(this, \"internationalFormat\", {\n        value,\n        enumerable: true,\n      });\n      return value;\n    },\n    // (949) 726-2896\n    get nationalFormat() {\n      let value = FormatNumber(this.regionMetaData, this.number, false);\n      Object.defineProperty(this, \"nationalFormat\", {\n        value,\n        enumerable: true,\n      });\n      return value;\n    },\n    // +19497262896\n    get internationalNumber() {\n      let value = this.internationalFormat\n        ? this.internationalFormat.replace(NON_DIALABLE_CHARS, \"\")\n        : null;\n      Object.defineProperty(this, \"internationalNumber\", {\n        value,\n        enumerable: true,\n      });\n      return value;\n    },\n    // 9497262896\n    get nationalNumber() {\n      let value = this.nationalFormat\n        ? this.nationalFormat.replace(NON_DIALABLE_CHARS, \"\")\n        : null;\n      Object.defineProperty(this, \"nationalNumber\", {\n        value,\n        enumerable: true,\n      });\n      return value;\n    },\n    // country name 'US'\n    get countryName() {\n      let value = this.region ? this.region : null;\n      Object.defineProperty(this, \"countryName\", { value, enumerable: true });\n      return value;\n    },\n    // country code '+1'\n    get countryCode() {\n      let value = this.regionMetaData.countryCode\n        ? \"+\" + this.regionMetaData.countryCode\n        : null;\n      Object.defineProperty(this, \"countryCode\", { value, enumerable: true });\n      return value;\n    },\n  };\n\n  // Check whether the number is valid for the given region.\n  function IsValidNumber(number, md) {\n    return md.possiblePattern.test(number);\n  }\n\n  // Check whether the number is a valid national number for the given region.\n  /* eslint-disable no-unused-vars */\n  function IsNationalNumber(number, md) {\n    return IsValidNumber(number, md) && md.nationalPattern.test(number);\n  }\n\n  // Determine the country code a number starts with, or return null if\n  // its not a valid country code.\n  function ParseCountryCode(number) {\n    for (let n = 1; n <= 3; ++n) {\n      let cc = number.substr(0, n);\n      if (dataBase[cc]) {\n        return cc;\n      }\n    }\n    return null;\n  }\n\n  // Parse a national number for a specific region. Return null if the\n  // number is not a valid national number (it might still be a possible\n  // number for parts of that region).\n  function ParseNationalNumber(number, md) {\n    if (!md.possiblePattern.test(number) || !md.nationalPattern.test(number)) {\n      return null;\n    }\n    // Success.\n    return new NationalNumber(md, number);\n  }\n\n  function ParseNationalNumberAndCheckNationalPrefix(number, md) {\n    let ret;\n\n    // This is not an international number. See if its a national one for\n    // the current region. National numbers can start with the national\n    // prefix, or without.\n    if (md.nationalPrefixForParsing) {\n      // Some regions have specific national prefix parse rules. Apply those.\n      let withoutPrefix = number.replace(\n        md.nationalPrefixForParsing,\n        md.nationalPrefixTransformRule || \"\"\n      );\n      ret = ParseNationalNumber(withoutPrefix, md);\n      if (ret) {\n        return ret;\n      }\n    } else {\n      // If there is no specific national prefix rule, just strip off the\n      // national prefix from the beginning of the number (if there is one).\n      let nationalPrefix = md.nationalPrefix;\n      if (\n        nationalPrefix &&\n        number.indexOf(nationalPrefix) == 0 &&\n        (ret = ParseNationalNumber(number.substr(nationalPrefix.length), md))\n      ) {\n        return ret;\n      }\n    }\n    ret = ParseNationalNumber(number, md);\n    if (ret) {\n      return ret;\n    }\n  }\n\n  function ParseNumberByCountryCode(number, countryCode) {\n    let ret;\n\n    // Lookup the meta data for the region (or regions) and if the rest of\n    // the number parses for that region, return the parsed number.\n    let entry = dataBase[countryCode];\n    if (Array.isArray(entry)) {\n      for (let n = 0; n < entry.length; ++n) {\n        if (typeof entry[n] == \"string\") {\n          entry[n] = ParseMetaData(countryCode, entry[n]);\n        }\n        if (n > 0) {\n          entry[n].formats = entry[0].formats;\n        }\n        ret = ParseNationalNumberAndCheckNationalPrefix(number, entry[n]);\n        if (ret) {\n          return ret;\n        }\n      }\n      return null;\n    }\n    if (typeof entry == \"string\") {\n      entry = dataBase[countryCode] = ParseMetaData(countryCode, entry);\n    }\n    return ParseNationalNumberAndCheckNationalPrefix(number, entry);\n  }\n\n  // Parse an international number that starts with the country code. Return\n  // null if the number is not a valid international number.\n  function ParseInternationalNumber(number) {\n    // Parse and strip the country code.\n    let countryCode = ParseCountryCode(number);\n    if (!countryCode) {\n      return null;\n    }\n    number = number.substr(countryCode.length);\n\n    return ParseNumberByCountryCode(number, countryCode);\n  }\n\n  // Parse a number and transform it into the national format, removing any\n  // international dial prefixes and country codes.\n  function ParseNumber(number, defaultRegion) {\n    let ret;\n\n    // Remove formating characters and whitespace.\n    number = lazy.PhoneNumberNormalizer.Normalize(number);\n\n    // If there is no defaultRegion or the defaultRegion is the global region,\n    // we can't parse international access codes.\n    if ((!defaultRegion || defaultRegion === \"001\") && number[0] !== \"+\") {\n      return null;\n    }\n\n    // Detect and strip leading '+'.\n    if (number[0] === \"+\") {\n      return ParseInternationalNumber(\n        number.replace(LEADING_PLUS_CHARS_PATTERN, \"\")\n      );\n    }\n\n    // If \"defaultRegion\" is a country code, use it to parse the number directly.\n    let matches = String(defaultRegion).match(/^\\+?(\\d+)/);\n    if (matches) {\n      let countryCode = ParseCountryCode(matches[1]);\n      if (!countryCode) {\n        return null;\n      }\n      return ParseNumberByCountryCode(number, countryCode);\n    }\n\n    // Lookup the meta data for the given region.\n    let md = FindMetaDataForRegion(defaultRegion.toUpperCase());\n    if (!md) {\n      dump(\"Couldn't find Meta Data for region: \" + defaultRegion + \"\\n\");\n      return null;\n    }\n\n    // See if the number starts with an international prefix, and if the\n    // number resulting from stripping the code is valid, then remove the\n    // prefix and flag the number as international.\n    if (md.internationalPrefix.test(number)) {\n      let possibleNumber = number.replace(md.internationalPrefix, \"\");\n      ret = ParseInternationalNumber(possibleNumber);\n      if (ret) {\n        return ret;\n      }\n    }\n\n    ret = ParseNationalNumberAndCheckNationalPrefix(number, md);\n    if (ret) {\n      return ret;\n    }\n\n    // Now lets see if maybe its an international number after all, but\n    // without '+' or the international prefix.\n    ret = ParseInternationalNumber(number);\n    if (ret) {\n      return ret;\n    }\n\n    // If the number matches the possible numbers of the current region,\n    // return it as a possible number.\n    if (md.possiblePattern.test(number)) {\n      return new NationalNumber(md, number);\n    }\n\n    // We couldn't parse the number at all.\n    return null;\n  }\n\n  function IsPlainPhoneNumber(number) {\n    if (typeof number !== \"string\") {\n      return false;\n    }\n\n    let length = number.length;\n    let isTooLong = length > MAX_PHONE_NUMBER_LENGTH;\n    let isEmpty = length === 0;\n    return !(isTooLong || isEmpty || NON_DIALABLE_CHARS_ONCE.test(number));\n  }\n\n  return {\n    IsPlain: IsPlainPhoneNumber,\n    IsValid: IsValidNumber,\n    Parse: ParseNumber,\n    FindMetaDataForRegion,\n  };\n})(resource_gre_modules_shared_PhoneNumberMetaData_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.PHONE_NUMBER_META_DATA);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs":
/*!*************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PHONE_NUMBER_META_DATA: () => (/* binding */ PHONE_NUMBER_META_DATA)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Apache License, Version\n * 2.0. If a copy of the Apache License was not distributed with this file, You\n * can obtain one at https://www.apache.org/licenses/LICENSE-2.0 */\n\n/*\n * This data was generated base on libphonenumber v8.4.1 via the script in\n * https://github.com/andreasgal/PhoneNumber.js\n *\n * The XML format of libphonenumber has changed since v8.4.2 so we can only stay\n * in this version for now.\n */\n\nvar PHONE_NUMBER_META_DATA = {\n  46: '[\"SE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,12}\",\"[1-35-9]\\\\\\\\d{5,11}|4\\\\\\\\d{6,8}\",[[\"(8)(\\\\\\\\d{2,3})(\\\\\\\\d{2,3})(\\\\\\\\d{2})\",\"$1-$2 $3 $4\",\"8\",null,\"$1 $2 $3 $4\"],[\"([1-69]\\\\\\\\d)(\\\\\\\\d{2,3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2 $3 $4\",\"1[013689]|2[0136]|3[1356]|4[0246]|54|6[03]|90\",null,\"$1 $2 $3 $4\"],[\"([1-469]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})\",\"$1-$2 $3\",\"1[136]|2[136]|3[356]|4[0246]|6[03]|90\",null,\"$1 $2 $3\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2 $3 $4\",\"1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[0-5]|4[0-3])\",null,\"$1 $2 $3 $4\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{2,3})(\\\\\\\\d{2})\",\"$1-$2 $3\",\"1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[0-5]|4[0-3])\",null,\"$1 $2 $3\"],[\"(7\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2 $3 $4\",\"7\",null,\"$1 $2 $3 $4\"],[\"(77)(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2$3\",\"7\",null,\"$1 $2 $3\"],[\"(20)(\\\\\\\\d{2,3})(\\\\\\\\d{2})\",\"$1-$2 $3\",\"20\",null,\"$1 $2 $3\"],[\"(9[034]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1-$2 $3 $4\",\"9[034]\",null,\"$1 $2 $3 $4\"],[\"(9[034]\\\\\\\\d)(\\\\\\\\d{4})\",\"$1-$2\",\"9[034]\",null,\"$1 $2\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2 $3 $4 $5\",\"25[245]|67[3-6]\",null,\"$1 $2 $3 $4 $5\"]]]',\n  299: '[\"GL\",\"00\",null,null,null,null,\"\\\\\\\\d{6}\",\"[1-689]\\\\\\\\d{5}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",null,null]]]',\n  385: '[\"HR\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,9}\",\"[1-7]\\\\\\\\d{5,8}|[89]\\\\\\\\d{6,8}\",[[\"(1)(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1\",null],[\"([2-5]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[2-5]\",null],[\"(9\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"9\",null],[\"(6[01])(\\\\\\\\d{2})(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"6[01]\",null],[\"([67]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[67]\",null],[\"(80[01])(\\\\\\\\d{2})(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"8\",null],[\"(80[01])(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"8\",null]]]',\n  670: '[\"TL\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[2-489]\\\\\\\\d{6}|7\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[2-489]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"7\",null]]]',\n  258: '[\"MZ\",\"00\",null,null,null,null,\"\\\\\\\\d{8,9}\",\"[28]\\\\\\\\d{7,8}\",[[\"([28]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"2|8[2-7]\",null],[\"(80\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"80\",null]]]',\n  359: '[\"BG\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,9}\",\"[23567]\\\\\\\\d{5,7}|[489]\\\\\\\\d{6,8}\",[[\"(2)(\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"2\",null],[\"(2)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"2\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"43[124-7]|70[1-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{2})\",\"$1 $2 $3\",\"43[124-7]|70[1-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[78]00\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"999\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"48|8[7-9]|9[08]\",null]]]',\n  682: '[\"CK\",\"00\",null,null,null,null,\"\\\\\\\\d{5}\",\"[2-8]\\\\\\\\d{4}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2\",null,null]]]',\n  852: '[\"HK\",\"00(?:[126-9]|30|5[09])?\",null,null,null,null,\"\\\\\\\\d{5,11}\",\"[235-7]\\\\\\\\d{7}|8\\\\\\\\d{7,8}|9\\\\\\\\d{4,10}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"[235-7]|[89](?:0[1-9]|[1-9])\",null],[\"(800)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"800\",null],[\"(900)(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"900\",null],[\"(900)(\\\\\\\\d{2,5})\",\"$1 $2\",\"900\",null]]]',\n  998: '[\"UZ\",\"810\",\"8\",null,null,\"$NP $FG\",\"\\\\\\\\d{7,9}\",\"[679]\\\\\\\\d{8}\",[[\"([679]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  291: '[\"ER\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,7}\",\"[178]\\\\\\\\d{6}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",null,null]]]',\n  95: '[\"MM\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,10}\",\"[1478]\\\\\\\\d{5,7}|[256]\\\\\\\\d{5,8}|9(?:[279]\\\\\\\\d{0,2}|[58]|[34]\\\\\\\\d{1,2}|6\\\\\\\\d?)\\\\\\\\d{6}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"1|2[245]\",null],[\"(2)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"251\",null],[\"(\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"16|2\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"67|81\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[4-8]\",null],[\"(9)(\\\\\\\\d{3})(\\\\\\\\d{4,6})\",\"$1 $2 $3\",\"9(?:2[0-4]|[35-9]|4[137-9])\",null],[\"(9)([34]\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"9(?:3[0-36]|4[0-57-9])\",null],[\"(9)(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"92[56]\",null],[\"(9)(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"93\",null]]]',\n  266: '[\"LS\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2568]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  245: '[\"GW\",\"00\",null,null,null,null,\"\\\\\\\\d{7,9}\",\"(?:4(?:0\\\\\\\\d{5}|4\\\\\\\\d{7})|9\\\\\\\\d{8})\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"44|9[567]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"40\",null]]]',\n  374: '[\"AM\",\"00\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{5,8}\",\"[1-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{6})\",\"$1 $2\",\"1|47\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{6})\",\"$1 $2\",\"4[1349]|[5-7]|9[1-9]\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"[23]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"8|90\",\"$NP $FG\"]]]',\n  61: [\n    '[\"AU\",\"(?:14(?:1[14]|34|4[17]|[56]6|7[47]|88))?001[14-689]\",\"0\",null,null,null,\"\\\\\\\\d{6,10}\",\"1\\\\\\\\d{4,9}|[2-578]\\\\\\\\d{8}\",[[\"([2378])(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[2378]\",\"($NP$FG)\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[45]|14\",\"$NP$FG\"],[\"(16)(\\\\\\\\d{3,4})\",\"$1 $2\",\"16\",\"$NP$FG\"],[\"(16)(\\\\\\\\d{3})(\\\\\\\\d{2,4})\",\"$1 $2 $3\",\"16\",\"$NP$FG\"],[\"(1[389]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1(?:[38]0|90)\",\"$FG\"],[\"(180)(2\\\\\\\\d{3})\",\"$1 $2\",\"180\",\"$FG\"],[\"(19\\\\\\\\d)(\\\\\\\\d{3})\",\"$1 $2\",\"19[13]\",\"$FG\"],[\"(19\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"19[679]\",\"$FG\"],[\"(13)(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",\"13[1-9]\",\"$FG\"]]]',\n    '[\"CC\",\"(?:14(?:1[14]|34|4[17]|[56]6|7[47]|88))?001[14-689]\",\"0\",null,null,null,\"\\\\\\\\d{6,10}\",\"[1458]\\\\\\\\d{5,9}\"]',\n    '[\"CX\",\"(?:14(?:1[14]|34|4[17]|[56]6|7[47]|88))?001[14-689]\",\"0\",null,null,null,\"\\\\\\\\d{6,10}\",\"[1458]\\\\\\\\d{5,9}\"]',\n  ],\n  500: '[\"FK\",\"00\",null,null,null,null,\"\\\\\\\\d{5}\",\"[2-7]\\\\\\\\d{4}\"]',\n  261: '[\"MG\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"[23]\\\\\\\\d{8}\",[[\"([23]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  92: '[\"PK\",\"00\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{6,12}\",\"1\\\\\\\\d{8}|[2-8]\\\\\\\\d{5,11}|9(?:[013-9]\\\\\\\\d{4,9}|2\\\\\\\\d(?:111\\\\\\\\d{6}|\\\\\\\\d{3,7}))\",[[\"(\\\\\\\\d{2})(111)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)1\",null],[\"(\\\\\\\\d{3})(111)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"2[349]|45|54|60|72|8[2-5]|9[2-9]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{7,8})\",\"$1 $2\",\"(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{6,7})\",\"$1 $2\",\"2[349]|45|54|60|72|8[2-5]|9[2-9]\",null],[\"(3\\\\\\\\d{2})(\\\\\\\\d{7})\",\"$1 $2\",\"3\",\"$NP$FG\"],[\"([15]\\\\\\\\d{3})(\\\\\\\\d{5,6})\",\"$1 $2\",\"58[12]|1\",null],[\"(586\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"586\",null],[\"([89]00)(\\\\\\\\d{3})(\\\\\\\\d{2})\",\"$1 $2 $3\",\"[89]00\",\"$NP$FG\"]]]',\n  234: '[\"NG\",\"009\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,14}\",\"[1-6]\\\\\\\\d{5,8}|9\\\\\\\\d{5,9}|[78]\\\\\\\\d{5,13}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[12]|9(?:0[3-9]|[1-9])\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"[3-6]|7(?:[1-79]|0[1-9])|8[2-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"70|8[01]|90[235-9]\",null],[\"([78]00)(\\\\\\\\d{4})(\\\\\\\\d{4,5})\",\"$1 $2 $3\",\"[78]00\",null],[\"([78]00)(\\\\\\\\d{5})(\\\\\\\\d{5,6})\",\"$1 $2 $3\",\"[78]00\",null],[\"(78)(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"78\",null]]]',\n  350: '[\"GI\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2568]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"2\",null]]]',\n  45: '[\"DK\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  963: '[\"SY\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,9}\",\"[1-59]\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[1-5]\",null],[\"(9\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"9\",null]]]',\n  226: '[\"BF\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[25-7]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  974: '[\"QA\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[2-8]\\\\\\\\d{6,7}\",[[\"([28]\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"[28]\",null],[\"([3-7]\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[3-7]\",null]]]',\n  218: '[\"LY\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"[25679]\\\\\\\\d{8}\",[[\"([25679]\\\\\\\\d)(\\\\\\\\d{7})\",\"$1-$2\",null,null]]]',\n  51: '[\"PE\",\"19(?:1[124]|77|90)00\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{6,9}\",\"[14-9]\\\\\\\\d{7,8}\",[[\"(1)(\\\\\\\\d{7})\",\"$1 $2\",\"1\",null],[\"([4-8]\\\\\\\\d)(\\\\\\\\d{6})\",\"$1 $2\",\"[4-7]|8[2-4]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"80\",null],[\"(9\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"9\",\"$FG\"]]]',\n  62: '[\"ID\",\"0(?:0[1789]|10(?:00|1[67]))\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,12}\",\"(?:[1-79]\\\\\\\\d{6,10}|8\\\\\\\\d{7,11})\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{5,8})\",\"$1 $2\",\"2[124]|[36]1\",\"($NP$FG)\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{5,8})\",\"$1 $2\",\"[4579]|2[035-9]|[36][02-9]\",\"($NP$FG)\"],[\"(8\\\\\\\\d{2})(\\\\\\\\d{3,4})(\\\\\\\\d{3})\",\"$1-$2-$3\",\"8[1-35-9]\",null],[\"(8\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4,5})\",\"$1-$2-$3\",\"8[1-35-9]\",null],[\"(1)(500)(\\\\\\\\d{3})\",\"$1 $2 $3\",\"15\",\"$FG\"],[\"(177)(\\\\\\\\d{6,8})\",\"$1 $2\",\"17\",null],[\"(800)(\\\\\\\\d{5,7})\",\"$1 $2\",\"800\",null],[\"(804)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"804\",null],[\"(80\\\\\\\\d)(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"80[79]\",null]]]',\n  298: '[\"FO\",\"00\",null,\"(10(?:01|[12]0|88))\",null,null,\"\\\\\\\\d{6}\",\"[2-9]\\\\\\\\d{5}\",[[\"(\\\\\\\\d{6})\",\"$1\",null,null]]]',\n  381: '[\"RS\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,12}\",\"[126-9]\\\\\\\\d{4,11}|3(?:[0-79]\\\\\\\\d{3,10}|8[2-9]\\\\\\\\d{2,9})\",[[\"([23]\\\\\\\\d{2})(\\\\\\\\d{4,9})\",\"$1 $2\",\"(?:2[389]|39)0\",null],[\"([1-3]\\\\\\\\d)(\\\\\\\\d{5,10})\",\"$1 $2\",\"1|2(?:[0-24-7]|[389][1-9])|3(?:[0-8]|9[1-9])\",null],[\"(6\\\\\\\\d)(\\\\\\\\d{6,8})\",\"$1 $2\",\"6\",null],[\"([89]\\\\\\\\d{2})(\\\\\\\\d{3,9})\",\"$1 $2\",\"[89]\",null],[\"(7[26])(\\\\\\\\d{4,9})\",\"$1 $2\",\"7[26]\",null],[\"(7[08]\\\\\\\\d)(\\\\\\\\d{4,9})\",\"$1 $2\",\"7[08]\",null]]]',\n  975: '[\"BT\",\"00\",null,null,null,null,\"\\\\\\\\d{6,8}\",\"[1-8]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"1|77\",null],[\"([2-8])(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[2-68]|7[246]\",null]]]',\n  34: '[\"ES\",\"00\",null,null,null,null,\"\\\\\\\\d{9}\",\"[5-9]\\\\\\\\d{8}\",[[\"([89]00)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[89]00\",null],[\"([5-9]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[568]|[79][0-8]\",null]]]',\n  881: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{9}\",\"[67]\\\\\\\\d{8}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2 $3\",\"[67]\",null]]]',\n  855: '[\"KH\",\"00[14-9]\",\"0\",null,null,null,\"\\\\\\\\d{6,10}\",\"[1-9]\\\\\\\\d{7,9}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"1\\\\\\\\d[1-9]|[2-9]\",\"$NP$FG\"],[\"(1[89]00)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1[89]0\",null]]]',\n  420: '[\"CZ\",\"00\",null,null,null,null,\"\\\\\\\\d{9,12}\",\"[2-8]\\\\\\\\d{8}|9\\\\\\\\d{8,11}\",[[\"([2-9]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[2-8]|9[015-7]\",null],[\"(96\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"96\",null],[\"(9\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"9[36]\",null]]]',\n  216: '[\"TN\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2-57-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",null,null]]]',\n  673: '[\"BN\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[2-578]\\\\\\\\d{6}\",[[\"([2-578]\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  290: [\n    '[\"SH\",\"00\",null,null,null,null,\"\\\\\\\\d{4,5}\",\"[256]\\\\\\\\d{4}\"]',\n    '[\"TA\",\"00\",null,null,null,null,\"\\\\\\\\d{4}\",\"8\\\\\\\\d{3}\"]',\n  ],\n  882: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{7,12}\",\"[13]\\\\\\\\d{6,11}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"3[23]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"16|342\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"34[57]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"348\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"16\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4,5})(\\\\\\\\d{5})\",\"$1 $2 $3\",\"16|39\",null]]]',\n  267: '[\"BW\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[2-79]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[2-6]\",null],[\"(7\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"7\",null],[\"(90)(\\\\\\\\d{5})\",\"$1 $2\",\"9\",null]]]',\n  94: '[\"LK\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"[1-9]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{1})(\\\\\\\\d{6})\",\"$1 $2 $3\",\"[1-689]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"7\",null]]]',\n  356: '[\"MT\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2357-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  375: '[\"BY\",\"810\",\"8\",\"8?0?\",null,null,\"\\\\\\\\d{5,11}\",\"[1-4]\\\\\\\\d{8}|800\\\\\\\\d{3,7}|[89]\\\\\\\\d{9,10}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2-$3-$4\",\"17[0-3589]|2[4-9]|[34]\",\"$NP 0$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2-$3-$4\",\"1(?:5[24]|6[235]|7[467])|2(?:1[246]|2[25]|3[26])\",\"$NP 0$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2-$3\",\"1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])\",\"$NP 0$FG\"],[\"([89]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"8[01]|9\",\"$NP $FG\"],[\"(82\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"82\",\"$NP $FG\"],[\"(800)(\\\\\\\\d{3})\",\"$1 $2\",\"800\",\"$NP $FG\"],[\"(800)(\\\\\\\\d{2})(\\\\\\\\d{2,4})\",\"$1 $2 $3\",\"800\",\"$NP $FG\"]]]',\n  690: '[\"TK\",\"00\",null,null,null,null,\"\\\\\\\\d{4,7}\",\"[2-47]\\\\\\\\d{3,6}\"]',\n  507: '[\"PA\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[1-9]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2\",\"[1-57-9]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",\"6\",null]]]',\n  692: '[\"MH\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}\",\"[2-6]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2\",null,null]]]',\n  250: '[\"RW\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{8,9}\",\"[027-9]\\\\\\\\d{7,8}\",[[\"(2\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2\",\"$FG\"],[\"([7-9]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[7-9]\",\"$NP$FG\"],[\"(0\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"0\",null]]]',\n  81: '[\"JP\",\"010\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{8,17}\",\"[1-9]\\\\\\\\d{8,9}|00(?:[36]\\\\\\\\d{7,14}|7\\\\\\\\d{5,7}|8\\\\\\\\d{7})\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1-$2-$3\",\"(?:12|57|99)0\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"800\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",\"0077\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{2})(\\\\\\\\d{3,4})\",\"$1-$2-$3\",\"0077\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"0088\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1-$2-$3\",\"00(?:37|66)\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})(\\\\\\\\d{4,5})\",\"$1-$2-$3\",\"00(?:37|66)\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{5})(\\\\\\\\d{5,6})\",\"$1-$2-$3\",\"00(?:37|66)\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{6})(\\\\\\\\d{6,7})\",\"$1-$2-$3\",\"00(?:37|66)\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"[2579]0|80[1-9]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d)(\\\\\\\\d{4})\",\"$1-$2-$3\",\"1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|5(?:76|97)|499|746|8(?:3[89]|63|47|51)|9(?:49|80|9[16])\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"1(?:2[3-6]|3[3-9]|4[2-6]|5[2-8]|[68][2-7]|7[2-689]|9[1-578])|2(?:2[03-689]|3[3-58]|4[0-468]|5[04-8]|6[013-8]|7[06-9]|8[02-57-9]|9[13])|4(?:2[28]|3[689]|6[035-7]|7[05689]|80|9[3-5])|5(?:3[1-36-9]|4[4578]|5[013-8]|6[1-9]|7[2-8]|8[14-7]|9[4-9])|7(?:2[15]|3[5-9]|4[02-9]|6[135-8]|7[0-4689]|9[014-9])|8(?:2[49]|3[3-8]|4[5-8]|5[2-9]|6[35-9]|7[579]|8[03-579]|9[2-8])|9(?:[23]0|4[02-46-9]|5[024-79]|6[4-9]|7[2-47-9]|8[02-7]|9[3-7])\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"1|2(?:2[37]|5[5-9]|64|78|8[39]|91)|4(?:2[2689]|64|7[347])|5(?:[2-589]|39)|60|8(?:[46-9]|3[279]|2[124589])|9(?:[235-8]|93)\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"2(?:9[14-79]|74|[34]7|[56]9)|82|993\",null],[\"(\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"3|4(?:2[09]|7[01])|6[1-9]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"[2479][1-9]\",null]]]',\n  237: '[\"CM\",\"00\",null,null,null,null,\"\\\\\\\\d{8,9}\",\"[2368]\\\\\\\\d{7,8}\",[[\"([26])(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4 $5\",\"[26]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[23]|88\",null],[\"(800)(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"80\",null]]]',\n  351: '[\"PT\",\"00\",null,null,null,null,\"\\\\\\\\d{9}\",\"[2-46-9]\\\\\\\\d{8}\",[[\"(2\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2[12]\",null],[\"([2-46-9]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2[3-9]|[346-9]\",null]]]',\n  246: '[\"IO\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"3\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  227: '[\"NE\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[0289]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[289]|09\",null],[\"(08)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"08\",null]]]',\n  27: '[\"ZA\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,9}\",\"[1-79]\\\\\\\\d{8}|8\\\\\\\\d{4,8}\",[[\"(860)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"860\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3,4})\",\"$1 $2\",\"8[1-4]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"8[1-4]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[1-79]|8(?:[0-57]|6[1-9])\",null]]]',\n  962: '[\"JO\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{8,9}\",\"[235-9]\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[2356]|87\",\"($NP$FG)\"],[\"(7)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"7[457-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{5,6})\",\"$1 $2\",\"70|8[0158]|9\",null]]]',\n  387: '[\"BA\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,9}\",\"[3-9]\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2-$3\",\"[3-5]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"6[1-356]|[7-9]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"6[047]\",null]]]',\n  33: '[\"FR\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[1-9]\\\\\\\\d{8}\",[[\"([1-79])(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4 $5\",\"[1-79]\",null],[\"(1\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2\",\"11\",\"$FG\",\"NA\"],[\"(8\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"8\",\"$NP $FG\"]]]',\n  972: '[\"IL\",\"0(?:0|1[2-9])\",\"0\",null,null,\"$FG\",\"\\\\\\\\d{4,12}\",\"1\\\\\\\\d{6,11}|[2-589]\\\\\\\\d{3}(?:\\\\\\\\d{3,6})?|6\\\\\\\\d{3}|7\\\\\\\\d{6,9}\",[[\"([2-489])(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"[2-489]\",\"$NP$FG\"],[\"([57]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"[57]\",\"$NP$FG\"],[\"(153)(\\\\\\\\d{1,2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3 $4\",\"153\",null],[\"(1)([7-9]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1-$2-$3-$4\",\"1[7-9]\",null],[\"(1255)(\\\\\\\\d{3})\",\"$1-$2\",\"125\",null],[\"(1200)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1-$2-$3\",\"120\",null],[\"(1212)(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2-$3\",\"121\",null],[\"(1599)(\\\\\\\\d{6})\",\"$1-$2\",\"15\",null],[\"(\\\\\\\\d{4})\",\"*$1\",\"[2-689]\",null]]]',\n  248: '[\"SC\",\"0(?:[02]|10?)\",null,null,null,null,\"\\\\\\\\d{6,7}\",\"[24689]\\\\\\\\d{5,6}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[246]\",null]]]',\n  297: '[\"AW\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[25-9]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  421: '[\"SK\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,9}\",\"(?:[2-68]\\\\\\\\d{5,8}|9\\\\\\\\d{6,8})\",[[\"(2)(1[67])(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"21[67]\",null],[\"([3-5]\\\\\\\\d)(1[67])(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"[3-5]\",null],[\"(2)(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{2})\",\"$1/$2 $3 $4\",\"2\",null],[\"([3-5]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1/$2 $3 $4\",\"[3-5]\",null],[\"([689]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[689]\",null],[\"(9090)(\\\\\\\\d{3})\",\"$1 $2\",\"9090\",null]]]',\n  672: '[\"NF\",\"00\",null,null,null,null,\"\\\\\\\\d{5,6}\",\"[13]\\\\\\\\d{5}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"1\",null],[\"(\\\\\\\\d)(\\\\\\\\d{5})\",\"$1 $2\",\"3\",null]]]',\n  870: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{9}\",\"[35-7]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",null,null]]]',\n  883: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{9}(?:\\\\\\\\d{3})?\",\"51\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"510\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"510\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"51[13]\",null]]]',\n  264: '[\"NA\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{8,9}\",\"[68]\\\\\\\\d{7,8}\",[[\"(8\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"8[1235]\",null],[\"(6\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"6\",null],[\"(88)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"88\",null],[\"(870)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"870\",null]]]',\n  878: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{12}\",\"1\\\\\\\\d{11}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{5})(\\\\\\\\d{5})\",\"$1 $2 $3\",null,null]]]',\n  239: '[\"ST\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[29]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  357: '[\"CY\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[257-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{6})\",\"$1 $2\",null,null]]]',\n  240: '[\"GQ\",\"00\",null,null,null,null,\"\\\\\\\\d{9}\",\"[23589]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[235]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"[89]\",null]]]',\n  506: '[\"CR\",\"00\",null,\"(19(?:0[012468]|1[09]|20|66|77|99))\",null,null,\"\\\\\\\\d{8,10}\",\"[24-9]\\\\\\\\d{7,9}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"[24-7]|8[3-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"[89]0\",null]]]',\n  86: '[\"CN\",\"(1(?:[129]\\\\\\\\d{3}|79\\\\\\\\d{2}))?00\",\"0\",\"(1(?:[129]\\\\\\\\d{3}|79\\\\\\\\d{2}))|0\",null,null,\"\\\\\\\\d{4,12}\",\"[1-7]\\\\\\\\d{6,11}|8[0-357-9]\\\\\\\\d{6,9}|9\\\\\\\\d{7,10}\",[[\"(80\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"80[2678]\",\"$NP$FG\"],[\"([48]00)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[48]00\",null],[\"(\\\\\\\\d{5,6})\",\"$1\",\"100|95\",null,\"NA\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{5,6})\",\"$1 $2\",\"(?:10|2\\\\\\\\d)[19]\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{5,6})\",\"$1 $2\",\"[3-9]\",\"$NP$FG\"],[\"(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2\",\"[2-9]\",null,\"NA\"],[\"(21)(\\\\\\\\d{4})(\\\\\\\\d{4,6})\",\"$1 $2 $3\",\"21\",\"$NP$FG\"],[\"([12]\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"10[1-9]|2[02-9]\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"3(?:1[02-9]|35|49|5|7[02-68]|9[1-68])|4(?:1[02-9]|2[179]|[35][2-9]|6[4789]|7\\\\\\\\d|8[23])|5(?:3[03-9]|4[36]|5[02-9]|6[1-46]|7[028]|80|9[2-46-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[04-9]|4[3-6]|6[2368])|8(?:1[236-8]|2[5-7]|3|5[1-9]|7[02-9]|8[3678]|9[1-7])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"3(?:11|7[179])|4(?:[15]1|3[1-35])|5(?:1|2[37]|3[12]|51|7[13-79]|9[15])|7(?:31|5[457]|6[09]|91)|8(?:[57]1|98)\",\"$NP$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"807\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1[3-578]\",null],[\"(10800)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"108\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{7,8})\",\"$1 $2\",\"950\",null]]]',\n  257: '[\"BI\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[267]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  683: '[\"NU\",\"00\",null,null,null,null,\"\\\\\\\\d{4}\",\"[1-5]\\\\\\\\d{3}\"]',\n  43: '[\"AT\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{3,13}\",\"[1-9]\\\\\\\\d{3,12}\",[[\"(116\\\\\\\\d{3})\",\"$1\",\"116\",\"$FG\"],[\"(1)(\\\\\\\\d{3,12})\",\"$1 $2\",\"1\",null],[\"(5\\\\\\\\d)(\\\\\\\\d{3,5})\",\"$1 $2\",\"5[079]\",null],[\"(5\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"5[079]\",null],[\"(5\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4,7})\",\"$1 $2 $3\",\"5[079]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3,10})\",\"$1 $2\",\"316|46|51|732|6(?:5[0-3579]|[6-9])|7(?:[28]0)|[89]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{3,9})\",\"$1 $2\",\"2|3(?:1[1-578]|[3-8])|4[2378]|5[2-6]|6(?:[12]|4[1-9]|5[468])|7(?:2[1-8]|35|4[1-8]|[5-79])\",null]]]',\n  247: '[\"AC\",\"00\",null,null,null,null,\"\\\\\\\\d{5,6}\",\"[46]\\\\\\\\d{4}|[01589]\\\\\\\\d{5}\"]',\n  675: '[\"PG\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[1-9]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[13-689]|27\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"20|7\",null]]]',\n  376: '[\"AD\",\"00\",null,null,null,null,\"\\\\\\\\d{6,9}\",\"[16]\\\\\\\\d{5,8}|[37-9]\\\\\\\\d{5}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2\",\"[137-9]|6[0-8]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"180\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"690\",null]]]',\n  63: '[\"PH\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{5,13}\",\"2\\\\\\\\d{5,7}|[3-9]\\\\\\\\d{7,9}|1800\\\\\\\\d{7,9}\",[[\"(2)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2\",\"($NP$FG)\"],[\"(2)(\\\\\\\\d{5})\",\"$1 $2\",\"2\",\"($NP$FG)\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{4,6})\",\"$1 $2\",\"3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|5(?:22|44)|642|8(?:62|8[245])\",\"($NP$FG)\"],[\"(\\\\\\\\d{5})(\\\\\\\\d{4})\",\"$1 $2\",\"346|4(?:27|9[35])|883\",\"($NP$FG)\"],[\"([3-8]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[3-8]\",\"($NP$FG)\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"81|9\",\"$NP$FG\"],[\"(1800)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",null],[\"(1800)(\\\\\\\\d{1,2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3 $4\",\"1\",null]]]',\n  236: '[\"CF\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[278]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  590: [\n    '[\"GP\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[56]\\\\\\\\d{8}\",[[\"([56]90)(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2-$3\",null,null]]]',\n    '[\"BL\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{9}\",\"[56]\\\\\\\\d{8}\"]',\n    '[\"MF\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{9}\",\"[56]\\\\\\\\d{8}\"]',\n  ],\n  53: '[\"CU\",\"119\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{4,8}\",\"[2-57]\\\\\\\\d{5,7}\",[[\"(\\\\\\\\d)(\\\\\\\\d{6,7})\",\"$1 $2\",\"7\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4,6})\",\"$1 $2\",\"[2-4]\",null],[\"(\\\\\\\\d)(\\\\\\\\d{7})\",\"$1 $2\",\"5\",\"$NP$FG\"]]]',\n  64: '[\"NZ\",\"0(?:0|161)\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,11}\",\"6[235-9]\\\\\\\\d{6}|[2-57-9]\\\\\\\\d{7,10}\",[[\"([34679])(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2 $3\",\"[346]|7[2-57-9]|9[1-9]\",null],[\"(24099)(\\\\\\\\d{3})\",\"$1 $2\",\"240\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"21\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,5})\",\"$1 $2 $3\",\"2(?:1[1-9]|[69]|7[0-35-9])|70|86\",null],[\"(2\\\\\\\\d)(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2[028]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"2(?:10|74)|5|[89]0\",null]]]',\n  965: '[\"KW\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[12569]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{3,4})\",\"$1 $2\",\"[16]|2(?:[0-35-9]|4[0-35-9])|9[024-9]|52[25]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"244|5(?:[015]|66)\",null]]]',\n  224: '[\"GN\",\"00\",null,null,null,null,\"\\\\\\\\d{8,9}\",\"[367]\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"3\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[67]\",null]]]',\n  973: '[\"BH\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[136-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  32: '[\"BE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{8,9}\",\"[1-9]\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"4[6-9]\",null],[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[23]|4[23]|9[2-4]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[156]|7[018]|8(?:0[1-9]|[1-79])\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"(?:80|9)0\",null]]]',\n  249: '[\"SD\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[19]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",null,null]]]',\n  678: '[\"VU\",\"00\",null,null,null,null,\"\\\\\\\\d{5,7}\",\"[2-57-9]\\\\\\\\d{4,6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[579]\",null]]]',\n  52: '[\"MX\",\"0[09]\",\"01\",\"0[12]|04[45](\\\\\\\\d{10})\",\"1$1\",\"$NP $FG\",\"\\\\\\\\d{7,11}\",\"[1-9]\\\\\\\\d{9,10}\",[[\"([358]\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"33|55|81\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[2467]|3[0-2457-9]|5[089]|8[02-9]|9[0-35-9]\",null],[\"(1)([358]\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"044 $2 $3 $4\",\"1(?:33|55|81)\",\"$FG\",\"$1 $2 $3 $4\"],[\"(1)(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"044 $2 $3 $4\",\"1(?:[2467]|3[0-2457-9]|5[089]|8[2-9]|9[1-35-9])\",\"$FG\",\"$1 $2 $3 $4\"]]]',\n  968: '[\"OM\",\"00\",null,null,null,null,\"\\\\\\\\d{7,9}\",\"(?:5|[279]\\\\\\\\d)\\\\\\\\d{6}|800\\\\\\\\d{5,6}\",[[\"(2\\\\\\\\d)(\\\\\\\\d{6})\",\"$1 $2\",\"2\",null],[\"([79]\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[79]\",null],[\"([58]00)(\\\\\\\\d{4,6})\",\"$1 $2\",\"[58]\",null]]]',\n  599: [\n    '[\"CW\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[169]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[13-7]\",null],[\"(9)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"9\",null]]]',\n    '[\"BQ\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[347]\\\\\\\\d{6}\"]',\n  ],\n  800: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{8}\",\"\\\\\\\\d{8}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  386: '[\"SI\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,8}\",\"[1-7]\\\\\\\\d{6,7}|[89]\\\\\\\\d{4,7}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[12]|3[24-8]|4[24-8]|5[2-8]|7[3-8]\",\"($NP$FG)\"],[\"([3-7]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[37][01]|4[0139]|51|6\",null],[\"([89][09])(\\\\\\\\d{3,6})\",\"$1 $2\",\"[89][09]\",null],[\"([58]\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"59|8[1-3]\",null]]]',\n  679: '[\"FJ\",\"0(?:0|52)\",null,null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{4})?\",\"[35-9]\\\\\\\\d{6}|0\\\\\\\\d{10}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[35-9]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"0\",null]]]',\n  238: '[\"CV\",\"0\",null,null,null,null,\"\\\\\\\\d{7}\",\"[259]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",null,null]]]',\n  691: '[\"FM\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[39]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  262: [\n    '[\"RE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[268]\\\\\\\\d{8}\",[[\"([268]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n    '[\"YT\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[268]\\\\\\\\d{8}\"]',\n  ],\n  241: '[\"GA\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"0?\\\\\\\\d{7}\",[[\"(\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[2-7]\",\"0$FG\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"0\",null]]]',\n  370: '[\"LT\",\"00\",\"8\",\"[08]\",null,\"($NP-$FG)\",\"\\\\\\\\d{8}\",\"[3-9]\\\\\\\\d{7}\",[[\"([34]\\\\\\\\d)(\\\\\\\\d{6})\",\"$1 $2\",\"37|4(?:1|5[45]|6[2-4])\",null],[\"([3-6]\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"3[148]|4(?:[24]|6[09])|528|6\",null],[\"([7-9]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[7-9]\",\"$NP $FG\"],[\"(5)(2\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"52[0-79]\",null]]]',\n  256: '[\"UG\",\"00[057]\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,9}\",\"\\\\\\\\d{9}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"[7-9]|20(?:[013-8]|2[5-9])|4(?:6[45]|[7-9])\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{7})\",\"$1 $2\",\"3|4(?:[1-5]|6[0-36-9])\",null],[\"(2024)(\\\\\\\\d{5})\",\"$1 $2\",\"2024\",null]]]',\n  677: '[\"SB\",\"0[01]\",null,null,null,null,\"\\\\\\\\d{5,7}\",\"[1-9]\\\\\\\\d{4,6}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"[7-9]\",null]]]',\n  377: '[\"MC\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{8,9}\",\"[34689]\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[39]\",\"$FG\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"4\",null],[\"(6)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4 $5\",\"6\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{2})\",\"$1 $2 $3\",\"8\",\"$FG\"]]]',\n  382: '[\"ME\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,9}\",\"[2-9]\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[2-57-9]|6[036-9]\",null]]]',\n  231: '[\"LR\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"2\\\\\\\\d{7,8}|[378]\\\\\\\\d{8}|4\\\\\\\\d{6}|5\\\\\\\\d{6,8}\",[[\"(2\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2\",null],[\"([4-5])(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[45]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[23578]\",null]]]',\n  591: '[\"BO\",\"00(1\\\\\\\\d)?\",\"0\",\"0(1\\\\\\\\d)?\",null,null,\"\\\\\\\\d{7,8}\",\"[23467]\\\\\\\\d{7}\",[[\"([234])(\\\\\\\\d{7})\",\"$1 $2\",\"[234]\",null],[\"([67]\\\\\\\\d{7})\",\"$1\",\"[67]\",null]]]',\n  808: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{8}\",\"\\\\\\\\d{8}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  964: '[\"IQ\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[1-7]\\\\\\\\d{7,9}\",[[\"(1)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",null],[\"([2-6]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[2-6]\",null],[\"(7\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"7\",null]]]',\n  225: '[\"CI\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[02-8]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  992: '[\"TJ\",\"810\",\"8\",null,null,\"$FG\",\"\\\\\\\\d{3,9}\",\"[3-57-9]\\\\\\\\d{8}\",[[\"([349]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[34]7|91[78]\",null],[\"([457-9]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"4[148]|[578]|9(?:1[59]|[0235-9])\",null],[\"(331700)(\\\\\\\\d)(\\\\\\\\d{2})\",\"$1 $2 $3\",\"331\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d)(\\\\\\\\d{4})\",\"$1 $2 $3\",\"3[1-5]\",null]]]',\n  55: '[\"BR\",\"00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)\",\"0\",\"(?:0|90)(?:(1[245]|2[135]|[34]1)(\\\\\\\\d{10,11}))?\",\"$2\",null,\"\\\\\\\\d{8,11}\",\"[1-46-9]\\\\\\\\d{7,10}|5(?:[0-4]\\\\\\\\d{7,9}|5(?:[2-8]\\\\\\\\d{7}|9\\\\\\\\d{7,8}))\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",\"[2-9](?:[1-9]|0[1-9])\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{5})(\\\\\\\\d{4})\",\"$1-$2\",\"9(?:[1-9]|0[1-9])\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{3,5})\",\"$1\",\"1[125689]\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2-$3\",\"[1-9][1-9]\",\"($FG)\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{5})(\\\\\\\\d{4})\",\"$1 $2-$3\",\"(?:[14689][1-9]|2[12478]|3[1-578]|5[1-5]|7[13-579])9\",\"($FG)\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",\"(?:300|40(?:0|20))\",null],[\"([3589]00)(\\\\\\\\d{2,3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[3589]00\",\"$NP$FG\"]]]',\n  674: '[\"NR\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[458]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  967: '[\"YE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,9}\",\"[1-7]\\\\\\\\d{6,8}\",[[\"([1-7])(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[1-6]|7[24-68]\",null],[\"(7\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"7[0137]\",null]]]',\n  49: '[\"DE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{2,15}\",\"[1-35-9]\\\\\\\\d{3,14}|4(?:[0-8]\\\\\\\\d{3,12}|9(?:[0-37]\\\\\\\\d|4(?:[1-35-8]|4\\\\\\\\d?)|5\\\\\\\\d{1,2}|6[1-8]\\\\\\\\d?)\\\\\\\\d{2,8})\",[[\"(1\\\\\\\\d{2})(\\\\\\\\d{7,8})\",\"$1 $2\",\"1[67]\",null],[\"(15\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"15[0568]\",null],[\"(1\\\\\\\\d{3})(\\\\\\\\d{7})\",\"$1 $2\",\"15\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3,11})\",\"$1 $2\",\"3[02]|40|[68]9\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3,11})\",\"$1 $2\",\"2(?:\\\\\\\\d1|0[2389]|1[24]|28|34)|3(?:[3-9][15]|40)|[4-8][1-9]1|9(?:06|[1-9]1)\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{2,11})\",\"$1 $2\",\"[24-6]|[7-9](?:\\\\\\\\d[1-9]|[1-9]\\\\\\\\d)|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])\",null],[\"(3\\\\\\\\d{4})(\\\\\\\\d{1,10})\",\"$1 $2\",\"3\",null],[\"(800)(\\\\\\\\d{7,12})\",\"$1 $2\",\"800\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d)(\\\\\\\\d{4,10})\",\"$1 $2 $3\",\"(?:18|90)0|137\",null],[\"(1\\\\\\\\d{2})(\\\\\\\\d{5,11})\",\"$1 $2\",\"181\",null],[\"(18\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"185\",null],[\"(18\\\\\\\\d{2})(\\\\\\\\d{7})\",\"$1 $2\",\"18[68]\",null],[\"(18\\\\\\\\d)(\\\\\\\\d{8})\",\"$1 $2\",\"18[2-579]\",null],[\"(700)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"700\",null],[\"(138)(\\\\\\\\d{4})\",\"$1 $2\",\"138\",null],[\"(15[013-68])(\\\\\\\\d{2})(\\\\\\\\d{8})\",\"$1 $2 $3\",\"15[013-68]\",null],[\"(15[279]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{7})\",\"$1 $2 $3\",\"15[279]\",null],[\"(1[67]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{7,8})\",\"$1 $2 $3\",\"1(?:6[023]|7)\",null]]]',\n  31: '[\"NL\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,10}\",\"1\\\\\\\\d{4,8}|[2-7]\\\\\\\\d{8}|[89]\\\\\\\\d{6,9}\",[[\"([1-578]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1[035]|2[0346]|3[03568]|4[0356]|5[0358]|7|8[4578]\",null],[\"([1-5]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1[16-8]|2[259]|3[124]|4[17-9]|5[124679]\",null],[\"(6)(\\\\\\\\d{8})\",\"$1 $2\",\"6[0-57-9]\",null],[\"(66)(\\\\\\\\d{7})\",\"$1 $2\",\"66\",null],[\"(14)(\\\\\\\\d{3,4})\",\"$1 $2\",\"14\",\"$FG\"],[\"([89]0\\\\\\\\d)(\\\\\\\\d{4,7})\",\"$1 $2\",\"80|9\",null]]]',\n  970: '[\"PS\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{4,10}\",\"[24589]\\\\\\\\d{7,8}|1(?:[78]\\\\\\\\d{8}|[49]\\\\\\\\d{2,3})\",[[\"([2489])(2\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[2489]\",null],[\"(5[69]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"5\",null],[\"(1[78]00)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1[78]\",\"$FG\"]]]',\n  58: '[\"VE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,10}\",\"[24589]\\\\\\\\d{9}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{7})\",\"$1-$2\",null,null]]]',\n  856: '[\"LA\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[2-8]\\\\\\\\d{7,9}\",[[\"(20)(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"20\",null],[\"([2-8]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2[13]|3[14]|[4-8]\",null],[\"(30)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"30\",null]]]',\n  354: '[\"IS\",\"1(?:0(?:01|10|20)|100)|00\",null,null,null,null,\"\\\\\\\\d{7,9}\",\"[4-9]\\\\\\\\d{6}|38\\\\\\\\d{7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[4-9]\",null],[\"(3\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"3\",null]]]',\n  242: '[\"CG\",\"00\",null,null,null,null,\"\\\\\\\\d{9}\",\"[028]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[02]\",null],[\"(\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"8\",null]]]',\n  423: '[\"LI\",\"00\",\"0\",\"0|10(?:01|20|66)\",null,null,\"\\\\\\\\d{7,9}\",\"6\\\\\\\\d{8}|[23789]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",\"[23789]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"6[56]\",null],[\"(69)(7\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"697\",null]]]',\n  213: '[\"DZ\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{8,9}\",\"(?:[1-4]|[5-9]\\\\\\\\d)\\\\\\\\d{7}\",[[\"([1-4]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[1-4]\",null],[\"([5-8]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[5-8]\",null],[\"(9\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"9\",null]]]',\n  371: '[\"LV\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2689]\\\\\\\\d{7}\",[[\"([2689]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",null,null]]]',\n  503: '[\"SV\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}|\\\\\\\\d{11}\",\"[267]\\\\\\\\d{7}|[89]\\\\\\\\d{6}(?:\\\\\\\\d{4})?\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"[267]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[89]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[89]\",null]]]',\n  685: '[\"WS\",\"0\",null,null,null,null,\"\\\\\\\\d{5,7}\",\"[2-8]\\\\\\\\d{4,6}\",[[\"(8\\\\\\\\d{2})(\\\\\\\\d{3,4})\",\"$1 $2\",\"8\",null],[\"(7\\\\\\\\d)(\\\\\\\\d{5})\",\"$1 $2\",\"7\",null],[\"(\\\\\\\\d{5})\",\"$1\",\"[2-6]\",null]]]',\n  880: '[\"BD\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[2-79]\\\\\\\\d{5,9}|1\\\\\\\\d{9}|8[0-7]\\\\\\\\d{4,8}\",[[\"(2)(\\\\\\\\d{7,8})\",\"$1-$2\",\"2\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4,6})\",\"$1-$2\",\"[3-79]1\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{3,6})\",\"$1-$2\",\"1|3(?:0|[2-58]2)|4(?:0|[25]2|3[23]|[4689][25])|5(?:[02-578]2|6[25])|6(?:[0347-9]2|[26][25])|7[02-9]2|8(?:[023][23]|[4-7]2)|9(?:[02][23]|[458]2|6[016])\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3,7})\",\"$1-$2\",\"[3-79][2-9]|8\",null]]]',\n  265: '[\"MW\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"(?:1(?:\\\\\\\\d{2})?|[2789]\\\\\\\\d{2})\\\\\\\\d{6}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1\",null],[\"(2\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[1789]\",null]]]',\n  65: '[\"SG\",\"0[0-3]\\\\\\\\d\",null,null,null,null,\"\\\\\\\\d{8,11}\",\"[36]\\\\\\\\d{7}|[17-9]\\\\\\\\d{7,10}\",[[\"([3689]\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[369]|8[1-9]\",null],[\"(1[89]00)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1[89]\",null],[\"(7000)(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"70\",null],[\"(800)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"80\",null]]]',\n  504: '[\"HN\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[237-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",null,null]]]',\n  688: '[\"TV\",\"00\",null,null,null,null,\"\\\\\\\\d{5,7}\",\"[279]\\\\\\\\d{4,6}\"]',\n  84: '[\"VN\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,10}\",\"[167]\\\\\\\\d{6,9}|[2-59]\\\\\\\\d{7,9}|8\\\\\\\\d{6,8}\",[[\"([17]99)(\\\\\\\\d{4})\",\"$1 $2\",\"[17]99\",null],[\"([48])(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"4|8(?:[1-57]|6[0-79]|9[0-7])\",null],[\"([235-7]\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2[025-79]|3[0136-9]|5[2-9]|6[0-46-8]|7[02-79]\",null],[\"(80)(\\\\\\\\d{5})\",\"$1 $2\",\"80\",null],[\"(69\\\\\\\\d)(\\\\\\\\d{4,5})\",\"$1 $2\",\"69\",null],[\"([235-7]\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2[0-489]|3[25]|5[01]|65|7[18]\",null],[\"([89]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"8(?:68|8|9[89])|9\",null],[\"(1[2689]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1(?:[26]|8[68]|99)\",null],[\"(1[89]00)(\\\\\\\\d{4,6})\",\"$1 $2\",\"1[89]0\",\"$FG\"]]]',\n  255: '[\"TZ\",\"00[056]\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"\\\\\\\\d{9}\",[[\"([24]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[24]\",null],[\"([67]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[67]\",null],[\"([89]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[89]\",null]]]',\n  222: '[\"MR\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2-48]\\\\\\\\d{7}\",[[\"([2-48]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  230: '[\"MU\",\"0(?:0|[2-7]0|33)\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[2-9]\\\\\\\\d{6,7}\",[[\"([2-46-9]\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"[2-46-9]\",null],[\"(5\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"5\",null]]]',\n  592: '[\"GY\",\"001\",null,null,null,null,\"\\\\\\\\d{7}\",\"[2-46-9]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  41: '[\"CH\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}(?:\\\\\\\\d{3})?\",\"[2-9]\\\\\\\\d{8}|860\\\\\\\\d{9}\",[[\"([2-9]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[2-7]|[89]1\",null],[\"([89]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"8[047]|90\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4 $5\",\"860\",null]]]',\n  39: [\n    '[\"IT\",\"00\",null,null,null,null,\"\\\\\\\\d{6,11}\",\"[01589]\\\\\\\\d{5,10}|3(?:[12457-9]\\\\\\\\d{8}|[36]\\\\\\\\d{7,9})\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"0[26]|55\",null],[\"(0[26])(\\\\\\\\d{4})(\\\\\\\\d{5})\",\"$1 $2 $3\",\"0[26]\",null],[\"(0[26])(\\\\\\\\d{4,6})\",\"$1 $2\",\"0[26]\",null],[\"(0\\\\\\\\d{2})(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"0[13-57-9][0159]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3,6})\",\"$1 $2\",\"0[13-57-9][0159]|8(?:03|4[17]|9[245])\",null],[\"(0\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"0[13-57-9][2-46-8]\",null],[\"(0\\\\\\\\d{3})(\\\\\\\\d{2,6})\",\"$1 $2\",\"0[13-57-9][2-46-8]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[13]|8(?:00|4[08]|9[59])\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"894\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"3\",null]]]',\n    '[\"VA\",\"00\",null,null,null,null,\"\\\\\\\\d{6,11}\",\"(?:0(?:878\\\\\\\\d{5}|6698\\\\\\\\d{5})|[1589]\\\\\\\\d{5,10}|3(?:[12457-9]\\\\\\\\d{8}|[36]\\\\\\\\d{7,9}))\"]',\n  ],\n  993: '[\"TM\",\"810\",\"8\",null,null,\"($NP $FG)\",\"\\\\\\\\d{8}\",\"[1-6]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2-$3-$4\",\"12\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{6})\",\"$1 $2\",\"6\",\"$NP $FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2-$3-$4\",\"13|[2-5]\",null]]]',\n  888: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{11}\",\"\\\\\\\\d{11}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2 $3\",null,null]]]',\n  353: '[\"IE\",\"00\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{5,10}\",\"[124-9]\\\\\\\\d{6,9}\",[[\"(1)(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"2[24-9]|47|58|6[237-9]|9[35-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"40[24]|50[45]\",null],[\"(48)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"48\",null],[\"(818)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"81\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[24-69]|7[14]\",null],[\"([78]\\\\\\\\d)(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"76|8[35-9]\",\"$NP$FG\"],[\"(700)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"70\",\"$NP$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1(?:8[059]|5)\",\"$FG\"]]]',\n  966: '[\"SA\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,10}\",\"1\\\\\\\\d{7,8}|(?:[2-467]|92)\\\\\\\\d{7}|5\\\\\\\\d{8}|8\\\\\\\\d{9}\",[[\"([1-467])(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[1-467]\",null],[\"(1\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1[1-467]\",null],[\"(5\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"5\",null],[\"(92\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"92\",\"$FG\"],[\"(800)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"80\",\"$FG\"],[\"(811)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"81\",null]]]',\n  380: '[\"UA\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,9}\",\"[3-9]\\\\\\\\d{8}\",[[\"([3-9]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[38]9|4(?:[45][0-5]|87)|5(?:0|6[37]|7[37])|6[36-8]|7|9[1-9]\",null],[\"([3-689]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"3[1-8]2|4[13678]2|5(?:[12457]2|6[24])|6(?:[49]2|[12][29]|5[24])|8[0-8]|90\",null],[\"([3-6]\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"3(?:5[013-9]|[1-46-8])|4(?:[137][013-9]|6|[45][6-9]|8[4-6])|5(?:[1245][013-9]|6[0135-9]|3|7[4-6])|6(?:[49][013-9]|5[0135-9]|[12][13-8])\",null]]]',\n  98: '[\"IR\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{4,10}\",\"[1-8]\\\\\\\\d{9}|9(?:[0-4]\\\\\\\\d{8}|9\\\\\\\\d{2,8})\",[[\"(21)(\\\\\\\\d{3,5})\",\"$1 $2\",\"21\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[1-8]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2\",\"9\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"9\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"9\",null]]]',\n  971: '[\"AE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,12}\",\"[2-79]\\\\\\\\d{7,8}|800\\\\\\\\d{2,9}\",[[\"([2-4679])(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[2-4679][2-8]\",null],[\"(5\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"5\",null],[\"([479]00)(\\\\\\\\d)(\\\\\\\\d{5})\",\"$1 $2 $3\",\"[479]0\",\"$FG\"],[\"([68]00)(\\\\\\\\d{2,9})\",\"$1 $2\",\"60|8\",\"$FG\"]]]',\n  30: '[\"GR\",\"00\",null,null,null,null,\"\\\\\\\\d{10}\",\"[26-9]\\\\\\\\d{9}\",[[\"([27]\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"21|7\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2[2-9]1|[689]\",null],[\"(2\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"2[2-9][02-9]\",null]]]',\n  228: '[\"TG\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[29]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[29]\",null]]]',\n  48: '[\"PL\",\"00\",null,null,null,null,\"\\\\\\\\d{6,9}\",\"[12]\\\\\\\\d{6,8}|[3-57-9]\\\\\\\\d{8}|6\\\\\\\\d{5,8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[14]|2[0-57-9]|3[2-4]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{1})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[12]2\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"26|39|5[0137]|6[0469]|7[02389]|8[08]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"64\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2\",\"64\",null]]]',\n  886: '[\"TW\",\"0(?:0[25679]|19)\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,10}\",\"2\\\\\\\\d{6,8}|[3-689]\\\\\\\\d{7,8}|7\\\\\\\\d{7,9}\",[[\"(20)(\\\\\\\\d)(\\\\\\\\d{4})\",\"$1 $2 $3\",\"202\",null],[\"(20)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"20[013-9]\",null],[\"([2-8])(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2[23-8]|[3-6]|[78][1-9]\",null],[\"([89]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"80|9\",null],[\"(70)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"70\",null]]]',\n  212: [\n    '[\"MA\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[5-9]\\\\\\\\d{8}\",[[\"([5-7]\\\\\\\\d{2})(\\\\\\\\d{6})\",\"$1-$2\",\"5(?:2[015-7]|3[0-4])|[67]\",null],[\"([58]\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1-$2\",\"5(?:2[2-489]|3[5-9]|92)|892\",null],[\"(5\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",\"5(?:29|38)\",null],[\"([5]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"5(?:4[067]|5[03])\",null],[\"(8[09])(\\\\\\\\d{7})\",\"$1-$2\",\"8(?:0|9[013-9])\",null]]]',\n    '[\"EH\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[5-9]\\\\\\\\d{8}\"]',\n  ],\n  372: '[\"EE\",\"00\",null,null,null,null,\"\\\\\\\\d{4,10}\",\"1\\\\\\\\d{3,4}|[3-9]\\\\\\\\d{6,7}|800\\\\\\\\d{6,7}\",[[\"([3-79]\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]\",null],[\"(70)(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"70\",null],[\"(8000)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"800\",null],[\"([458]\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2\",\"40|5|8(?:00|[1-5])\",null]]]',\n  598: '[\"UY\",\"0(?:1[3-9]\\\\\\\\d|0)\",\"0\",null,null,null,\"\\\\\\\\d{7,8}\",\"[2489]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"[24]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"9[1-9]\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[89]0\",\"$NP$FG\"]]]',\n  502: '[\"GT\",\"00\",null,null,null,null,\"\\\\\\\\d{8}(?:\\\\\\\\d{3})?\",\"[2-7]\\\\\\\\d{7}|1[89]\\\\\\\\d{9}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"[2-7]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",null]]]',\n  82: '[\"KR\",\"00(?:[124-68]|3\\\\\\\\d{2}|7(?:[0-8]\\\\\\\\d|9[0-79]))\",\"0\",\"0(8[1-46-8]|85\\\\\\\\d{2})?\",null,\"$NP$FG\",\"\\\\\\\\d{3,14}\",\"007\\\\\\\\d{9,11}|[1-7]\\\\\\\\d{3,9}|8\\\\\\\\d{8}\",[[\"(\\\\\\\\d{5})(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"00798\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{5})(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3 $4\",\"00798\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"1(?:0|1[19]|[69]9|5[458])|[57]0\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"1(?:[01]|5[1-4]|6[2-8]|[7-9])|[68]0|[3-6][1-9][1-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d)(\\\\\\\\d{4})\",\"$1-$2-$3\",\"131\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"131\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"13[2-9]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3-$4\",\"30\",null],[\"(\\\\\\\\d)(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"2[1-9]\",null],[\"(\\\\\\\\d)(\\\\\\\\d{3,4})\",\"$1-$2\",\"21[0-46-9]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3,4})\",\"$1-$2\",\"[3-6][1-9]1\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",\"1(?:5[246-9]|6[04678]|8[03579])\",\"$FG\"]]]',\n  253: '[\"DJ\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[27]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  91: '[\"IN\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,13}\",\"008\\\\\\\\d{9}|1\\\\\\\\d{7,12}|[2-9]\\\\\\\\d{9,10}\",[[\"(\\\\\\\\d{5})(\\\\\\\\d{5})\",\"$1 $2\",\"600|7(?:[02-8]|19|9[037-9])|8(?:0[015-9]|[1-9]|20)|9\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"11|2[02]|33|4[04]|79[1-9]|80[2-46]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1(?:2[0-249]|3[0-25]|4[145]|[59][14]|7[1257]|[68][1-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|[36][25]|22|4[28]|5[12]|[78]1|9[15])|6(?:12|[2-4]1|5[17]|6[13]|7[14]|80)|7(?:12|2[14]|3[134]|4[47]|5[15]|[67]1|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1(?:[23579]|[468][1-9])|[2-8]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"008\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"140\",\"$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"160\",\"$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{4,5})\",\"$1 $2\",\"180\",\"$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{2,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"180\",\"$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"186\",\"$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"18[06]\",\"$FG\"]]]',\n  389: '[\"MK\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,8}\",\"[2-578]\\\\\\\\d{7}\",[[\"(2)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2\",null],[\"([347]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[347]\",null],[\"([58]\\\\\\\\d{2})(\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[58]\",null]]]',\n  1: [\n    '[\"US\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[2-9]\\\\\\\\d{9}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2\",null,null,\"NA\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"($1) $2-$3\",null,null,\"$1-$2-$3\"]]]',\n    '[\"AI\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[2589]\\\\\\\\d{9}\"]',\n    '[\"AS\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5689]\\\\\\\\d{9}\"]',\n    '[\"BB\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[2589]\\\\\\\\d{9}\"]',\n    '[\"BM\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[4589]\\\\\\\\d{9}\"]',\n    '[\"BS\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[2589]\\\\\\\\d{9}\"]',\n    '[\"CA\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[2-9]\\\\\\\\d{9}|3\\\\\\\\d{6}\"]',\n    '[\"DM\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[57-9]\\\\\\\\d{9}\"]',\n    '[\"DO\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[589]\\\\\\\\d{9}\"]',\n    '[\"GD\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[4589]\\\\\\\\d{9}\"]',\n    '[\"GU\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5689]\\\\\\\\d{9}\"]',\n    '[\"JM\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[589]\\\\\\\\d{9}\"]',\n    '[\"KN\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[589]\\\\\\\\d{9}\"]',\n    '[\"KY\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[3589]\\\\\\\\d{9}\"]',\n    '[\"LC\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5789]\\\\\\\\d{9}\"]',\n    '[\"MP\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5689]\\\\\\\\d{9}\"]',\n    '[\"MS\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5689]\\\\\\\\d{9}\"]',\n    '[\"PR\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5789]\\\\\\\\d{9}\"]',\n    '[\"SX\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5789]\\\\\\\\d{9}\"]',\n    '[\"TC\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5689]\\\\\\\\d{9}\"]',\n    '[\"TT\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[589]\\\\\\\\d{9}\"]',\n    '[\"AG\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[2589]\\\\\\\\d{9}\"]',\n    '[\"VC\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5789]\\\\\\\\d{9}\"]',\n    '[\"VG\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[2589]\\\\\\\\d{9}\"]',\n    '[\"VI\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[3589]\\\\\\\\d{9}\"]',\n  ],\n  60: '[\"MY\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{6,10}\",\"[13-9]\\\\\\\\d{7,9}\",[[\"([4-79])(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2 $3\",\"[4-79]\",\"$NP$FG\"],[\"(3)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2 $3\",\"3\",\"$NP$FG\"],[\"([18]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1-$2 $3\",\"1[02-46-9][1-9]|8\",\"$NP$FG\"],[\"(1)([36-8]00)(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1-$2-$3-$4\",\"1[36-8]0\",null],[\"(11)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2 $3\",\"11\",\"$NP$FG\"],[\"(15[49])(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2 $3\",\"15\",\"$NP$FG\"]]]',\n  355: '[\"AL\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,9}\",\"[2-57]\\\\\\\\d{7}|6\\\\\\\\d{8}|8\\\\\\\\d{5,7}|9\\\\\\\\d{5}\",[[\"(4)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"4[0-6]\",null],[\"(6\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"6\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[2358][2-5]|4[7-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3,5})\",\"$1 $2\",\"[235][16-9]|8[016-9]|[79]\",null]]]',\n  254: '[\"KE\",\"000\",\"0\",\"005|0\",null,\"$NP$FG\",\"\\\\\\\\d{7,10}\",\"20\\\\\\\\d{6,7}|[4-9]\\\\\\\\d{6,9}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{5,7})\",\"$1 $2\",\"[24-6]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"7\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[89]\",null]]]',\n  223: '[\"ML\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[246-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[246-9]\",null],[\"(\\\\\\\\d{4})\",\"$1\",\"67|74\",null,\"NA\"]]]',\n  686: '[\"KI\",\"00\",null,\"0\",null,null,\"\\\\\\\\d{5,8}\",\"[2458]\\\\\\\\d{4}|3\\\\\\\\d{4,7}|7\\\\\\\\d{7}\"]',\n  994: '[\"AZ\",\"00\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{7,9}\",\"[1-9]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"(?:1[28]|2(?:[45]2|[0-36])|365)\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[4-8]\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"9\",\"$NP$FG\"]]]',\n  979: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{9}\",\"\\\\\\\\d{9}\",[[\"(\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",null,null]]]',\n  66: '[\"TH\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{4}|\\\\\\\\d{8,10}\",\"[2-9]\\\\\\\\d{7,8}|1\\\\\\\\d{3}(?:\\\\\\\\d{5,6})?\",[[\"(2)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2\",null],[\"([13-9]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"14|[3-9]\",null],[\"(1[89]00)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1\",\"$FG\"]]]',\n  233: '[\"GH\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"[235]\\\\\\\\d{8}|8\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[235]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"8\",null]]]',\n  593: '[\"EC\",\"00\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{7,11}\",\"1\\\\\\\\d{9,10}|[2-8]\\\\\\\\d{7}|9\\\\\\\\d{8}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2-$3\",\"[247]|[356][2-8]\",null,\"$1-$2-$3\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"9\",\"$NP$FG\"],[\"(1800)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"1\",\"$FG\"]]]',\n  509: '[\"HT\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2-489]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",null,null]]]',\n  54: '[\"AR\",\"00\",\"0\",\"0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\\\\\\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))?15)?\",\"9$1\",\"$NP$FG\",\"\\\\\\\\d{6,11}\",\"11\\\\\\\\d{8}|[2368]\\\\\\\\d{9}|9\\\\\\\\d{10}\",[[\"([68]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"[68]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1-$2\",\"[2-9]\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2\",\"[2-9]\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",\"[2-9]\",\"$FG\",\"NA\"],[\"(9)(11)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$2 15-$3-$4\",\"911\",null,\"$1 $2 $3-$4\"],[\"(9)(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$2 15-$3-$4\",\"9(?:2[234689]|3[3-8])\",null,\"$1 $2 $3-$4\"],[\"(9)(\\\\\\\\d{4})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$2 15-$3-$4\",\"9[23]\",null,\"$1 $2 $3-$4\"],[\"(11)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2-$3\",\"1\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2-$3\",\"2(?:2[013]|3[067]|49|6[01346]|80|9[147-9])|3(?:36|4[1-358]|5[138]|6[24]|7[069]|8[013578])\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2-$3\",\"[23]\",null],[\"(\\\\\\\\d{3})\",\"$1\",\"1[012]|911\",\"$FG\",\"NA\"]]]',\n  57: '[\"CO\",\"00(?:4(?:[14]4|56)|[579])\",\"0\",\"0([3579]|4(?:44|56))?\",null,null,\"\\\\\\\\d{7,11}\",\"(?:[13]\\\\\\\\d{0,3}|[24-8])\\\\\\\\d{7}\",[[\"(\\\\\\\\d)(\\\\\\\\d{7})\",\"$1 $2\",\"1(?:8[2-9]|9[0-3]|[2-7])|[24-8]\",\"($FG)\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{7})\",\"$1 $2\",\"3\",null],[\"(1)(\\\\\\\\d{3})(\\\\\\\\d{7})\",\"$1-$2-$3\",\"1(?:80|9[04])\",\"$NP$FG\",\"$1 $2 $3\"]]]',\n  597: '[\"SR\",\"00\",null,null,null,null,\"\\\\\\\\d{6,7}\",\"[2-8]\\\\\\\\d{5,6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1-$2\",\"[2-4]|5[2-58]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2-$3\",\"56\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2\",\"[6-8]\",null]]]',\n  676: '[\"TO\",\"00\",null,null,null,null,\"\\\\\\\\d{5,7}\",\"[02-8]\\\\\\\\d{4,6}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1-$2\",\"[1-6]|7[0-4]|8[05]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"7[5-9]|8[47-9]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1 $2\",\"0\",null]]]',\n  505: '[\"NI\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[12578]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  850: '[\"KP\",\"00|99\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,8}|\\\\\\\\d{10}\",\"1\\\\\\\\d{9}|[28]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",null],[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"8\",null]]]',\n  7: [\n    '[\"RU\",\"810\",\"8\",null,null,\"$NP ($FG)\",\"\\\\\\\\d{10}\",\"[3489]\\\\\\\\d{9}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2-$3\",\"[1-79]\",\"$FG\",\"NA\"],[\"([3489]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2-$3-$4\",\"[34689]\",null],[\"(7\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"7\",null]]]',\n    '[\"KZ\",\"810\",\"8\",null,null,null,\"\\\\\\\\d{10}\",\"(?:33\\\\\\\\d|7\\\\\\\\d{2}|80[09])\\\\\\\\d{7}\"]',\n  ],\n  268: '[\"SZ\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[027]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"[027]\",null]]]',\n  501: '[\"BZ\",\"00\",null,null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{4})?\",\"[2-8]\\\\\\\\d{6}|0\\\\\\\\d{10}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2\",\"[2-8]\",null],[\"(0)(800)(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1-$2-$3-$4\",\"0\",null]]]',\n  252: '[\"SO\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{6,9}\",\"[1-9]\\\\\\\\d{5,8}\",[[\"(\\\\\\\\d{6})\",\"$1\",\"[134]\",null],[\"(\\\\\\\\d)(\\\\\\\\d{6})\",\"$1 $2\",\"2[0-79]|[13-5]\",null],[\"(\\\\\\\\d)(\\\\\\\\d{7})\",\"$1 $2\",\"24|[67]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"8[125]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{5,7})\",\"$1 $2\",\"15|28|6[1-35-9]|799|9[2-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"3[59]|4[89]|6[24-6]|79|8[08]|90\",null]]]',\n  229: '[\"BJ\",\"00\",null,null,null,null,\"\\\\\\\\d{4,8}\",\"[2689]\\\\\\\\d{7}|7\\\\\\\\d{3}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  680: '[\"PW\",\"01[12]\",null,null,null,null,\"\\\\\\\\d{7}\",\"[2-8]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  263: '[\"ZW\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{3,10}\",\"2(?:[012457-9]\\\\\\\\d{3,8}|6(?:[14]\\\\\\\\d{7}|\\\\\\\\d{4}))|[13-79]\\\\\\\\d{4,9}|8[06]\\\\\\\\d{8}\",[[\"([49])(\\\\\\\\d{3})(\\\\\\\\d{2,4})\",\"$1 $2 $3\",\"4|9[2-9]\",null],[\"(7\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"7\",null],[\"(86\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"86[24]\",null],[\"([2356]\\\\\\\\d{2})(\\\\\\\\d{3,5})\",\"$1 $2\",\"2(?:0[45]|2[278]|[49]8|[78])|3(?:08|17|3[78]|7[1569]|8[37]|98)|5[15][78]|6(?:[29]8|[38]7|6[78]|75|[89]8)\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"2(?:1[39]|2[0157]|6[14]|7[35]|84)|329\",null],[\"([1-356]\\\\\\\\d)(\\\\\\\\d{3,5})\",\"$1 $2\",\"1[3-9]|2[0569]|3[0-69]|5[05689]|6[0-46-9]\",null],[\"([235]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[23]9|54\",null],[\"([25]\\\\\\\\d{3})(\\\\\\\\d{3,5})\",\"$1 $2\",\"(?:25|54)8\",null],[\"(8\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"86\",null],[\"(80\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"80\",null]]]',\n  90: '[\"TR\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{7,10}\",\"[2-589]\\\\\\\\d{9}|444\\\\\\\\d{4}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[23]|4(?:[0-35-9]|4[0-35-9])\",\"($NP$FG)\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"5[02-69]\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"51|[89]\",\"$NP$FG\"],[\"(444)(\\\\\\\\d{1})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"444\",null]]]',\n  352: '[\"LU\",\"00\",null,\"(15(?:0[06]|1[12]|35|4[04]|55|6[26]|77|88|99)\\\\\\\\d)\",null,null,\"\\\\\\\\d{4,11}\",\"[24-9]\\\\\\\\d{3,10}|3(?:[0-46-9]\\\\\\\\d{2,9}|5[013-9]\\\\\\\\d{1,8})\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2\",\"[2-5]|7[1-9]|[89](?:[1-9]|0[2-9])\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",\"[2-5]|7[1-9]|[89](?:[1-9]|0[2-9])\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"20\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{1,2})\",\"$1 $2 $3 $4\",\"2(?:[0367]|4[3-8])\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"20\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{1,2})\",\"$1 $2 $3 $4 $5\",\"2(?:[0367]|4[3-8])\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{1,4})\",\"$1 $2 $3 $4\",\"2(?:[12589]|4[12])|[3-5]|7[1-9]|8(?:[1-9]|0[2-9])|9(?:[1-9]|0[2-46-9])\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"70|80[01]|90[015]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"6\",null]]]',\n  47: [\n    '[\"NO\",\"00\",null,null,null,null,\"\\\\\\\\d{5}(?:\\\\\\\\d{3})?\",\"0\\\\\\\\d{4}|[2-9]\\\\\\\\d{7}\",[[\"([489]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[489]\",null],[\"([235-7]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[235-7]\",null]]]',\n    '[\"SJ\",\"00\",null,null,null,null,\"\\\\\\\\d{5}(?:\\\\\\\\d{3})?\",\"0\\\\\\\\d{4}|[45789]\\\\\\\\d{7}\"]',\n  ],\n  243: '[\"CD\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"[2-6]\\\\\\\\d{6}|[18]\\\\\\\\d{6,8}|9\\\\\\\\d{8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"12\",null],[\"([89]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"8[0-2459]|9\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"88\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"[1-6]\",null]]]',\n  220: '[\"GM\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[2-9]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  687: '[\"NC\",\"00\",null,null,null,null,\"\\\\\\\\d{6}\",\"[2-57-9]\\\\\\\\d{5}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1.$2.$3\",\"[2-46-9]|5[0-4]\",null]]]',\n  995: '[\"GE\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{6,9}\",\"[34578]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[348]\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"7\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"5\",\"$FG\"]]]',\n  961: '[\"LB\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{7,8}\",\"[13-9]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[13-6]|7(?:[2-57]|62|8[0-7]|9[04-9])|8[02-9]|9\",\"$NP$FG\"],[\"([7-9]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[89][01]|7(?:[01]|6[013-9]|8[89]|9[1-3])\",null]]]',\n  40: '[\"RO\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,9}\",\"[23]\\\\\\\\d{5,8}|[7-9]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[23]1\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"[23]1\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[23][3-7]|[7-9]\",null],[\"(2\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2\",\"2[3-6]\",null]]]',\n  232: '[\"SL\",\"00\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{6,8}\",\"[2-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{6})\",\"$1 $2\",null,null]]]',\n  594: '[\"GF\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[56]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  976: '[\"MN\",\"001\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[12]\\\\\\\\d{7,9}|[57-9]\\\\\\\\d{7}\",[[\"([12]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[12]1\",null],[\"([12]2\\\\\\\\d)(\\\\\\\\d{5,6})\",\"$1 $2\",\"[12]2[1-3]\",null],[\"([12]\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"[12](?:27|[3-5])\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"[57-9]\",\"$FG\"],[\"([12]\\\\\\\\d{4})(\\\\\\\\d{4,5})\",\"$1 $2\",\"[12](?:27|[3-5])\",null]]]',\n  20: '[\"EG\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,10}\",\"1\\\\\\\\d{4,9}|[2456]\\\\\\\\d{8}|3\\\\\\\\d{7}|[89]\\\\\\\\d{8,9}\",[[\"(\\\\\\\\d)(\\\\\\\\d{7,8})\",\"$1 $2\",\"[23]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1[012]|[89]00\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{6,7})\",\"$1 $2\",\"1[35]|[4-6]|[89][2-9]\",null]]]',\n  689: '[\"PF\",\"00\",null,null,null,null,\"\\\\\\\\d{6}(?:\\\\\\\\d{2})?\",\"4\\\\\\\\d{5,7}|8\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"4[09]|8[79]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",\"44\",null]]]',\n  56: '[\"CL\",\"(?:0|1(?:1[0-69]|2[0-57]|5[13-58]|69|7[0167]|8[018]))0\",\"0\",\"0|(1(?:1[0-69]|2[0-57]|5[13-58]|69|7[0167]|8[018]))\",null,\"$NP$FG\",\"\\\\\\\\d{7,11}\",\"(?:[2-9]|600|123)\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2[23]\",\"($FG)\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[357]|4[1-35]|6[13-57]\",\"($FG)\"],[\"(9)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"9\",null],[\"(44)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"44\",null],[\"([68]00)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"60|8\",\"$FG\"],[\"(600)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"60\",\"$FG\"],[\"(1230)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",\"$FG\"],[\"(\\\\\\\\d{5})(\\\\\\\\d{4})\",\"$1 $2\",\"219\",\"($FG)\"],[\"(\\\\\\\\d{4,5})\",\"$1\",\"[1-9]\",\"$FG\",\"NA\"]]]',\n  596: '[\"MQ\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[56]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  508: '[\"PM\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6}\",\"[45]\\\\\\\\d{5}\",[[\"([45]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",null,null]]]',\n  269: '[\"KM\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[3478]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",null,null]]]',\n  358: [\n    '[\"FI\",\"00|99(?:[02469]|5(?:11|33|5[59]|88|9[09]))\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,12}\",\"1\\\\\\\\d{4,11}|[2-9]\\\\\\\\d{4,10}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3,7})\",\"$1 $2\",\"(?:[1-3]00|[6-8]0)\",null],[\"(116\\\\\\\\d{3})\",\"$1\",\"116\",\"$FG\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{4,10})\",\"$1 $2\",\"[14]|2[09]|50|7[135]\",null],[\"(\\\\\\\\d)(\\\\\\\\d{4,11})\",\"$1 $2\",\"[25689][1-8]|3\",null]]]',\n    '[\"AX\",\"00|99(?:[02469]|5(?:11|33|5[59]|88|9[09]))\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,12}\",\"1\\\\\\\\d{5,11}|[35]\\\\\\\\d{5,9}|[27]\\\\\\\\d{4,9}|4\\\\\\\\d{5,10}|6\\\\\\\\d{7,9}|8\\\\\\\\d{6,9}\"]',\n  ],\n  251: '[\"ET\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"[1-59]\\\\\\\\d{8}\",[[\"([1-59]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",null,null]]]',\n  681: '[\"WF\",\"00\",null,null,null,null,\"\\\\\\\\d{6}\",\"[4-8]\\\\\\\\d{5}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",null,null]]]',\n  853: '[\"MO\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[268]\\\\\\\\d{7}\",[[\"([268]\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  44: [\n    '[\"GB\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{4,10}\",\"\\\\\\\\d{7,10}\",[[\"(7\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"7(?:[1-5789]|62)\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2|5[56]|7[06]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1(?:1|\\\\\\\\d1)|3|9[018]\",null],[\"(\\\\\\\\d{5})(\\\\\\\\d{4,5})\",\"$1 $2\",\"1(?:38|5[23]|69|76|94)\",null],[\"(1\\\\\\\\d{3})(\\\\\\\\d{5,6})\",\"$1 $2\",\"1\",null],[\"(800)(\\\\\\\\d{4})\",\"$1 $2\",\"800\",null],[\"(845)(46)(4\\\\\\\\d)\",\"$1 $2 $3\",\"845\",null],[\"(8\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"8(?:4[2-5]|7[0-3])\",null],[\"(80\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"80\",null],[\"([58]00)(\\\\\\\\d{6})\",\"$1 $2\",\"[58]00\",null]]]',\n    '[\"GG\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[135789]\\\\\\\\d{6,9}\"]',\n    '[\"IM\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[135789]\\\\\\\\d{6,9}\"]',\n    '[\"JE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[135789]\\\\\\\\d{6,9}\"]',\n  ],\n  244: '[\"AO\",\"00\",null,null,null,null,\"\\\\\\\\d{9}\",\"[29]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",null,null]]]',\n  211: '[\"SS\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{9}\",\"[19]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",null,\"$NP$FG\"]]]',\n  373: '[\"MD\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{8}\",\"[235-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"22|3\",null],[\"([25-7]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2[13-9]|[5-7]\",null],[\"([89]\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"[89]\",null]]]',\n  996: '[\"KG\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,10}\",\"[235-8]\\\\\\\\d{8,9}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[25-7]|31[25]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{5})\",\"$1 $2\",\"3(?:1[36]|[2-9])\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d)(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"8\",null]]]',\n  93: '[\"AF\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"[2-7]\\\\\\\\d{8}\",[[\"([2-7]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[2-7]\",null]]]',\n  260: '[\"ZM\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[289]\\\\\\\\d{8}\",[[\"([29]\\\\\\\\d)(\\\\\\\\d{7})\",\"$1 $2\",\"[29]\",null],[\"(800)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"8\",null]]]',\n  378: '[\"SM\",\"00\",null,\"(?:0549)?([89]\\\\\\\\d{5})\",\"0549$1\",null,\"\\\\\\\\d{6,10}\",\"[05-7]\\\\\\\\d{7,9}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[5-7]\",null],[\"(0549)(\\\\\\\\d{6})\",\"$1 $2\",\"0\",null,\"($1) $2\"],[\"(\\\\\\\\d{6})\",\"0549 $1\",\"[89]\",null,\"(0549) $1\"]]]',\n  235: '[\"TD\",\"00|16\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2679]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  960: '[\"MV\",\"0(?:0|19)\",null,null,null,null,\"\\\\\\\\d{7,10}\",\"[346-8]\\\\\\\\d{6,9}|9(?:00\\\\\\\\d{7}|\\\\\\\\d{6})\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2\",\"[3467]|9(?:[1-9]|0[1-9])\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[89]00\",null]]]',\n  221: '[\"SN\",\"00\",null,null,null,null,\"\\\\\\\\d{9}\",\"[3789]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[379]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"8\",null]]]',\n  595: '[\"PY\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{5,9}\",\"5[0-5]\\\\\\\\d{4,7}|[2-46-9]\\\\\\\\d{5,8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"(?:[26]1|3[289]|4[124678]|7[123]|8[1236])\",\"($NP$FG)\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"(?:[26]1|3[289]|4[124678]|7[123]|8[1236])\",\"($NP$FG)\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3,6})\",\"$1 $2\",\"[2-9]0\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"9[1-9]\",\"$NP$FG\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"8700\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4,5})\",\"$1 $2\",\"[2-8][1-9]\",\"($NP$FG)\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[2-8][1-9]\",\"$NP$FG\"]]]',\n  977: '[\"NP\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[1-8]\\\\\\\\d{7}|9(?:[1-69]\\\\\\\\d{6,8}|7[2-6]\\\\\\\\d{5,7}|8\\\\\\\\d{8})\",[[\"(1)(\\\\\\\\d{7})\",\"$1-$2\",\"1[2-6]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{6})\",\"$1-$2\",\"1[01]|[2-8]|9(?:[1-69]|7[15-9])\",null],[\"(9\\\\\\\\d{2})(\\\\\\\\d{7})\",\"$1-$2\",\"9(?:6[013]|7[245]|8)\",\"$FG\"]]]',\n  36: '[\"HU\",\"00\",\"06\",null,null,\"($FG)\",\"\\\\\\\\d{6,9}\",\"[1-9]\\\\\\\\d{7,8}\",[[\"(1)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[2-9]\",null]]]',\n};\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs":
/*!***************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhoneNumberNormalizer: () => (/* binding */ PhoneNumberNormalizer)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Apache License, Version\n * 2.0. If a copy of the Apache License was not distributed with this file, You\n * can obtain one at https://www.apache.org/licenses/LICENSE-2.0 */\n\n// This library came from https://github.com/andreasgal/PhoneNumber.js but will\n// be further maintained by our own in Form Autofill codebase.\n\nvar PhoneNumberNormalizer = (function () {\n  const UNICODE_DIGITS = /[\\uFF10-\\uFF19\\u0660-\\u0669\\u06F0-\\u06F9]/g;\n  const VALID_ALPHA_PATTERN = /[a-zA-Z]/g;\n  const LEADING_PLUS_CHARS_PATTERN = /^[+\\uFF0B]+/g;\n  const NON_DIALABLE_CHARS = /[^,#+\\*\\d]/g;\n\n  // Map letters to numbers according to the ITU E.161 standard\n  let E161 = {\n    a: 2,\n    b: 2,\n    c: 2,\n    d: 3,\n    e: 3,\n    f: 3,\n    g: 4,\n    h: 4,\n    i: 4,\n    j: 5,\n    k: 5,\n    l: 5,\n    m: 6,\n    n: 6,\n    o: 6,\n    p: 7,\n    q: 7,\n    r: 7,\n    s: 7,\n    t: 8,\n    u: 8,\n    v: 8,\n    w: 9,\n    x: 9,\n    y: 9,\n    z: 9,\n  };\n\n  // Normalize a number by converting unicode numbers and symbols to their\n  // ASCII equivalents and removing all non-dialable characters.\n  function NormalizeNumber(number, numbersOnly) {\n    if (typeof number !== \"string\") {\n      return \"\";\n    }\n\n    number = number.replace(UNICODE_DIGITS, function (ch) {\n      return String.fromCharCode(48 + (ch.charCodeAt(0) & 0xf));\n    });\n    if (!numbersOnly) {\n      number = number.replace(VALID_ALPHA_PATTERN, function (ch) {\n        return String(E161[ch.toLowerCase()] || 0);\n      });\n    }\n    number = number.replace(LEADING_PLUS_CHARS_PATTERN, \"+\");\n    number = number.replace(NON_DIALABLE_CHARS, \"\");\n    return number;\n  }\n\n  return {\n    Normalize: NormalizeNumber,\n  };\n})();\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/TranslationsHelpers.ios.mjs":
/*!*************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/TranslationsHelpers.ios.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cu: () => (/* binding */ Cu),\n/* harmony export */   clearTimeout: () => (/* binding */ clearTimeout),\n/* harmony export */   setTimeout: () => (/* binding */ setTimeout)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_shared_Helpers_ios_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/shared/Helpers.ios.mjs */ \"./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\nNode.prototype.ownerGlobal = window;\n\nObject.defineProperty(Node.prototype, \"flattenedTreeParentNode\", {\n  get() {\n    return this.parentElement ?? null;\n  },\n  configurable: true,\n});\n\nconst Cu = {\n  // NOTE(Issam): Is this enough ? Or maybe we can use WeakRefs.\n  isDeadWrapper: (node) => !node?.isConnected,\n  isInAutomation: false,\n};\nglobalThis.Cu = Cu;\n\n/// Mock for DOMParser.parseFromSafeString\n/// Currently just uses `parseFromString`.\n/// `parseFromSafeString` is a gecko API that is not standard.\n/// See: https://searchfox.org/firefox-main/source/dom/base/DOMParser.cpp#122\n/// TODO(Issam): Implement a safer version (e.g., using DOMPurify to sanitize input HTML)\nDOMParser.prototype.parseFromSafeString = function (str, type) {\n  return this.parseFromString(str, type);\n};\n\nconst setTimeout = globalThis.setTimeout.bind(window);\nconst clearTimeout = globalThis.clearTimeout.bind(window);\n\n\n\n// TODO(Issam): Implement this for debugging\nglobalThis.console.createInstance = () => ({\n  log: (...whatever) => console.log(\"createInstance --- \", ...whatever),\n  warn: (...whatever) => console.warn(\"createInstance --- \", ...whatever),\n  error: (...whatever) => console.error(\"createInstance --- \", ...whatever),\n  shouldLog: () => false, // TODO(Issam): Maybe enable for webpack dev builds\n});\n\nglobalThis.ChromeUtils = globalThis.ChromeUtils || {};\nglobalThis.ChromeUtils.addProfilerMarker = () => { };\nglobalThis.ChromeUtils.domProcessChild = {\n  getActor: () => globalThis,\n};\nglobalThis.ChromeUtils.now = () => performance.now();\n\n/// TODO(Issam): Copy over implementation from: \n/// https://searchfox.org/firefox-main/source/toolkit/components/mozintl/mozIntl.sys.mjs#1044-1058\nglobalThis.Services = {\n  intl: {\n    getScriptDirection: () => \"ltr\",\n  }\n};\n\n// // QUESTION(Issam): It would be better if the code in the engine ingests these as is.\n// // TODO(Issam): Can we send the binary data as is from siwift and use new Uint8Array(byteArray) only \n// // to convert the binary array to a typed one.\n// const base64ToArrayBuffer = (base64) => {\n//   const binaryString = atob(base64);\n//   const length = binaryString.length;\n//   const bytes = new Uint8Array(length);\n//   for (let i = 0; i < length; i++) {\n//     bytes[i] = binaryString.charCodeAt(i);\n//   }\n//   return bytes;\n// };\n\n// // QUESTION(Issam): It would be better if the code in the engine ingests these as is.\n// // TODO(Issam): Can we send the binary data as is from siwift and use new Uint8Array(byteArray) only \n// // to convert the binary array to a typed one.\nconst base64ToArrayBuffer = (base64) => {\n  const binary = atob(base64);\n  return Uint8Array.from(binary, c => c.charCodeAt(0)).buffer;\n}\n\n// // NOTE(Issam): Wasm is bundled using webpack. Language models are fetched from swift.\n// // Is this a good approach ?\n// export const getAllModels = async (sourceLanguage, targetLanguage) => {\n//   // NOTE(Issam): Most processing is done in swift. If we manage to accept base64 encoded models\n//   // Then we can omit the processing here all together.\n//   // TODO(Issam): models in base64 to array buffer\n//   // languageModelFiles: {\n//   //     lex: {buffer: \"\"}\n//   //     vocab: {buffer: \"\"}\n//   //     model: {buffer: \"\"}\n//   // }\n//   const modelsForLanguagePair =\n//     await webkit.messageHandlers.translationsBackground.postMessage({\n//       type: \"getModels\",\n//       payload: {\n//         sourceLanguage,\n//         targetLanguage,\n//       },\n//     });\n\n//   const languageModelFiles = modelsForLanguagePair.languageModelFiles;\n//   for (const model of Object.values(languageModelFiles)) {\n//     model.buffer = base64ToArrayBuffer(model.buffer);\n//   }\n//   return modelsForLanguagePair;\n// };\n\nglobalThis.TE_getLogLevel = () => { };\nglobalThis.TE_log = (message) => console.log(\"TE_log ---- \", message);\nglobalThis.log = (message) => console.log(\"log ---- \", message);\n\nglobalThis.TE_logError = (...error) =>\n  console.error(\"TE_error ---- \", ...error);\nglobalThis.TE_getLogLevel = () => { };\nglobalThis.TE_destroyEngineProcess = () => { };\nglobalThis.TE_reportEnginePerformance = () => { };\nglobalThis.TE_requestEnginePayload = async ({ sourceLanguage, targetLanguage  }) => {\n  const modelsURL = `translations://app/models?from=${encodeURIComponent(sourceLanguage)}&to=${encodeURIComponent(targetLanguage)}`;\n  const modelsResponse = await fetch(modelsURL);\n  if (!modelsResponse.ok) throw new Error(`Model fetch failed: ${modelsResponse.status}`);\n  const translationModelPayloads = await modelsResponse.json();\n  // TODO(Issam): I hate this extra processing we should just send it as a binary array. \n  const processedPayloads = processTranslationPayloads(translationModelPayloads);\n  // TODO(Issam): Use Promise.all to parallelize this with fetching the wasm so we don't wait for one then the other.\n  const translatorURL = `translations://app/translator`;\n  const translatorResponse = await fetch(translatorURL);\n  if (!translatorResponse.ok) throw new Error(`Translator fetch failed: ${translatorResponse.status}`);\n  const bergamotTranslator = await translatorResponse.json();\n\n  return {\n    bergamotWasmArrayBuffer: base64ToArrayBuffer(bergamotTranslator.wasm),\n    translationModelPayloads: processedPayloads,\n    isMocked: false,\n  };\n};\nglobalThis.TE_reportEngineStatus = () => { };\nglobalThis.TE_resolveForceShutdown = () => { };\nglobalThis.TE_addProfilerMarker = () => { };\n\n\n// TODO(Issam): We should figure a better way to do this instead of all the extra processing here.\n// Maybe we can send the binary data as is from swift and use new Uint8Array(byteArray) only \n// to convert the binary array to a typed one.\nconst processTranslationPayloads = (payloads) =>\n  payloads.map(payload => {\n    const processedFiles = {};\n    for (const [type, file] of Object.entries(payload.languageModelFiles)) {\n      processedFiles[type] = {\n        ...file,\n        buffer: base64ToArrayBuffer(file.buffer),\n      };\n    }\n    return { ...payload, languageModelFiles: processedFiles };\n  });\n\n// NOTE(Issam): Calling new Worker(url) will cause a security error since we are loading from an unsafe context.\n// To bypass this we inline the worker and override the Worker constructor. This way we don't have to touch the shared code.\n// We are only calling this to load translations-engine.worker.js for now, so it's hardcoded\nconst OriginalWorker = globalThis.Worker;\nglobalThis.Worker = class extends OriginalWorker {\n  constructor(url, options) {\n    if (url.endsWith(\"translations-engine.worker.js\")) {\n      const translationsWorker = __webpack_require__(/*! Assets/CC_Script/translations-engine.worker.js */ \"./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js\");\n      return new translationsWorker();\n    }\n    return new OriginalWorker(url, options);\n  }\n};\n\n// NOTE(Issam): importScripts is resolved at runtime which is problematic. The best solution I found for this is to:\n// - Override it to use require so webpack can build the deps graph.\n// - Use script-loader to expose loadBergamot to the worker since it's not an es module.\nglobalThis.importScripts = (moduleURI) => {\n  const moduleName = moduleURI.split(\"/\").pop();\n  __webpack_require__(\"./firefox-ios/Client/Assets/CC_Script sync recursive ./node_modules/script-loader/index.js! ^\\\\.\\\\/.*$\")(`./${moduleName}`);\n};\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/TranslationsHelpers.ios.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/TranslationsUtils.mjs":
/*!*******************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/TranslationsUtils.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TranslationsUtils: () => (/* binding */ TranslationsUtils)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * @typedef {import(\"./translations\").LanguagePair} LanguagePair\n */\n\n/**\n * A set of global static utility functions that are useful throughout the\n * Translations ecosystem within the Firefox code base.\n */\nclass TranslationsUtils {\n  /**\n   * Checks if the language tag string parses as a valid BCP-47 language tag.\n   *\n   * @param {string} langTag - A BCP-47 language tag.\n   * @returns {boolean} - True if the given language tag parses or false if it does not.\n   */\n  static isLangTagValid(langTag) {\n    if (!langTag) {\n      return false;\n    }\n\n    try {\n      new Intl.Locale(langTag);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Normalizes the language tag for comparison within the Translations ecosystem.\n   *\n   * Prefers to compare languages with a script tag if one is available, only resorting\n   * to returning the language tag in isolation if a script tag could not be derived.\n   *\n   * @param {string} langTag - A BCP-47 language tag.\n   * @returns {string} - A BCP-47 language tag normalized for Translations.\n   */\n  static #normalizeLangTag(langTag) {\n    let locale = new Intl.Locale(langTag);\n\n    if (!locale.script) {\n      // Attempt to populate a script tag via likely subtags.\n      locale = locale.maximize();\n    }\n\n    if (locale.script) {\n      // If the locale has a script, use it.\n      return `${locale.language}-${locale.script}`;\n    }\n\n    return locale.language;\n  }\n\n  /**\n   * Compares two BCP-47 language tags for Translations compatibility.\n   *\n   * If one language tag belongs to one of our models, and the other\n   * language tag is determined to be a match, then it is determined\n   * that the model is compatible to for translation with that language.\n   *\n   * @param {string} lhsLangTag - The left-hand-side language tag to compare.\n   * @param {string} rhsLangTag - The right-hand-side language tag to compare.\n   *\n   * @returns {boolean}\n   *  `true`  if the language tags match, either directly or after normalization.\n   *  `false` if either tag is invalid or empty, or if they do not match.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc5646#appendix-A\n   */\n  static langTagsMatch(lhsLangTag, rhsLangTag) {\n    if (!lhsLangTag || !rhsLangTag) {\n      return false;\n    }\n\n    if (lhsLangTag === rhsLangTag) {\n      // A simple direct match.\n      return true;\n    }\n\n    if (lhsLangTag.split(\"-\")[0] !== rhsLangTag.split(\"-\")[0]) {\n      // The language components of the tags do not match so there is no need to normalize them and compare.\n      return false;\n    }\n\n    try {\n      return (\n        TranslationsUtils.#normalizeLangTag(lhsLangTag) ===\n        TranslationsUtils.#normalizeLangTag(rhsLangTag)\n      );\n    } catch {\n      // One of the locales is not valid, just continue on to return false.\n    }\n\n    return false;\n  }\n\n  /**\n   * Serializes a language pair into a unique key that is human readable. This is useful\n   * for caching, deduplicating, and logging.\n   *\n   * e.g.\n   *   \"en -> fr\"\n   *   \"en -> fr,base\"\n   *   \"zh-Hans,tiny -> fr,base\"\n   *\n   * @param {LanguagePair} languagePair\n   */\n  static serializeLanguagePair({\n    sourceLanguage,\n    targetLanguage,\n    sourceVariant,\n    targetVariant,\n  }) {\n    let key = sourceLanguage;\n    if (sourceVariant) {\n      key += `,${sourceVariant}`;\n    }\n    key += ` -> ${targetLanguage}`;\n    if (targetVariant) {\n      key += `,${targetVariant}`;\n    }\n    return key;\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/TranslationsUtils.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/addressFormLayout.mjs":
/*!*******************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/addressFormLayout.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canSubmitForm: () => (/* binding */ canSubmitForm),\n/* harmony export */   createFormLayoutFromRecord: () => (/* binding */ createFormLayoutFromRecord),\n/* harmony export */   getCurrentFormData: () => (/* binding */ getCurrentFormData)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  FormAutofill: \"resource://autofill/FormAutofill.sys.mjs\",\n  FormAutofillUtils: \"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\",\n});\n\n// Defines template descriptors for generating elements in convertLayoutToUI.\nconst fieldTemplates = {\n  commonAttributes(item) {\n    return {\n      id: item.fieldId,\n      name: item.fieldId,\n      required: item.required,\n      value: item.value ?? \"\",\n      // Conditionally add pattern attribute since pattern=\"\"/false/undefined\n      // results in weird behaviour.\n      ...(item.pattern && { pattern: item.pattern }),\n    };\n  },\n  input(item) {\n    return {\n      tag: \"input\",\n      type: item.type ?? \"text\",\n      ...this.commonAttributes(item),\n    };\n  },\n  textarea(item) {\n    return {\n      tag: \"textarea\",\n      ...this.commonAttributes(item),\n    };\n  },\n  select(item) {\n    return {\n      tag: \"select\",\n      children: item.options.map(({ value, text }) => ({\n        tag: \"option\",\n        selected: value === item.value,\n        value,\n        text,\n      })),\n      ...this.commonAttributes(item),\n    };\n  },\n};\n\n/**\n * Creates an HTML element with specified attributes and children.\n *\n * @param {string} tag - Tag name for the element to create.\n * @param {object} options - Options object containing attributes and children.\n * @param {object} options.attributes - Element's Attributes/Props (id, class, etc.)\n * @param {Array} options.children - Element's children (array of objects with tag and options).\n * @returns {HTMLElement} The newly created element.\n */\nconst createElement = (tag, { children = [], ...attributes }) => {\n  const element = document.createElement(tag);\n\n  for (let [attributeName, attributeValue] of Object.entries(attributes)) {\n    if (attributeName in element) {\n      element[attributeName] = attributeValue;\n    } else {\n      element.setAttribute(attributeName, attributeValue);\n    }\n  }\n\n  for (let { tag: childTag, ...childRest } of children) {\n    element.appendChild(createElement(childTag, childRest));\n  }\n\n  return element;\n};\n\n/**\n * Generator that creates UI elements from `fields` object, using localization from `l10nStrings`.\n *\n * @param {Array} fields - Array of objects as returned from `FormAutofillUtils.getFormLayout`.\n * @param {object} l10nStrings - Key-value pairs for field label localization.\n * @yields {HTMLElement} - A localized label element with constructed from a field.\n */\nfunction* convertLayoutToUI(fields, l10nStrings) {\n  for (const item of fields) {\n    // eslint-disable-next-line no-nested-ternary\n    const fieldTag = item.options\n      ? \"select\"\n      : item.multiline\n        ? \"textarea\"\n        : \"input\";\n\n    const fieldUI = {\n      label: {\n        id: `${item.fieldId}-container`,\n        class: `container ${item.newLine ? \"new-line\" : \"\"}`,\n      },\n      field: fieldTemplates[fieldTag](item),\n      span: {\n        class: \"label-text\",\n        textContent: l10nStrings[item.l10nId] ?? \"\",\n      },\n    };\n\n    const label = createElement(\"label\", fieldUI.label);\n    const { tag, ...rest } = fieldUI.field;\n    const span = createElement(\"span\", fieldUI.span);\n    label.appendChild(span);\n    const field = createElement(tag, rest);\n    label.appendChild(field);\n    yield label;\n  }\n}\n\n/**\n * Retrieves the current form data from the current form element on the page.\n * NOTE: We are intentionally not using FormData here because on iOS we have states where\n *       selects are disabled and FormData ignores disabled elements. We want getCurrentFormData\n *       to always refelect the exact state of the form.\n *\n * @returns {object} An object containing key-value pairs of form data.\n */\nconst getCurrentFormData = () => {\n  const formData = {};\n  for (const element of document.querySelector(\"form\").elements) {\n    formData[element.name] = element.value ?? \"\";\n  }\n  return formData;\n};\n\n/**\n * Checks if the form can be submitted based on the number of non-empty values.\n * TODO(Bug 1891734): Add address validation. Right now we don't do any validation. (2 fields mimics the old behaviour ).\n *\n * @returns {boolean} True if the form can be submitted\n */\nconst canSubmitForm = () => {\n  const formData = getCurrentFormData();\n  const validValues = Object.values(formData).filter(Boolean);\n  return validValues.length >= 2;\n};\n\n/**\n * Generates a form layout based on record data and localization strings.\n *\n * @param {HTMLFormElement} formElement - Target form element.\n * @param {object} record - Address record, includes at least country code defaulted to FormAutofill.DEFAULT_REGION.\n * @param {object} l10nStrings - Localization strings map.\n */\nconst createFormLayoutFromRecord = (\n  formElement,\n  record = { country: lazy.FormAutofill.DEFAULT_REGION },\n  l10nStrings = {}\n) => {\n  // Always clear select values because they are not persisted between countries.\n  // For example from US with state NY, we don't want the address-level1 to be NY\n  // when changing to another country that doesn't have state options\n  const selects = formElement.querySelectorAll(\"select:not(#country)\");\n  for (const select of selects) {\n    select.value = \"\";\n  }\n\n  // Get old data to persist before clearing form\n  const formData = getCurrentFormData();\n  record = {\n    ...record,\n    ...formData,\n  };\n\n  formElement.innerHTML = \"\";\n  const fields = lazy.FormAutofillUtils.getFormLayout(record);\n\n  const layoutGenerator = convertLayoutToUI(fields, l10nStrings);\n\n  for (const fieldElement of layoutGenerator) {\n    formElement.appendChild(fieldElement);\n  }\n\n  document.querySelector(\"#country\").addEventListener(\n    \"change\",\n    ev =>\n      // Allow some time for the user to type\n      // before we set the new country and re-render\n      setTimeout(() => {\n        record.country = ev.target.value;\n        createFormLayoutFromRecord(formElement, record, l10nStrings);\n      }, 300),\n    { once: true }\n  );\n\n  // Used to notify tests that the form has been updated and is ready\n  window.dispatchEvent(new CustomEvent(\"FormReadyForTests\"));\n};\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/addressFormLayout.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/fathom.mjs":
/*!********************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/fathom.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   atMost: () => (/* binding */ atMost),\n/* harmony export */   clusters: () => (/* binding */ clusters$1),\n/* harmony export */   dom: () => (/* binding */ dom),\n/* harmony export */   element: () => (/* binding */ element),\n/* harmony export */   exceptions: () => (/* binding */ exceptions),\n/* harmony export */   nearest: () => (/* binding */ nearest),\n/* harmony export */   note: () => (/* binding */ note),\n/* harmony export */   out: () => (/* binding */ out),\n/* harmony export */   props: () => (/* binding */ props),\n/* harmony export */   rule: () => (/* binding */ rule),\n/* harmony export */   ruleset: () => (/* binding */ ruleset),\n/* harmony export */   score: () => (/* binding */ score),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   typeIn: () => (/* binding */ typeIn),\n/* harmony export */   utils: () => (/* binding */ utilsForFrontend),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/*\nDO NOT TOUCH fathom.mjs DIRECTLY. See the README for instructions.\n*/\n\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * A :func:`rule` depends on another rule which itself depends on the first\n * rule again, either directly or indirectly.\n */\nclass CycleError extends Error {\n}\n\n/**\n  * An examined element was not contained in a browser ``window`` object, but\n  * something needed it to be.\n  */\nclass NoWindowError extends Error {\n}\n\nvar exceptions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  CycleError: CycleError,\n  NoWindowError: NoWindowError\n});\n\n/**\n * Return the passed-in arg. Useful as a default.\n */\nfunction identity(x) {\n    return x;\n}\n\n/*eslint-env browser*/\n\n/**\n * From an iterable return the best item, according to an arbitrary comparator\n * function. In case of a tie, the first item wins.\n *\n * @arg by {function} Given an item of the iterable, return a value to compare\n * @arg isBetter {function} Return whether its first arg is better than its\n *     second\n */\nfunction best(iterable, by, isBetter) {\n    let bestSoFar, bestKeySoFar;\n    let isFirst = true;\n    forEach(\n        function (item) {\n            const key = by(item);\n            if (isBetter(key, bestKeySoFar) || isFirst) {\n                bestSoFar = item;\n                bestKeySoFar = key;\n                isFirst = false;\n            }\n        },\n        iterable);\n    if (isFirst) {\n        throw new Error('Tried to call best() on empty iterable');\n    }\n    return bestSoFar;\n}\n\n/**\n * Return the maximum item from an iterable, as defined by >.\n *\n * Works with any type that works with >. If multiple items are equally great,\n * return the first.\n *\n * @arg by {function} Given an item of the iterable, returns a value to\n *     compare\n */\nfunction max(iterable, by = identity) {\n    return best(iterable, by, (a, b) => a > b);\n}\n\n/**\n * Return an Array of maximum items from an iterable, as defined by > and ===.\n *\n * If an empty iterable is passed in, return [].\n */\nfunction maxes(iterable, by = identity) {\n    let bests = [];\n    let bestKeySoFar;\n    let isFirst = true;\n    forEach(\n        function (item) {\n            const key = by(item);\n            if (key > bestKeySoFar || isFirst) {\n                bests = [item];\n                bestKeySoFar = key;\n                isFirst = false;\n            } else if (key === bestKeySoFar) {\n                bests.push(item);\n            }\n        },\n        iterable);\n    return bests;\n}\n\n/**\n * Return the minimum item from an iterable, as defined by <.\n *\n * If multiple items are equally great, return the first.\n */\nfunction min(iterable, by = identity) {\n    return best(iterable, by, (a, b) => a < b);\n}\n\n/**\n * Return the sum of an iterable, as defined by the + operator.\n */\nfunction sum(iterable) {\n    let total;\n    let isFirst = true;\n    forEach(\n        function assignOrAdd(addend) {\n            if (isFirst) {\n                total = addend;\n                isFirst = false;\n            } else {\n                total += addend;\n            }\n        },\n        iterable);\n    return total;\n}\n\n/**\n * Return the number of items in an iterable, consuming it as a side effect.\n */\nfunction length(iterable) {\n    let num = 0;\n    // eslint-disable-next-line no-unused-vars\n    for (let item of iterable) {\n        num++;\n    }\n    return num;\n}\n\n/**\n * Iterate, depth first, over a DOM node. Return the original node first.\n *\n * @arg shouldTraverse {function} Given a node, say whether we should\n *     include it and its children. Default: always true.\n */\nfunction *walk(element, shouldTraverse = element => true) {\n    yield element;\n    for (let child of element.childNodes) {\n        if (shouldTraverse(child)) {\n            for (let w of walk(child, shouldTraverse)) {\n                yield w;\n            }\n        }\n    }\n}\n\nconst blockTags = new Set(\n    ['ADDRESS', 'BLOCKQUOTE', 'BODY', 'CENTER', 'DIR', 'DIV', 'DL',\n     'FIELDSET', 'FORM', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HR',\n     'ISINDEX', 'MENU', 'NOFRAMES', 'NOSCRIPT', 'OL', 'P', 'PRE',\n     'TABLE', 'UL', 'DD', 'DT', 'FRAMESET', 'LI', 'TBODY', 'TD',\n     'TFOOT', 'TH', 'THEAD', 'TR', 'HTML']);\n/**\n * Return whether a DOM element is a block element by default (rather than by\n * styling).\n */\nfunction isBlock(element) {\n    return blockTags.has(element.tagName);\n}\n\n/**\n * Yield strings of text nodes within a normalized DOM node and its children,\n * without venturing into any contained block elements.\n *\n * @arg shouldTraverse {function} Specify additional elements to exclude by\n *     returning false\n */\nfunction *inlineTexts(element, shouldTraverse = element => true) {\n    // TODO: Could we just use querySelectorAll() with a really long\n    // selector rather than walk(), for speed?\n    for (let child of walk(element,\n                           element => !(isBlock(element) ||\n                                        element.tagName === 'SCRIPT' &&\n                                        element.tagName === 'STYLE')\n                                      && shouldTraverse(element))) {\n        if (child.nodeType === child.TEXT_NODE) {\n            // wholeText() is not implemented by jsdom, so we use\n            // textContent(). The result should be the same, since\n            // we're calling it on only text nodes, but it may be\n            // slower. On the positive side, it means we don't need to\n            // normalize the DOM tree first.\n            yield child.textContent;\n        }\n    }\n}\n\n/**\n * Return the total length of the inline text within an element, with\n * whitespace collapsed.\n *\n * @arg shouldTraverse {function} Specify additional elements to exclude by\n *     returning false\n */\nfunction inlineTextLength(element, shouldTraverse = element => true) {\n    return sum(map(text => collapseWhitespace(text).length,\n                   inlineTexts(element, shouldTraverse)));\n}\n\n/**\n * Return a string with each run of whitespace collapsed to a single space.\n */\nfunction collapseWhitespace(str) {\n    return str.replace(/\\s{2,}/g, ' ');\n}\n\n/**\n * Return the ratio of the inline text length of the links in an element to the\n * inline text length of the entire element.\n *\n * @arg inlineLength {number} Optionally, the precalculated inline\n *     length of the fnode. If omitted, we will calculate it ourselves.\n */\nfunction linkDensity(fnode, inlineLength) {\n    if (inlineLength === undefined) {\n        inlineLength = inlineTextLength(fnode.element);\n    }\n    const lengthWithoutLinks = inlineTextLength(fnode.element,\n                                                element => element.tagName !== 'A');\n    return (inlineLength - lengthWithoutLinks) / inlineLength;\n}\n\n/**\n * Return whether an element is a text node that consist wholly of whitespace.\n */\nfunction isWhitespace(element) {\n    return (element.nodeType === element.TEXT_NODE &&\n            element.textContent.trim().length === 0);\n}\n\n/**\n * Get a key of a map, first setting it to a default value if it's missing.\n */\nfunction setDefault(map, key, defaultMaker) {\n    if (map.has(key)) {\n        return map.get(key);\n    }\n    const defaultValue = defaultMaker();\n    map.set(key, defaultValue);\n    return defaultValue;\n}\n\n/**\n * Get a key of a map or, if it's missing, a default value.\n */\nfunction getDefault(map, key, defaultMaker) {\n    if (map.has(key)) {\n        return map.get(key);\n    }\n    return defaultMaker();\n}\n\n/**\n * Return an Array, the reverse topological sort of the given nodes.\n *\n * @arg nodes An iterable of arbitrary things\n * @arg nodesThatNeed {function} Take a node and returns an Array of nodes\n *     that depend on it\n */\nfunction toposort(nodes, nodesThatNeed) {\n    const ret = [];\n    const todo = new Set(nodes);\n    const inProgress = new Set();\n\n    function visit(node) {\n        if (inProgress.has(node)) {\n            throw new CycleError('The graph has a cycle.');\n        }\n        if (todo.has(node)) {\n            inProgress.add(node);\n            for (let needer of nodesThatNeed(node)) {\n                visit(needer);\n            }\n            inProgress.delete(node);\n            todo.delete(node);\n            ret.push(node);\n        }\n    }\n\n    while (todo.size > 0) {\n        visit(first(todo));\n    }\n    return ret;\n}\n\n/**\n * A Set with the additional methods it ought to have had\n */\nclass NiceSet extends Set {\n    /**\n     * Remove and return an arbitrary item. Throw an Error if I am empty.\n     */\n    pop() {\n        for (let v of this.values()) {\n            this.delete(v);\n            return v;\n        }\n        throw new Error('Tried to pop from an empty NiceSet.');\n    }\n\n    /**\n     * Union another set or other iterable into myself.\n     *\n     * @return myself, for chaining\n     */\n    extend(otherSet) {\n        for (let item of otherSet) {\n            this.add(item);\n        }\n        return this;\n    }\n\n    /**\n     * Subtract another set from a copy of me.\n     *\n     * @return a copy of myself excluding the elements in ``otherSet``.\n     */\n    minus(otherSet) {\n        const ret = new NiceSet(this);\n        for (const item of otherSet) {\n            ret.delete(item);\n        }\n        return ret;\n    }\n\n    /**\n     * Actually show the items in me.\n     */\n    toString() {\n        return '{' + Array.from(this).join(', ') + '}';\n    }\n}\n\n/**\n * Return the first item of an iterable.\n */\nfunction first(iterable) {\n    for (let i of iterable) {\n        return i;\n    }\n}\n\n/**\n * Given any node in a DOM tree, return the root element of the tree, generally\n * an HTML element.\n */\nfunction rootElement(element) {\n    return element.ownerDocument.documentElement;\n}\n\n/**\n * Return the number of times a regex occurs within the string `haystack`.\n *\n * Caller must make sure `regex` has the 'g' option set.\n */\nfunction numberOfMatches(regex, haystack) {\n    return (haystack.match(regex) || []).length;\n}\n\n/**\n * Wrap a scoring callback, and set its element to the page root iff a score is\n * returned.\n *\n * This is used to build rulesets which classify entire pages rather than\n * picking out specific elements.\n *\n * For example, these rules might classify a page as a \"login page\", influenced\n * by whether they have login buttons or username fields:\n *\n * ``rule(type('loginPage'), score(page(pageContainsLoginButton))),``\n * ``rule(type('loginPage'), score(page(pageContainsUsernameField)))``\n */\nfunction page(scoringFunction) {\n    function wrapper(fnode) {\n        const scoreAndTypeAndNote = scoringFunction(fnode);\n        if (scoreAndTypeAndNote.score !== undefined) {\n            scoreAndTypeAndNote.element = rootElement(fnode.element);\n        }\n        return scoreAndTypeAndNote;\n    }\n    return wrapper;\n}\n\n/**\n * Sort the elements by their position in the DOM.\n *\n * @arg fnodes {iterable} fnodes to sort\n * @return {Array} sorted fnodes\n */\nfunction domSort(fnodes) {\n    function compare(a, b) {\n        const element = a.element;\n        const position = element.compareDocumentPosition(b.element);\n        if (position & element.DOCUMENT_POSITION_FOLLOWING) {\n            return -1;\n        } else if (position & element.DOCUMENT_POSITION_PRECEDING) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n    return Array.from(fnodes).sort(compare);\n}\n\n/* istanbul ignore next */\n/**\n * Return the DOM element contained in a passed-in fnode. Return passed-in DOM\n * elements verbatim.\n *\n * @arg fnodeOrElement {Node|Fnode}\n */\nfunction toDomElement(fnodeOrElement) {\n    return isDomElement(fnodeOrElement) ? fnodeOrElement : fnodeOrElement.element;\n}\n\n/**\n * Checks whether any of the element's attribute values satisfy some condition.\n *\n * Example::\n *\n *     rule(type('foo'),\n *          score(attributesMatch(element,\n *                                attr => attr.includes('good'),\n *                                ['id', 'alt']) ? 2 : 1))\n *\n * @arg element {Node} Element whose attributes you want to search\n * @arg predicate {function} A condition to check. Take a string and\n *     return a boolean. If an attribute has multiple values (e.g. the class\n *     attribute), attributesMatch will check each one.\n * @arg attrs {string[]} An Array of attributes you want to search. If none are\n *     provided, search all.\n * @return Whether any of the attribute values satisfy the predicate function\n */\nfunction attributesMatch(element, predicate, attrs = []) {\n    const attributes = attrs.length === 0 ? Array.from(element.attributes).map(a => a.name) : attrs;\n    for (let i = 0; i < attributes.length; i++) {\n        const attr = element.getAttribute(attributes[i]);\n        // If the attribute is an array, apply the scoring function to each element\n        if (attr && ((Array.isArray(attr) && attr.some(predicate)) || predicate(attr))) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/* istanbul ignore next */\n/**\n * Yield an element and each of its ancestors.\n */\nfunction *ancestors(element) {\n    yield element;\n    let parent;\n    while ((parent = element.parentNode) !== null && parent.nodeType === parent.ELEMENT_NODE) {\n        yield parent;\n        element = parent;\n    }\n}\n\n/**\n * Return the sigmoid of the argument: 1 / (1 + exp(-x)). This is useful for\n * crunching a feature value that may have a wide range into the range (0, 1)\n * without a hard ceiling: the sigmoid of even a very large number will be a\n * little larger than that of a slightly smaller one.\n *\n * @arg x {Number} a number to be compressed into the range (0, 1)\n */\nfunction sigmoid(x) {\n    return 1 / (1 + Math.exp(-x));\n}\n\n/* istanbul ignore next */\n/**\n * Return whether an element is practically visible, considering things like 0\n * size or opacity, ``visibility: hidden`` and ``overflow: hidden``.\n *\n * Merely being scrolled off the page in either horizontally or vertically\n * doesn't count as invisible; the result of this function is meant to be\n * independent of viewport size.\n *\n * @throws {NoWindowError} The element (or perhaps one of its ancestors) is not\n *     in a window, so we can't find the `getComputedStyle()` routine to call.\n *     That routine is the source of most of the information we use, so you\n *     should pick a different strategy for non-window contexts.\n */\nfunction isVisible(fnodeOrElement) {\n    // This could be 5x more efficient if https://github.com/w3c/csswg-drafts/issues/4122 happens.\n    const element = toDomElement(fnodeOrElement);\n    const elementWindow = windowForElement(element);\n    const elementRect = element.getBoundingClientRect();\n    const elementStyle = elementWindow.getComputedStyle(element);\n    // Alternative to reading ``display: none`` due to Bug 1381071.\n    if (elementRect.width === 0 && elementRect.height === 0 && elementStyle.overflow !== 'hidden') {\n        return false;\n    }\n    if (elementStyle.visibility === 'hidden') {\n        return false;\n    }\n    // Check if the element is irrevocably off-screen:\n    if (elementRect.x + elementRect.width < 0 ||\n        elementRect.y + elementRect.height < 0\n    ) {\n        return false;\n    }\n    for (const ancestor of ancestors(element)) {\n        const isElement = ancestor === element;\n        const style = isElement ? elementStyle : elementWindow.getComputedStyle(ancestor);\n        if (style.opacity === '0') {\n            return false;\n        }\n        if (style.display === 'contents') {\n            // ``display: contents`` elements have no box themselves, but children are\n            // still rendered.\n            continue;\n        }\n        const rect = isElement ? elementRect : ancestor.getBoundingClientRect();\n        if ((rect.width === 0 || rect.height === 0) && elementStyle.overflow === 'hidden') {\n            // Zero-sized ancestors don’t make descendants hidden unless the descendant\n            // has ``overflow: hidden``.\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Return the extracted [r, g, b, a] values from a string like \"rgba(0, 5, 255, 0.8)\",\n * and scale them to 0..1. If no alpha is specified, return undefined for it.\n */\nfunction rgbaFromString(str) {\n    const m = str.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d+(?:\\.\\d+)?)\\s*)?\\)$/i);\n    if (m) {\n        return [m[1] / 255, m[2] / 255, m[3] / 255, m[4] === undefined ? undefined : parseFloat(m[4])];\n    } else {\n        throw new Error('Color ' + str + ' did not match pattern rgb[a](r, g, b[, a]).');\n    }\n}\n\n/**\n * Return the saturation 0..1 of a color defined by RGB values 0..1.\n */\nfunction saturation(r, g, b) {\n    const cMax = Math.max(r, g, b);\n    const cMin = Math.min(r, g, b);\n    const delta = cMax - cMin;\n    const lightness = (cMax + cMin) / 2;\n    const denom = (1 - (Math.abs(2 * lightness - 1)));\n    // Return 0 if it's black (R, G, and B all 0).\n    return (denom === 0) ? 0 : delta / denom;\n}\n\n/**\n * Scale a number to the range [0, 1] using a linear slope.\n *\n * For a rising line, the result is 0 until the input reaches zeroAt, then\n * increases linearly until oneAt, at which it becomes 1. To make a falling\n * line, where the result is 1 to the left and 0 to the right, use a zeroAt\n * greater than oneAt.\n */\nfunction linearScale(number, zeroAt, oneAt) {\n    const isRising = zeroAt < oneAt;\n    if (isRising) {\n        if (number <= zeroAt) {\n            return 0;\n        } else if (number >= oneAt) {\n            return 1;\n        }\n    } else {\n        if (number >= zeroAt) {\n            return 0;\n        } else if (number <= oneAt) {\n            return 1;\n        }\n    }\n    const slope = 1 / (oneAt - zeroAt);\n    return slope * (number - zeroAt);\n}\n\n// -------- Routines below this point are private to the framework. --------\n\n/**\n * Flatten out an iterable of iterables into a single iterable of non-\n * iterables. Does not consider strings to be iterable.\n */\nfunction *flatten(iterable) {\n    for (const i of iterable) {\n        if (typeof i !== 'string' && isIterable(i)) {\n            yield *(flatten(i));\n        } else {\n            yield i;\n        }\n    }\n}\n\n/**\n * A lazy, top-level ``Array.map()`` workalike that works on anything iterable\n */\nfunction *map(fn, iterable) {\n    for (const i of iterable) {\n        yield fn(i);\n    }\n}\n\n/**\n * A lazy, top-level ``Array.forEach()`` workalike that works on anything\n * iterable\n */\nfunction forEach(fn, iterable) {\n    for (const i of iterable) {\n        fn(i);\n    }\n}\n\n/* istanbul ignore next */\n/**\n * @return whether a thing appears to be a DOM element.\n */\nfunction isDomElement(thing) {\n    return thing.nodeName !== undefined;\n}\n\nfunction isIterable(thing) {\n    return thing && typeof thing[Symbol.iterator] === 'function';\n}\n\n/**\n * Return an backward iterator over an Array without reversing it in place.\n */\nfunction *reversed(array) {\n    for (let i = array.length - 1; i >= 0; i--) {\n        yield array[i];\n    }\n}\n\n/* istanbul ignore next */\n/*\n * Return the window an element is in.\n *\n * @throws {NoWindowError} There isn't such a window.\n */\nfunction windowForElement(element) {\n    let doc = element.ownerDocument;\n    if (doc === null) {\n        // The element itself was a document.\n        doc = element;\n    }\n    const win = doc.defaultView;\n    if (win === null) {\n        throw new NoWindowError();\n    }\n    return win;\n}\n\nvar utilsForFrontend = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  identity: identity,\n  best: best,\n  max: max,\n  maxes: maxes,\n  min: min,\n  sum: sum,\n  length: length,\n  walk: walk,\n  isBlock: isBlock,\n  inlineTexts: inlineTexts,\n  inlineTextLength: inlineTextLength,\n  collapseWhitespace: collapseWhitespace,\n  linkDensity: linkDensity,\n  isWhitespace: isWhitespace,\n  setDefault: setDefault,\n  getDefault: getDefault,\n  toposort: toposort,\n  NiceSet: NiceSet,\n  first: first,\n  rootElement: rootElement,\n  numberOfMatches: numberOfMatches,\n  page: page,\n  domSort: domSort,\n  toDomElement: toDomElement,\n  attributesMatch: attributesMatch,\n  ancestors: ancestors,\n  sigmoid: sigmoid,\n  isVisible: isVisible,\n  rgbaFromString: rgbaFromString,\n  saturation: saturation,\n  linearScale: linearScale,\n  flatten: flatten,\n  map: map,\n  forEach: forEach,\n  isDomElement: isDomElement,\n  reversed: reversed,\n  windowForElement: windowForElement\n});\n\n/**\n * Return the number of stride nodes between 2 DOM nodes *at the same\n * level of the tree*, without going up or down the tree.\n *\n * ``left`` xor ``right`` may also be undefined.\n */\nfunction numStrides(left, right) {\n    let num = 0;\n\n    // Walk right from left node until we hit the right node or run out:\n    let sibling = left;\n    let shouldContinue = sibling && sibling !== right;\n    while (shouldContinue) {\n        sibling = sibling.nextSibling;\n        if ((shouldContinue = sibling && sibling !== right) &&\n            !isWhitespace(sibling)) {\n            num += 1;\n        }\n    }\n    if (sibling !== right) {  // Don't double-punish if left and right are siblings.\n        // Walk left from right node:\n        sibling = right;\n        while (sibling) {\n            sibling = sibling.previousSibling;\n            if (sibling && !isWhitespace(sibling)) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}\n\n/**\n * Return a topological distance between 2 DOM nodes or :term:`fnodes<fnode>`\n * weighted according to the similarity of their ancestry in the DOM. For\n * instance, if one node is situated inside ``<div><span><b><theNode>`` and the\n * other node is at ``<differentDiv><span><b><otherNode>``, they are considered\n * close to each other for clustering purposes. This is useful for picking out\n * nodes which have similar purposes.\n *\n * Return ``Number.MAX_VALUE`` if one of the nodes contains the other.\n *\n * This is largely an implementation detail of :func:`clusters`, but you can\n * call it yourself if you wish to implement your own clustering. Takes O(n log\n * n) time.\n *\n * Note that the default costs may change; pass them in explicitly if they are\n * important to you.\n *\n * @arg fnodeA {Node|Fnode}\n * @arg fnodeB {Node|Fnode}\n * @arg differentDepthCost {number} Cost for each level deeper one node is than\n *    the other below their common ancestor\n * @arg differentTagCost {number} Cost for a level below the common ancestor\n *    where tagNames differ\n * @arg sameTagCost {number} Cost for a level below the common ancestor where\n *    tagNames are the same\n * @arg strideCost {number} Cost for each stride node between A and B. Stride\n *     nodes are siblings or siblings-of-ancestors that lie between the 2\n *     nodes. These interposed nodes make it less likely that the 2 nodes\n *     should be together in a cluster.\n * @arg additionalCost {function} Return an additional cost, given 2 fnodes or\n *    nodes.\n *\n */\nfunction distance(fnodeA,\n                         fnodeB,\n                         {differentDepthCost = 2,\n                          differentTagCost = 2,\n                          sameTagCost = 1,\n                          strideCost = 1,\n                          additionalCost = (fnodeA, fnodeB) => 0} = {}) {\n    // I was thinking of something that adds little cost for siblings. Up\n    // should probably be more expensive than down (see middle example in the\n    // Nokia paper).\n\n    // TODO: Test and tune default costs. They're off the cuff at the moment.\n\n    if (fnodeA === fnodeB) {\n        return 0;\n    }\n\n    const elementA = isDomElement(fnodeA) ? fnodeA : fnodeA.element;\n    const elementB = isDomElement(fnodeB) ? fnodeB : fnodeB.element;\n\n    // Stacks that go from the common ancestor all the way to A and B:\n    const aAncestors = [elementA];\n    const bAncestors = [elementB];\n\n    let aAncestor = elementA;\n    let bAncestor = elementB;\n\n    // Ascend to common parent, stacking them up for later reference:\n    while (!aAncestor.contains(elementB)) {  // Note: an element does contain() itself.\n        aAncestor = aAncestor.parentNode;\n        aAncestors.push(aAncestor); //aAncestors = [a, b]. aAncestor = b // if a is outer: no loop here; aAncestors = [a]. aAncestor = a.\n    }\n\n    // In compareDocumentPosition()'s opinion, inside implies after. Basically,\n    // before and after pertain to opening tags.\n    const comparison = elementA.compareDocumentPosition(elementB);\n\n    // If either contains the other, abort. We'd either return a misleading\n    // number or else walk upward right out of the document while trying to\n    // make the ancestor stack.\n    if (comparison & (elementA.DOCUMENT_POSITION_CONTAINS | elementA.DOCUMENT_POSITION_CONTAINED_BY)) {\n        return Number.MAX_VALUE;\n    }\n    // Make an ancestor stack for the right node too so we can walk\n    // efficiently down to it:\n    do {\n        bAncestor = bAncestor.parentNode;  // Assumes we've early-returned above if A === B. This walks upward from the outer node and up out of the tree. It STARTS OUT with aAncestor === bAncestor!\n        bAncestors.push(bAncestor);\n    } while (bAncestor !== aAncestor);\n\n    // Figure out which node is left and which is right, so we can follow\n    // sibling links in the appropriate directions when looking for stride\n    // nodes:\n    let left = aAncestors;\n    let right = bAncestors;\n    let cost = 0;\n    if (comparison & elementA.DOCUMENT_POSITION_FOLLOWING) {\n        // A is before, so it could contain the other node. What did I mean to do if one contained the other?\n        left = aAncestors;\n        right = bAncestors;\n    } else if (comparison & elementA.DOCUMENT_POSITION_PRECEDING) {\n        // A is after, so it might be contained by the other node.\n        left = bAncestors;\n        right = aAncestors;\n    }\n\n    // Descend to both nodes in parallel, discounting the traversal\n    // cost iff the nodes we hit look similar, implying the nodes dwell\n    // within similar structures.\n    while (left.length || right.length) {\n        const l = left.pop();\n        const r = right.pop();\n        if (l === undefined || r === undefined) {\n            // Punishment for being at different depths: same as ordinary\n            // dissimilarity punishment for now\n            cost += differentDepthCost;\n        } else {\n            // TODO: Consider similarity of classList.\n            cost += l.tagName === r.tagName ? sameTagCost : differentTagCost;\n        }\n        // Optimization: strides might be a good dimension to eliminate.\n        if (strideCost !== 0) {\n            cost += numStrides(l, r) * strideCost;\n        }\n    }\n\n    return cost + additionalCost(fnodeA, fnodeB);\n}\n\n/**\n * Return the spatial distance between 2 fnodes or elements, assuming a\n * rendered page.\n *\n * Specifically, return the distance in pixels between the centers of\n * ``fnodeA.element.getBoundingClientRect()`` and\n * ``fnodeB.element.getBoundingClientRect()``.\n */\nfunction euclidean(fnodeA, fnodeB) {\n    /**\n     * Return the horizontal distance from the left edge of the viewport to the\n     * center of an element, given a DOMRect object for it. It doesn't matter\n     * that the distance is affected by the page's scroll offset, since the 2\n     * elements have the same offset.\n     */\n    function xCenter(domRect) {\n        return domRect.left + domRect.width / 2;\n    }\n    function yCenter(domRect) {\n        return domRect.top + domRect.height / 2;\n    }\n\n    const elementA = toDomElement(fnodeA);\n    const elementB = toDomElement(fnodeB);\n    const aRect = elementA.getBoundingClientRect();\n    const bRect = elementB.getBoundingClientRect();\n    return Math.sqrt((xCenter(aRect) - xCenter(bRect)) ** 2 +\n                     (yCenter(aRect) - yCenter(bRect)) ** 2);\n}\n\n/** A lower-triangular matrix of inter-cluster distances */\nclass DistanceMatrix {\n    /**\n     * @arg distance {function} Some notion of distance between 2 given nodes\n     */\n    constructor(elements, distance) {\n        // A sparse adjacency matrix:\n        // {A => {},\n        //  B => {A => 4},\n        //  C => {A => 4, B => 4},\n        //  D => {A => 4, B => 4, C => 4}\n        //  E => {A => 4, B => 4, C => 4, D => 4}}\n        //\n        // A, B, etc. are arrays of [arrays of arrays of...] nodes, each\n        // array being a cluster. In this way, they not only accumulate a\n        // cluster but retain the steps along the way.\n        //\n        // This is an efficient data structure in terms of CPU and memory, in\n        // that we don't have to slide a lot of memory around when we delete a\n        // row or column from the middle of the matrix while merging. Of\n        // course, we lose some practical efficiency by using hash tables, and\n        // maps in particular are slow in their early implementations.\n        this._matrix = new Map();\n\n        // Convert elements to clusters:\n        const clusters = elements.map(el => [el]);\n\n        // Init matrix:\n        for (let outerCluster of clusters) {\n            const innerMap = new Map();\n            for (let innerCluster of this._matrix.keys()) {\n                innerMap.set(innerCluster, distance(outerCluster[0],\n                                                    innerCluster[0]));\n            }\n            this._matrix.set(outerCluster, innerMap);\n        }\n        this._numClusters = clusters.length;\n    }\n\n    // Return (distance, a: clusterA, b: clusterB) of closest-together clusters.\n    // Replace this to change linkage criterion.\n    closest() {\n        const self = this;\n\n        if (this._numClusters < 2) {\n            throw new Error('There must be at least 2 clusters in order to return the closest() ones.');\n        }\n\n        // Return the distances between every pair of clusters.\n        function clustersAndDistances() {\n            const ret = [];\n            for (let [outerKey, row] of self._matrix.entries()) {\n                for (let [innerKey, storedDistance] of row.entries()) {\n                    ret.push({a: outerKey, b: innerKey, distance: storedDistance});\n                }\n            }\n            return ret;\n        }\n        // Optimizing this by inlining the loop and writing it less\n        // functionally doesn't help:\n        return min(clustersAndDistances(), x => x.distance);\n    }\n\n    // Look up the distance between 2 clusters in me. Try the lookup in the\n    // other direction if the first one falls in the nonexistent half of the\n    // triangle.\n    _cachedDistance(clusterA, clusterB) {\n        let ret = this._matrix.get(clusterA).get(clusterB);\n        if (ret === undefined) {\n            ret = this._matrix.get(clusterB).get(clusterA);\n        }\n        return ret;\n    }\n\n    // Merge two clusters.\n    merge(clusterA, clusterB) {\n        // An example showing how rows merge:\n        //  A: {}\n        //  B: {A: 1}\n        //  C: {A: 4, B: 4},\n        //  D: {A: 4, B: 4, C: 4}\n        //  E: {A: 4, B: 4, C: 2, D: 4}}\n        //\n        // Step 2:\n        //  C: {}\n        //  D: {C: 4}\n        //  E: {C: 2, D: 4}}\n        //  AB: {C: 4, D: 4, E: 4}\n        //\n        // Step 3:\n        //  D:  {}\n        //  AB: {D: 4}\n        //  CE: {D: 4, AB: 4}\n\n        // Construct new row, finding min distances from either subcluster of\n        // the new cluster to old clusters.\n        //\n        // There will be no repetition in the matrix because, after all,\n        // nothing pointed to this new cluster before it existed.\n        const newRow = new Map();\n        for (let outerKey of this._matrix.keys()) {\n            if (outerKey !== clusterA && outerKey !== clusterB) {\n                newRow.set(outerKey, Math.min(this._cachedDistance(clusterA, outerKey),\n                                              this._cachedDistance(clusterB, outerKey)));\n            }\n        }\n\n        // Delete the rows of the clusters we're merging.\n        this._matrix.delete(clusterA);\n        this._matrix.delete(clusterB);\n\n        // Remove inner refs to the clusters we're merging.\n        for (let inner of this._matrix.values()) {\n            inner.delete(clusterA);\n            inner.delete(clusterB);\n        }\n\n        // Attach new row.\n        this._matrix.set([clusterA, clusterB], newRow);\n\n        // There is a net decrease of 1 cluster:\n        this._numClusters -= 1;\n    }\n\n    numClusters() {\n        return this._numClusters;\n    }\n\n    // Return an Array of nodes for each cluster in me.\n    clusters() {\n        // TODO: Can't get map to work here. Don't know why.\n        return Array.from(this._matrix.keys()).map(e => Array.from(flatten(e)));\n    }\n}\n\n/**\n * Partition the given nodes into one or more clusters by position in the DOM\n * tree.\n *\n * This implements an agglomerative clustering. It uses single linkage, since\n * we're talking about adjacency here more than Euclidean proximity: the\n * clusters we're talking about in the DOM will tend to be adjacent, not\n * overlapping. We haven't tried other linkage criteria yet.\n *\n * In a later release, we may consider score or notes.\n *\n * @arg {Fnode[]|Node[]} fnodes :term:`fnodes<fnode>` or DOM nodes to group\n *     into clusters\n * @arg {number} splittingDistance The closest-nodes :func:`distance` beyond\n *     which we will not attempt to unify 2 clusters. Make this larger to make\n *     larger clusters.\n * @arg getDistance {function} A function that returns some notion of numerical\n *    distance between 2 nodes. Default: :func:`distance`\n * @return {Array} An Array of Arrays, with each Array containing all the\n *     nodes in one cluster. Note that neither the clusters nor the nodes are\n *     in any particular order. You may find :func:`domSort` helpful to remedy\n *     the latter.\n */\nfunction clusters(fnodes, splittingDistance, getDistance = distance) {\n    const matrix = new DistanceMatrix(fnodes, getDistance);\n    let closest;\n\n    while (matrix.numClusters() > 1 && (closest = matrix.closest()).distance < splittingDistance) {\n        matrix.merge(closest.a, closest.b);\n    }\n\n    return matrix.clusters();\n}\n\nvar clusters$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  distance: distance,\n  euclidean: euclidean,\n  clusters: clusters\n});\n\n// The left-hand side of a rule\n\n\n/**\n * Take nodes that match a given DOM selector. Example:\n * ``dom('meta[property=\"og:title\"]')``\n *\n * Every ruleset has at least one ``dom`` or :func:`element` rule, as that is\n * where nodes begin to flow into the system. If run against a subtree of a\n * document, the root of the subtree is not considered as a possible match.\n */\nfunction dom(selector) {\n    return new DomLhs(selector);\n}\n\n/**\n * Take a single given node if it matches a given DOM selector, without looking\n * through its descendents or ancestors. Otherwise, take no nodes. Example:\n * ``element('input')``\n *\n * This is useful for applications in which you want Fathom to classify an\n * element the user has selected, rather than scanning the whole page for\n * candidates.\n */\nfunction element(selector) {\n    return new ElementLhs(selector);\n}\n\n/**\n * Rules and the LHSs and RHSs that comprise them have no mutable state. This\n * lets us make BoundRulesets from Rulesets without duplicating the rules. It\n * also lets us share a common cache among rules: multiple ones might care\n * about a cached type(), for instance; there isn't a one-to-one relationship\n * of storing with caring. There would also, because of the interdependencies\n * of rules in a ruleset, be little use in segmenting the caches: if you do\n * something that causes one to need to be cleared, you'll need to clear many\n * more as well.\n *\n * Lhses are responsible for maintaining ruleset.maxCache.\n *\n * Lhs and its subclasses are private to the Fathom framework.\n */\nclass Lhs {\n    constructor() {\n        this._predicate = () => true;\n    }\n\n    /** Return a new Lhs of the appropriate kind, given its first call. */\n    static fromFirstCall(firstCall) {\n        // firstCall is never 'dom', because dom() directly returns a DomLhs.\n        if (firstCall.method === 'type') {\n            return new TypeLhs(...firstCall.args);\n        } else if (firstCall.method === 'and') {\n            return new AndLhs(firstCall.args);\n        } else if (firstCall.method === 'nearest') {\n            return new NearestLhs(firstCall.args);\n        } else {\n            throw new Error('The left-hand side of a rule() must start with dom(), type(), and(), or nearest().');\n        }\n    }\n\n    /**\n     * Prune nodes from consideration early in run execution, before scoring is\n     * done.\n     *\n     * Reserve this for where you are sure it is always correct or when\n     * performance demands it. It is generally preferable to use :func:`score`\n     * and let the :doc:`trainer<training>` determine the relative significance\n     * of each rule. Human intuition as to what is important is often wrong:\n     * for example, one might assume that a music player website would include\n     * the word \"play\", but this does not hold once you include sites in other\n     * languages.\n     *\n     * Can be chained after :func:`type` or :func:`dom`.\n     *\n     * Example: ``dom('p').when(isVisible)``\n     *\n     * @arg {function} predicate Accepts a fnode and returns a boolean\n     */\n    when(predicate) {\n        let lhs = this.clone();\n        lhs._predicate = predicate;\n        return lhs;\n    }\n\n    /**\n     * Of all the dom nodes selected by type() or dom(), return only\n     * the fnodes that satisfy all the predicates imposed by calls to\n     * when()\n     */\n    fnodesSatisfyingWhen(fnodes) {\n        return Array.from(fnodes).filter(this._predicate);\n    }\n\n    /**\n     * Return an iterable of output fnodes selected by this left-hand-side\n     * expression.\n     *\n     * Pre: The rules I depend on have already been run, and their results are\n     * in ruleset.typeCache.\n     *\n     * @arg ruleset {BoundRuleset}\n     */\n    // fnodes (ruleset) {}\n\n    /**\n     * Check that a RHS-emitted fact is legal for this kind of LHS, and throw\n     * an error if it isn't.\n     */\n    checkFact(fact) {}\n\n    /**\n     * Return the single type the output of the LHS is guaranteed to have.\n     * Return undefined if there is no such single type we can ascertain.\n     */\n    guaranteedType() {}\n\n    /**\n     * Return the type I aggregate if I am an aggregate LHS; return undefined\n     * otherwise.\n     */\n    aggregatedType() {}\n\n    /**\n     * Return each combination of types my selected nodes could be locally (that\n     * is, by this rule only) constrained to have.\n     *\n     * For example, type(A) would return [A]. and(A, or(B, C)) would return\n     * [AB, AC, ABC]. More examples:\n     *\n     * or(A, B) → typeIn(A, B, C)  # Finalizes A, B.   combos A, B, AB: finalizes AB. Optimization: there's no point in returning the last combo in ors. Compilation into 2 rules with identical RHSs will inherently implement this optimization.\n     * or(A, B) → typeIn(A, B)  # Finalizes A, B\n     * or(A, B) → A  # Finalizes B\n     * and(A) -> A  # Finalizes nothing\n     * and(A, B) -> A  # Finalizes nothing.   AB: Ø\n     * and(A) -> typeIn(A, B)  # Finalizes A.   A\n     * and(A, B) -> typeIn(A, B)  # Finalizes nothing.   AB\n     * and(A, B) -> typeIn(A, B, C)  # Finalizes A, B.   AB\n     * and(A, or(B, C)) -> D  # Finalizes A, B, C.   AB, AC, ABC: ABC\n     * and(A, or(B, C)) -> B  # Finalizes A, C.   AB, AC, ABC: AC\n     * type(A).not(and(A, B)) ->\n     *\n     * @return {NiceSet[]}\n     */\n    // possibleTypeCombinations() {}\n\n    /**\n     * Types mentioned in this LHS.\n     *\n     * In other words, the types I need to know the assignment status of before\n     * I can make my selections\n     *\n     * @return NiceSet of strings\n     */\n    // typesMentioned() {}\n}\n\nclass DomLhs extends Lhs {\n    constructor(selector) {\n        super();\n        if (selector === undefined) {\n            throw new Error('A querySelector()-style selector is required as the argument to ' + this._callName() + '().');\n        }\n        this.selector = selector;\n    }\n\n    /**\n     * Return the name of this kind of LHS, for use in error messages.\n     */\n    _callName() {\n        return 'dom';\n    }\n\n    clone() {\n        return new this.constructor(this.selector);\n    }\n\n    fnodes(ruleset) {\n        return this._domNodesToFilteredFnodes(\n            ruleset,\n            ruleset.doc.querySelectorAll(this.selector));\n    }\n\n    /**\n     * Turn a NodeList of DOM nodes into an array of fnodes, and filter out\n     * those that don't match the :func:`when()` clause.\n     */\n    _domNodesToFilteredFnodes(ruleset, domNodes) {\n        let ret = [];\n        for (let i = 0; i < domNodes.length; i++) {\n            ret.push(ruleset.fnodeForElement(domNodes[i]));\n        }\n        return this.fnodesSatisfyingWhen(ret);\n    }\n\n    checkFact(fact) {\n        if (fact.type === undefined) {\n            throw new Error(`The right-hand side of a ${this._callName()}() rule failed to specify a type. This means there is no way for its output to be used by later rules. All it specified was ${fact}.`);\n        }\n    }\n\n    asLhs() {\n        return this;\n    }\n\n    possibleTypeCombinations() {\n        return [];\n    }\n\n    typesMentioned() {\n        return new NiceSet();\n    }\n}\n\nclass ElementLhs extends DomLhs {\n    _callName() {\n        return 'element';\n    }\n\n    fnodes(ruleset) {\n        return this._domNodesToFilteredFnodes(\n            ruleset,\n            ruleset.doc.matches(this.selector) ? [ruleset.doc] : []);\n    }\n}\n\n/** Internal representation of a LHS constrained by type but not by max() */\nclass TypeLhs extends Lhs {\n    constructor(type) {\n        super();\n        if (type === undefined) {\n            throw new Error('A type name is required when calling type().');\n        }\n        this._type = type;  // the input type\n    }\n\n    clone() {\n        return new this.constructor(this._type);\n    }\n\n    fnodes(ruleset) {\n        const cached = getDefault(ruleset.typeCache, this._type, () => []);\n        return this.fnodesSatisfyingWhen(cached);\n    }\n\n    /** Override the type previously specified by this constraint. */\n    type(inputType) {\n        // Preserve the class in case this is a TypeMaxLhs.\n        return new this.constructor(inputType);\n    }\n\n    /**\n     * Of the nodes selected by a ``type`` call to the left, constrain the LHS\n     * to return only the max-scoring one. If there is a tie, more than 1 node\n     * will be returned. Example: ``type('titley').max()``\n     */\n    max() {\n        return new TypeMaxLhs(this._type);\n    }\n\n    /**\n     * Take the nodes selected by a ``type`` call to the left, group them into\n     * clusters, and return the nodes in the cluster that has the highest total\n     * score (on the relevant type).\n     *\n     * Nodes come out in arbitrary order, so, if you plan to emit them,\n     * consider using ``.out('whatever').allThrough(domSort)``. See\n     * :func:`domSort`.\n     *\n     * If multiple clusters have equally high scores, return an arbitrary one,\n     * because Fathom has no way to represent arrays of arrays in rulesets.\n     *\n     * @arg options {Object} The same depth costs taken by :func:`distance`,\n     *     plus ``splittingDistance``, which is the distance beyond which 2\n     *     clusters will be considered separate. ``splittingDistance``, if\n     *     omitted, defaults to 3.\n     */\n    bestCluster(options) {\n        return new BestClusterLhs(this._type, options);\n    }\n\n    // Other clustering calls could be called biggestCluster() (having the most\n    // nodes) and bestAverageCluster() (having the highest average score).\n\n    guaranteedType() {\n        return this._type;\n    }\n\n    possibleTypeCombinations() {\n        return [this.typesMentioned()];\n    }\n\n    typesMentioned() {\n        return new NiceSet([this._type]);\n    }\n}\n\n/**\n * Abstract LHS that is an aggregate function taken across all fnodes of a type\n *\n * The main point here is that any aggregate function over a (typed) set of\n * nodes depends on first computing all the rules that could emit those nodes\n * (nodes of that type).\n */\nclass AggregateTypeLhs extends TypeLhs {\n    aggregatedType() {\n        return this._type;\n    }\n}\n\n/**\n * Internal representation of a LHS that has both type and max([NUMBER])\n * constraints. max(NUMBER != 1) support is not yet implemented.\n */\nclass TypeMaxLhs extends AggregateTypeLhs {\n    /**\n     * Return the max-scoring node (or nodes if there is a tie) of the given\n     * type.\n     */\n    fnodes(ruleset) {\n        // TODO: Optimize better. Walk the dependency tree, and run only the\n        // rules that could possibly lead to a max result. As part of this,\n        // make RHSs expose their max potential scores.\n        const self = this;\n        // Work around V8 bug:\n        // https://stackoverflow.com/questions/32943776/using-super-within-an-\n        // arrow-function-within-an-arrow-function-within-a-method\n        const getSuperFnodes = () => super.fnodes(ruleset);\n        return setDefault(\n            ruleset.maxCache,\n            this._type,\n            function maxFnodesOfType() {\n                return maxes(getSuperFnodes(), fnode => ruleset.weightedScore(fnode.scoresSoFarFor(self._type)));\n            });\n    }\n}\n\nclass BestClusterLhs extends AggregateTypeLhs {\n    constructor(type, options) {\n        super(type);\n        this._options = options || {splittingDistance: 3};\n    }\n\n    /**\n     * Group the nodes of my type into clusters, and return the cluster with\n     * the highest total score for that type.\n     */\n    fnodes(ruleset) {\n        // Get the nodes of the type:\n        const fnodesOfType = Array.from(super.fnodes(ruleset));\n        if (fnodesOfType.length === 0) {\n            return [];\n        }\n        // Cluster them:\n        const clusts = clusters(\n            fnodesOfType,\n            this._options.splittingDistance,\n            (a, b) => distance(a, b, this._options));\n        // Tag each cluster with the total of its nodes' scores:\n        const clustsAndSums = clusts.map(\n            clust => [clust,\n                      sum(clust.map(fnode => fnode.scoreFor(this._type)))]);\n        // Return the highest-scoring cluster:\n        return max(clustsAndSums, clustAndSum => clustAndSum[1])[0];\n    }\n}\n\nclass AndLhs extends Lhs {\n    constructor(lhss) {\n        super();\n\n        // For the moment, we accept only type()s as args. TODO: Generalize to\n        // type().max() and such later.\n        this._args = lhss.map(sideToTypeLhs);\n    }\n\n    *fnodes(ruleset) {\n        // Take an arbitrary one for starters. Optimization: we could always\n        // choose the pickiest one to start with.\n        const fnodes = this._args[0].fnodes(ruleset);\n        // Then keep only the fnodes that have the type of every other arg:\n        fnodeLoop: for (let fnode of fnodes) {\n            for (let otherLhs of this._args.slice(1)) {\n                // Optimization: could use a .hasTypeSoFar() below\n                if (!fnode.hasType(otherLhs.guaranteedType())) {\n                    // TODO: This is n^2. Why is there no set intersection in JS?!\n                    continue fnodeLoop;\n                }\n            }\n            yield fnode;\n        }\n    }\n\n    possibleTypeCombinations() {\n        return [this.typesMentioned()];\n    }\n\n    typesMentioned() {\n        return new NiceSet(this._args.map(arg => arg.guaranteedType()));\n    }\n}\n\nfunction sideToTypeLhs(side) {\n    const lhs = side.asLhs();\n    if (!(lhs.constructor === TypeLhs)) {\n        throw new Error('and() and nearest() support only simple type() calls as arguments for now.');\n        // TODO: Though we could solve this with a compilation step: and(type(A), type(B).max()) is equivalent to type(B).max() -> type(Bmax); and(type(A), type(Bmax)).\n        // In fact, we should be able to compile most (any?) arbitrary and()s, including nested ands and and(type(...).max(), ...) constructions into several and(type(A), type(B), ...) rules.\n    }\n    return lhs;\n}\n\nclass NearestLhs extends Lhs {\n    constructor([a, b, distance]) {\n        super();\n        this._a = sideToTypeLhs(a);\n        this._b = sideToTypeLhs(b);\n        this._distance = distance;\n    }\n\n    /**\n     * Return an iterable of {fnodes, transformer} pairs.\n     */\n    *fnodes(ruleset) {\n        // Go through all the left arg's nodes. For each one, find the closest\n        // right-arg's node. O(a * b). Once a right-arg's node is used, we\n        // don't eliminate it from consideration, because then order of left-\n        // args' nodes would matter.\n\n        // TODO: Still not sure how to get the distance to factor into the\n        // score unless we hard-code nearest() to do that. It's a\n        // matter of not being able to bind on the RHS to the output of the\n        // distance function on the LHS. Perhaps we could at least make\n        // distance part of the note and read it in a props() callback.\n\n        // We're assuming here that simple type() calls return just plain\n        // fnodes, not {fnode, rhsTransformer} pairs:\n        const as_ = this._a.fnodes(ruleset);\n        const bs = Array.from(this._b.fnodes(ruleset));\n        if (bs.length > 0) {\n            // If bs is empty, there can be no nearest nodes, so don't emit any.\n            for (const a of as_) {\n                const nearest = min(bs, b => this._distance(a, b));\n                yield {fnode: a,\n                       rhsTransformer: function setNoteIfEmpty(fact) {\n                           // If note is explicitly set by the RHS, let it take\n                           // precedence, even though that makes this entire LHS\n                           // pointless.\n                           if (fact.note === undefined) {\n                               fact.note = nearest;  // TODO: Wrap this in an object to make room to return distance later.\n                           }\n                           return fact;\n                       }};\n            }\n        }\n    }\n\n    checkFact(fact) {\n        // Barf if the fact doesn't set a type at least. It should be a *new* type or at least one that doesn't result in cycles, but we can't deduce that.\n    }\n\n    possibleTypeCombinations() {\n        return [new NiceSet([this._a.guaranteedType()])];\n    }\n\n    typesMentioned() {\n        return new NiceSet([this._a.guaranteedType(),\n                            this._b.guaranteedType()]);\n    }\n\n    guaranteedType() {\n        return this._a.guaranteedType();\n    }\n}\n\n// The right-hand side of a rule\n\n\nconst TYPE = 1;\nconst NOTE = 2;\nconst SCORE = 4;\nconst ELEMENT = 8;\nconst SUBFACTS = {\n    type: TYPE,\n    note: NOTE,\n    score: SCORE,\n    element: ELEMENT\n};\n\n/**\n * Expose the output of this rule's LHS as a \"final result\" to the surrounding\n * program. It will be available by calling :func:`~BoundRuleset.get` on the\n * ruleset and passing the key. You can run each node through a callback\n * function first by adding :func:`through()`, or you can run the entire set of\n * nodes through a callback function by adding :func:`allThrough()`.\n */\nfunction out(key) {\n    return new OutwardRhs(key);\n}\n\nclass InwardRhs {\n    constructor(calls = [], max = Infinity, types) {\n        this._calls = calls.slice();\n        this._max = max;  // max score\n        this._types = new NiceSet(types);  // empty set if unconstrained\n    }\n\n    /**\n     * Declare that the maximum returned subscore is such and such,\n     * which helps the optimizer plan efficiently. This doesn't force it to be\n     * true; it merely throws an error at runtime if it isn't. To lift an\n     * ``atMost`` constraint, call ``atMost()`` (with no args). The reason\n     * ``atMost`` and ``typeIn`` apply until explicitly cleared is so that, if\n     * someone used them for safety reasons on a lexically distant rule you are\n     * extending, you won't stomp on their constraint and break their\n     * invariants accidentally.\n     */\n    atMost(score) {\n        return new this.constructor(this._calls, score, this._types);\n    }\n\n    _checkAtMost(fact) {\n        if (fact.score !== undefined && fact.score > this._max) {\n            throw new Error(`Score of ${fact.score} exceeds the declared atMost(${this._max}).`);\n        }\n    }\n\n    /**\n      * Determine any of type, note, score, and element using a callback. This\n      * overrides any previous call to `props` and, depending on what\n      * properties of the callback's return value are filled out, may override\n      * the effects of other previous calls as well.\n      *\n      * The callback should return...\n      *\n      * * An optional :term:`subscore`\n      * * A type (required on ``dom(...)`` rules, defaulting to the input one on\n      *   ``type(...)`` rules)\n      * * Optional notes\n      * * An element, defaulting to the input one. Overriding the default\n      *   enables a callback to walk around the tree and say things about nodes\n      *   other than the input one.\n      */\n    props(callback) {\n        function getSubfacts(fnode) {\n            const subfacts = callback(fnode);\n            // Filter the raw result down to okayed properties so callbacks\n            // can't insert arbitrary keys (like conserveScore, which might\n            // mess up the optimizer).\n            for (let subfact in subfacts) {\n                if (!SUBFACTS.hasOwnProperty(subfact) || !(SUBFACTS[subfact] & getSubfacts.possibleSubfacts)) {\n                    // The ES5.1 spec says in 12.6.4 that it's fine to delete\n                    // as we iterate.\n                    delete subfacts[subfact];\n                }\n            }\n            return subfacts;\n        }\n        // Thse are the subfacts this call could affect:\n        getSubfacts.possibleSubfacts = TYPE | NOTE | SCORE | ELEMENT;\n        getSubfacts.kind = 'props';\n        return new this.constructor(this._calls.concat(getSubfacts),\n                                    this._max,\n                                    this._types);\n    }\n\n    /**\n     * Set the type applied to fnodes processed by this RHS.\n     */\n    type(theType) {\n        // In the future, we might also support providing a callback that receives\n        // the fnode and returns a type. We couldn't reason based on these, but the\n        // use would be rather a consise way to to override part of what a previous\n        // .props() call provides.\n\n        // Actually emit a given type.\n        function getSubfacts() {\n            return {type: theType};\n        }\n        getSubfacts.possibleSubfacts = TYPE;\n        getSubfacts.type = theType;\n        getSubfacts.kind = 'type';\n        return new this.constructor(this._calls.concat(getSubfacts),\n                                    this._max,\n                                    this._types);\n    }\n\n    /**\n     * Constrain this rule to emit 1 of a set of given types. Pass no args to lift\n     * a previous ``typeIn`` constraint, as you might do when basing a LHS on a\n     * common value to factor out repetition.\n     *\n     * ``typeIn`` is mostly a hint for the query planner when you're emitting types\n     * dynamically from ``props`` calls—in fact, an error will be raised if\n     * ``props`` is used without a ``typeIn`` or ``type`` to constrain it—but it\n     * also checks conformance at runtime to ensure validity.\n     */\n    typeIn(...types) {\n        // Rationale: If we used the spelling \"type('a', 'b', ...)\" instead of\n        // this, one might expect type('a', 'b').type(fn) to have the latter\n        // call override, while expecting type(fn).type('a', 'b') to keep both\n        // in effect. Then different calls to type() don't consistently\n        // override each other, and the rules get complicated. Plus you can't\n        // inherit a type constraint and then sub in another type-returning\n        // function that still gets the constraint applied.\n        return new this.constructor(this._calls,\n                                    this._max,\n                                    types);\n    }\n\n    /**\n     * Check a fact for conformance with any typeIn() call.\n     *\n     * @arg leftType the type of the LHS, which becomes my emitted type if the\n     *    fact doesn't specify one\n     */\n    _checkTypeIn(result, leftType) {\n        if (this._types.size > 0) {\n            if (result.type === undefined) {\n                if (!this._types.has(leftType)) {\n                    throw new Error(`A right-hand side claimed, via typeIn(...) to emit one of the types ${this._types} but actually inherited ${leftType} from the left-hand side.`);\n                }\n            } else if (!this._types.has(result.type)) {\n                throw new Error(`A right-hand side claimed, via typeIn(...) to emit one of the types ${this._types} but actually emitted ${result.type}.`);\n            }\n        }\n    }\n\n    /**\n     * Whatever the callback returns (even ``undefined``) becomes the note of\n     * the fact. This overrides any previous call to ``note``.\n     */\n    note(callback) {\n        function getSubfacts(fnode) {\n            return {note: callback(fnode)};\n        }\n        getSubfacts.possibleSubfacts = NOTE;\n        getSubfacts.kind = 'note';\n        return new this.constructor(this._calls.concat(getSubfacts),\n                                    this._max,\n                                    this._types);\n    }\n\n    /**\n     * Affect the confidence with which the input node should be considered a\n     * member of a type.\n     *\n     * The parameter is generally between 0 and 1 (inclusive), with 0 meaning\n     * the node does not have the \"smell\" this rule checks for and 1 meaning it\n     * does. The range between 0 and 1 is available to represent \"fuzzy\"\n     * confidences. If you have an unbounded range to compress down to [0, 1],\n     * consider using :func:`sigmoid` or a scaling thereof.\n     *\n     * Since every node can have multiple, independent scores (one for each\n     * type), this applies to the type explicitly set by the RHS or, if none,\n     * to the type named by the ``type`` call on the LHS. If the LHS has none\n     * because it's a ``dom(...)`` LHS, an error is raised.\n     *\n     * @arg {number|function} scoreOrCallback Can either be a static number,\n     *     generally 0 to 1 inclusive, or else a callback which takes the fnode\n     *     and returns such a number. If the callback returns a boolean, it is\n     *     cast to a number.\n     */\n    score(scoreOrCallback) {\n        let getSubfacts;\n\n        function getSubfactsFromNumber(fnode) {\n            return {score: scoreOrCallback};\n        }\n\n        function getSubfactsFromFunction(fnode) {\n            let result = scoreOrCallback(fnode);\n            if (typeof result === 'boolean') {\n                // Case bools to numbers for convenience. Boolean features are\n                // common. Don't cast other things, as it frustrates ruleset\n                // debugging.\n                result = Number(result);\n            }\n            return {score: result};\n        }\n\n        if (typeof scoreOrCallback === 'number') {\n            getSubfacts = getSubfactsFromNumber;\n        } else {\n            getSubfacts = getSubfactsFromFunction;\n        }\n        getSubfacts.possibleSubfacts = SCORE;\n        getSubfacts.kind = 'score';\n\n        return new this.constructor(this._calls.concat(getSubfacts),\n                                    this._max,\n                                    this._types);\n    }\n\n    // Future: why not have an .element() method for completeness?\n\n    // -------- Methods below this point are private to the framework. --------\n\n    /**\n     * Run all my props().type().note().score() stuff across a given fnode,\n     * enforce my max() stuff, and return a fact ({element, type, score,\n     * notes}) for incorporation into that fnode (or a different one, if\n     * element is specified). Any of the 4 fact properties can be missing;\n     * filling in defaults is a job for the caller.\n     *\n     * @arg leftType The type the LHS takes in\n     */\n    fact(fnode, leftType) {\n        const doneKinds = new Set();\n        const result = {};\n        let haveSubfacts = 0;\n        for (let call of reversed(this._calls)) {\n            // If we've already called a call of this kind, then forget it.\n            if (!doneKinds.has(call.kind)) {\n                doneKinds.add(call.kind);\n\n                if (~haveSubfacts & call.possibleSubfacts) {\n                    // This call might provide a subfact we are missing.\n                    const newSubfacts = call(fnode);\n\n                    // We start with an empty object, so we're okay here.\n                    // eslint-disable-next-line guard-for-in\n                    for (let subfact in newSubfacts) {\n                        // A props() callback could insert arbitrary keys into\n                        // the result, but it shouldn't matter, because nothing\n                        // pays any attention to them.\n                        if (!result.hasOwnProperty(subfact)) {\n                            result[subfact] = newSubfacts[subfact];\n                        }\n                        haveSubfacts |= SUBFACTS[subfact];\n                    }\n                }\n            }\n        }\n        this._checkAtMost(result);\n        this._checkTypeIn(result, leftType);\n        return result;\n    }\n\n    /**\n     * Return a record describing the types I might emit (which means either to\n     * add a type to a fnode or to output a fnode that already has that type).\n     * {couldChangeType: whether I might add a type to the fnode,\n     *  possibleTypes: If couldChangeType, the types I might emit; empty set if\n     *      we cannot infer it. If not couldChangeType, undefined.}\n     */\n    possibleEmissions() {\n        // If there is a typeIn() constraint or there is a type() call to the\n        // right of all props() calls, we have a constraint. We hunt for the\n        // tightest constraint we can find, favoring a type() call because it\n        // gives us a single type but then falling back to a typeIn().\n        let couldChangeType = false;\n        for (let call of reversed(this._calls)) {\n            if (call.kind === 'props') {\n                couldChangeType = true;\n                break;\n            } else if (call.kind === 'type') {\n                return {couldChangeType: true,\n                        possibleTypes: new Set([call.type])};\n            }\n        }\n        return {couldChangeType,\n                possibleTypes: this._types};\n    }\n}\n\nclass OutwardRhs {\n    constructor(key, through = x => x, allThrough = x => x) {\n        this.key = key;\n        this.callback = through;\n        this.allCallback = allThrough;\n    }\n\n    /**\n     * Append ``.through`` to :func:`out` to run each :term:`fnode` emitted\n     * from the LHS through an arbitrary function before returning it to the\n     * containing program. Example::\n     *\n     *     out('titleLengths').through(fnode => fnode.noteFor('title').length)\n     */\n    through(callback) {\n        return new this.constructor(this.key, callback, this.allCallback);\n    }\n\n    /**\n     * Append ``.allThrough`` to :func:`out` to run the entire iterable of\n     * emitted :term:`fnodes<fnode>` through an arbitrary function before\n     * returning them to the containing program. Example::\n     *\n     *     out('sortedTitles').allThrough(domSort)\n     */\n    allThrough(callback) {\n        return new this.constructor(this.key, this.callback, callback);\n    }\n\n    asRhs() {\n        return this;\n    }\n}\n\nfunction props(callback) {\n    return new Side({method: 'props', args: [callback]});\n}\n\n/** Constrain to an input type on the LHS, or apply a type on the RHS. */\nfunction type(theType) {\n    return new Side({method: 'type', args: [theType]});\n}\n\nfunction note(callback) {\n    return new Side({method: 'note', args: [callback]});\n}\n\nfunction score(scoreOrCallback) {\n    return new Side({method: 'score', args: [scoreOrCallback]});\n}\n\nfunction atMost(score) {\n    return new Side({method: 'atMost', args: [score]});\n}\n\nfunction typeIn(...types) {\n    return new Side({method: 'typeIn', args: types});\n}\n\n/**\n * Pull nodes that conform to multiple conditions at once.\n *\n * For example: ``and(type('title'), type('english'))``\n *\n * Caveats: ``and`` supports only simple ``type`` calls as arguments for now,\n * and it may fire off more rules as prerequisites than strictly necessary.\n * ``not`` and ``or`` don't exist yet, but you can express ``or`` the long way\n * around by having 2 rules with identical RHSs.\n */\nfunction and(...lhss) {\n    return new Side({method: 'and', args: lhss});\n}\n\n/**\n * Experimental. For each :term:`fnode` from ``typeCallA``, find the closest\n * node from ``typeCallB``, and attach it as a note. The note is attached to\n * the type specified by the RHS, defaulting to the type of ``typeCallA``. If\n * no nodes are emitted from ``typeCallB``, do nothing.\n *\n * For example... ::\n *\n *     nearest(type('image'), type('price'))\n *\n * The score of the ``typeCallA`` can be added to the new type's score by using\n * :func:`conserveScore` (though this routine has since been removed)::\n *\n *     rule(nearest(type('image'), type('price')),\n *          type('imageWithPrice').score(2).conserveScore())\n *\n * Caveats: ``nearest`` supports only simple ``type`` calls as arguments ``a``\n * and ``b`` for now.\n *\n * @arg distance {function} A function that takes 2 fnodes and returns a\n *     numerical distance between them. Included options are :func:`distance`,\n *     which is a weighted topological distance, and :func:`euclidean`, which\n *     is a spatial distance.\n */\nfunction nearest(typeCallA, typeCallB, distance = euclidean) {\n    return new Side({method: 'nearest', args: [typeCallA, typeCallB, distance]});\n}\n\n/**\n * A chain of calls that can be compiled into a Rhs or Lhs, depending on its\n * position in a Rule. This lets us use type() as a leading call for both RHSs\n * and LHSs. I would prefer to do this dynamically, but that wouldn't compile\n * down to old versions of ES.\n */\nclass Side {\n    constructor(...calls) {\n        // A \"call\" is like {method: 'dom', args: ['p.smoo']}.\n        this._calls = calls;\n    }\n\n    max() {\n        return this._and('max');\n    }\n\n    bestCluster(options) {\n        return this._and('bestCluster', options);\n    }\n\n    props(callback) {\n        return this._and('props', callback);\n    }\n\n    type(...types) {\n        return this._and('type', ...types);\n    }\n\n    note(callback) {\n        return this._and('note', callback);\n    }\n\n    score(scoreOrCallback) {\n        return this._and('score', scoreOrCallback);\n    }\n\n    atMost(score) {\n        return this._and('atMost', score);\n    }\n\n    typeIn(...types) {\n        return this._and('typeIn', ...types);\n    }\n\n    and(...lhss) {\n        return this._and('and', lhss);\n    }\n\n    _and(method, ...args) {\n        return new this.constructor(...this._calls.concat({method, args}));\n    }\n\n    asLhs() {\n        return this._asSide(Lhs.fromFirstCall(this._calls[0]), this._calls.slice(1));\n    }\n\n    asRhs() {\n        return this._asSide(new InwardRhs(), this._calls);\n    }\n\n    _asSide(side, calls) {\n        for (let call of calls) {\n            side = side[call.method](...call.args);\n        }\n        return side;\n    }\n\n    when(pred) {\n        return this._and('when', pred);\n    }\n}\n\n/**\n * A wrapper around a DOM node, storing :term:`types<type>`,\n * :term:`scores<score>`, and :term:`notes<note>` that apply to it\n */\nclass Fnode {\n    /**\n     * @arg element The DOM element described by the fnode.\n     * @arg ruleset The ruleset which created the fnode.\n     */\n    constructor(element, ruleset) {\n        if (element === undefined) {\n            throw new Error(\"Someone tried to make a fnode without specifying the element they're talking about.\");\n        }\n        /**\n         * The raw DOM element this fnode describes\n         */\n        this.element = element;\n        this._ruleset = ruleset;\n\n        // A map of type => {score: number, note: anything}. `score` is always\n        // present and defaults to 1. A note is set iff `note` is present and\n        // not undefined.\n        this._types = new Map();\n\n        // Note: conserveScore() is temporarily absent in 3.0.\n        //\n        // By default, a fnode has an independent score for each of its types.\n        // However, a RHS can opt to conserve the score of an upstream type,\n        // carrying it forward into another type. To avoid runaway scores in\n        // the case that multiple rules choose to do this, we limit the\n        // contribution of an upstream type's score to being multiplied in a\n        // single time. In this set, we keep track of which upstream types'\n        // scores have already been multiplied into each type. LHS fnode => Set\n        // of types whose score for that node have been multiplied into this\n        // node's score.\n        this._conservedScores = new Map();\n    }\n\n    /**\n     * Return whether the given type is one of the ones attached to the wrapped\n     * HTML node.\n     */\n    hasType(type) {\n        // Run type(theType) against the ruleset to make sure this doesn't\n        // return false just because we haven't lazily run certain rules yet.\n        this._computeType(type);\n        return this._types.has(type);\n    }\n\n    /**\n     * Return the confidence, in the range (0, 1), that the fnode belongs to the\n     * given type, 0 by default.\n     */\n    scoreFor(type) {\n        this._computeType(type);\n        return sigmoid(this._ruleset.weightedScore(this.scoresSoFarFor(type)) +\n                       getDefault(this._ruleset.biases, type, () => 0));\n    }\n\n    /**\n     * Return the fnode's note for the given type, ``undefined`` if none.\n     */\n    noteFor(type) {\n        this._computeType(type);\n        return this._noteSoFarFor(type);\n    }\n\n    /**\n     * Return whether this fnode has a note for the given type.\n     *\n     * ``undefined`` is not considered a note and may be overwritten with\n     * impunity.\n     */\n    hasNoteFor(type) {\n        this._computeType(type);\n        return this._hasNoteSoFarFor(type);\n    }\n\n    // -------- Methods below this point are private to the framework. --------\n\n    /**\n     * Return an iterable of the types tagged onto me by rules that have\n     * already executed.\n     */\n    typesSoFar() {\n        return this._types.keys();\n    }\n\n    _noteSoFarFor(type) {\n        return this._typeRecordForGetting(type).note;\n    }\n\n    _hasNoteSoFarFor(type) {\n        return this._noteSoFarFor(type) !== undefined;\n    }\n\n    /**\n     * Return the score thus far computed on me for a certain type. Doesn't\n     * implicitly run any rules. If no score has yet been determined for the\n     * given type, return undefined.\n     */\n    scoresSoFarFor(type) {\n        return this._typeRecordForGetting(type).score;\n    }\n\n    /**\n     * Add a given number to one of our per-type scores. Implicitly assign us\n     * the given type. Keep track of which rule it resulted from so we can\n     * later mess with the coeffs.\n     */\n    addScoreFor(type, score, ruleName) {\n        this._typeRecordForSetting(type).score.set(ruleName, score);\n    }\n\n    /**\n     * Set the note attached to one of our types. Implicitly assign us that\n     * type if we don't have it already.\n     */\n    setNoteFor(type, note) {\n        if (this._hasNoteSoFarFor(type)) {\n            if (note !== undefined) {\n                throw new Error(`Someone (likely the right-hand side of a rule) tried to add a note of type ${type} to an element, but one of that type already exists. Overwriting notes is not allowed, since it would make the order of rules matter.`);\n            }\n            // else the incoming note is undefined and we already have the\n            // type, so it's a no-op\n        } else {\n            // Apply either a type and note or just a type (which means a note\n            // that is undefined):\n            this._typeRecordForSetting(type).note = note;\n        }\n    }\n\n    /**\n     * Return a score/note record for a type, creating it if it doesn't exist.\n     */\n    _typeRecordForSetting(type) {\n        return setDefault(this._types, type, () => ({score: new Map()}));\n    }\n\n    /**\n     * Manifest a temporary type record for reading, working around the lack of\n     * a .? operator in JS.\n     */\n    _typeRecordForGetting(type) {\n        return getDefault(this._types, type, () => ({score: new Map()}));\n    }\n\n    /**\n     * Make sure any scores, notes, and type-tagging for the given type are\n     * computed for my element.\n     */\n    _computeType(theType) {\n        if (!this._types.has(theType)) {  // Prevent infinite recursion when an A->A rule looks at A's note in a callback.\n            this._ruleset.get(type(theType));\n        }\n    }\n}\n\n/**\n * Construct and return the proper type of rule class based on the\n * inwardness/outwardness of the RHS.\n *\n * @arg lhs {Lhs} The left-hand side of the rule\n * @arg rhs {Rhs} The right-hand side of the rule\n * @arg options {object} Other, optional information about the rule.\n *     Currently, the only recognized option is ``name``, which points to a\n *     string that uniquely identifies this rule in a ruleset. The name\n *     correlates this rule with one of the coefficients passed into\n *     :func:`ruleset`. If no name is given, an identifier is assigned based on\n *     the index of this rule in the ruleset, but that is, of course, brittle.\n */\nfunction rule(lhs, rhs, options) {\n    // Since out() is a valid call only on the RHS (unlike type()), we can take\n    // a shortcut here: any outward RHS will already be an OutwardRhs; we don't\n    // need to sidetrack it through being a Side. And OutwardRhs has an asRhs()\n    // that just returns itself.\n    if (typeof rhs === 'string') {\n        rhs = out(rhs);\n    }\n    return new ((rhs instanceof OutwardRhs) ? OutwardRule : InwardRule)(lhs, rhs, options);\n}\n\nlet nextRuleNumber = 0;\nfunction newInternalRuleName() {\n    return '_' + nextRuleNumber++;\n}\n\n/**\n * We place the in/out distinction in Rules because it determines whether the\n * RHS result is cached, and Rules are responsible for maintaining the rulewise\n * cache ruleset.ruleCache.\n */\nclass Rule {  // abstract\n    constructor(lhs, rhs, options) {\n        this.lhs = lhs.asLhs();\n        this.rhs = rhs.asRhs();\n        // TODO: Make auto-generated rule names be based on the out types of\n        // the rules, e.g. _priceish_4. That way, adding rules for one type\n        // won't make the coeffs misalign for another.\n        this.name = (options ? options.name : undefined) || newInternalRuleName();\n    }\n\n    /**\n     * Return a NiceSet of the rules that this one shallowly depends on in the\n     * given ruleset. In a BoundRuleset, this may include rules that have\n     * already been executed.\n     *\n     * Depend on emitters of any LHS type this rule finalizes. (See\n     * _typesFinalized for a definition.) Depend on adders of any other LHS\n     * types (because, after all, we need to know what nodes have that type in\n     * order to find the set of LHS nodes). This works for simple rules and\n     * complex ones like and().\n     *\n     * Specific examples (where A is a type):\n     * * A.max->* depends on anything emitting A.\n     * * Even A.max->A depends on A emitters, because we have to have all the\n     *   scores factored in first. For example, what if we did\n     *   max(A)->score(.5)?\n     * * A->A depends on anything adding A.\n     * * A->(something other than A) depends on anything emitting A. (For\n     *   example, we need the A score finalized before we could transfer it to\n     *   B using conserveScore().)\n     * * A->out() also depends on anything emitting A. Fnode methods aren't\n     *   smart enough to lazily run emitter rules as needed. We could make them\n     *   so if it was shown to be an advantage.\n     */\n    prerequisites(ruleset) {\n        // Optimization: we could cache the result of this when in a compiled (immutable) ruleset.\n\n        // Extend prereqs with rules derived from each of the given types. If\n        // no rules are found, raise an exception, as that indicates a\n        // malformed ruleset.\n        function extendOrThrow(prereqs, types, ruleGetter, verb) {\n            for (let type of types) {\n                const rules = ruleGetter(type);\n                if (rules.length > 0) {\n                    prereqs.extend(rules);\n                } else {\n                    throw new Error(`No rule ${verb} the \"${type}\" type, but another rule needs it as input.`);\n                }\n            }\n        }\n\n        const prereqs = new NiceSet();\n\n        // Add finalized types:\n        extendOrThrow(prereqs, this._typesFinalized(), type => ruleset.inwardRulesThatCouldEmit(type), 'emits');\n\n        // Add mentioned types:\n        // We could say this.lhs.typesMentioned().minus(typesFinalized) as an\n        // optimization. But since types mentioned are a superset of types\n        // finalized and rules adding are a subset of rules emitting, we get\n        // the same result without.\n        extendOrThrow(prereqs, this.lhs.typesMentioned(), type => ruleset.inwardRulesThatCouldAdd(type), 'adds');\n\n        return prereqs;\n    }\n\n    /**\n     * Return the types that this rule finalizes.\n     *\n     * To \"finalize\" a type means to make sure we're finished running all\n     * possible rules that might change a node's score or notes w.r.t. a given\n     * type. This is generally done because we're about to use those data for\n     * something, like computing a new type's score or or an aggregate\n     * function. Exhaustively, we're about to...\n     * * change the type of the nodes or\n     * * aggregate all nodes of a type\n     *\n     * This base-class implementation just returns what aggregate functions\n     * need, since that need spans inward and outward rules.\n     *\n     * @return Set of types\n     */\n    _typesFinalized() {\n        // Get the types that are fed to aggregate functions. Aggregate\n        // functions are more demanding than a simple type() LHS. A type() LHS\n        // itself does not finalize its nodes because the things it could do to\n        // them without changing their type (adding notes, adding to score)\n        // are immutable or commutative (respectively). Thus, we require a RHS\n        // type change in order to require finalization of a simple type()\n        // mention. A max(B), OTOH, is not commutative with other B->B rules\n        // (imagine type(B).max()->score(.5)), so it must depend on B emitters\n        // and thus finalize B. (This will have to be relaxed or rethought when\n        // we do the max()/atMost() optimization. Perhaps we can delegate to\n        // aggregate functions up in Rule.prerequisites() to ask what their\n        // prereqs are. If they implement such an optimization, they can reply.\n        // Otherwise, we can assume they are all the nodes of their type.)\n        //\n        // TODO: Could arbitrary predicates (once we implement those) matter\n        // too? Maybe it's not just aggregations.\n        const type = this.lhs.aggregatedType();\n        return (type === undefined) ? new NiceSet() : new NiceSet([type]);\n    }\n}\n\n/**\n * A normal rule, whose results head back into the Fathom knowledgebase, to be\n * operated on by further rules.\n */\nclass InwardRule extends Rule {\n    // TODO: On construct, complain about useless rules, like a dom() rule that\n    // doesn't assign a type.\n\n    /**\n     * Return an iterable of the fnodes emitted by the RHS of this rule.\n     * Side effect: update ruleset's store of fnodes, its accounting of which\n     * rules are done executing, and its cache of results per type.\n     */\n    results(ruleset) {\n        if (ruleset.doneRules.has(this)) {  // shouldn't happen\n            throw new Error('A bug in Fathom caused results() to be called on an inward rule twice. That could cause redundant score contributions, etc.');\n        }\n        const self = this;\n        // For now, we consider most of what a LHS computes to be cheap, aside\n        // from type() and type().max(), which are cached by their specialized\n        // LHS subclasses.\n        const leftResults = this.lhs.fnodes(ruleset);\n        // Avoid returning a single fnode more than once. LHSs uniquify\n        // themselves, but the RHS can change the element it's talking\n        // about and thus end up with dupes.\n        const returnedFnodes = new Set();\n\n        // Merge facts into fnodes:\n        forEach(\n            // leftResult can be either a fnode or a {fnode, rhsTransformer} pair.\n            function updateFnode(leftResult) {\n                const leftType = self.lhs.guaranteedType();\n                // Get a fnode and a RHS transformer, whether a plain fnode is\n                // returned or a {fnode, rhsTransformer} pair:\n                const {fnode: leftFnode = leftResult, rhsTransformer = identity} = leftResult;\n                // Grab the fact from the RHS, and run the LHS's optional\n                // transformer over it to pick up anything special it wants to\n                // do:\n                const fact = rhsTransformer(self.rhs.fact(leftFnode, leftType));\n                self.lhs.checkFact(fact);\n                const rightFnode = ruleset.fnodeForElement(fact.element || leftFnode.element);\n                // If the RHS doesn't specify a type, default to the\n                // type of the LHS, if any:\n                const rightType = fact.type || self.lhs.guaranteedType();\n                if (fact.score !== undefined) {\n                    if (rightType !== undefined) {\n                        rightFnode.addScoreFor(rightType, fact.score, self.name);\n                    } else {\n                        throw new Error(`The right-hand side of a rule specified a score (${fact.score}) with neither an explicit type nor one we could infer from the left-hand side.`);\n                    }\n                }\n                if (fact.type !== undefined || fact.note !== undefined) {\n                    // There's a reason to call setNoteFor.\n                    if (rightType === undefined) {\n                        throw new Error(`The right-hand side of a rule specified a note (${fact.note}) with neither an explicit type nor one we could infer from the left-hand side. Notes are per-type, per-node, so that's a problem.`);\n                    } else {\n                        rightFnode.setNoteFor(rightType, fact.note);\n                    }\n                }\n                returnedFnodes.add(rightFnode);\n            },\n            leftResults);\n\n        // Update ruleset lookup tables.\n        // First, mark this rule as done:\n        ruleset.doneRules.add(this);\n        // Then, stick each fnode in typeCache under all applicable types.\n        // Optimization: we really only need to loop over the types\n        // this rule can possibly add.\n        for (let fnode of returnedFnodes) {\n            for (let type of fnode.typesSoFar()) {\n                setDefault(ruleset.typeCache, type, () => new Set()).add(fnode);\n            }\n        }\n        return returnedFnodes.values();\n    }\n\n    /**\n     * Return a Set of the types that could be emitted back into the system.\n     * To emit a type means to either to add it to a fnode emitted from the RHS\n     * or to leave it on such a fnode where it already exists.\n     */\n    typesItCouldEmit() {\n        const rhs = this.rhs.possibleEmissions();\n        if (!rhs.couldChangeType && this.lhs.guaranteedType() !== undefined) {\n            // It's a b -> b rule.\n            return new Set([this.lhs.guaranteedType()]);\n        } else if (rhs.possibleTypes.size > 0) {\n            // We can prove the type emission from the RHS alone.\n            return rhs.possibleTypes;\n        } else {\n            throw new Error('Could not determine the emitted type of a rule because its right-hand side calls props() without calling typeIn().');\n        }\n    }\n\n    /**\n     * Return a Set of types I could add to fnodes I output (where the fnodes\n     * did not already have them).\n     */\n    typesItCouldAdd() {\n        const ret = new Set(this.typesItCouldEmit());\n        ret.delete(this.lhs.guaranteedType());\n        return ret;\n    }\n\n    /**\n     * Add the types we could change to the superclass's result.\n     */\n    _typesFinalized() {\n        const self = this;\n        function typesThatCouldChange() {\n            const ret = new NiceSet();\n\n            // Get types that could change:\n            const emissions = self.rhs.possibleEmissions();\n            if (emissions.couldChangeType) {\n                // Get the possible guaranteed combinations of types on the LHS\n                // (taking just this LHS into account). For each combo, if the RHS\n                // adds a type that's not in the combo, the types in the combo get\n                // unioned into ret.\n                for (let combo of self.lhs.possibleTypeCombinations()) {\n                    for (let rhsType of emissions.possibleTypes) {\n                        if (!combo.has(rhsType)) {\n                            ret.extend(combo);\n                            break;\n                        }\n                    }\n                }\n            }\n            // Optimization: the possible combos could be later expanded to be\n            // informed by earlier rules which add the types mentioned in the LHS.\n            // If the only way for something to get B is to have Q first, then we\n            // can add Q to each combo and end up with fewer types finalized. Would\n            // this imply the existence of a Q->B->Q cycle and thus be impossible?\n            // Think about it. If we do this, we can centralize that logic here,\n            // rather than repeating it in all the Lhs subclasses).\n            return ret;\n        }\n\n        return typesThatCouldChange().extend(super._typesFinalized());\n    }\n}\n\n/**\n * A rule whose RHS is an out(). This represents a final goal of a ruleset.\n * Its results go out into the world, not inward back into the Fathom\n * knowledgebase.\n */\nclass OutwardRule extends Rule {\n    /**\n     * Compute the whole thing, including any .through() and .allThrough().\n     * Do not mark me done in ruleset.doneRules; out rules are never marked as\n     * done so they can be requested many times without having to cache their\n     * (potentially big, since they aren't necessarily fnodes?) results. (We\n     * can add caching later if it proves beneficial.)\n     */\n    results(ruleset) {\n        /**\n         * From a LHS's ``{fnode, rhsTransform}`` object or plain fnode, pick off just\n         * the fnode and return it.\n         */\n        function justFnode(fnodeOrStruct) {\n            return (fnodeOrStruct instanceof Fnode) ? fnodeOrStruct : fnodeOrStruct.fnode;\n        }\n\n        return this.rhs.allCallback(map(this.rhs.callback, map(justFnode, this.lhs.fnodes(ruleset))));\n    }\n\n    /**\n     * @return the key under which the output of this rule will be available\n     */\n    key() {\n        return this.rhs.key;\n    }\n\n    /**\n     * OutwardRules finalize all types mentioned.\n     */\n    _typesFinalized() {\n        return this.lhs.typesMentioned().extend(super._typesFinalized());\n    }\n}\n\n/**\n * A shortcut for creating a new :class:`Ruleset`, for symmetry with\n * :func:`rule`\n */\nfunction ruleset(rules, coeffs = [], biases = []) {\n    return new Ruleset(rules, coeffs, biases);\n}\n\n/**\n * An unbound ruleset. When you bind it by calling :func:`~Ruleset.against()`,\n * the resulting :class:`BoundRuleset` will be immutable.\n */\nclass Ruleset {\n    /**\n     * @arg rules {Array} Rules returned from :func:`rule`\n     * @arg coeffs {Map} A map of rule names to numerical weights, typically\n     *     returned by the :doc:`trainer<training>`. Example:\n     *     ``[['someRuleName', 5.04], ...]``. If not given, coefficients\n     *     default to 1.\n     * @arg biases {object} A map of type names to neural-net biases. These\n     *      enable accurate confidence estimates. Example: ``[['someType',\n     *      -2.08], ...]``. If absent, biases default to 0.\n     */\n    constructor(rules, coeffs = [], biases = []) {\n        this._inRules = [];\n        this._outRules = new Map();  // key -> rule\n        this._rulesThatCouldEmit = new Map();  // type -> [rules]\n        this._rulesThatCouldAdd = new Map();  // type -> [rules]\n        // Private to the framework:\n        this._coeffs = new Map(coeffs);  // rule name => coefficient\n        this.biases = new Map(biases);  // type name => bias\n\n        // Separate rules into out ones and in ones, and sock them away. We do\n        // this here so mistakes raise errors early.\n        for (let rule of rules) {\n            if (rule instanceof InwardRule) {\n                this._inRules.push(rule);\n\n                // Keep track of what inward rules can emit or add:\n                // TODO: Combine these hashes for space efficiency:\n                const emittedTypes = rule.typesItCouldEmit();\n                for (let type of emittedTypes) {\n                    setDefault(this._rulesThatCouldEmit, type, () => []).push(rule);\n                }\n                for (let type of rule.typesItCouldAdd()) {\n                    setDefault(this._rulesThatCouldAdd, type, () => []).push(rule);\n                }\n            } else if (rule instanceof OutwardRule) {\n                this._outRules.set(rule.key(), rule);\n            } else {\n                throw new Error(`This element of ruleset()'s first param wasn't a rule: ${rule}`);\n            }\n        }\n    }\n\n    /**\n     * Commit this ruleset to running against a specific DOM tree or subtree.\n     *\n     * When run against a subtree, the root of the subtree is not considered as\n     * a possible match.\n     *\n     * This doesn't actually modify the Ruleset but rather returns a fresh\n     * :class:`BoundRuleset`, which contains caches and other stateful, per-DOM\n     * bric-a-brac.\n     */\n    against(doc) {\n        return new BoundRuleset(doc,\n                                this._inRules,\n                                this._outRules,\n                                this._rulesThatCouldEmit,\n                                this._rulesThatCouldAdd,\n                                this._coeffs,\n                                this.biases);\n    }\n\n    /**\n     * Return all the rules (both inward and outward) that make up this ruleset.\n     *\n     * From this, you can construct another ruleset like this one but with your\n     * own rules added.\n     */\n    rules() {\n        return Array.from([...this._inRules, ...this._outRules.values()]);\n    }\n}\n\n/**\n * A ruleset that is earmarked to analyze a certain DOM\n *\n * Carries a cache of rule results on that DOM. Typically comes from\n * :meth:`~Ruleset.against`.\n */\nclass BoundRuleset {\n    /**\n     * @arg inRules {Array} Non-out() rules\n     * @arg outRules {Map} Output key -> out() rule\n     */\n    constructor(doc, inRules, outRules, rulesThatCouldEmit, rulesThatCouldAdd, coeffs, biases) {\n        this.doc = doc;\n        this._inRules = inRules;\n        this._outRules = outRules;\n        this._rulesThatCouldEmit = rulesThatCouldEmit;\n        this._rulesThatCouldAdd = rulesThatCouldAdd;\n        this._coeffs = coeffs;\n\n        // Private, for the use of only helper classes:\n        this.biases = biases;\n        this._clearCaches();\n        this.elementCache = new WeakMap();  // DOM element => fnode about it\n        this.doneRules = new Set();  // InwardRules that have been executed. OutwardRules can be executed more than once because they don't change any fnodes and are thus idempotent.\n    }\n\n    /**\n     * Change my coefficients and biases after construction.\n     *\n     * @arg coeffs See the :class:`Ruleset` constructor.\n     * @arg biases See the :class:`Ruleset` constructor.\n     */\n    setCoeffsAndBiases(coeffs, biases = []) {\n        // Destructuring assignment doesn't make it through rollup properly\n        // (https://github.com/rollup/rollup-plugin-commonjs/issues/358):\n        this._coeffs = new Map(coeffs);\n        this.biases = new Map(biases);\n        this._clearCaches();\n    }\n\n    /**\n     * Clear the typeCache and maxCache, usually in the wake of changing\n     * ``this._coeffs``, because both of thise depend on weighted scores.\n     */\n    _clearCaches() {\n        this.maxCache = new Map();  // type => Array of max fnode (or fnodes, if tied) of this type\n        this.typeCache = new Map();  // type => Set of all fnodes of this type found so far. (The dependency resolution during execution ensures that individual types will be comprehensive just in time.)\n    }\n\n    /**\n     * Return an array of zero or more fnodes.\n     * @arg thing {string|Lhs|Node} Can be\n     *\n     *       (1) A string which matches up with an \"out\" rule in the ruleset.\n     *           If the out rule uses through(), the results of through's\n     *           callback (which might not be fnodes) will be returned.\n     *       (2) An arbitrary LHS which we calculate and return the results of.\n     *       (3) A DOM node, for which we will return the corresponding fnode.\n     *\n     *     Results are cached for cases (1) and (3).\n     */\n    get(thing) {\n        if (typeof thing === 'string') {\n            if (this._outRules.has(thing)) {\n                return Array.from(this._execute(this._outRules.get(thing)));\n            } else {\n                throw new Error(`There is no out() rule with key \"${thing}\".`);\n            }\n        } else if (isDomElement(thing)) {\n            // Return the fnode and let it run type(foo) on demand, as people\n            // ask it things like scoreFor(foo).\n            return this.fnodeForElement(thing);\n        } else if (thing.asLhs !== undefined) {\n            // Make a temporary out rule, and run it. This may add things to\n            // the ruleset's cache, but that's fine: it doesn't change any\n            // future results; it just might make them faster. For example, if\n            // you ask for .get(type('smoo')) twice, the second time will be a\n            // cache hit.\n            const outRule = rule(thing, out(Symbol('outKey')));\n            return Array.from(this._execute(outRule));\n        } else {\n            throw new Error('ruleset.get() expects a string, an expression like on the left-hand side of a rule, or a DOM node.');\n        }\n    }\n\n    /**\n     * Return the weighted sum of the per-rule, per-type scores from a fnode.\n     *\n     * @arg mapOfScores a Map of rule name to the [0, 1] score it computed for\n     *      the type in question\n     */\n    weightedScore(mapOfScores) {\n        let total = 0;\n        for (const [name, score] of mapOfScores) {\n            total += score * getDefault(this._coeffs, name, () => 1);\n        }\n        return total;\n    }\n\n    // Provide an opaque context object to be made available to all ranker\n    // functions.\n    // context (object) {\n    //     self.context = object;\n    // }\n\n    // -------- Methods below this point are private to the framework. --------\n\n    /**\n     * Return all the thus-far-unexecuted rules that will have to run to run\n     * the requested rule, in the form of Map(prereq: [rulesItIsNeededBy]).\n     */\n    _prerequisitesTo(rule, undonePrereqs = new Map()) {\n        for (let prereq of rule.prerequisites(this)) {\n            if (!this.doneRules.has(prereq)) {\n                // prereq is not already run. (If it were, we wouldn't care\n                // about adding it to the graph.)\n                const alreadyAdded = undonePrereqs.has(prereq);\n                setDefault(undonePrereqs, prereq, () => []).push(rule);\n\n                // alreadyAdded means we've already computed the prereqs of\n                // this prereq and added them to undonePrereqs. So, now\n                // that we've hooked up the rule to this prereq in the\n                // graph, we can stop. But, if we haven't, then...\n                if (!alreadyAdded) {\n                    this._prerequisitesTo(prereq, undonePrereqs);\n                }\n            }\n        }\n        return undonePrereqs;\n    }\n\n    /**\n     * Run the given rule (and its dependencies, in the proper order), and\n     * return its results.\n     *\n     * The caller is responsible for ensuring that _execute() is not called\n     * more than once for a given InwardRule, lest non-idempotent\n     * transformations, like score contributions, be applied to fnodes more\n     * than once.\n     *\n     * The basic idea is to sort rules in topological order (according to input\n     * and output types) and then run them. On top of that, we do some\n     * optimizations. We keep a cache of results by type (whether partial or\n     * comprehensive--either way, the topology ensures that any\n     * non-comprehensive typeCache entry is made comprehensive before another\n     * rule needs it). And we prune our search for prerequisite rules at the\n     * first encountered already-executed rule.\n     */\n    _execute(rule) {\n        const prereqs = this._prerequisitesTo(rule);\n        let sorted;\n        try {\n            sorted = [rule].concat(toposort(prereqs.keys(),\n                                            prereq => prereqs.get(prereq)));\n        } catch (exc) {\n            if (exc instanceof CycleError) {\n                throw new CycleError('There is a cyclic dependency in the ruleset.');\n            } else {\n                throw exc;\n            }\n        }\n        let fnodes;\n        for (let eachRule of reversed(sorted)) {\n            // Sock each set of results away in this.typeCache:\n            fnodes = eachRule.results(this);\n        }\n        return Array.from(fnodes);\n    }\n\n    /** @return {Rule[]} */\n    inwardRulesThatCouldEmit(type) {\n        return getDefault(this._rulesThatCouldEmit, type, () => []);\n    }\n\n    /** @return {Rule[]} */\n    inwardRulesThatCouldAdd(type) {\n        return getDefault(this._rulesThatCouldAdd, type, () => []);\n    }\n\n    /**\n     * @return the Fathom node that describes the given DOM element. This does\n     *     not trigger any execution, so the result may be incomplete.\n     */\n    fnodeForElement(element) {\n        return setDefault(this.elementCache,\n                          element,\n                          () => new Fnode(element, this));\n    }\n}\n\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst version = '3.7.3';\n\n\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/fathom.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/translations-document.sys.mjs":
/*!***************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/translations-document.sys.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LRUCache: () => (/* binding */ LRUCache),\n/* harmony export */   TranslationsDocument: () => (/* binding */ TranslationsDocument)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_AppConstants_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/AppConstants.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n/**\n * @typedef {object} Lazy\n * @property {typeof setTimeout} setTimeout\n * @property {typeof clearTimeout} clearTimeout\n * @property {typeof console} console\n * @property {typeof import(\"chrome://global/content/translations/TranslationsUtils.mjs\").TranslationsUtils} TranslationsUtils\n */\n\n/** @type {Lazy} */\nconst lazy = /** @type {any} */ ({});\n\nChromeUtils.defineESModuleGetters(lazy, {\n  setTimeout: \"resource://gre/modules/Timer.sys.mjs\",\n  clearTimeout: \"resource://gre/modules/Timer.sys.mjs\",\n  TranslationsUtils:\n    \"chrome://global/content/translations/TranslationsUtils.mjs\",\n});\n\nChromeUtils.defineLazyGetter(lazy, \"console\", () => {\n  return console.createInstance({\n    maxLogLevelPref: \"browser.translations.logLevel\",\n    prefix: \"Translations\",\n  });\n});\n\n/**\n * Map the NodeFilter enums that are used by the TreeWalker into enums that make\n * sense for determining the status of the nodes for the TranslationsDocument process.\n * This aligns the meanings of the filtering for the translations process.\n */\nconst NodeStatus = {\n  // This node is ready to translate as is.\n  READY_TO_TRANSLATE: NodeFilter.FILTER_ACCEPT,\n\n  // This node is a shadow host and needs to be subdivided further.\n  SHADOW_HOST: NodeFilter.FILTER_ACCEPT,\n\n  // This node contains too many block elements and needs to be subdivided further.\n  SUBDIVIDE_FURTHER: NodeFilter.FILTER_SKIP,\n\n  // This node should not be considered for translation.\n  NOT_TRANSLATABLE: NodeFilter.FILTER_REJECT,\n};\n\n/**\n * @typedef {import(\"../translations\").NodeVisibility} NodeVisibility\n * @typedef {import(\"../translations\").LanguagePair} LanguagePair\n * @typedef {import(\"../translations\").PortToPage} PortToPage\n * @typedef {import(\"../translations\").EngineStatus} EngineStatus\n * @typedef {import(\"../translations\").TranslationsMode} TranslationsMode\n * @typedef {import(\"../translations\").ScrollDirection} ScrollDirection\n * @typedef {import(\"../translations\").NodeViewportContext} NodeViewportContext\n * @typedef {import(\"../translations\").NodeSpatialContext} NodeSpatialContext\n * @typedef {import(\"../translations\").UpdateEligibility} UpdateEligibility\n * @typedef {import(\"../translations\").SortableContentElement} SortableContentElement\n * @typedef {import(\"../translations\").PrioritizedContentElements} PrioritizedContentElements\n * @typedef {import(\"../translations\").SortableAttributeElement} SortableAttributeElement\n * @typedef {import(\"../translations\").PrioritizedAttributeElements} PrioritizedAttributeElements\n * @typedef {import(\"../translations\").TranslationPriorityKinds} TranslationPriorityKinds\n * @typedef {import(\"../translations\").TranslationRequest} TranslationRequest\n * @typedef {import(\"../translations\").TranslationFunction} TranslationFunction\n */\n\n/**\n * Create a translation cache with a limit. It implements a \"least recently used\" strategy\n * to remove old translations. After `#cacheExpirationMS` the cache will be emptied.\n * This cache is owned statically by the TranslationsChild. This means that it will be\n * re-used on page reloads if the origin of the site does not change.\n */\nclass LRUCache {\n  /**\n   * A Map from input HTML strings to their translated HTML strings.\n   *\n   * This cache is used to check if we already have a translated response for the given\n   * input HTML, to help avoid spending CPU cycles translating HTML for which we already\n   * know the translated output.\n   *\n   * @type {Map<string, string>}\n   */\n  #htmlCacheMap = new Map();\n\n  /**\n   * A Map from input text strings to their translated text strings.\n   *\n   * This cache is used to check if we already have a translated response for the given\n   * input text, to help avoid spending CPU cycles translating text for which we already\n   * know the translated output.\n   *\n   * @type {Map<string, string>}\n   */\n  #textCacheMap = new Map();\n\n  /**\n   * A Set containing strings of translated HTML output.\n   *\n   * This cache is used to check if the HTML has already been translated,\n   * to help avoid sending already-translated HTML to be translated a second time.\n   *\n   * Ideally, a translation model that receives source text that is already in the\n   * target translation language should just pass it through, but this is not always\n   * the case in practice. Depending on the model, sending already-translated text to\n   * be translated again may change the translation or even produce garbage as a response.\n   *\n   * Best to avoid this situation altogether if we can.\n   *\n   * @type {Set<string>}\n   */\n  #htmlCacheSet = new Set();\n\n  /**\n   * A Set containing strings of translated plain text output.\n   *\n   * This cache is used to check if the text has already been translated,\n   * to help avoid sending already-translated text to be translated a second time.\n   *\n   * Ideally, a translation model that receives source text that is already in the\n   * target translation language should just pass it through, but this is not always\n   * the case in practice. Depending on the model, sending already-translated text to\n   * be translated again may change the translation or even produce garbage as a response.\n   *\n   * Best to avoid this situation altogether if we can.\n   *\n   * @type {Set<string>}\n   */\n  #textCacheSet = new Set();\n\n  /**\n   * The language pair for this cache. All cached translations will be for the given pair.\n   *\n   * @type {LanguagePair}\n   */\n  #languagePair;\n\n  /**\n   * The limit of entries that can be held in each underlying cache before old entries\n   * will start being replaced by new entries.\n   *\n   * @type {number}\n   */\n  #cacheLimit = 5_000;\n\n  /**\n   * This cache will self-destruct after 10 minutes.\n   *\n   * @type {number}\n   */\n  #cacheExpirationMS = 10 * 60_000;\n\n  /**\n   * The source and target langue pair for the content in this cache.\n   *\n   * @param {LanguagePair} languagePair\n   */\n  constructor(languagePair) {\n    this.#languagePair = languagePair;\n  }\n\n  /**\n   * Retrieves the corresponding Map from source text to translated text.\n   *\n   * This is used to determine if a cached translation already exists for\n   * the given source text, preventing us from having to spend CPU time by\n   * recomputing the translation.\n   *\n   * @param {boolean} isHTML\n   *\n   * @returns {Map<string, string>}\n   */\n  #getCacheMap(isHTML) {\n    return isHTML ? this.#htmlCacheMap : this.#textCacheMap;\n  }\n\n  /**\n   * Retrieves the corresponding Set of translated text responses\n   *\n   * This is used to determine if the text being sent to translate\n   * has already been translated. In such a situation we want to\n   * avoid sending it to the translator a second time.\n   *\n   * @param {boolean} isHTML\n   * @returns {Set<string>}\n   */\n  #getCacheSet(isHTML) {\n    return isHTML ? this.#htmlCacheSet : this.#textCacheSet;\n  }\n\n  /**\n   * Get a translation if it exists from the cache, and move it to the end of the cache\n   * to keep it alive longer.\n   *\n   * @param {string} sourceString\n   * @param {boolean} isHTML\n   *\n   * @returns {string | undefined}\n   */\n  get(sourceString, isHTML) {\n    const cacheMap = this.#getCacheMap(isHTML);\n    const targetString = cacheMap.get(sourceString);\n\n    if (targetString === undefined) {\n      return undefined;\n    }\n\n    // Maps are ordered, move this item to the end of the list so it will stay\n    // alive longer.\n    cacheMap.delete(sourceString);\n    cacheMap.set(sourceString, targetString);\n\n    this.keepAlive();\n\n    return targetString;\n  }\n\n  /**\n   * Adds a new translation to the cache, a mapping from the source text to the target text.\n   *\n   * @param {string} sourceString\n   * @param {string} targetString\n   * @param {boolean} isHTML\n   */\n  set(sourceString, targetString, isHTML) {\n    const cacheMap = this.#getCacheMap(isHTML);\n    if (cacheMap.has(sourceString)) {\n      // The Map already has this value, so we must delete it to\n      // re-insert it at the most-recently-used position of the Map.\n      cacheMap.delete(sourceString);\n    } else if (cacheMap.size === this.#cacheLimit) {\n      // The Map is at capacity, so we must evict the least-recently-used value.\n      const oldestKey = cacheMap.keys().next().value;\n      // @ts-ignore: We can ensure that oldestKey is not undefined.\n      cacheMap.delete(oldestKey);\n    }\n    cacheMap.set(sourceString, targetString);\n\n    const cacheSet = this.#getCacheSet(isHTML);\n    if (cacheSet.has(targetString)) {\n      // The Set already has this value, so we must delete it to\n      // re-insert it at the most-recently-used position of the Set.\n      cacheSet.delete(targetString);\n    } else if (cacheSet.size === this.#cacheLimit) {\n      // The Set is at capacity, so we must evict the least-recently-used value.\n      const oldestKey = cacheSet.keys().next().value;\n      // @ts-ignore: We can ensure that oldestKey is not undefined.\n      cacheSet.delete(oldestKey);\n    }\n    cacheSet.add(targetString);\n\n    this.keepAlive();\n  }\n\n  /**\n   * Returns true if the source text is text that has already been translated\n   * into the target language, otherwise false. If so, we want to avoid sending\n   * this text to be translated a second time. Depending on the model, retranslating\n   * text that is already in the target language may produce garbage output.\n   *\n   * @param {string} sourceText\n   * @param {boolean} isHTML\n   *\n   * @returns {boolean}\n   */\n  isAlreadyTranslated(sourceText, isHTML) {\n    return this.#getCacheSet(isHTML).has(sourceText);\n  }\n\n  /**\n   * Returns true if the given pair matches the language pair for this cache, otherwise false.\n   *\n   * @param {LanguagePair} languagePair\n   *\n   * @returns {boolean}\n   */\n  matches(languagePair) {\n    return (\n      lazy.TranslationsUtils.langTagsMatch(\n        this.#languagePair.sourceLanguage,\n        languagePair.sourceLanguage\n      ) &&\n      lazy.TranslationsUtils.langTagsMatch(\n        this.#languagePair.targetLanguage,\n        languagePair.targetLanguage\n      )\n    );\n  }\n\n  /**\n   * The id for the cache's keep-alive timeout, at which point it will destroy itself.\n   *\n   * @type {number}\n   */\n  #keepAliveTimeoutId = 0;\n\n  /**\n   * Used to ensure that only one callback is added to the event loop to set keep-alive timeout.\n   *\n   * @type {boolean}\n   */\n  #hasPendingKeepAliveCallback = false;\n\n  /**\n   * Resets the timer for the cache's keep-alive timeout, extending the time the cache will live.\n   */\n  keepAlive() {\n    if (this.#hasPendingKeepAliveCallback) {\n      // There is already a pending callback to extend the timeout.\n      return;\n    }\n\n    if (this.#keepAliveTimeoutId) {\n      lazy.clearTimeout(this.#keepAliveTimeoutId);\n      this.#keepAliveTimeoutId = 0;\n    }\n\n    this.#hasPendingKeepAliveCallback = true;\n    lazy.setTimeout(() => {\n      this.#hasPendingKeepAliveCallback = false;\n      this.#keepAliveTimeoutId = lazy.setTimeout(() => {\n        this.#htmlCacheMap = new Map();\n        this.#textCacheMap = new Map();\n        this.#htmlCacheSet = new Set();\n        this.#textCacheSet = new Set();\n      }, this.#cacheExpirationMS);\n    }, 0);\n  }\n}\n\n/**\n * How often the DOM is updated with translations, in milliseconds.\n *\n * Each time the DOM is updated, we must pause the mutation observer.\n *\n *  - Stopping the observer takes about 5 micro seconds based on profiling.\n *\n *  - Starting the observer takes about 30 micro seconds based on profiling.\n *\n * We want to choose a DOM update interval that is fast enough to feel instantaneously\n * reactive when completed translation requests come in, while also allowing multiple\n * nodes to be updated within a single pause of the observer.\n *\n * @type {number}\n */\nconst DOM_UPDATE_INTERVAL_MS = 25;\n\n/**\n * Tags excluded from content translation.\n */\nconst CONTENT_EXCLUDED_TAGS = new Set([\n  // The following are elements that semantically should not be translated.\n  \"CODE\",\n  \"KBD\",\n  \"SAMP\",\n  \"VAR\",\n  \"ACRONYM\",\n\n  // The following are deprecated tags.\n  \"DIR\",\n  \"APPLET\",\n\n  // The following are embedded elements, and are not supported (yet).\n  \"MATH\",\n  \"EMBED\",\n  \"OBJECT\",\n  \"IFRAME\",\n\n  // This is an SVG tag that can contain arbitrary XML, ignore it.\n  \"METADATA\",\n\n  // These are elements that are treated as opaque by Firefox which causes their\n  // innerHTML property to be just the raw text node behind it. Any text that is sent as\n  // HTML must be valid, and there is no guarantee that the innerHTML is valid.\n  \"NOSCRIPT\",\n  \"NOEMBED\",\n  \"NOFRAMES\",\n\n  // The title is handled separately, and a HEAD tag should not be considered.\n  \"HEAD\",\n\n  // These are not user-visible tags.\n  \"STYLE\",\n  \"SCRIPT\",\n  \"TEMPLATE\",\n\n  // Textarea elements contain user content, which should not be translated.\n  \"TEXTAREA\",\n]);\n\n/**\n * Tags excluded from attribute translation.\n */\nconst ATTRIBUTE_EXCLUDED_TAGS = (() => {\n  const attributeTags = new Set(CONTENT_EXCLUDED_TAGS);\n\n  // The <head> element may contain <meta> elements that may have translatable attributes.\n  // So we will allow <head> for attribute translations, but not for content translations.\n  attributeTags.delete(\"HEAD\");\n\n  // <textarea> elements are excluded from content translation, because we do not want to\n  // translate text that the user types, but the \"placeholder\"attribute should be translated.\n  attributeTags.delete(\"TEXTAREA\");\n\n  return attributeTags;\n})();\n\n/**\n * A map of criteria to determine if an attribute is translatable for a given element.\n * Each key in the map represents an attribute name, while the value can be either `null` or an array of further criteria.\n *\n * - If the criteria value is `null`, the attribute is considered translatable for any element.\n *\n * - If the criteria array is specified, then at least one criterion must match a given element in order for the attribute to be translatable.\n *   Each object in the array defines a tagName and optional conditions to match against an element in question.\n *\n *   - If none of the tagNames match the element, then the attribute is not translatable for that element.\n *\n *   - If a tagName matches and no further conditions are specified, then the attribute is always translatable for elements of that type.\n *\n *   - If a tagName matches and further conditions are specified, then at least one of the conditions must match for the attribute to be translatable for that element.\n *\n * Example:\n *\n * - \"title\" is translatable for all elements.\n *\n * - \"label\" is translatable only for \"TRACK\" elements.\n *\n * - \"value\" is translatable only for \"INPUT\" elements whose \"type\" attribute is \"button\", \"reset\".\n *\n * @type {Map<string, Array<{ tagName: string, conditions?: Record<string, Array<string>> }> | null>}\n */\nconst TRANSLATABLE_ATTRIBUTES = new Map([\n  [\"abbr\", [{ tagName: \"TH\" }]],\n  [\n    \"alt\",\n    [\n      { tagName: \"AREA\" },\n      { tagName: \"IMAGE\" },\n      { tagName: \"IMG\" },\n      { tagName: \"INPUT\" },\n    ],\n  ],\n  [\"aria-braillelabel\", null],\n  [\"aria-brailleroledescription\", null],\n  [\"aria-colindextext\", null],\n  [\"aria-description\", null],\n  [\"aria-label\", null],\n  [\"aria-placeholder\", null],\n  [\"aria-roledescription\", null],\n  [\"aria-rowindextext\", null],\n  [\"aria-valuetext\", null],\n  [\n    \"content\",\n    [{ tagName: \"META\", conditions: { name: [\"description\", \"keywords\"] } }],\n  ],\n  [\"download\", [{ tagName: \"A\" }, { tagName: \"AREA\" }]],\n  [\n    \"label\",\n    [{ tagName: \"TRACK\" }, { tagName: \"OPTGROUP\" }, { tagName: \"OPTION\" }],\n  ],\n  [\"placeholder\", [{ tagName: \"INPUT\" }, { tagName: \"TEXTAREA\" }]],\n  [\"title\", null],\n  [\n    // We only want to translate value attributes for button-like <input> elements.\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=1919230#c10\n    // type: submit is not translated because it may affect form submission, depending on how the server is configured.\n    // See https://github.com/whatwg/html/issues/3396#issue-291182587\n    \"value\",\n    [{ tagName: \"INPUT\", conditions: { type: [\"button\", \"reset\"] } }],\n  ],\n]);\n\n/**\n * A single CSS selector string that matches elements with the criteria defined in TRANSLATABLE_ATTRIBUTES.\n *\n * @see TRANSLATABLE_ATTRIBUTES\n *\n * @type {string}\n */\nconst TRANSLATABLE_ATTRIBUTES_SELECTOR = (() => {\n  const selectors = [];\n\n  for (const [attribute, criteria] of TRANSLATABLE_ATTRIBUTES) {\n    if (!criteria) {\n      // There are no further criteria: we translate this attribute for all elements.\n      // Example: [title]\n      selectors.push(`[${attribute}]`);\n      continue;\n    }\n\n    for (const { tagName, conditions } of criteria) {\n      if (!conditions) {\n        // There are no further conditions: we translate this attribute for all elements with this tagName.\n        // Example: TRACK[label]\n        selectors.push(`${tagName}[${attribute}]`);\n        continue;\n      }\n\n      // Further conditions are specified, so we must add a selector for each condition.\n      for (const [key, values] of Object.entries(conditions)) {\n        for (const value of values) {\n          // Example: INPUT[value][type=\"button\"]\n          selectors.push(`${tagName}[${attribute}][${key}=\"${value}\"]`);\n        }\n      }\n    }\n  }\n\n  return selectors.join(\",\");\n})();\n\n/**\n * Options used by the mutation observer\n */\nconst MUTATION_OBSERVER_OPTIONS = {\n  characterData: true,\n  childList: true,\n  subtree: true,\n  attributes: true,\n  attributeOldValue: true,\n  attributeFilter: [...TRANSLATABLE_ATTRIBUTES.keys()],\n};\n\n/**\n * This class manages the process of translating the DOM from one language to another.\n *\n * The logic within this class is generally separated into two types of translations:\n * Content Translations and Attribute Translations.\n *\n *  - For Content Translations, the DOM is traversed, filtered, and subdivided into smaller\n *    groups of Nodes that have translatable text content.\n *\n *  - For Attribute Translations, a series of query selectors are used to filter all of\n *    the Nodes that have translatable attributes within the DOM.\n *\n * Once nodes have been identified for both Content Translations and Attribute Translations,\n * they are then registered for intersection observation and mutation observation.\n *\n * The mutation observer notifies us when a Node's content has changed, when a Node's translatable\n * attributes have changed, as well as when new nodes are added into the DOM tree, and need to be\n * further filtered, subdivided, and registered for intersection observation.\n *\n * In total, four intersection observers are used to prioritize which nodes should be translated: two to\n * handle content-translation observations, and the other two to handle attribute-translation observations.\n *\n * Once intersections have been observed, the relevant nodes are sent into a queue where they will\n * wait to be assigned a priority, based on both the type of translation, as well as the Node's location\n * relative to the viewport of the screen.\n *\n * Prioritized nodes are then sent to the translation scheduler @see {TranslationScheduler}, which\n * will attempt to optimally send requests to the TranslationsEngine worker to be translated, based\n * both on the engine's throughput as well as on how many new translation requests are coming in.\n *\n * Once a request has come back from the TranslationsEngine worker, its response is validated, then\n * the relevant node's content or attribute is scheduled to be updated in the DOM with the corresponding\n * result of the translation.\n *\n * Note that a pending translation request may be cancelled at any stage in this process, up until the point\n * where the request has come back from the TranslationsEngine worker, and the Node's content or attribute\n * has been replaced in the DOM. Cancellations may happen for one of several reasons:\n *\n *  1) The page has been hidden (such as switching tabs), and we are pausing all execution until it is shown again.\n *  2) The user has scrolled to a new location on the page entirely, and prior requests are no longer relevant.\n *  3) A Node's location with respect to the viewport has changed and it needs a new translation priority.\n *  4) A Node's content has mutated within the DOM, and the pending translation request is no longer relevant.\n *\n * The following diagram shows the flow of translations throughout the entire lifecycle of the TranslationsDocument.\n *\n *                             ┌────────────────────────┐    ┌──────────┐\n *                             │ Register DOM roots for │    │ Mutation │\n *                             │ mutation observation   │    │ Observer │\n *                             └────────────────────────┘    └──────────┘\n *                                         │                      │\n *                                         │                      │ New nodes\n *                                         │                      │ observed\n *                                         v                      │\n *                                ┌─────────────────┐             │\n *                                │ Subdivide nodes │ <───────────┘\n *                                │ within the DOM  │\n *                                └─────────────────┘\n *                                         │\n *                                         │\n *                                         │\n *                                         v\n *                                ┌──────────────────┐\n *                                │ Register nodes   │\n * ┌────────────────────────────> │ for intersection │\n * │                              │ observation      │\n * │                              └──────────────────┘\n * │                                       │\n * │                                       │\n * │                                       │\n * │                                       v\n * │                              ┌───────────────────┐\n * │                              │ Wait for observed │\n * │  ┌─────────────────────────> │ intersection      │\n * │  │                           └───────────────────┘\n * │  │                                    │\n * │  │                                    │ Node intersection with\n * │  │                                    │ viewport is observed\n * │  │                                    │\n * │  │                                    v\n * │  │  ┌────────┐ Node mutated  ┌──────────────────┐\n * │  ├─ │ Cancel │ <──────────── │ Enqueue node for │ Node's intersection context with\n * │  │  └────────┘               │ prioritization   │ respect to the viewport has changed   ┌────────┐\n * │  │                           │                  │ ────────────────────────────────────> │ Cancel │\n * │  │                           └──────────────────┘                                       └────────┘\n * │  │                                    │   ^   ^                                              │ Node's new intersection context is\n * │  │           Send prioritized node    │   │   │                                              │ still relevant to be translated\n * │  │           to translation scheduler │   │   └──────────────────────────────────────────────┘\n * │  │                                    │   │\n * │  │                                    v   └───────────────────────────────────────────────────┐\n * │  │                           ┌───────────────────┐                                            │ Node's new intersection context is\n * │  │                           │ Scheduler creates │ Node's intersection context with           │ still relevant to be translated\n * │  │  ┌────────┐ Node mutated  │ a request promise │ respect to the viewport has changed    ┌────────┐\n * │  ├─ │ Cancel │ <──────────── │ for the node      │ ─────────────────────────────────────> │ Cancel │\n * │  │  └────────┘               └───────────────────┘                                        └────────┘\n * │  │                                    │\n * │  │                                    │ Send translation request\n * │  │                                    │ to TranslationsEngine\n * │  │                                    │\n * │  │                                    v\n * │  │                           ┌───────────────────┐\n * │  │                           │ Wait for response │\n * │  │  ┌────────┐ Node mutated  │ from translations │\n * │  ├─ │ Cancel │ <──────────── │ engine            │\n * │  │  └────────┘               └───────────────────┘\n * │  │                                    │\n * │  │                                    │ Receive response with\n * │  │                                    │ translated text for node\n * │  │                                    │\n * │  │                                    v\n * │  │                           ┌───────────────┐\n * │  │                           │ Schedule node │\n * │  │  ┌────────┐  Node mutated │ to be updated │\n * │  └─ │ Cancel │ <──────────── │               │\n * │     └────────┘               └───────────────┘\n * │                                       │\n * │                                       │ Update node content\n * │                                       │ or attribute with\n * │                                       │ translated text\n * │                                       v\n * │                              ┌───────────────────┐\n * │                              │ Unregister node   │\n * │                 Node mutated │ from intersection │\n * └───────────────────────────── │ observation       │\n *                                └───────────────────┘\n */\nclass TranslationsDocument {\n  /**\n   * The BCP 47 language tag that matches the page's source language.\n   *\n   * If elements are found that do not match this language, then they are skipped,\n   * because our translation models only operate between the exact language pair.\n   *\n   * @type {string}\n   */\n  #documentLanguage;\n\n  /**\n   * Marks when we have a pending callback for updating all nodes whose content translation\n   * requests have completed. This ensures that we won't redundantly request to update nodes.\n   *\n   * @type {boolean}\n   */\n  #hasPendingUpdateContentCallback = false;\n\n  /**\n   * Marks when we have a pending callback for updating all elements whose attribute\n   * translation requests have completed. This ensures that we won't redundantly request\n   * to update nodes.\n   *\n   * @type {boolean}\n   */\n  #hasPendingUpdateAttributesCallback = false;\n\n  /**\n   * A map of elements with translatable text content that may be prevented and removed\n   * by the intersection observers before they are prioritized and sent to the scheduler.\n   *\n   * @type {Map<Element, Set<Node>>}\n   */\n  #queuedIntersectionPrunableContentElements = new Map();\n\n  /**\n   * A map of elements with translatable text content that are unaffected by intersection\n   * observation. An example of this would be the <title> element, which will never intersect\n   * with the viewport.\n   *\n   * @type {Map<Element, Set<Node>>}\n   */\n  #queuedIntersectionExemptContentElements = new Map();\n\n  /**\n   * A map of elements with translatable attributes that may be prevented and removed\n   * by the intersection observers before they are prioritized and sent to the scheduler.\n   *\n   * @type {Map<Element, Set<string>>}\n   */\n  #queuedIntersectionPrunableAttributeElements = new Map();\n\n  /**\n   * A map of elements with translatable attributes that are unaffected by intersection\n   * observation. An example of this would be the <head> element, which may have translatable\n   * attributes, but will never intersect with the viewport.\n   *\n   * @type {Map<Element, Set<string>>}\n   */\n  #queuedIntersectionExemptAttributeElements = new Map();\n\n  /**\n   * The list of nodes that need updating with the translated content. These are batched into an update.\n   * The translationId is a monotonically increasing number that represents a unique id for a translation.\n   * It guards against races where a node is mutated before the translation is returned. The translation is\n   * asynchronously cancelled during a mutation, but it can still return a translation before it is\n   * cancelled.\n   *\n   * @type {Set<{ element: Element, targetNode: Node, translatedContent: string, translationId: number }>}\n   */\n  #elementsThatNeedContentUpdates = new Set();\n\n  /**\n   * The list of nodes that need updating with the translated attributes. These are batched into an update.\n   * The translationId is a monotonically increasing number that represents a unique id for a translation.\n   * It guards against races where a node is mutated before the translation is returned. The translation is\n   * asynchronously cancelled during a mutation, but it can still return a translation before it is\n   * cancelled.\n   *\n   * @type {Set<{ element: Element, translation: string, attribute: string, translationId: number }>}\n   */\n  #elementsThatNeedAttributeUpdates = new Set();\n\n  /**\n   * This is the set of nodes (both elements and text nodes) whose translation requests\n   * have fully completed, and the node's content has been updated with the translated\n   * value.\n   *\n   * Nodes will be removed from this set when they are observed for mutations.\n   *\n   * @type {WeakSet<Node>}\n   */\n  #processedContentNodes = new WeakSet();\n\n  /**\n   * All root elements we're trying to translate. This should be the `document.body`\n   * the `head` (for attributes only), and the `title` element.\n   *\n   * @type {Set<Node>}\n   */\n  #rootNodes = new Set();\n\n  /**\n   * A collection of nodes whose text content has mutated, which will be batched\n   * together and sent to be re-translated once every requestAnimationFrame.\n   *\n   * @type {Set<Node>}\n   */\n  #nodesWithMutatedContent = new Set();\n\n  /**\n   * A collection of elements whose attributes have mutated, which will be batched\n   * together and sent to be re-translated once every requestAnimationFrame.\n   *\n   * @type {Map<Element, Set<string>>}\n   */\n  #elementsWithMutatedAttributes = new Map();\n\n  /**\n   * Marks when we have a pending callback for updating the mutated nodes.\n   * This ensures that we won't redundantly request for nodes to be updated.\n   *\n   * @type {boolean}\n   */\n  #hasPendingMutatedNodesCallback = false;\n\n  /**\n   * Marks when we have a pending callback for sending prioritizing translation\n   * requests and submitting them to the TranslationScheduler. This ensures that\n   * we won't redundantly request prioritization.\n   *\n   * @type {boolean}\n   */\n  #hasPendingPrioritizationCallback = false;\n\n  /**\n   * This boolean indicates whether the first visible DOM translation change is about to occur.\n   *\n   * @type {boolean}\n   */\n  #hasFirstVisibleChange = false;\n\n  /**\n   * A unique ID that guards against races between translations and mutations.\n   *\n   * @type {Map<Element, Map<Node, number>>}\n   */\n  #pendingContentTranslations = new Map();\n\n  /**\n   * A unique ID that guards against races between translations and mutations. The\n   * Map<string, number> is a mapping of the node's attribute to the translation id.\n   *\n   * @type {Map<Element, Map<string, number>>}\n   */\n  #pendingAttributeTranslations = new Map();\n\n  /**\n   * Cache a map of all child nodes to their pending parents. This lookup was slow\n   * from profiling sites like YouTube with lots of mutations. Caching the relationship\n   * speeds it up.\n   *\n   * @type {WeakMap<Node, Node>}\n   */\n  #nodeToPendingParent = new WeakMap();\n\n  /**\n   * The y-axis location of the viewport the previous time a scroll event was fired.\n   *\n   * @type {number}\n   */\n  #previousScrollY = 0;\n\n  /**\n   * A hint at the most recent direction in which the user scrolled since requesting translations.\n   * This helps with the prioritization of translation requests for outside-of-viewport nodes.\n   *\n   * @type {ScrollDirection?}\n   */\n  #mostRecentScrollDirection = null;\n\n  /**\n   * The most recent timestamp from a \"scroll\" event.\n   *\n   * @type {number}\n   */\n  #mostRecentScrollTimestamp = 0;\n\n  /**\n   * Start with 1 so that it will never be falsey.\n   *\n   * @type {number}\n   */\n  #lastTranslationId = 1;\n\n  /**\n   * A cache of recent translations, used to avoid wasting CPU time translating text\n   * for which we already have a translated response.\n   *\n   * @type {LRUCache}\n   */\n  #translationsCache;\n\n  /**\n   * The DOMParser is used when updating elements with translated text.\n   *\n   * @type {DOMParser}\n   */\n  #domParser;\n\n  /**\n   * The mutation observer that watches for both new and mutated nodes.\n   *\n   * @type {MutationObserver}\n   */\n  #mutationObserver;\n\n  /**\n   * The inner-window ID is used for better profiler marker reporting.\n   *\n   * @type {number}\n   */\n  #innerWindowId;\n\n  /**\n   * The original document of the page that we will be updating with translated text.\n   *\n   * @type {Document}\n   */\n  #sourceDocument;\n\n  /**\n   * A callback that will report that the first visible change has been made to the page.\n   * This is a key performance metric when considering the time to initialize translations.\n   *\n   * @type {() => void}\n   */\n  #actorReportFirstVisibleChange;\n\n  /**\n   * The scheduler that is responsible for sending translation requests to the TranslationsEngine.\n   *\n   * @type {TranslationScheduler}\n   */\n  #scheduler;\n\n  /**\n   * The script direction of the target language.\n   *\n   * @type {(\"ltr\"|\"rtl\")}\n   */\n  #targetScriptDirection;\n\n  /**\n   * The mode of translation, either \"content-eager\" or \"lazy\".\n   *\n   * When the find bar is closed, the mode will be \"lazy\", translating only content near the viewport.\n   * This is better for power consumption, conserves battery on mobile, etc., and is the default behavior.\n   *\n   * When the find bar is open, the mode will change to \"content-eager\", eventually translating the entire page,\n   * regardless of proximity to the viewport. This way the find-in-page functionality will work as intended.\n   *\n   * @type {TranslationsMode}\n   */\n  #translationsMode;\n\n  /**\n   * A map containing all elements that are being observed for content translations,\n   * and the set of translatable nodes for that element.\n   *\n   * Only Element type nodes are observable for intersection, so in order to observe\n   * a Text Node for intersection, it must be linked to its parent element.\n   *\n   * Note that the set of translatable nodes may contain the element itself.\n   *\n   * @type {Map<Element, Set<Node>>}\n   */\n  #intersectionObservedContentElements = new Map();\n\n  /**\n   * A map containing all elements that are being observed for attribute translations,\n   * and the set of translatable attribute names for each element.\n   *\n   * @type {Map<Element, Set<string>>}\n   */\n  #intersectionObservedAttributeElements = new Map();\n\n  // The following four intersection observers are responsible for detecting when nodes are within close enough range of the viewport\n  // to have their content and/or attributes scheduled to be translated. Two observers are dedicated to observing nodes with translatable\n  // text content, and two observers are dedicated to observing nodes with translatable attributes.\n  //\n  // Each pair has one In-Viewport Observer and one Beyond-Viewport Observer. The priority at which a node's translations are scheduled is\n  // determined by its location within these observer pairs. Translations for nodes that are observed by the In-Viewport observers are scheduled\n  // at the highest priority. Translations for nodes that are observed by the Beyond-Viewport observers are scheduled at lower priorities.\n  //\n  // As the location of the viewport changes with respect to the page, translations for nodes may be reprioritized or cancelled altogether.\n  // The following diagram shows a few examples of how translation priorities for nodes may change as the viewport moves:\n  //\n  //\n  //                                    Page                                                             Page\n  //                   ┌─────────────────────────────────────┐                          ┌─────────────────────────────────────┐\n  //                   │ ~~~                    ~ ~ ~ ~ ~    │                          │ ~~~                    ~ ~ ~ ~ ~    │\n  //                   │                                     │                          │                                     │\n  //                   │         ~~~~~~~~~~~~~~~~~~          │                          │         ~~~~~~~~~~~~~~~~~~          │\n  // Beyond-Viewport ══╪═> ┌─────────────────────────────┐   │   v                      │ ╔═══════════════════════════════════╪════╦═══ Translations for these nodes\n  // Observer          │   │ ~~  ~~~~~~~~~~~~~~~~~~      │   │   v                      │ ╠═> ~~  ~~~~~~~~~~~~~~~~~~  <═══════╪════╣    will be cancelled if their\n  //                   │   │ ~~  ~~~~~~~~~~~~~~~~~~~     │   │   v                      │ ╚═> ~~  ~~~~~~~~~~~~~~~~~~~ <═══════╪════╣    requests did not yet complete.\n  //                   │   │                             │   │   v                      │                                     │    ║\n  //     In-Viewport ══╪═══╪══> ┌───────────────────┐    │   │   v                      │                                     │    ║\n  //     Observer      │   │    │~~~~~~~~~~~~~~~~~  │    │   │   v                      │         ~~~~~~~~~~~~~~~~~   <═══════╪════╝\n  //                   │   │    │                   │    │   │   v    Beyond-Viewport ══╪═> ┌─────────────────────────────┐   │\n  //                   │   │    │~~~~~~~~~~~~~~~~~~ │    │   │   v    Observer          │   │     ~~~~~~~~~~~~~~~~~~~ <═══╪═══╪════╦═══ Translations for these nodes\n  //                   │   │    │                   │    │   │                          │   │                             │   │    ║    will be moved to a lower priority\n  //                   │   │    └───────────────────┘    │   │ Scroll                   │   │     ~~~~~~~~~~~~~~~~~~ <════╪═══╪════╝    if their requests did not yet complete.\n  //                   │   │                             │   │  down      In-Viewport ══╪═══╪══> ┌───────────────────┐    │   │\n  //                   │   │ ~~                          │   │            Observer      │   │ ~~ │                   │    │   │\n  //                   │   │ ~~  ~~~~~~~~~~~~~~~         │   │   v                      │   │ ~~ │~~~~~~~~~~~~~~~ <══╪════╪═══╪════════ Translations for this node will\n  //                   │   └─────────────────────────────┘   │   v                      │   │    │                   │    │   │         be moved to a higher priority if\n  //                   │                                     │   v                      │   │    │                   │    │   │         its requests did not yet complete.\n  //                   │                                     │   v                      │   │    └───────────────────┘    │   │\n  //                   │                                     │   v                      │   │                             │   │\n  //                   │         ~~~~~~~~~~~~~~~~~~          │   v                      │   │     ~~~~~~~~~~~~~~~~~~ <════╪═══╪════╦═══ Translations for these nodes will\n  //                   │         ~~~~~~~~~~~~~~~~~           │   v                      │   │     ~~~~~~~~~~~~~~~~~ <═════╪═══╪════╝    be newly requested at a lower priority.\n  //                   │                                     │                          │   └─────────────────────────────┘   │\n  //                   │     ~~  ~~~~~~~~~~~~~~~~~~~         │                          │     ~~  ~~~~~~~~~~~~~~~~~~~         │\n  //                   │         ~~~~~~~~~~~~~~~~            │                          │         ~~~~~~~~~~~~~~~~            │\n  //                   │ ~~~                            ~~~~ │                          │ ~~~                            ~~~~ │\n  //                   └─────────────────────────────────────┘                          └─────────────────────────────────────┘\n\n  /**\n   * An intersection observer bound to the exact dimensions of the viewport\n   * that watches for nodes whose text content is translatable.\n   *\n   * Nodes observed by this observer lead to the highest-priority translation requests\n   * since they are the nodes that are immediately within the viewport.\n   *\n   * @type {IntersectionObserver}\n   */\n  #intersectionObserverForContentTranslationsWithinViewport;\n\n  /**\n   * A promise that is resolved once the in-viewport content intersection observer's\n   * first observation has completed.\n   *\n   * @type {PromiseWithResolvers<void>}\n   */\n  #contentWithinViewportInitialObservation = Promise.withResolvers();\n\n  /**\n   * An intersection observer whose borders extend beyond the viewport\n   * that watches for nodes whose text content is translatable.\n   *\n   * Nodes observed by this observer lead to lower-priority translation requests\n   * since they lie just beyond the viewport of what the user can see.\n   *\n   * @type {IntersectionObserver}\n   */\n  #intersectionObserverForContentTranslationsBeyondViewport;\n\n  /**\n   * A promise that is resolved once the beyond-viewport content intersection observer's\n   * first observation has completed.\n   *\n   * @type {PromiseWithResolvers<void>}\n   */\n  #contentBeyondViewportInitialObservation = Promise.withResolvers();\n\n  /**\n   * An intersection observer bound to the exact dimensions of the viewport\n   * that watches for nodes with attributes that are translatable.\n   *\n   * Nodes observed by this observer lead to the highest-priority translation requests\n   * since they are the nodes that are immediately within the viewport.\n   *\n   * @type {IntersectionObserver}\n   */\n  #intersectionObserverForAttributeTranslationsWithinViewport;\n\n  /**\n   * A promise that is resolved once the in-viewport attribute intersection observer's\n   * first observation has completed.\n   *\n   * @type {PromiseWithResolvers<void>}\n   */\n  #attributesWithinViewportInitialObservation = Promise.withResolvers();\n\n  /**\n   * An intersection observer whose borders extend beyond the viewport\n   * that watches for nodes with attributes that are translatable.\n   *\n   * Nodes observed by this observer lead to lower-priority translation requests\n   * since they lie just beyond the viewport of what the user can see.\n   *\n   * @type {IntersectionObserver}\n   */\n  #intersectionObserverForAttributeTranslationsBeyondViewport;\n\n  /**\n   * A promise that is resolved once the beyond-viewport attribute intersection observer's\n   * first observation has completed.\n   *\n   * @type {PromiseWithResolvers<void>}\n   */\n  #attributesBeyondViewportInitialObservation = Promise.withResolvers();\n\n  /**\n   * Construct a new TranslationsDocument. It is tied to a specific Document and cannot\n   * be re-used. The translation functions are injected since this class shouldn't\n   * manage the life cycle of the translations engines.\n   *\n   * @param {Document} document\n   * @param {string} documentLanguage - The BCP 47 tag of the source language.\n   * @param {string} targetLanguage - The BCP 47 tag of the destination language.\n   * @param {number} innerWindowId - This is used for better profiler marker reporting.\n   * @param {MessagePort} port - The port to the translations engine.\n   * @param {() => void} requestNewPort - Used when an engine times out and a new\n   *                                      translation request comes in.\n   * @param {() => void} reportVisibleChange - Used to report to the actor that the first visible change\n   *                                           for a translation is about to occur.\n   * @param {LRUCache} translationsCache - A cache in which to store translated text.\n   * @param {boolean} isFindBarOpen - Whether the find bar was open in the current tab upon construction.\n   */\n  constructor(\n    document,\n    documentLanguage,\n    targetLanguage,\n    innerWindowId,\n    port,\n    requestNewPort,\n    reportVisibleChange,\n    translationsCache,\n    isFindBarOpen\n  ) {\n    /** @type {WindowProxy} */\n    const ownerGlobal = ensureExists(document.ownerGlobal);\n    ownerGlobal.addEventListener(\"scroll\", this.#handleScrollEvent);\n\n    this.#domParser = new ownerGlobal.DOMParser();\n    this.#innerWindowId = innerWindowId;\n    this.#sourceDocument = document;\n    this.#documentLanguage = documentLanguage;\n    this.#translationsCache = translationsCache;\n    this.#actorReportFirstVisibleChange = reportVisibleChange;\n    this.#targetScriptDirection =\n      Services.intl.getScriptDirection(targetLanguage);\n    this.#translationsMode = isFindBarOpen ? \"content-eager\" : \"lazy\";\n\n    this.#scheduler = new TranslationScheduler(\n      port,\n      this.#innerWindowId,\n      translationsCache,\n      requestNewPort\n    );\n\n    /**\n     * This selector runs to find child nodes that should be excluded. It should be\n     * basically the same implementation of `isExcludedNode`, but as a selector.\n     *\n     * @type {string}\n     */\n    this.contentExcludedNodeSelector = [\n      // Use: [lang|=value] to match language codes.\n      //\n      // Per: https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\n      //\n      // The elements with an attribute name of attr whose value can be exactly\n      // value or can begin with value immediately followed by a hyphen, - (U+002D).\n      // It is often used for language subcode matches.\n      `[lang]:not([lang|=\"${this.#documentLanguage}\"])`,\n      `[translate=no]`,\n      `.notranslate`,\n      `[contenteditable=\"true\"]`,\n      `[contenteditable=\"\"]`,\n      [...CONTENT_EXCLUDED_TAGS].join(\",\"),\n    ].join(\",\");\n\n    /**\n     * This selector runs to find elements that should be excluded from attribute translation.\n     *\n     * @type {string}\n     */\n    this.attributeExcludedNodeSelector = [\n      // Exclude any element with translate=\"no\", as it explicitly opts out of translation.\n      `[translate=\"no\"]`,\n\n      // Exclude any element that is a descendant of a container marked with \"notranslate\" class.\n      `.notranslate`,\n      [...ATTRIBUTE_EXCLUDED_TAGS].join(\",\"),\n    ].join(\",\");\n\n    /**\n     * Define the type of IntersectionObserver for lazily prioritizing translations.\n     *\n     * @type {typeof IntersectionObserver}\n     */\n    const DocumentIntersectionObserver = ownerGlobal.IntersectionObserver;\n\n    this.#intersectionObserverForContentTranslationsWithinViewport =\n      new DocumentIntersectionObserver(\n        entries => {\n          // The count of requests that we prevent from being sent to the TranslationsEngine.\n          let preventedCount = 0;\n\n          // The count of requests that we had to cancel from the TranslationScheduler.\n          // This is a subset of preventedCount.\n          let cancelledCount = 0;\n\n          // The count of nodes that entered this observer's proximity.\n          let enteredCount = 0;\n\n          // The count of nodes that exited this observer's proximity.\n          let exitedCount = 0;\n\n          const startTime = ChromeUtils.now();\n          for (const { target, isIntersecting } of entries) {\n            isIntersecting ? enteredCount++ : exitedCount++;\n\n            // The logic here does not care about `isIntersecting`, because it doesn't matter\n            // whether the target entered the boundary or exited the boundary. If the target\n            // entered, then it may need to be reprioritized to a higher priority. If it exited\n            // then the target may need to be reprioritized to a lower priority. In either case, we\n            // need to try to cancel any unscheduled requests, and resubmit them with a new priority.\n            const { preventedNodeSet, cancelledFromSchedulerCount } =\n              this.#preventUnscheduledContentTranslations(target);\n\n            if (preventedNodeSet) {\n              preventedCount += preventedNodeSet.size;\n              cancelledCount += cancelledFromSchedulerCount;\n\n              this.#queuedIntersectionPrunableContentElements.set(\n                target,\n                preventedNodeSet\n              );\n            }\n          }\n\n          ChromeUtils.addProfilerMarker(\n            \"TranslationsDocument IntersectionObserver (Content)\",\n            { startTime, innerWindowId },\n            `Within Viewport: ${enteredCount} elements entered, ${exitedCount} exited, ` +\n              `prevented ${preventedCount} requests: ` +\n              `${preventedCount - cancelledCount} requests were never sent to the scheduler, ` +\n              `${cancelledCount} requests were cancelled from the scheduler.`\n          );\n\n          this.#contentWithinViewportInitialObservation.resolve();\n          this.#maybePrioritizeRequestsAndSubmitToScheduler();\n        },\n        {\n          root: null,\n          rootMargin: \"0% 0% 0% 0%\",\n        }\n      );\n\n    this.#intersectionObserverForContentTranslationsBeyondViewport =\n      new DocumentIntersectionObserver(\n        entries => {\n          // The count of requests that we prevent from being sent to the TranslationsEngine.\n          let preventedCount = 0;\n\n          // The count of requests that we had to cancel from the TranslationScheduler.\n          // This is a subset of preventedCount.\n          let cancelledCount = 0;\n\n          // The count of nodes that entered this observer's proximity.\n          let enteredCount = 0;\n\n          // The count of nodes that exited this observer's proximity.\n          let exitedCount = 0;\n\n          const startTime = ChromeUtils.now();\n          for (const { target, isIntersecting } of entries) {\n            if (isIntersecting) {\n              // The target has entered the boundary, so we will enqueue it for translation.\n              // Even if the target is also within the boundary of the in-viewport observer\n              // this call is idempotent and the target will be enqueued only one time.\n              enteredCount++;\n              this.#enqueueForIntersectionPrunableContentPrioritization(target);\n            } else {\n              // The target has exited the boundary of the beyond-viewport observer,\n              // which means that is certainly not within range of the in-viewport observer.\n              // We should simply cancel the translation at this point until a time when the\n              // user moves the viewport near to this target again.\n              exitedCount++;\n\n              if (this.#translationsMode === \"lazy\") {\n                // We only want to prevent content translations after they exit beyond-viewport\n                // proximity in \"lazy\" translations mode. In \"content-eager\" translation mode,\n                // we must ensure that all content is still translated regardless of spatial context.\n                const { preventedNodeSet, cancelledFromSchedulerCount } =\n                  this.#preventUnscheduledContentTranslations(target);\n\n                if (preventedNodeSet) {\n                  preventedCount += preventedNodeSet.size;\n                  cancelledCount += cancelledFromSchedulerCount;\n                }\n              }\n            }\n          }\n\n          ChromeUtils.addProfilerMarker(\n            \"TranslationsDocument IntersectionObserver (Content)\",\n            { startTime, innerWindowId },\n            `Extended Viewport: ${enteredCount} elements entered, ${exitedCount} exited, ` +\n              `prevented ${preventedCount} requests: ` +\n              `${preventedCount - cancelledCount} requests were never sent to the scheduler, ` +\n              `${cancelledCount} requests were cancelled from the scheduler.`\n          );\n\n          this.#contentBeyondViewportInitialObservation.resolve();\n          this.#maybePrioritizeRequestsAndSubmitToScheduler();\n        },\n        {\n          root: null,\n          rootMargin: \"150% 50% 150% 50%\",\n        }\n      );\n\n    this.#intersectionObserverForAttributeTranslationsWithinViewport =\n      new DocumentIntersectionObserver(\n        entries => {\n          // The count of requests that we prevent from being sent to the TranslationsEngine.\n          let preventedCount = 0;\n\n          // The count of requests that we had to cancel from the TranslationScheduler.\n          // This is a subset of preventedCount.\n          let cancelledCount = 0;\n\n          // The count of nodes that entered this observer's proximity.\n          let enteredCount = 0;\n\n          // The count of nodes that exited this observer's proximity.\n          let exitedCount = 0;\n\n          const startTime = ChromeUtils.now();\n          for (const { target, isIntersecting } of entries) {\n            isIntersecting ? enteredCount++ : exitedCount++;\n\n            // The logic here does not care about `isIntersecting`, because it doesn't matter\n            // whether the target entered the boundary or exited the boundary. If the target\n            // entered, then it may need to be reprioritized to a higher priority. If it exited\n            // then the target may need to be reprioritized to a lower priority. In either case, we\n            // need to try to cancel any unscheduled requests, and resubmit them with a new priority.\n            const { preventedAttributeSet, cancelledFromSchedulerCount } =\n              this.#preventUnscheduledAttributeTranslations(target);\n            if (preventedAttributeSet) {\n              preventedCount += preventedAttributeSet.size;\n              cancelledCount += cancelledFromSchedulerCount;\n              this.#queuedIntersectionPrunableAttributeElements.set(\n                target,\n                preventedAttributeSet\n              );\n            }\n          }\n\n          ChromeUtils.addProfilerMarker(\n            \"TranslationsDocument IntersectionObserver (Attributes)\",\n            { startTime, innerWindowId },\n            `Within Viewport: ${enteredCount} elements entered, ${exitedCount} exited, ` +\n              `prevented ${preventedCount} requests: ` +\n              `${preventedCount - cancelledCount} requests were never sent to the scheduler, ` +\n              `${cancelledCount} requests were cancelled from the scheduler.`\n          );\n\n          this.#attributesWithinViewportInitialObservation.resolve();\n          this.#maybePrioritizeRequestsAndSubmitToScheduler();\n        },\n        {\n          root: null,\n          rootMargin: \"0% 0% 0% 0%\",\n        }\n      );\n\n    this.#intersectionObserverForAttributeTranslationsBeyondViewport =\n      new DocumentIntersectionObserver(\n        entries => {\n          // The count of requests that we prevent from being sent to the TranslationsEngine.\n          let preventedCount = 0;\n\n          // The count of requests that we had to cancel from the TranslationScheduler.\n          // This is a subset of preventedCount.\n          let cancelledCount = 0;\n\n          // The count of nodes that entered this observer's proximity.\n          let enteredCount = 0;\n\n          // The count of nodes that exited this observer's proximity.\n          let exitedCount = 0;\n\n          const startTime = ChromeUtils.now();\n          for (const { target, isIntersecting } of entries) {\n            if (isIntersecting) {\n              // The target has entered the boundary, so we will enqueue it for translation.\n              // Even if the target is also within the boundary of the in-viewport observer\n              // this call is idempotent and the target will be enqueued only one time.\n              enteredCount++;\n              this.#enqueueForIntersectionPrunableAttributePrioritization(\n                target\n              );\n            } else {\n              // The target has exited the boundary of the beyond-viewport observer,\n              // which means that is certainly not within range of the in-viewport observer.\n              // We should simply cancel the translation at this point until a time when the\n              // user moves the viewport near to this target again.\n              exitedCount++;\n\n              const { preventedAttributeSet, cancelledFromSchedulerCount } =\n                this.#preventUnscheduledAttributeTranslations(target);\n\n              if (preventedAttributeSet) {\n                preventedCount += preventedAttributeSet.size;\n                cancelledCount += cancelledFromSchedulerCount;\n              }\n            }\n          }\n\n          ChromeUtils.addProfilerMarker(\n            \"TranslationsDocument IntersectionObserver (Attributes)\",\n            { startTime, innerWindowId },\n            `Extended Viewport: ${enteredCount} elements entered, ${exitedCount} exited, ` +\n              `prevented ${preventedCount} requests: ` +\n              `${preventedCount - cancelledCount} were never sent to the scheduler, ` +\n              `${cancelledCount} requests were cancelled from the scheduler.`\n          );\n\n          this.#attributesBeyondViewportInitialObservation.resolve();\n          this.#maybePrioritizeRequestsAndSubmitToScheduler();\n        },\n        {\n          root: null,\n          rootMargin: \"100% 50% 100% 50%\",\n        }\n      );\n\n    /**\n     * Define the type of the MutationObserver for editor type hinting.\n     *\n     * @type {typeof MutationObserver}\n     */\n    const DocumentMutationObserver = ownerGlobal.MutationObserver;\n\n    this.#mutationObserver = new DocumentMutationObserver(\n      async mutationsList => {\n        await this.#waitForFirstIntersectionObservations();\n\n        const startTime = ChromeUtils.now();\n\n        // The count of attribute mutations in this observation.\n        let attributeCount = 0;\n\n        // The count of child-list mutations in this observation.\n        let childListCount = 0;\n\n        // The count of character-data mutations in this observation.\n        let characterDataCount = 0;\n\n        // The count of requests that we prevent from being sent to the TranslationsEngine.\n        let preventedCount = 0;\n\n        // The count of translation requests that had to be cancelled from the TranslationScheduler.\n        // This is a subset of preventedCount.\n        let cancelledFromSchedulerCount = 0;\n\n        // The count of translation requests that had to be cancelled from the TranslationsEngine.\n        // This is a subset of cancelledFromSchedulerCount.\n        let cancelledFromEngineCount = 0;\n\n        for (const mutation of mutationsList) {\n          if (!mutation.target) {\n            continue;\n          }\n\n          const pendingParentElement = this.#getPendingParentElementFromTarget(\n            mutation.target\n          );\n\n          if (pendingParentElement && mutation.type === \"childList\") {\n            const preventionResult =\n              this.#preventContentTranslation(pendingParentElement);\n\n            if (preventionResult.preventedCount) {\n              preventedCount += preventionResult.preventedCount;\n              cancelledFromSchedulerCount +=\n                preventionResult.cancelledFromSchedulerCount;\n              cancelledFromEngineCount +=\n                preventionResult.cancelledFromEngineCount;\n\n              // The node was still pending to be translated, and we cancelled it.\n              // Make sure it gets marked as mutated so it will be resubmitted.\n              this.#markNodeContentMutated(pendingParentElement);\n\n              // New nodes could have been added, make sure we can follow their shadow roots.\n              ensureExists(\n                this.#sourceDocument.ownerGlobal\n              ).requestAnimationFrame(() => {\n                this.#addShadowRootsToObserver(pendingParentElement);\n              });\n            }\n          }\n\n          switch (mutation.type) {\n            case \"childList\": {\n              childListCount++;\n\n              for (const addedNode of mutation.addedNodes) {\n                if (!addedNode) {\n                  continue;\n                }\n                this.#subdivideNodeForAttributeTranslations(addedNode);\n                this.#addShadowRootsToObserver(addedNode);\n                this.#markNodeContentMutated(addedNode);\n              }\n              for (const removedNode of mutation.removedNodes) {\n                if (!removedNode) {\n                  continue;\n                }\n\n                const contentPreventionResult =\n                  this.#preventContentTranslation(removedNode);\n\n                preventedCount += contentPreventionResult.preventedCount;\n                cancelledFromSchedulerCount +=\n                  contentPreventionResult.cancelledFromSchedulerCount;\n                cancelledFromEngineCount +=\n                  contentPreventionResult.cancelledFromEngineCount;\n\n                const selfOrParentElement =\n                  asElement(removedNode) ?? asElement(removedNode.parentNode);\n\n                if (selfOrParentElement) {\n                  deleteFromNestedMap(\n                    this.#pendingContentTranslations,\n                    selfOrParentElement,\n                    removedNode\n                  );\n                  this.#removeFromContentIntersectionObservation(\n                    selfOrParentElement,\n                    removedNode\n                  );\n                }\n\n                const element = asElement(removedNode);\n\n                if (element) {\n                  const attributePreventionResult =\n                    this.#preventAttributeTranslations(element);\n\n                  preventedCount += attributePreventionResult.preventedCount;\n\n                  cancelledFromSchedulerCount +=\n                    attributePreventionResult.cancelledFromSchedulerCount;\n\n                  cancelledFromEngineCount +=\n                    attributePreventionResult.cancelledFromEngineCount;\n\n                  this.#pendingAttributeTranslations.delete(element);\n                  this.#removeFromAttributeIntersectionObservation(element);\n                }\n              }\n              break;\n            }\n            case \"characterData\": {\n              characterDataCount++;\n\n              const node = mutation.target;\n              if (node) {\n                // The mutated node will implement the CharacterData interface. The only\n                // node of this type that contains user-visible text is the `Text` node.\n                // Ignore others such as the comment node.\n                // https://developer.mozilla.org/en-US/docs/Web/API/CharacterData\n                if (node.nodeType === Node.TEXT_NODE) {\n                  const preventionResult =\n                    this.#preventContentTranslation(node);\n\n                  preventedCount += preventionResult.preventedCount;\n                  cancelledFromSchedulerCount +=\n                    preventionResult.cancelledFromSchedulerCount;\n                  cancelledFromEngineCount +=\n                    preventionResult.cancelledFromEngineCount;\n\n                  this.#markNodeContentMutated(node);\n                }\n              }\n              break;\n            }\n            case \"attributes\": {\n              attributeCount++;\n\n              const element = asElement(mutation.target);\n              if (element && mutation.attributeName) {\n                const { oldValue, attributeName } = mutation;\n                this.#maybeMarkElementAttributeMutated(\n                  element,\n                  attributeName,\n                  oldValue\n                );\n              }\n              break;\n            }\n            default: {\n              break;\n            }\n          }\n        }\n\n        ChromeUtils.addProfilerMarker(\n          \"TranslationsDocument MutationObserver\",\n          { startTime, innerWindowId },\n          `Observed ${childListCount + characterDataCount + attributeCount} mutations: ` +\n            `childList(${childListCount}), characterData(${characterDataCount}), attribute(${attributeCount}), ` +\n            `prevented ${preventedCount} requests: ` +\n            `${preventedCount - cancelledFromSchedulerCount - cancelledFromEngineCount} requests were never sent to the scheduler, ` +\n            `${cancelledFromSchedulerCount - cancelledFromEngineCount} requests were cancelled from the scheduler before being sent to the engine, ` +\n            `${cancelledFromEngineCount} requests were cancelled from the engine.`\n        );\n\n        this.#maybePrioritizeRequestsAndSubmitToScheduler();\n      }\n    );\n\n    this.#sourceDocument.addEventListener(\n      \"visibilitychange\",\n      this.#handleVisibilityChange\n    );\n\n    const addRootElements = () => {\n      const startTime = ChromeUtils.now();\n\n      this.#addRootElement(document.body);\n      this.#addRootElement(document.head);\n      this.#addRootElement(document.querySelector(\"title\"));\n\n      ChromeUtils.addProfilerMarker(\n        \"TranslationsDocument Initialize\",\n        { startTime, innerWindowId: this.#innerWindowId },\n        \"Added initial root elements for translation\"\n      );\n\n      if (this.#intersectionObservedContentElements.size === 0) {\n        // After the initial parse of the page, there are no intersection-observable\n        // content elements, so we must vacuously consider the first observation complete.\n        this.#contentWithinViewportInitialObservation.resolve();\n        this.#contentBeyondViewportInitialObservation.resolve();\n      }\n\n      if (this.#intersectionObservedAttributeElements.size === 0) {\n        // After the initial parse of the page, there are no intersection-observable\n        // attribute elements, so we must vacuously consider the first observation complete.\n        this.#attributesWithinViewportInitialObservation.resolve();\n        this.#attributesBeyondViewportInitialObservation.resolve();\n      }\n\n      if (\n        // The page may have content nodes that cannot be observed for intersection.\n        this.#queuedIntersectionExemptContentElements.size > 0 ||\n        // The page may have attribute elements that cannot be observed for intersection.\n        this.#queuedIntersectionExemptAttributeElements.size > 0\n      ) {\n        // These are either elements such as <title> that will never intersect with the\n        // observers, or the find bar was open when Full-Page Translations was invoked,\n        // causing us to start in \"content-eager\" translations mode.\n        this.#maybePrioritizeRequestsAndSubmitToScheduler();\n      }\n    };\n\n    if (document.body) {\n      addRootElements();\n    } else {\n      // The TranslationsDocument was invoked before the DOM was ready, wait for\n      // it to be loaded.\n      document.addEventListener(\"DOMContentLoaded\", addRootElements, {\n        once: true,\n      });\n    }\n\n    /** @type {HTMLElement} */ (document.documentElement).lang = targetLanguage;\n\n    lazy.console.log(\n      \"Beginning to translate.\",\n      // The defaultView may not be there on tests.\n      document.defaultView?.location.href\n    );\n  }\n\n  /**\n   * Enters content-eager translations mode, where all elements with translatable\n   * text content will be sent to the scheduler, but attribute translations will\n   * continue to be handled lazily based on viewport intersection proximity.\n   */\n  async enterContentEagerTranslationsMode() {\n    lazy.console.info(\"Entering Content-Eager translations mode.\");\n    this.#translationsMode = \"content-eager\";\n\n    await this.#waitForFirstIntersectionObservations();\n\n    if (this.#translationsMode !== \"content-eager\") {\n      // The translations mode changed while we were waiting for the\n      // first intersection observations: do not continue.\n      return;\n    }\n\n    for (const element of this.#intersectionObservedContentElements.keys()) {\n      this.#enqueueForIntersectionPrunableContentPrioritization(element);\n    }\n\n    // Most attributes are not searchable within the find bar, so we will not eagerly\n    // enqueue them to be sent to the scheduler. They will still be translated based\n    // on their proximity to the viewport.\n    this.#maybePrioritizeRequestsAndSubmitToScheduler();\n  }\n\n  /**\n   * Enters lazy translations mode, where all translations will be scheduled lazily\n   * based on viewport intersection proximity. Any pending requests that are not\n   * within viewport proximity will be cancelled.\n   */\n  async enterLazyTranslationsMode() {\n    lazy.console.info(\"Entering Lazy translations mode.\");\n    this.#translationsMode = \"lazy\";\n\n    await this.#waitForFirstIntersectionObservations();\n\n    if (this.#translationsMode !== \"lazy\") {\n      // The translations mode changed while we were waiting for the\n      // first intersection observations: do not continue.\n      return;\n    }\n\n    for (const element of this.#pendingContentTranslations.keys()) {\n      if (getNodeSpatialContext(element).viewportContext !== \"within\") {\n        this.#preventUnscheduledContentTranslations(element);\n      }\n    }\n\n    this.#maybePrioritizeRequestsAndSubmitToScheduler();\n  }\n\n  /**\n   * This is a test-only function that simulates intersection observation\n   * by running through all of the observed nodes and enqueuing them for\n   * prioritization if they are not already associated with a pending\n   * translation request.\n   *\n   * This function may only be used in testing contexts where the viewport\n   * is effectively non-existent, such that the intersection observers will\n   * not observe nodes as intended.\n   *\n   * @throws If this function is called outside of automated testing.\n   * @throws If the viewport is not zero-width or zero-height.\n   */\n  simulateIntersectionObservationForNonPendingNodes() {\n    lazy.console.debug(\"Simulating intersection observations for test.\");\n\n    if (!Cu.isInAutomation) {\n      // There is no scenario in which we should call this function outside of an\n      // automated test that requires it.\n      throw new Error(\n        \"Attempt to manually simulate intersection observation outside of test.\"\n      );\n    }\n\n    const window = ensureExists(this.#sourceDocument.ownerGlobal);\n    const { visualViewport } = window;\n    if (visualViewport.width > 0 && visualViewport.height > 0) {\n      // The only time we should call this function is in test cases where the\n      // intersection observers will not function because a viewport dimension is zero.\n      // If a viewport dimension is not actually zero, then this was called in error.\n      throw new Error(\n        \"Attempt to manually simulate intersection observation with a valid viewport.\"\n      );\n    }\n\n    // This should never be called as the first intersection observation.\n    // See #waitForFirstIntersectionObservation for an explanation why.\n    //\n    // The code is written so that the first intersection observation is\n    // guaranteed to be fulfilled when adding the initial root elements.\n    //\n    // If you are modifying this code, and this promise hangs, then the\n    // code has been modified incorrectly such that the first observation\n    // guarantee is no longer upheld.\n    /** @type {PromiseWithResolvers<void>} */\n    const firstIntersectionObservationsTimeout = Promise.withResolvers();\n    lazy.setTimeout(\n      () =>\n        firstIntersectionObservationsTimeout.reject(\n          new Error(\n            \"The TranslationDocument's first intersection observations failed to resolve.\"\n          )\n        ),\n      2000\n    );\n\n    Promise.race([\n      firstIntersectionObservationsTimeout.promise,\n      this.#waitForFirstIntersectionObservations(),\n    ]).then(() => {\n      firstIntersectionObservationsTimeout.resolve();\n\n      for (const element of this.#intersectionObservedContentElements.keys()) {\n        if (!this.#pendingContentTranslations.has(element)) {\n          this.#enqueueForIntersectionPrunableContentPrioritization(element);\n        }\n      }\n\n      for (const element of this.#intersectionObservedAttributeElements.keys()) {\n        if (!this.#pendingAttributeTranslations.has(element)) {\n          this.#enqueueForIntersectionPrunableAttributePrioritization(element);\n        }\n      }\n\n      this.#maybePrioritizeRequestsAndSubmitToScheduler();\n    });\n  }\n\n  /**\n   * The first intersection observation is critical to the flow of the TranslationsDocument.\n   *\n   * When we add the root elements within the constructor, the entire DOM is parsed, and each\n   * translatable element on the page is registered with the intersection observers. As such,\n   * each observer's first observation will mostly contain nodes that are \"exiting\" proximity,\n   * since most of the element on the page will likely lie well beyond the viewport.\n   *\n   * To prevent unnecessary cancellations, race conditions, etc. many of the asynchronous\n   * callbacks within this file such as submitting nodes to the scheduler or handling mutated\n   * nodes must wait until the first intersection observation has occurred.\n   */\n  async #waitForFirstIntersectionObservations() {\n    await Promise.all([\n      this.#contentWithinViewportInitialObservation.promise,\n      this.#contentBeyondViewportInitialObservation.promise,\n      this.#attributesWithinViewportInitialObservation.promise,\n      this.#attributesBeyondViewportInitialObservation.promise,\n    ]);\n  }\n\n  /**\n   * Marks that the text content of the given node has mutated, both allowing and\n   * ensuring that the node will be rescheduled for translation, even if it had\n   * previously been translated.\n   *\n   * @param {Node} node\n   */\n  #markNodeContentMutated(node) {\n    this.#processedContentNodes.delete(node);\n    this.#nodesWithMutatedContent.add(node);\n\n    const selfOrParentElement = asElement(node) ?? asElement(node.parentNode);\n\n    if (selfOrParentElement) {\n      deleteFromNestedMap(\n        this.#pendingContentTranslations,\n        selfOrParentElement,\n        node\n      );\n\n      if (this.#intersectionObservedContentElements.has(selfOrParentElement)) {\n        // If the mutated content belongs to an element that we are already observing\n        // for intersection, we must re-register it with the Beyond-Viewport intersection\n        // observer, which will ensure that any mutated elements within extended-viewport\n        // proximity will be re-enqueued for prioritization when the next observer cycle runs.\n        this.#intersectionObserverForContentTranslationsBeyondViewport.unobserve(\n          selfOrParentElement\n        );\n        this.#intersectionObserverForContentTranslationsBeyondViewport.observe(\n          selfOrParentElement\n        );\n      }\n    }\n\n    this.#ensureMutationUpdateCallbackIsRegistered();\n  }\n\n  /**\n   * Marks that the given element's attribute has been mutated, only if that attribute\n   * is translatable for that element, both allowing and ensuring that the attribute will\n   * be rescheduled for translation, even if it had previously been translated.\n   *\n   * @param {Element} element\n   * @param {string} attributeName\n   * @param {string?} oldValue\n   */\n  #maybeMarkElementAttributeMutated(element, attributeName, oldValue) {\n    const newValue = element.getAttribute(attributeName);\n\n    if (!newValue) {\n      // The element no longer has a value for this attribute.\n      return;\n    }\n\n    if (oldValue === newValue) {\n      // The new attribute value is exactly the same as the old value.\n      return;\n    }\n\n    if (\n      this.#translationsCache.isAlreadyTranslated(newValue, /* isHTML */ false)\n    ) {\n      // We know that the new attribute value is already text in the target language.\n      return;\n    }\n\n    if (!isAttributeTranslatable(element, attributeName)) {\n      // The given attribute is not translatable for this element.\n      return;\n    }\n\n    let mutatedAttributes = this.#elementsWithMutatedAttributes.get(element);\n    if (!mutatedAttributes) {\n      mutatedAttributes = new Set();\n      this.#elementsWithMutatedAttributes.set(element, mutatedAttributes);\n    }\n    mutatedAttributes.add(attributeName);\n\n    deleteFromNestedMap(\n      this.#pendingAttributeTranslations,\n      element,\n      attributeName\n    );\n\n    if (this.#intersectionObservedAttributeElements.has(element)) {\n      // If the mutated attribute belongs to an element that we are already observing\n      // for intersection, we must re-register it with the Beyond-Viewport intersection\n      // observer, which will ensure that any mutated elements within extended-viewport\n      // proximity will be re-enqueued for prioritization when the next observer cycle runs.\n      this.#intersectionObserverForAttributeTranslationsBeyondViewport.unobserve(\n        element\n      );\n      this.#intersectionObserverForAttributeTranslationsBeyondViewport.observe(\n        element\n      );\n    }\n\n    this.#ensureMutationUpdateCallbackIsRegistered();\n  }\n\n  /**\n   * Ensures that all nodes that have been picked up by the mutation observer\n   * are processed, prioritized and sent to the scheduler to re translated.\n   */\n  #ensureMutationUpdateCallbackIsRegistered() {\n    if (this.#hasPendingMutatedNodesCallback) {\n      // A callback has already been registered to update mutated nodes.\n      return;\n    }\n\n    if (\n      this.#nodesWithMutatedContent.size === 0 &&\n      this.#elementsWithMutatedAttributes.size === 0\n    ) {\n      // There are no mutated nodes to update.\n      return;\n    }\n\n    this.#hasPendingMutatedNodesCallback = true;\n    const ownerGlobal = ensureExists(this.#sourceDocument.ownerGlobal);\n\n    // Nodes can be mutated in a tight loop. To guard against the performance of re-translating nodes too frequently,\n    // we will batch the processing of mutated nodes into a double requestAnimationFrame.\n    ownerGlobal.requestAnimationFrame(() => {\n      ownerGlobal.requestAnimationFrame(async () => {\n        // We should not handle any mutations until the intersection observers have completed their first observations.\n        await this.#waitForFirstIntersectionObservations();\n\n        this.#hasPendingMutatedNodesCallback = false;\n\n        // The count of content translation requests will be 1:1 with the count of content-translation nodes.\n        const contentNodeCount = this.#nodesWithMutatedContent.size;\n\n        // Attribute translation requests have a 1:many relationship with their element, so we must increment manually.\n        const attributeElementCount = this.#elementsWithMutatedAttributes.size;\n        let attributeRequestCount = 0;\n\n        const startTime = ChromeUtils.now();\n\n        // Ensure the nodes are still alive.\n        const liveNodes = [];\n        for (const node of this.#nodesWithMutatedContent) {\n          if (isNodeDetached(node)) {\n            this.#nodesWithMutatedContent.delete(node);\n          } else {\n            liveNodes.push(node);\n          }\n        }\n\n        // Remove any nodes that are contained in another node.\n        for (let i = 0; i < liveNodes.length; i++) {\n          const node = liveNodes[i];\n          if (!this.#nodesWithMutatedContent.has(node)) {\n            continue;\n          }\n          for (let j = i + 1; j < liveNodes.length; j++) {\n            const otherNode = liveNodes[j];\n\n            if (!this.#nodesWithMutatedContent.has(otherNode)) {\n              continue;\n            }\n\n            if (node.contains(otherNode)) {\n              this.#nodesWithMutatedContent.delete(otherNode);\n            } else if (otherNode.contains(node)) {\n              this.#nodesWithMutatedContent.delete(node);\n              break;\n            }\n          }\n        }\n\n        for (const node of this.#nodesWithMutatedContent) {\n          this.#addShadowRootsToObserver(node);\n          this.#subdivideNodeForContentTranslations(node);\n        }\n        this.#nodesWithMutatedContent.clear();\n\n        for (const [\n          element,\n          attributes,\n        ] of this.#elementsWithMutatedAttributes.entries()) {\n          attributeRequestCount += attributes.size;\n          this.#maybeObserveElementForAttributePrioritization(\n            element,\n            attributes\n          );\n        }\n        this.#elementsWithMutatedAttributes.clear();\n\n        ChromeUtils.addProfilerMarker(\n          \"TranslationsDocument MutationObserver\",\n          { startTime, innerWindowId: this.#innerWindowId },\n          `Handled content mutations for ${contentNodeCount} nodes, and ` +\n            `${attributeRequestCount} attribute mutations among ${attributeElementCount} elements.`\n        );\n\n        this.#maybePrioritizeRequestsAndSubmitToScheduler();\n      });\n    });\n  }\n\n  /**\n   * If a pending node contains or is the target node, return that pending node.\n   *\n   * @param {Node} target\n   *\n   * @returns {Element | undefined}\n   */\n  #getPendingParentElementFromTarget(target) {\n    const pendingParent = this.#nodeToPendingParent.get(target);\n    const pendingParentElement = asElement(pendingParent);\n\n    if (\n      pendingParentElement &&\n      this.#pendingContentTranslations.has(pendingParentElement)\n    ) {\n      return pendingParentElement;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Attempts to cancel a translation for the given node, even if the relevant\n   * translation request has already been sent to the TranslationsEngine.\n   *\n   * This function is primarily used by the mutation observer, when we are certain\n   * that content has changed, and the previous translation is no longer valid.\n   *\n   * For a more conservative cancellation that will only cancel a translation\n   * request before it has been sent to the TranslationsEngine, use the\n   * `#maybePreventUnscheduledContentTranslation` function.\n   *\n   * @param {Node} node\n   *\n   * @returns {{\n   *  preventedCount: number,\n   *  cancelledFromSchedulerCount: number,\n   *  cancelledFromEngineCount: number,\n   * }}\n   */\n  #preventContentTranslation(node) {\n    const textNode = asTextNode(node);\n    const parentElement = asElement(node.parentNode);\n\n    if (textNode && parentElement) {\n      const pendingNodes = this.#pendingContentTranslations.get(parentElement);\n      const translationId = pendingNodes?.get(textNode);\n\n      if (translationId) {\n        const { didPrevent, didCancelFromScheduler, didCancelFromEngine } =\n          this.#scheduler.preventSingleTranslation(translationId);\n\n        if (didPrevent) {\n          return {\n            preventedCount: Number(didPrevent),\n            cancelledFromSchedulerCount: Number(didCancelFromScheduler),\n            cancelledFromEngineCount: Number(didCancelFromEngine),\n          };\n        }\n      }\n    }\n\n    const element = asElement(node);\n    if (!element) {\n      return {\n        preventedCount: 0,\n        cancelledFromSchedulerCount: 0,\n        cancelledFromEngineCount: 0,\n      };\n    }\n\n    let preventedCount = 0;\n    let cancelledFromSchedulerCount = 0;\n    let cancelledFromEngineCount = 0;\n\n    const preventionResult =\n      this.#preventUnscheduledContentTranslations(element);\n\n    if (preventionResult.preventedNodeSet) {\n      // We were able to prevent these content translations before\n      // they were sent to the TranslationsEngine.\n      preventedCount += preventionResult.preventedNodeSet.size;\n      cancelledFromSchedulerCount +=\n        preventionResult.cancelledFromSchedulerCount;\n    }\n\n    const pendingNodes = this.#pendingContentTranslations.get(element);\n    if (!pendingNodes) {\n      // No pending content translations were found for this element.\n      // They either already completed, or never existed.\n      return {\n        preventedCount,\n        cancelledFromSchedulerCount,\n        cancelledFromEngineCount: 0,\n      };\n    }\n\n    for (const [pendingNode, translationId] of pendingNodes) {\n      // eslint-disable-next-line no-shadow\n      const { didPrevent, didCancelFromScheduler, didCancelFromEngine } =\n        this.#scheduler.preventSingleTranslation(translationId);\n\n      if (didPrevent) {\n        pendingNodes.delete(pendingNode);\n      }\n\n      preventedCount += Number(didPrevent);\n      cancelledFromSchedulerCount += Number(didCancelFromScheduler);\n      cancelledFromEngineCount += Number(didCancelFromEngine);\n    }\n\n    if (pendingNodes.size === 0) {\n      removeMozTranslationsIds(element);\n      this.#pendingContentTranslations.delete(element);\n    }\n\n    return {\n      preventedCount,\n      cancelledFromSchedulerCount,\n      cancelledFromEngineCount,\n    };\n  }\n\n  /**\n   * Attempts to cancel all attribute translations for the given node, even if the\n   * relevant translation requests have already been sent to the TranslationsEngine.\n   *\n   * This function is primarily used by the mutation observer, when we are certain\n   * that content has changed, and the previous translation is no longer valid.\n   *\n   * For a more conservative cancellation that will only cancel translation requests\n   * before they have been sent to the TranslationsEngine, use the\n   * `#maybePreventUnscheduledAttributeTranslations` function.\n   *\n   * @param {Element} element\n   *\n   * @returns {{\n   *  preventedCount: number,\n   *  cancelledFromSchedulerCount: number,\n   *  cancelledFromEngineCount: number,\n   * }}\n   */\n  #preventAttributeTranslations(element) {\n    const preventionResult =\n      this.#preventUnscheduledAttributeTranslations(element);\n\n    let preventedCount = 0;\n    let cancelledFromSchedulerCount = 0;\n    let cancelledFromEngineCount = 0;\n\n    if (preventionResult.preventedAttributeSet) {\n      // We were able to prevent these attributes translations before\n      // they were send to the TranslationsEngine.\n      preventedCount += preventionResult.preventedAttributeSet.size;\n      cancelledFromSchedulerCount +=\n        preventionResult.cancelledFromSchedulerCount;\n    }\n\n    const pendingAttributes = this.#pendingAttributeTranslations.get(element);\n    if (!pendingAttributes) {\n      // No pending attribute translations were found for this element.\n      // They either already completed, or never existed.\n      return {\n        preventedCount,\n        cancelledFromSchedulerCount,\n        cancelledFromEngineCount: 0,\n      };\n    }\n\n    for (const [attributeName, translationId] of pendingAttributes) {\n      // eslint-disable-next-line no-shadow\n      const { didPrevent, didCancelFromScheduler, didCancelFromEngine } =\n        this.#scheduler.preventSingleTranslation(translationId);\n\n      if (didPrevent) {\n        pendingAttributes.delete(attributeName);\n      }\n\n      preventedCount += Number(didPrevent);\n      cancelledFromSchedulerCount += Number(didCancelFromScheduler);\n      cancelledFromEngineCount += Number(didCancelFromEngine);\n    }\n\n    if (pendingAttributes.size === 0) {\n      this.#pendingAttributeTranslations.delete(element);\n    }\n\n    return {\n      preventedCount,\n      cancelledFromSchedulerCount,\n      cancelledFromEngineCount,\n    };\n  }\n\n  /**\n   * Adds an element to a queue from which it will eventually be prioritized\n   * and submitted to the scheduler for attribute translation.\n   *\n   * The queue is intersection-exempt, meaning that the intersection observers\n   * will not be able to remove this element from the queue before it is prioritized\n   * and submitted to the scheduler.\n   *\n   * @param {Element} element\n   */\n  #enqueueForIntersectionPrunableAttributePrioritization(element) {\n    if (this.#queuedIntersectionPrunableAttributeElements.has(element)) {\n      return;\n    }\n\n    const translatableAttributes =\n      this.#intersectionObservedAttributeElements.get(element);\n\n    if (!translatableAttributes) {\n      lazy.console.warn(`\n        Attempted to enqueue an element for attribute translation,\n        but no translatable attributes were registered with the element.\n      `);\n      return;\n    }\n\n    let queuedAttributes =\n      this.#queuedIntersectionPrunableAttributeElements.get(element);\n\n    if (queuedAttributes) {\n      for (const attributeName of translatableAttributes) {\n        queuedAttributes.add(attributeName);\n      }\n    } else {\n      queuedAttributes = translatableAttributes;\n      this.#queuedIntersectionPrunableAttributeElements.set(\n        element,\n        translatableAttributes\n      );\n    }\n  }\n\n  /**\n   * Adds an element to a queue from which it will eventually be prioritized\n   * and submitted to the scheduler for attribute translation.\n   *\n   * The queue is intersection-exempt, meaning that the intersection observers\n   * will not be able to remove this element from the queue before it is prioritized\n   * and submitted to the scheduler.\n   *\n   * @param {Element} element\n   */\n  #maybeEnqueueForIntersectionExemptAttributePrioritization(element) {\n    if (this.#queuedIntersectionExemptAttributeElements.has(element)) {\n      return;\n    }\n\n    const translatableAttributes =\n      this.#intersectionObservedAttributeElements.get(element) ??\n      this.#getTranslatableAttributes(element);\n\n    if (!translatableAttributes) {\n      return;\n    }\n\n    let queuedAttributes =\n      this.#queuedIntersectionExemptAttributeElements.get(element);\n\n    if (queuedAttributes) {\n      for (const attributeName of translatableAttributes) {\n        queuedAttributes.add(attributeName);\n      }\n    } else {\n      queuedAttributes = translatableAttributes;\n      this.#queuedIntersectionExemptAttributeElements.set(\n        element,\n        translatableAttributes\n      );\n    }\n  }\n\n  /**\n   * Retrieves an array of translatable attributes within the given node.\n   *\n   * If the node is deemed to be excluded from translation, no attributes\n   * will be returned even if they are otherwise translatable.\n   *\n   * @see TRANSLATABLE_ATTRIBUTES\n   * @see TranslationsDocument.contentExcludedNodeSelector\n   *\n   * @param {Node} node - The node from which to retrieve translatable attributes.\n   *\n   * @returns {null | Set<string>} - The translatable attribute names from the given node.\n   */\n  #getTranslatableAttributes(node) {\n    const element = asHTMLElement(node);\n    if (!element) {\n      // We only translate attributes on element node types.\n      return null;\n    }\n\n    if (element.closest(this.attributeExcludedNodeSelector)) {\n      // Either this node or an ancestor is explicitly excluded from translations, so we should not translate.\n      return null;\n    }\n\n    let attributes = null;\n\n    for (const attribute of TRANSLATABLE_ATTRIBUTES.keys()) {\n      if (isAttributeTranslatable(node, attribute)) {\n        if (!attributes) {\n          attributes = new Set();\n        }\n        attributes.add(attribute);\n      }\n    }\n\n    return attributes;\n  }\n\n  /**\n   * Start and stop translation as the page is shown. For instance, this will\n   * transition into \"hidden\" when the user tabs away from a document.\n   */\n  #handleVisibilityChange = () => {\n    if (this.#sourceDocument.visibilityState === \"visible\") {\n      this.#scheduler.onShowPage();\n    } else {\n      ChromeUtils.addProfilerMarker(\n        \"TranslationsDocument Pause\",\n        { innerWindowId: this.#innerWindowId },\n        \"Pausing translations and discarding the port\"\n      );\n      this.#scheduler.onHidePage();\n    }\n  };\n\n  /**\n   * Remove any dangling event handlers.\n   */\n  destroy() {\n    this.#scheduler.destroy();\n    this.#stopAllObservers();\n\n    if (!Cu.isDeadWrapper(this.#sourceDocument)) {\n      this.#sourceDocument.removeEventListener(\n        \"visibilitychange\",\n        this.#handleVisibilityChange\n      );\n\n      const window = this.#sourceDocument.ownerGlobal;\n      if (window) {\n        window.removeEventListener(\"scroll\", this.#handleScrollEvent);\n      }\n    }\n  }\n\n  /**\n   * Helper function for adding a new root to the mutation\n   * observer.\n   *\n   * @param {Node} root\n   */\n  #observeNewRoot(root) {\n    this.#rootNodes.add(root);\n    this.#mutationObserver.observe(root, MUTATION_OBSERVER_OPTIONS);\n  }\n\n  /**\n   * Shadow roots are used in custom elements, and are a method for encapsulating\n   * markup. Normally only \"open\" shadow roots can be accessed, but in privileged\n   * contexts, they can be traversed using the ChromeOnly property openOrClosedShadowRoot.\n   *\n   * @param {Node} node\n   */\n  #addShadowRootsToObserver(node) {\n    const { ownerDocument } = node;\n    if (!ownerDocument) {\n      return;\n    }\n    const nodeIterator = ownerDocument.createTreeWalker(\n      node,\n      NodeFilter.SHOW_ELEMENT,\n      currentNode =>\n        getShadowRoot(currentNode)\n          ? NodeFilter.FILTER_ACCEPT\n          : NodeFilter.FILTER_SKIP\n    );\n\n    /** @type {Node | null} */\n    let currentNode;\n    while ((currentNode = nodeIterator.nextNode())) {\n      // Only shadow hosts are accepted nodes\n      const shadowRoot = ensureExists(getShadowRoot(currentNode));\n      if (!this.#rootNodes.has(shadowRoot)) {\n        this.#observeNewRoot(shadowRoot);\n      }\n      // A shadow root may contain other shadow roots, recurse into them.\n      this.#addShadowRootsToObserver(shadowRoot);\n    }\n  }\n\n  /**\n   * Add a new element to start translating. This root is tracked for mutations and\n   * kept up to date with translations. This will be the body element and title tag\n   * for the document.\n   *\n   * @param {Node | null | undefined} node\n   */\n  #addRootElement(node) {\n    if (!node) {\n      return;\n    }\n\n    const element = asHTMLElement(node);\n    if (!element) {\n      return;\n    }\n\n    if (this.#rootNodes.has(element)) {\n      // Exclude nodes that are already targeted.\n      return;\n    }\n\n    this.#rootNodes.add(element);\n\n    if (element.nodeName === \"TITLE\") {\n      // The <title> node is special, in that it will never intersect with the viewport,\n      // so we must explicitly enqueue it for translation here.\n      this.#enqueueForIntersectionExemptContentPrioritization(element);\n      this.#maybeEnqueueForIntersectionExemptAttributePrioritization(element);\n      this.#mutationObserver.observe(element, MUTATION_OBSERVER_OPTIONS);\n      return;\n    }\n\n    if (element.nodeName === \"HEAD\") {\n      // The <head> element is not considered for content translations, but it may contain <meta>\n      // elements that may have translatable attributes. This is a special case where we should\n      // explicitly check for <meta> elements within the <head> and eagerly enqueue them, since\n      // they will not intersect with the intersection observers.\n      for (const metaElement of element.querySelectorAll(\"meta\")) {\n        this.#maybeEnqueueForIntersectionExemptAttributePrioritization(\n          metaElement\n        );\n      }\n      this.#mutationObserver.observe(element, MUTATION_OBSERVER_OPTIONS);\n      return;\n    }\n\n    const contentStartTime = ChromeUtils.now();\n    this.#subdivideNodeForContentTranslations(element);\n    ChromeUtils.addProfilerMarker(\n      \"TranslationsDocument Add Root\",\n      { startTime: contentStartTime, innerWindowId: this.#innerWindowId },\n      `Subdivided new root \"${node.nodeName}\" for content translations`\n    );\n\n    const attributeStartTime = ChromeUtils.now();\n    this.#subdivideNodeForAttributeTranslations(element);\n    ChromeUtils.addProfilerMarker(\n      \"TranslationsDocument Add Root\",\n      { startTime: attributeStartTime, innerWindowId: this.#innerWindowId },\n      `Subdivided new root \"${node.nodeName}\" for attribute translations`\n    );\n\n    this.#mutationObserver.observe(element, MUTATION_OBSERVER_OPTIONS);\n    this.#addShadowRootsToObserver(element);\n  }\n\n  /**\n   * Add qualified nodes to be observed for intersection or enqueued for\n   * translation by recursively walking through the DOM tree of nodes,\n   * including elements in the Shadow DOM.\n   *\n   * @param {Node} node\n   */\n  #processSubdivide(node) {\n    const { ownerDocument } = node;\n    if (!ownerDocument) {\n      return;\n    }\n\n    // This iterator will contain each node that has been subdivided enough to be translated.\n    const nodeIterator = ownerDocument.createTreeWalker(\n      node,\n      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,\n      this.#determineTranslationStatusForUnprocessedNodes\n    );\n\n    let currentNode;\n    while ((currentNode = nodeIterator.nextNode())) {\n      const shadowRoot = getShadowRoot(currentNode);\n      if (shadowRoot) {\n        this.#processSubdivide(shadowRoot);\n      } else {\n        this.#observeOrEnqueueNodeForContentPrioritization(currentNode);\n      }\n    }\n  }\n\n  /**\n   * Start walking down through a node's subtree and decide which nodes to queue for\n   * content translation. This first node could be the root nodes of the DOM, such as\n   * the document body, or the title element, or it could be a mutation target.\n   *\n   * The nodes go through a process of subdivision until an appropriate sized chunk\n   * of inline text can be found.\n   *\n   * @param {Node} node\n   */\n  #subdivideNodeForContentTranslations(node) {\n    if (!this.#rootNodes.has(node)) {\n      // This is a non-root node, which means it came from a mutation observer.\n      // This new node could be a host element for shadow tree\n      const shadowRoot = getShadowRoot(node);\n      if (shadowRoot && !this.#rootNodes.has(shadowRoot)) {\n        this.#observeNewRoot(shadowRoot);\n      } else {\n        // Ensure that it is a valid node to translate by checking all of its ancestors.\n        for (let parent of getAncestorsIterator(node)) {\n          // Parent is ShadowRoot. We can stop here since this is\n          // the top ancestor of the shadow tree.\n          if (parent.containingShadowRoot == parent) {\n            break;\n          }\n          if (\n            this.#determineTranslationStatus(parent) ===\n            NodeStatus.NOT_TRANSLATABLE\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    switch (this.#determineTranslationStatusForUnprocessedNodes(node)) {\n      case NodeStatus.NOT_TRANSLATABLE: {\n        // This node is rejected as it shouldn't be translated.\n        return;\n      }\n\n      // SHADOW_HOST and READY_TO_TRANSLATE both map to FILTER_ACCEPT\n      case NodeStatus.SHADOW_HOST:\n      case NodeStatus.READY_TO_TRANSLATE: {\n        const shadowRoot = getShadowRoot(node);\n        if (shadowRoot) {\n          this.#processSubdivide(shadowRoot);\n        } else {\n          // This node is ready for translating, and doesn't need to be subdivided. There\n          // is no reason to run the TreeWalker, it can be directly submitted for\n          // translation.\n          this.#observeOrEnqueueNodeForContentPrioritization(node);\n        }\n        break;\n      }\n\n      case NodeStatus.SUBDIVIDE_FURTHER: {\n        // This node may be translatable, but it needs to be subdivided into smaller\n        // pieces. Create a TreeWalker to walk the subtree, and find the subtrees/nodes\n        // that contain enough inline elements to send to be translated.\n        this.#processSubdivide(node);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Uses query selectors to locate all of the elements that have translatable attributes,\n   * then registers those elements with the intersection observers for their attributes\n   * to be translated when observed.\n   *\n   * @param {Node} node\n   */\n  #subdivideNodeForAttributeTranslations(node) {\n    const element = asElement(node);\n    if (!element) {\n      // We only translate attributes on Element type nodes.\n      return;\n    }\n\n    this.#maybeObserveElementForAttributePrioritization(element);\n\n    const childElementsWithTranslatableAttributes = element.querySelectorAll(\n      TRANSLATABLE_ATTRIBUTES_SELECTOR\n    );\n\n    for (const childElement of childElementsWithTranslatableAttributes) {\n      this.#maybeObserveElementForAttributePrioritization(childElement);\n    }\n  }\n\n  /**\n   * Test whether this is an element we do not want to translate. These are things like\n   * <code> elements, elements with a different \"lang\" attribute, and elements that\n   * have a `translate=no` attribute.\n   *\n   * @param {Node} node\n   */\n  #isExcludedNode(node) {\n    // Property access be expensive, so destructure required properties so they are\n    // not accessed multiple times.\n    const { nodeType } = node;\n\n    if (nodeType === Node.TEXT_NODE) {\n      // Text nodes are never excluded.\n      return false;\n    }\n    const element = asElement(node);\n    if (!element) {\n      // Only elements and and text nodes should be considered.\n      return true;\n    }\n\n    const { nodeName } = element;\n\n    if (CONTENT_EXCLUDED_TAGS.has(nodeName.toUpperCase())) {\n      // SVG tags can be lowercased, so ensure everything is uppercased.\n      // This is an excluded tag.\n      return true;\n    }\n\n    if (!this.#matchesDocumentLanguage(element)) {\n      // Exclude nodes that don't match the sourceLanguage.\n      return true;\n    }\n\n    if (element.getAttribute(\"translate\") === \"no\") {\n      // This element has a translate=\"no\" attribute.\n      // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/translate\n      return true;\n    }\n\n    if (element.classList.contains(\"notranslate\")) {\n      // Google Translate skips translations if the classList contains \"notranslate\"\n      // https://cloud.google.com/translate/troubleshooting\n      return true;\n    }\n\n    if (asHTMLElement(element)?.isContentEditable) {\n      // This field is editable, and so exclude it similar to the way that form input\n      // fields are excluded.\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Runs `determineTranslationStatus`, but only on unprocessed nodes.\n   *\n   * @param {Node} node\n   *\n   * @returns {number} - One of the NodeStatus values.\n   */\n  #determineTranslationStatusForUnprocessedNodes = node => {\n    if (this.#processedContentNodes.has(node)) {\n      // Skip nodes that have already been processed.\n      return NodeStatus.NOT_TRANSLATABLE;\n    }\n\n    return this.#determineTranslationStatus(node);\n  };\n\n  /**\n   * Determines if a node should be submitted for translation, not translatable, or if\n   * it should be subdivided further. It doesn't check if the node has already been\n   * processed.\n   *\n   * The return result works as a TreeWalker NodeFilter as well.\n   *\n   * @param {Node} node\n   *\n   * @returns {number} - One of the `NodeStatus` values. See that object\n   *   for documentation. These values match the filters for the TreeWalker.\n   *   These values also work as a `NodeFilter` value.\n   */\n  #determineTranslationStatus(node) {\n    if (getShadowRoot(node)) {\n      return NodeStatus.SHADOW_HOST;\n    }\n\n    if (this.#isExcludedNode(node)) {\n      // This is an explicitly excluded node.\n      return NodeStatus.NOT_TRANSLATABLE;\n    }\n\n    if (\n      nodeOrParentIncludesItself(\n        node,\n        this.#intersectionObservedContentElements\n      )\n    ) {\n      // This node or its parent is already being observed for translation: reject it.\n      return NodeStatus.NOT_TRANSLATABLE;\n    }\n\n    if (\n      containsExcludedNode(node, this.contentExcludedNodeSelector) &&\n      !hasNonWhitespaceTextNodes(node)\n    ) {\n      // Skip this node, and dig deeper into its tree to cut off smaller pieces to translate.\n      return NodeStatus.SUBDIVIDE_FURTHER;\n    }\n\n    if (nodeNeedsSubdividing(node)) {\n      // Skip this node, and dig deeper into its tree to cut off smaller pieces\n      // to translate. It is presumed to be a wrapper of block elements.\n      return NodeStatus.SUBDIVIDE_FURTHER;\n    }\n\n    if (!node.textContent?.trim().length) {\n      // Do not use subtrees that are empty of text. This textContent call is fairly expensive.\n      return !node.hasChildNodes()\n        ? NodeStatus.NOT_TRANSLATABLE\n        : NodeStatus.SUBDIVIDE_FURTHER;\n    }\n\n    // This node can be treated as entire block to submit for translation.\n    return NodeStatus.READY_TO_TRANSLATE;\n  }\n\n  /**\n   * Adds an element to a queue from which it will eventually be prioritized\n   * and submitted to the scheduler for content translation.\n   *\n   * The queue is intersection-exempt, meaning that the intersection observers\n   * will not be able to remove this element from the queue before it is prioritized\n   * and submitted to the scheduler.\n   *\n   * @param {Element} element\n   */\n  #enqueueForIntersectionPrunableContentPrioritization(element) {\n    if (this.#queuedIntersectionPrunableContentElements.has(element)) {\n      return;\n    }\n\n    const nodeSet =\n      this.#intersectionObservedContentElements.get(element) ??\n      new Set([element]);\n\n    let queuedNodes =\n      this.#queuedIntersectionPrunableContentElements.get(element);\n\n    if (queuedNodes) {\n      for (const node of nodeSet) {\n        queuedNodes.add(node);\n      }\n    } else {\n      queuedNodes = nodeSet;\n      this.#queuedIntersectionPrunableContentElements.set(element, queuedNodes);\n    }\n  }\n\n  /**\n   * Adds an element to a queue from which it will eventually be prioritized\n   * and submitted to the scheduler for attribute translation.\n   *\n   * The queue is intersection-exempt, meaning that the intersection observers\n   * will not be able to remove this element from the queue before it is prioritized\n   * and submitted to the scheduler.\n   *\n   * @param {Element} element\n   */\n  #enqueueForIntersectionExemptContentPrioritization(element) {\n    if (this.#queuedIntersectionExemptContentElements.has(element)) {\n      return;\n    }\n\n    const nodeSet =\n      this.#intersectionObservedContentElements.get(element) ??\n      new Set([element]);\n\n    let queuedNodes =\n      this.#queuedIntersectionExemptContentElements.get(element);\n\n    if (queuedNodes) {\n      for (const node of nodeSet) {\n        queuedNodes.add(node);\n      }\n    } else {\n      queuedNodes = nodeSet;\n      this.#queuedIntersectionExemptContentElements.set(element, queuedNodes);\n    }\n  }\n\n  /**\n   * Submit each translatable attribute for the given element to the TranslationScheduler\n   * to have the attribute text translated.\n   *\n   * @param {number} priority\n   * @param {Element} element\n   * @param {Set<string>} attributeSet\n   */\n  #submitForAttributeTranslation(priority, element, attributeSet) {\n    for (const attribute of attributeSet) {\n      const sourceText = element.getAttribute(attribute);\n\n      if (!sourceText?.trim().length) {\n        continue;\n      }\n      const translationId = this.#lastTranslationId++;\n\n      let pendingAttributes = this.#pendingAttributeTranslations.get(element);\n      if (!pendingAttributes) {\n        pendingAttributes = new Map();\n        this.#pendingAttributeTranslations.set(element, pendingAttributes);\n      }\n      pendingAttributes.set(attribute, translationId);\n\n      this.#tryTranslate(\n        element,\n        sourceText,\n        false /*isHTML*/,\n        translationId,\n        priority\n      )\n        .then(translation => {\n          if (translation) {\n            this.#registerElementForAttributeTranslationUpdate(\n              element,\n              translation,\n              attribute,\n              translationId\n            );\n          } else if (\n            pendingAttributes.get(attribute) === translationId &&\n            this.#pendingAttributeTranslations.get(element) ===\n              pendingAttributes\n          ) {\n            // There is nothing to update for this translation request.\n            pendingAttributes.delete(attribute);\n            if (pendingAttributes.size === 0) {\n              this.#pendingAttributeTranslations.delete(element);\n              this.#removeFromAttributeIntersectionObservation(\n                element,\n                attribute\n              );\n            }\n          }\n        })\n        .catch(error => {\n          lazy.console.error(error);\n          if (\n            pendingAttributes.get(attribute) === translationId &&\n            this.#pendingAttributeTranslations.get(element) ===\n              pendingAttributes\n          ) {\n            // There is nothing to update for this translation request.\n            pendingAttributes.delete(attribute);\n            if (pendingAttributes.size === 0) {\n              this.#pendingAttributeTranslations.delete(element);\n              this.#removeFromAttributeIntersectionObservation(\n                element,\n                attribute\n              );\n            }\n          }\n        });\n    }\n  }\n\n  /**\n   * Ensures that elements with completed attribute translation requests will be updated.\n   *\n   * This may happen immediately if there are very few active translation requests.\n   *\n   * If there are many active translation requests, we will register a callback to the\n   * event loop to update a batch of elements all at once.\n   *\n   * This distinction is made because updating any content within the DOM requires\n   * pausing the mutation observer, and that cost adds up if you do it individually\n   * for every translation request that completes.\n   *\n   * @param {Element} element\n   * @param {string} translation\n   * @param {string} attribute\n   * @param {number} translationId\n   */\n  #registerElementForAttributeTranslationUpdate(\n    element,\n    translation,\n    attribute,\n    translationId\n  ) {\n    // Add the nodes to be populated with the next translation update.\n    this.#elementsThatNeedAttributeUpdates.add({\n      element,\n      translation,\n      attribute,\n      translationId,\n    });\n\n    if (this.#scheduler.isWithinFinalBatches()) {\n      // The scheduler is within the final batches of requests that it will send, so we will eagerly update\n      // instead of registering a callback to update several nodes in a batch. This is particularly important\n      // for cases such as translating a YouTube video with closed captions. When the rest of the viewport\n      // is already translated, and a new request for a caption comes in, that will be the only request that\n      // the scheduler is reacting to, and we want to update the caption text as soon as we possibly can.\n      this.#updateElementsWithAttributeTranslations();\n    } else if (!this.#hasPendingUpdateAttributesCallback) {\n      // Schedule a callback on the event loop to update a batch elements with completed attribute translations.\n      this.#hasPendingUpdateAttributesCallback = true;\n      lazy.setTimeout(\n        this.#updateElementsWithAttributeTranslations,\n        DOM_UPDATE_INTERVAL_MS\n      );\n    } else {\n      // An update has been previously scheduled, do nothing here.\n    }\n  }\n\n  /**\n   * Updates all elements that have completed attribute translation requests.\n   *\n   * This function is intentionally written as a lambda so that it can be passed as a callback without the\n   * need to explicitly bind `this` to the function object.\n   */\n  #updateElementsWithAttributeTranslations = () => {\n    this.#hasPendingUpdateAttributesCallback = false;\n\n    let staleRequestCount = 0;\n    let detachedElementCount = 0;\n    let updatedAttributeCount = 0;\n\n    const startTime = ChromeUtils.now();\n\n    // Stop the mutations so that the updates won't trigger observations.\n    this.#pauseMutationObserverAndThen(() => {\n      for (const entry of this.#elementsThatNeedAttributeUpdates) {\n        const { element, translation, attribute, translationId } = entry;\n\n        const eligibility = this.#determineElementAttributeUpdateEligibility(\n          element,\n          attribute,\n          translationId\n        );\n\n        if (eligibility === \"stale\") {\n          // A new request has been submitted for this node. This one is no longer relevant.\n          staleRequestCount++;\n          continue;\n        } else if (eligibility === \"detached\") {\n          // This element is detached from the DOM: there is no point in updating it.\n          detachedElementCount++;\n        } else {\n          updatedAttributeCount++;\n          element.setAttribute(attribute, translation);\n        }\n\n        deleteFromNestedMap(\n          this.#queuedIntersectionPrunableAttributeElements,\n          element,\n          attribute\n        );\n\n        deleteFromNestedMap(\n          this.#queuedIntersectionExemptAttributeElements,\n          element,\n          attribute\n        );\n\n        deleteFromNestedMap(\n          this.#pendingAttributeTranslations,\n          element,\n          attribute\n        );\n\n        this.#removeFromAttributeIntersectionObservation(element, attribute);\n      }\n\n      this.#elementsThatNeedAttributeUpdates.clear();\n    });\n\n    ChromeUtils.addProfilerMarker(\n      \"TranslationsDocument Update (Attributes)\",\n      { startTime, innerWindowId: this.#innerWindowId },\n      \"Attribute Update Request: \" +\n        `${staleRequestCount} stale requests, ${detachedElementCount} detached elements, ` +\n        `${updatedAttributeCount} attributes updated.`\n    );\n  };\n\n  /**\n   * Submit a node to the TranslationScheduler to have its text content translated.\n   *\n   * @param {number} priority\n   * @param {Element} observableElement\n   * @param {Set<Node>} nodeSet\n   */\n  #submitForContentTranslation(priority, observableElement, nodeSet) {\n    for (const targetNode of nodeSet) {\n      // Give each element an id that gets passed through the translation so it can be reunited later on.\n      if (observableElement === targetNode) {\n        /** @type {Array<Element>} */\n        const elements = observableElement.querySelectorAll(\"*\");\n\n        elements.forEach((el, i) => {\n          const dataset = getDataset(el);\n          if (dataset) {\n            dataset.mozTranslationsId = String(i);\n          }\n        });\n      }\n\n      /** @type {string} */\n      let sourceText;\n      /** @type {boolean} */\n      let isHTML;\n\n      if (\n        // This node is a text node, therefore it cannot be an HTML translation.\n        asTextNode(targetNode) ||\n        // When an element has no child elements and its textContent is exactly\n        // equal to its innerHTML, then it is safe to treat as a text translation.\n        (observableElement.childElementCount === 0 &&\n          observableElement.textContent === observableElement.innerHTML)\n      ) {\n        sourceText = targetNode.textContent ?? \"\";\n        isHTML = false;\n      } else {\n        sourceText = /** @type {string} */ (observableElement.innerHTML);\n        isHTML = true;\n      }\n\n      if (sourceText.trim().length === 0) {\n        return;\n      }\n      const translationId = this.#lastTranslationId++;\n\n      let pendingNodes =\n        this.#pendingContentTranslations.get(observableElement);\n      if (!pendingNodes) {\n        pendingNodes = new Map();\n        this.#pendingContentTranslations.set(observableElement, pendingNodes);\n      }\n      pendingNodes.set(targetNode, translationId);\n\n      this.#walkNodeToPendingParent(targetNode);\n      this.#tryTranslate(\n        targetNode,\n        sourceText,\n        isHTML,\n        translationId,\n        priority\n      )\n        .then(translation => {\n          if (translation) {\n            this.#registerElementForContentTranslationUpdate(\n              observableElement,\n              targetNode,\n              translation,\n              translationId\n            );\n          } else if (\n            pendingNodes.get(targetNode) === translationId &&\n            this.#pendingContentTranslations.get(observableElement) ===\n              pendingNodes\n          ) {\n            // There is nothing to update for this translation request.\n            pendingNodes.delete(targetNode);\n            if (pendingNodes.size === 0) {\n              this.#pendingContentTranslations.delete(observableElement);\n              this.#removeFromContentIntersectionObservation(\n                observableElement,\n                targetNode\n              );\n            }\n          }\n        })\n        .catch(error => {\n          lazy.console.error(error);\n          if (\n            pendingNodes.get(targetNode) === translationId &&\n            this.#pendingContentTranslations.get(observableElement) ===\n              pendingNodes\n          ) {\n            pendingNodes.delete(targetNode);\n            if (pendingNodes.size === 0) {\n              this.#pendingContentTranslations.delete(observableElement);\n              this.#removeFromContentIntersectionObservation(\n                observableElement,\n                targetNode\n              );\n            }\n          }\n        });\n    }\n  }\n\n  /**\n   * Walks the nodes to set the relationship between the node to the pending parent node.\n   * This solves a performance problem with pages with large subtrees and lots of mutation.\n   * For instance on YouTube it took 838ms to `getPendingParentElementFromTarget` by going\n   * through all pending translations. Caching this relationship reduced it to 26ms to walk\n   * it while adding the pending translation.\n   *\n   * On a page like the Wikipedia \"Cat\" entry, there are not many mutations, and this\n   * adds 4ms of additional wasted work.\n   *\n   * @param {Node} pendingParent\n   */\n  #walkNodeToPendingParent(pendingParent) {\n    this.#nodeToPendingParent.set(pendingParent, pendingParent);\n    const { ownerDocument } = pendingParent;\n    if (!ownerDocument) {\n      return;\n    }\n    const nodeIterator = ownerDocument.createTreeWalker(\n      pendingParent,\n      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT\n    );\n    /** @type {Node | null} */\n    let node;\n    while ((node = nodeIterator.nextNode())) {\n      this.#nodeToPendingParent.set(node, pendingParent);\n    }\n  }\n\n  /**\n   * Attempts to translate the given text for the given node.\n   *\n   * If we already have a cached result for this translation,\n   * then we will resolve immediately and never send the request\n   * to the TranslationsEngine.\n   *\n   * The request may also fail or be cancelled before it completes.\n   *\n   * @param {Node} node\n   * @param {string} sourceText\n   * @param {boolean} isHTML\n   * @param {number} translationId\n   * @param {number} priority\n   *\n   * @returns {Promise<string | null>}\n   */\n  async #tryTranslate(node, sourceText, isHTML, translationId, priority) {\n    if (this.#translationsCache.isAlreadyTranslated(sourceText, isHTML)) {\n      // The cache indicates that the text being sent to translate is already\n      // translated into the target language. Don't try to re-translate it.\n      return null;\n    }\n\n    /** @type {string | null | undefined} */\n    let translation = this.#translationsCache.get(sourceText, isHTML);\n\n    if (translation !== undefined) {\n      // We already have a cached translation for this source text.\n      return translation;\n    }\n\n    translation = await this.#scheduler\n      .createTranslationRequestPromise(\n        node,\n        sourceText,\n        isHTML,\n        translationId,\n        priority\n      )\n      .finally(() => {\n        // Any time a request resolves or rejects, we need to inform the scheduler\n        // so that it can determine if it needs to schedule a new batch of requests.\n        this.#scheduler.maybeScheduleMoreTranslationRequests();\n      });\n\n    if (translation !== null) {\n      this.#translationsCache.set(sourceText, translation, isHTML);\n      if (!this.#hasFirstVisibleChange) {\n        this.#hasFirstVisibleChange = true;\n        this.#actorReportFirstVisibleChange();\n      }\n    }\n\n    return translation;\n  }\n\n  /**\n   * Start the mutation observer, for instance after applying the translations to the DOM.\n   */\n  #startMutationObserver() {\n    if (Cu.isDeadWrapper(this.#mutationObserver)) {\n      // This observer is no longer alive.\n      return;\n    }\n\n    for (const node of this.#rootNodes) {\n      if (Cu.isDeadWrapper(node)) {\n        // This node is no longer alive.\n        continue;\n      }\n      this.#mutationObserver.observe(node, MUTATION_OBSERVER_OPTIONS);\n    }\n  }\n\n  /**\n   * Stop the mutation observer, for instance to apply the translations to the DOM.\n   */\n  #stopMutationObserver() {\n    // Was the window already destroyed?\n    if (!Cu.isDeadWrapper(this.#mutationObserver)) {\n      this.#mutationObserver.disconnect();\n    }\n  }\n\n  /**\n   * Stops the mutation observer and all intersection observers.\n   */\n  #stopAllObservers() {\n    const observers = [\n      this.#mutationObserver,\n      this.#intersectionObserverForContentTranslationsWithinViewport,\n      this.#intersectionObserverForContentTranslationsBeyondViewport,\n      this.#intersectionObserverForAttributeTranslationsWithinViewport,\n      this.#intersectionObserverForAttributeTranslationsBeyondViewport,\n    ];\n\n    for (const observer of observers) {\n      if (!Cu.isDeadWrapper(observer)) {\n        observer.disconnect();\n      }\n    }\n  }\n\n  /**\n   * Updates all nodes that have completed attribute translation requests.\n   *\n   * This function is called asynchronously, so nodes may already be dead. Before\n   * accessing a node make sure and run `Cu.isDeadWrapper` to check that it is alive.\n   */\n  #updateNodesWithContentTranslations = () => {\n    this.#hasPendingUpdateContentCallback = false;\n\n    let staleRequestCount = 0;\n    let detachedNodeCount = 0;\n    let textNodeCount = 0;\n    let elementCount = 0;\n\n    const startTime = ChromeUtils.now();\n\n    // Stop the mutations so that the updates won't trigger observations.\n    this.#pauseMutationObserverAndThen(() => {\n      const entries = this.#elementsThatNeedContentUpdates;\n      for (const {\n        element,\n        targetNode,\n        translatedContent,\n        translationId,\n      } of entries) {\n        const eligibility = this.#determineNodeContentUpdateEligibility(\n          element,\n          targetNode,\n          translationId\n        );\n\n        if (eligibility === \"stale\") {\n          // A new request has been submitted for this node. This one is no longer relevant.\n          staleRequestCount++;\n          continue;\n        } else if (eligibility === \"detached\") {\n          // This node is detached from the DOM: there is no point in updating it.\n          detachedNodeCount++;\n        } else if (element === targetNode) {\n          elementCount++;\n\n          const translationsDocument = this.#domParser.parseFromSafeString(\n            `<!DOCTYPE html><div>${translatedContent}</div>`,\n            \"text/html\"\n          );\n\n          updateElement(translationsDocument, element);\n          this.#processedContentNodes.add(targetNode);\n        } else {\n          textNodeCount++;\n          targetNode.textContent = translatedContent;\n          this.#processedContentNodes.add(targetNode);\n        }\n\n        deleteFromNestedMap(\n          this.#queuedIntersectionPrunableContentElements,\n          element,\n          targetNode\n        );\n\n        deleteFromNestedMap(\n          this.#queuedIntersectionExemptContentElements,\n          element,\n          targetNode\n        );\n\n        deleteFromNestedMap(\n          this.#pendingContentTranslations,\n          element,\n          targetNode\n        );\n\n        this.#removeFromContentIntersectionObservation(element, targetNode);\n      }\n\n      this.#elementsThatNeedContentUpdates.clear();\n    });\n\n    ChromeUtils.addProfilerMarker(\n      \"TranslationsDocument Update (Content)\",\n      { startTime, innerWindowId: this.#innerWindowId },\n      \"Content Update Request: \" +\n        `${staleRequestCount} stale requests, ${detachedNodeCount} detached nodes, ` +\n        `${textNodeCount} text nodes, and ${elementCount} elements.`\n    );\n  };\n\n  /**\n   * Stops the mutation observer while running the given callback,\n   * then restarts the mutation observer once the callback has finished.\n   *\n   * This is used to update nodes with translated content when their\n   * translation requests have completed, ensuring that we will always\n   * stop and restart the observer.\n   *\n   * @param {Function} callback - A callback to run while the mutation observer is paused.\n   */\n  #pauseMutationObserverAndThen(callback) {\n    this.#stopMutationObserver();\n    try {\n      callback();\n    } finally {\n      this.#startMutationObserver();\n    }\n  }\n\n  /**\n   * Ensures that nodes with completed content translation requests will be updated.\n   *\n   * This may happen immediately if there are very few active translation requests.\n   *\n   * If there are many active translation requests, we will register a callback to the\n   * event loop to update a batch of nodes all at once.\n   *\n   * This distinction is made because updating any content within the DOM requires\n   * pausing the mutation observer, and that cost adds up if you do it individually\n   * for every translation request that completes.\n   *\n   * @param {Element} element\n   * @param {Node} targetNode\n   * @param {string} translatedContent\n   * @param {number} translationId - A unique id to identify this translation request.\n   */\n  #registerElementForContentTranslationUpdate(\n    element,\n    targetNode,\n    translatedContent,\n    translationId\n  ) {\n    // Add the nodes to be populated with the next translation update.\n    this.#elementsThatNeedContentUpdates.add({\n      element,\n      targetNode,\n      translatedContent,\n      translationId,\n    });\n\n    if (this.#scheduler.isWithinFinalBatches()) {\n      // The scheduler is within the final batches of requests that it will send, so we will eagerly update\n      // instead of registering a callback to update several nodes in a batch. This is particularly important\n      // for cases such as translating a YouTube video with closed captions. When the rest of the viewport\n      // is already translated, and a new request for a caption comes in, that will be the only request that\n      // the scheduler is reacting to, and we want to update the caption text as soon as we possibly can.\n      this.#updateNodesWithContentTranslations();\n    } else if (!this.#hasPendingUpdateContentCallback) {\n      // Schedule a callback on the event loop to update all nodes with completed translations.\n      this.#hasPendingUpdateContentCallback = true;\n      lazy.setTimeout(\n        this.#updateNodesWithContentTranslations,\n        DOM_UPDATE_INTERVAL_MS\n      );\n    } else {\n      // An update has been previously scheduled, do nothing here.\n    }\n  }\n\n  /**\n   * Check to see if a language matches the document's source language.\n   *\n   * @param {Node} node\n   */\n  #matchesDocumentLanguage(node) {\n    const lang = asHTMLElement(node)?.lang;\n    if (!lang) {\n      // No `lang` was present, so assume it matches the language.\n      return true;\n    }\n\n    // First, cheaply check if language tags match, without canonicalizing.\n    if (lazy.TranslationsUtils.langTagsMatch(this.#documentLanguage, lang)) {\n      return true;\n    }\n\n    try {\n      // Make sure the local is in the canonical form, and check again. This function\n      // throws, so don't trust that the language tags are formatting correctly.\n      const [language] = Intl.getCanonicalLocales(lang);\n\n      return lazy.TranslationsUtils.langTagsMatch(\n        this.#documentLanguage,\n        language\n      );\n    } catch (_error) {\n      return false;\n    }\n  }\n\n  /**\n   * Called by external code (the actor) once a new MessagePort has been established.\n   * We pass this along to the scheduler, since this is the port that will be used\n   * to send translation requests to the TranslationsEngine.\n   *\n   * @param {MessagePort} port\n   */\n  acquirePort(port) {\n    this.#scheduler.acquirePort(port);\n  }\n\n  /**\n   * Retrieves the current status of the TranslationsEngine that is handling translations\n   * for this TranslationsDocument instance.\n   *\n   * @returns {EngineStatus}\n   */\n  get engineStatus() {\n    return this.#scheduler.engineStatus;\n  }\n\n  /**\n   * Returns true if the TranslationsDocument has any pending translation requests\n   * that are actively being handled by the TranslationScheduler, otherwise false.\n   *\n   * @returns {boolean}\n   */\n  hasPendingTranslationRequests() {\n    return (\n      this.#pendingContentTranslations.size > 0 ||\n      this.#pendingAttributeTranslations.size > 0\n    );\n  }\n\n  /**\n   * Returns true if the TranslationsDocument has any pending callback on the event loop\n   * that has not yet completed, otherwise false.\n   *\n   * @returns {boolean}\n   */\n  hasPendingCallbackOnEventLoop() {\n    return (\n      this.#hasPendingMutatedNodesCallback ||\n      this.#hasPendingPrioritizationCallback ||\n      this.#hasPendingUpdateAttributesCallback ||\n      this.#hasPendingUpdateContentCallback ||\n      this.#scheduler.hasPendingScheduleRequestsCallback()\n    );\n  }\n\n  /**\n   * Returns true if the TranslationsDocument is observing at least one\n   * element for intersection to translate its content, otherwise false.\n   *\n   * @returns {boolean}\n   */\n  isObservingAnyElementForContentIntersection() {\n    return this.#intersectionObservedContentElements.size > 0;\n  }\n\n  /**\n   * Returns true if the TranslationsDocument is observing at least one\n   * element for intersection to translate its attributes, otherwise false.\n   *\n   * @returns {boolean}\n   */\n  isObservingAnyElementForAttributeIntersection() {\n    return this.#intersectionObservedAttributeElements.size > 0;\n  }\n\n  /**\n   * An event handler for when the user scrolls around the page.\n   * Uses the scrollY position to determine if the user is scrolling up or down.\n   * This scroll hint is used to help optimally prioritize translation requests.\n   *\n   * This function is intentionally written as a lambda so that it can be passed as a\n   * callback without the need to explicitly bind `this` to the function object.\n   */\n  #handleScrollEvent = () => {\n    if (ChromeUtils.now() - this.#mostRecentScrollTimestamp < 100) {\n      // Scrolling can fire a lot of events in rapid succession, and computing the scrollY value can\n      // trigger reflow, so we will limit how often we take the time to compute the scrollY value.\n      // Scroll hints are critical to providing a smooth translation experience, but it's not the\n      // end of the world if we happen to miss one.\n      return;\n    }\n\n    const scrollY = ensureExists(this.#sourceDocument.ownerGlobal).scrollY;\n\n    this.#mostRecentScrollDirection =\n      scrollY >= this.#previousScrollY ? \"down\" : \"up\";\n\n    this.#previousScrollY = scrollY;\n    this.#mostRecentScrollTimestamp = ChromeUtils.now();\n  };\n\n  /**\n   * Returns true if the user has scrolled recently, otherwise false.\n   *\n   * @returns {boolean}\n   */\n  #hasUserScrolledRecently() {\n    return ChromeUtils.now() - this.#mostRecentScrollTimestamp < 200;\n  }\n\n  /**\n   * Attempts to determine an optimal set of translation priorities considering the location\n   * of nodes with respect to the viewport, the type of translation request (content or attribute),\n   * as well as the user's recent scroll activity.\n   *\n   * For example, if the user is actively scrolling up, we will do our best to prioritize visible\n   * content translations that are just above the user's viewport, in hopes that their translation\n   * requests will complete before the user even sees them.\n   *\n   * @returns {TranslationPriorityKinds}\n   */\n  #determinePrioritiesForTranslations() {\n    // The following priorities are always the same, regardless of recent scroll activity.\n    // Translating in-viewport content will always be of the highest priority.\n    const inViewportContentPriority = TranslationScheduler.P0;\n\n    // The priority of translating content nodes whose viewport context was indeterminate.\n    const otherContentPriority = TranslationScheduler.P6;\n\n    // The priority of translating attributes whose viewport context was indeterminate.\n    const otherAttributePriority = TranslationScheduler.P7;\n\n    // The following priorities are all dependent on the user's recent scroll activity.\n    // The priority of translating attributes within the viewport.\n    let inViewportAttributePriority;\n\n    // The priority of translating content above the viewport.\n    let aboveViewportContentPriority;\n\n    // The priority of translating attributes above the viewport.\n    let aboveViewportAttributePriority;\n\n    // The priority of translating content below the viewport.\n    let belowViewportContentPriority;\n\n    // The priority of translating attributes below the viewport.\n    let belowViewportAttributePriority;\n\n    switch (this.#mostRecentScrollDirection) {\n      case \"up\": {\n        // The user has recently scrolled up, so we will prioritize content above the viewport.\n        aboveViewportContentPriority = TranslationScheduler.P1;\n\n        // Since the user is scrolling up, it is likely that the content below the viewport\n        // has already been translated, which means that we can skip over this priority in most\n        // cases, but in the event that there are leftover, untranslated nodes, we still want to\n        // get all of the visible content around the viewport translated at the highest priorities.\n        belowViewportContentPriority = TranslationScheduler.P2;\n\n        // Attributes within and above the viewport are the next most important.\n        inViewportAttributePriority = TranslationScheduler.P3;\n        aboveViewportAttributePriority = TranslationScheduler.P4;\n\n        // Attributes below the viewport are the next most important.\n        belowViewportAttributePriority = TranslationScheduler.P5;\n        break;\n      }\n      case \"down\": {\n        // The user has recently scrolled down, so we will prioritize content below the viewport.\n        belowViewportContentPriority = TranslationScheduler.P1;\n\n        // Since the user is scrolling down, it is likely that the content above the viewport\n        // has already been translated, which means that we can skip over this priority in most\n        // cases, but in the event that there are leftover, untranslated nodes, we still want to\n        // get all of the visible content around the viewport translated at the highest priorities.\n        aboveViewportContentPriority = TranslationScheduler.P2;\n\n        // Attributes within and above the viewport are the next most important.\n        inViewportAttributePriority = TranslationScheduler.P3;\n        belowViewportAttributePriority = TranslationScheduler.P4;\n\n        // Attributes above the viewport are the next most important.\n        aboveViewportAttributePriority = TranslationScheduler.P5;\n        break;\n      }\n      default: {\n        // The user has not scrolled at all since activating Full-Page Translations.\n        if (resource_gre_modules_AppConstants_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.AppConstants.platform === \"android\") {\n          // Attributes, e.g. \"title\" are less accessible on Android, so even if the user has not\n          // scrolled yet, we are going to do our best to prioritize visible content beyond the viewport.\n          // Mobile viewports are also pretty small, so we should quickly get through to the attributes.\n          belowViewportContentPriority = TranslationScheduler.P1;\n          aboveViewportContentPriority = TranslationScheduler.P2;\n          inViewportAttributePriority = TranslationScheduler.P3;\n        } else {\n          // On Desktop, however, if the user has not scrolled yet, we have no indication that they\n          // are going to scroll, so we should prioritize the entire viewport, including attributes.\n          inViewportAttributePriority = TranslationScheduler.P1;\n          belowViewportContentPriority = TranslationScheduler.P2;\n          aboveViewportContentPriority = TranslationScheduler.P3;\n        }\n\n        belowViewportAttributePriority = TranslationScheduler.P4;\n        aboveViewportAttributePriority = TranslationScheduler.P5;\n      }\n    }\n\n    return {\n      inViewportContentPriority,\n      inViewportAttributePriority,\n      aboveViewportContentPriority,\n      aboveViewportAttributePriority,\n      belowViewportContentPriority,\n      belowViewportAttributePriority,\n      otherContentPriority,\n      otherAttributePriority,\n    };\n  }\n\n  /**\n   * Registers a callback on the event loop to drain the queued content-translation nodes and the\n   * queued attribute-translation elements, prioritizing them and sending their translation requests\n   * to the TranslationScheduler.\n   *\n   * Does nothing if a callback is already pending.\n   *\n   * The callback registered by this function uses a dynamic rate limit, where the time between sending\n   * a batch of requests to the scheduler is much longer if the user is actively scrolling around the page.\n   *\n   * The intersection observers are constantly monitoring the locations of nodes within the page,\n   * enqueuing them to be scheduled when they get near to the viewport, cancelling their requests\n   * when they exit the viewport, etc.\n   *\n   * When an intersection observer needs to cancel a translation request, it is much cheaper to\n   * remove the node from the queue before it gets assigned a priority submitted to the scheduler.\n   * If we submit a translation request for every node that gets close to the viewport immediately\n   * then we will waste a lot of resources cancelling all of those requests if the viewport moves.\n   *\n   * So we want to have some mechanism to throttle how frequently nodes are submitted to the scheduler,\n   * allowing the intersection observers to rapidly resolve the ideal state by adding and removing nodes\n   * from the queues before we pause to schedule translations for all of the nodes currently in the queues.\n   *\n   * However, if we wait too long between each time we send requests to the scheduler, the user experience\n   * will no longer feel fluid and reactive.\n   *\n   * When the user is scrolling, the observers are going to be adding and cancelling many nodes in rapid\n   * succession as their spatial contexts relative to the viewport change. We need to allow extra time\n   * to cheaply resolve the state of the queues before sending requests to the scheduler.\n   *\n   * When the user is not scrolling, new nodes may still be entering or exiting proximity with te viewport,\n   * but in this case it is often due to closed caption text updates on a video, or a chat section for a live\n   * stream being flooded with new comments. Here we want to prioritize and submit much more quickly so that\n   * we can react fluidly to dynamic changes on the page.\n   */\n  async #maybePrioritizeRequestsAndSubmitToScheduler() {\n    // Ensure that we've completed the first intersection observation before we submit any requests\n    // to the scheduler. Otherwise, the observers may end up cancelling the requests, because every observed\n    // element that is not within the observer's proximity will be seen the first time as leaving proximity.\n    await this.#waitForFirstIntersectionObservations();\n\n    if (this.#hasPendingPrioritizationCallback) {\n      // A callback has already been registered to submit to the scheduler.\n      return;\n    }\n\n    if (\n      this.#queuedIntersectionExemptContentElements.size === 0 &&\n      this.#queuedIntersectionPrunableContentElements.size === 0 &&\n      this.#queuedIntersectionExemptAttributeElements.size === 0 &&\n      this.#queuedIntersectionPrunableAttributeElements.size === 0\n    ) {\n      // There are no nodes to submit to the scheduler.\n      return;\n    }\n\n    this.#hasPendingPrioritizationCallback = true;\n\n    lazy.setTimeout(\n      async () => {\n        const contentElementCount =\n          this.#queuedIntersectionPrunableContentElements.size;\n        const attributeElementCount =\n          this.#queuedIntersectionPrunableAttributeElements.size;\n\n        let contentRequestCount = 0;\n        let attributeRequestCount = 0;\n\n        const startTime = ChromeUtils.now();\n\n        const {\n          inViewportContentPriority,\n          inViewportAttributePriority,\n          aboveViewportContentPriority,\n          aboveViewportAttributePriority,\n          belowViewportContentPriority,\n          belowViewportAttributePriority,\n          otherContentPriority,\n          otherAttributePriority,\n        } = this.#determinePrioritiesForTranslations();\n\n        const {\n          titleElement,\n          inViewportContent,\n          aboveViewportContent,\n          belowViewportContent,\n          otherContent,\n        } = this.#prioritizeQueuedContentElements();\n\n        const {\n          inViewportAttributes,\n          aboveViewportAttributes,\n          belowViewportAttributes,\n          otherAttributes,\n        } = this.#prioritizeQueuedAttributeElements();\n\n        for (const { element, nodeSet } of inViewportContent) {\n          contentRequestCount += nodeSet.size;\n          this.#submitForContentTranslation(\n            inViewportContentPriority,\n            element,\n            nodeSet\n          );\n        }\n\n        if (titleElement) {\n          // The translator pops nodes off in LIFO order, so if the <title> element is present\n          // in this group, we want to push it on as the final top-priority node, to ensure\n          // that it is the very first element to be translated.\n          contentRequestCount++;\n          this.#submitForContentTranslation(\n            inViewportContentPriority,\n            titleElement,\n            new Set([titleElement])\n          );\n        }\n\n        for (const { element, attributeSet } of inViewportAttributes) {\n          attributeRequestCount += attributeSet.size;\n          this.#submitForAttributeTranslation(\n            inViewportAttributePriority,\n            element,\n            attributeSet\n          );\n        }\n\n        for (const { element, nodeSet } of aboveViewportContent) {\n          contentRequestCount += nodeSet.size;\n          this.#submitForContentTranslation(\n            aboveViewportContentPriority,\n            element,\n            nodeSet\n          );\n        }\n\n        for (const { element, attributeSet } of aboveViewportAttributes) {\n          attributeRequestCount += attributeSet.size;\n          this.#submitForAttributeTranslation(\n            aboveViewportAttributePriority,\n            element,\n            attributeSet\n          );\n        }\n\n        for (const { element, nodeSet } of belowViewportContent) {\n          contentRequestCount += nodeSet.size;\n          this.#submitForContentTranslation(\n            belowViewportContentPriority,\n            element,\n            nodeSet\n          );\n        }\n\n        for (const { element, attributeSet } of belowViewportAttributes) {\n          attributeRequestCount += attributeSet.size;\n          this.#submitForAttributeTranslation(\n            belowViewportAttributePriority,\n            element,\n            attributeSet\n          );\n        }\n\n        for (const { element, nodeSet } of otherContent) {\n          contentRequestCount += nodeSet.size;\n          this.#submitForContentTranslation(\n            otherContentPriority,\n            element,\n            nodeSet\n          );\n        }\n\n        for (const { element, attributeSet } of otherAttributes) {\n          attributeRequestCount += attributeSet.size;\n          this.#submitForAttributeTranslation(\n            otherAttributePriority,\n            element,\n            attributeSet\n          );\n        }\n\n        this.#hasPendingPrioritizationCallback = false;\n\n        ChromeUtils.addProfilerMarker(\n          \"TranslationsDocument Prioritize\",\n          { startTime, innerWindowId: this.#innerWindowId },\n          `Prioritized ${contentRequestCount} content translation requests among ${contentElementCount} elements, ` +\n            `${attributeRequestCount} attribute translation requests among ${attributeElementCount} elements.`\n        );\n      },\n      this.#hasUserScrolledRecently() ? 250 : 25\n    );\n  }\n\n  /**\n   * Iterates through all of the nodes that the observers have queued to be sent\n   * to the TranslationScheduler for attribute translations, groups them based on their\n   * spatial context with respect to the viewport, then sorts them such that the nodes\n   * most likely to be encountered next will be scheduled for translation first.\n   *\n   * If the <title> is contained within this batch, it specially returns the title node\n   * as a distinct field so that we can specially ensure that it is the very first translation.\n   *\n   * @returns {PrioritizedContentElements}\n   */\n  #prioritizeQueuedContentElements() {\n    /**\n     * Nodes that lie at least partially within the viewport.\n     *\n     * @type {Array<SortableContentElement>}\n     */\n    const inViewportContent = [];\n\n    /**\n     * Nodes that lie entirely above the viewport.\n     *\n     * @type {Array<SortableContentElement>}\n     */\n    const aboveViewportContent = [];\n\n    /**\n     * Nodes that lie entirely below the viewport.\n     *\n     * @type {Array<SortableContentElement>}\n     */\n    const belowViewportContent = [];\n\n    /**\n     * Nodes that lie entirely to either side of the viewport,\n     * or whose position could not be determined.\n     *\n     * @type {Array<SortableContentElement>}\n     */\n    const otherContent = [];\n\n    // The <title> will be specially returned in this variable if it is present\n    // in this batch of nodes.\n    let titleElement;\n\n    const queuedContentElements =\n      this.#queuedIntersectionPrunableContentElements;\n\n    for (const [element, nodeSet] of this\n      .#queuedIntersectionExemptContentElements) {\n      const existingSet = queuedContentElements.get(element);\n\n      if (existingSet) {\n        for (const node of nodeSet) {\n          existingSet.add(node);\n        }\n      } else {\n        queuedContentElements.set(element, nodeSet);\n      }\n    }\n\n    for (const [element, nodeSet] of queuedContentElements) {\n      // We will cache the location values so that they don't have to be recomputed\n      // for every comparison when we sort. Based on my profiles, this all but removes\n      // samples captured with `Array.prototype.sort`, and cuts the number of samples\n      // from submitting nodes to the scheduler roughly in half.\n      const { top, left, right, viewportContext } =\n        getNodeSpatialContext(element);\n\n      switch (viewportContext) {\n        case \"within\": {\n          inViewportContent.push({ element, nodeSet, top, left, right });\n          break;\n        }\n        case \"above\": {\n          aboveViewportContent.push({ element, nodeSet, top, left, right });\n          break;\n        }\n        case \"below\": {\n          belowViewportContent.push({ element, nodeSet, top, left, right });\n          break;\n        }\n        default: {\n          if (element.nodeName === \"TITLE\") {\n            titleElement = element;\n          } else {\n            otherContent.push({ element, nodeSet, top, left, right });\n          }\n        }\n      }\n    }\n\n    // These node groups will be iterated over and sent to the TranslationScheduler in a regular loop,\n    // but the scheduler processes new requests in a stack-based LIFO ordering, so the following\n    // sorting semantics will sort nodes in the REVERSE order of how we want them to be scheduled.\n\n    // Sort nodes below the viewport such that the top-most nodes will be scheduled first.\n    this.#orderFromBottomToTop(belowViewportContent);\n\n    // Sort nodes above the viewport such that the bottom-most nodes will be scheduled first.\n    this.#orderFromTopToBottom(aboveViewportContent);\n\n    if (\n      this.#mostRecentScrollDirection === \"up\" &&\n      this.#hasUserScrolledRecently()\n    ) {\n      // If the user is scrolling up, we should sort nodes that come into intersection proximity\n      // such that the bottom-most nodes will be scheduled first.\n      this.#orderFromTopToBottom(inViewportContent);\n    } else {\n      // If the user is scrolling down, or by default if they have not scrolled recently, we should\n      // sort such that the top-most nodes will be scheduled first.\n      this.#orderFromBottomToTop(inViewportContent);\n    }\n\n    this.#queuedIntersectionPrunableContentElements.clear();\n    this.#queuedIntersectionExemptContentElements.clear();\n\n    return {\n      titleElement,\n      inViewportContent,\n      aboveViewportContent,\n      belowViewportContent,\n      otherContent,\n    };\n  }\n\n  /**\n   * Iterates through all of the elements that the observers have queued to be sent\n   * to the TranslationScheduler for attribute translations, groups them based on their\n   * spatial context with respect to the viewport, then sorts them such that the elements\n   * most likely to be encountered next will be scheduled for translation first.\n   *\n   * @returns {PrioritizedAttributeElements}\n   */\n  #prioritizeQueuedAttributeElements() {\n    /**\n     * Elements that lie at least partially within the viewport.\n     *\n     * @type {Array<SortableAttributeElement>}\n     */\n    const inViewportAttributes = [];\n\n    /**\n     * Elements that lie entirely above the viewport.\n     *\n     * @type {Array<SortableAttributeElement>}\n     */\n    const aboveViewportAttributes = [];\n\n    /**\n     * Elements that lie entirely below the viewport.\n     *\n     * @type {Array<SortableAttributeElement>}\n     */\n    const belowViewportAttributes = [];\n\n    /**\n     * Elements that lie to either side of the viewport,\n     * or whose position could not be determined.\n     *\n     * @type {Array<SortableAttributeElement>}\n     */\n    const otherAttributes = [];\n\n    const queuedAttributeElements =\n      this.#queuedIntersectionPrunableAttributeElements;\n\n    for (const [element, attributeSet] of this\n      .#queuedIntersectionExemptAttributeElements) {\n      const existingSet = queuedAttributeElements.get(element);\n\n      if (!existingSet) {\n        queuedAttributeElements.set(element, attributeSet);\n        continue;\n      }\n\n      for (const attributeName of attributeSet) {\n        existingSet.add(attributeName);\n      }\n    }\n\n    for (const [element, attributeSet] of queuedAttributeElements) {\n      // We will cache the location values so that they don't have to be recomputed\n      // for every comparison when we sort. Based on my profiles, this all but removes\n      // samples captured with `Array.prototype.sort`, and cuts the time to submit requests\n      // to the scheduler roughly in half.\n      const { top, left, right, viewportContext } =\n        getNodeSpatialContext(element);\n\n      switch (viewportContext) {\n        case \"within\": {\n          inViewportAttributes.push({\n            element,\n            attributeSet,\n            top,\n            left,\n            right,\n          });\n          break;\n        }\n        case \"above\": {\n          aboveViewportAttributes.push({\n            element,\n            attributeSet,\n            top,\n            left,\n            right,\n          });\n          break;\n        }\n        case \"below\": {\n          belowViewportAttributes.push({\n            element,\n            attributeSet,\n            top,\n            left,\n            right,\n          });\n          break;\n        }\n        default: {\n          otherAttributes.push({ element, attributeSet, top, left, right });\n        }\n      }\n    }\n\n    // These element groups will be iterated over and sent to the TranslationScheduler in a regular loop,\n    // but the scheduler processes new requests in a stack-based LIFO ordering, so the following\n    // sorting semantics will sort elements in the REVERSE order of how we want them to be scheduled.\n\n    // Sort elements below the viewport such that the top-most elements will be scheduled first.\n    this.#orderFromBottomToTop(belowViewportAttributes);\n\n    // Sort elements above the viewport such that the bottom-most elements will be scheduled first.\n    this.#orderFromTopToBottom(aboveViewportAttributes);\n\n    if (this.#mostRecentScrollDirection === \"up\") {\n      // If we are scrolling up, we should sort new elements that come into the viewport\n      // such that the bottom-most elements will be scheduled first.\n      this.#orderFromTopToBottom(inViewportAttributes);\n    } else {\n      // If we are scrolling down, we should sort new elements that come into the viewport\n      // such that the top-most elements will be scheduled first.\n      this.#orderFromBottomToTop(inViewportAttributes);\n    }\n\n    this.#queuedIntersectionPrunableAttributeElements.clear();\n    this.#queuedIntersectionExemptAttributeElements.clear();\n\n    return {\n      inViewportAttributes,\n      aboveViewportAttributes,\n      belowViewportAttributes,\n      otherAttributes,\n    };\n  }\n\n  /**\n   * Sorts such that nodes closer to the top of the page are first,\n   * and nodes closer to the bottom of the page are last.\n   *\n   * @param {Array<SortableContentElement> | Array<SortableAttributeElement>} nodes\n   */\n  #orderFromTopToBottom(nodes) {\n    nodes.sort((lhs, rhs) => {\n      const verticalDifference =\n        (lhs.top ?? -Infinity) - (rhs.top ?? -Infinity);\n\n      if (Math.abs(verticalDifference) > 1) {\n        // The vertical difference is greater than one pixel: this takes full precedence.\n        return verticalDifference;\n      }\n\n      if (this.#targetScriptDirection === \"ltr\") {\n        // Secondarily sort such that the LIFO scheduler will process from left to right.\n        return (rhs.right ?? Infinity) - (lhs.right ?? Infinity);\n      }\n\n      // Secondarily sort such that the LIFO scheduler will process from right to left.\n      return (lhs.left ?? -Infinity) - (rhs.left ?? -Infinity);\n    });\n  }\n\n  /**\n   * Sorts such that nodes closer to the bottom of the page are first,\n   * and nodes closer to the bottom of the page are last.\n   *\n   * @param {Array<SortableContentElement> | Array<SortableAttributeElement>} nodes\n   */\n  #orderFromBottomToTop(nodes) {\n    nodes.sort((lhs, rhs) => {\n      const verticalDifference = (rhs.top ?? Infinity) - (lhs.top ?? Infinity);\n\n      if (verticalDifference) {\n        // The vertical difference is greater than one pixel: this takes full precedence.\n        return verticalDifference;\n      }\n\n      if (this.#targetScriptDirection === \"ltr\") {\n        // Secondarily sort such that the LIFO scheduler will process from left to right.\n        return (rhs.right ?? Infinity) - (lhs.right ?? Infinity);\n      }\n\n      // Secondarily sort such that the LIFO scheduler will process from right to left.\n      return (lhs.left ?? -Infinity) - (rhs.left ?? -Infinity);\n    });\n  }\n\n  /**\n   * Attempts to register a node with the content-translation intersection observers.\n   *\n   * If the node is a text node that was determined to be translatable, then it will\n   * be immediately enqueued for translation because only element type nodes can be\n   * observed for intersection.\n   *\n   * @param {Node} node\n   */\n  #observeOrEnqueueNodeForContentPrioritization(node) {\n    let observableElement;\n    let translatableNode;\n\n    const element = asElement(node);\n    if (element) {\n      observableElement = element;\n      translatableNode = element;\n    } else if ((translatableNode = asTextNode(node))) {\n      observableElement = asElement(node.parentNode);\n    }\n\n    if (!translatableNode) {\n      // This node is not translatable, and it should have been filtered earlier.\n      lazy.console.warn(\n        `A non-translatable ${node.nodeName} node was not filtered correctly.`\n      );\n      return;\n    }\n\n    if (!observableElement) {\n      // This node is translatable, but its immediate parent is not observable for intersection.\n      lazy.console.warn(\n        `Found a translatable ${node.nodeName} node is not a direct child of an element.`\n      );\n      return;\n    }\n\n    let nodeSet =\n      this.#intersectionObservedContentElements.get(observableElement);\n\n    if (!nodeSet) {\n      nodeSet = new Set([translatableNode]);\n      this.#intersectionObservedContentElements.set(observableElement, nodeSet);\n    }\n\n    nodeSet.add(translatableNode);\n\n    if (this.#translationsMode === \"content-eager\") {\n      this.#enqueueForIntersectionPrunableContentPrioritization(\n        observableElement\n      );\n    }\n\n    // It is very important that we register the element with the In-Viewport\n    // observer before the Beyond-Viewport observer, to ensure that the In-Viewport\n    // observer callback is triggered first, otherwise we will be sending unnecessary\n    // cancellations for any nodes that lie within the bounds of both observers.\n    this.#intersectionObserverForContentTranslationsWithinViewport.observe(\n      observableElement\n    );\n    this.#intersectionObserverForContentTranslationsBeyondViewport.observe(\n      observableElement\n    );\n  }\n\n  /**\n   * Ensures that an element is removed from content intersection observation.\n   * If the element was not already being observed, has no effect.\n   *\n   * @param {Element} observableElement\n   * @param {Node} targetNode\n   */\n  #removeFromContentIntersectionObservation(observableElement, targetNode) {\n    const { didDeleteOuterEntry } = deleteFromNestedMap(\n      this.#intersectionObservedContentElements,\n      observableElement,\n      targetNode\n    );\n\n    if (didDeleteOuterEntry) {\n      this.#intersectionObserverForContentTranslationsWithinViewport.unobserve(\n        observableElement\n      );\n      this.#intersectionObserverForContentTranslationsBeyondViewport.unobserve(\n        observableElement\n      );\n    }\n  }\n\n  /**\n   * Ensures that an element is removed from attribute intersection observation.\n   * If the element was not already being observed, has no effect.\n   *\n   * @param {Element} observableElement\n   * @param {string} [attributeName]\n   */\n  #removeFromAttributeIntersectionObservation(\n    observableElement,\n    attributeName\n  ) {\n    let didDeleteOuterEntry = false;\n\n    if (!attributeName) {\n      didDeleteOuterEntry = true;\n      this.#intersectionObservedAttributeElements.delete(observableElement);\n    } else {\n      const deletionResult = deleteFromNestedMap(\n        this.#intersectionObservedAttributeElements,\n        observableElement,\n        attributeName\n      );\n      didDeleteOuterEntry = deletionResult.didDeleteOuterEntry;\n    }\n\n    if (didDeleteOuterEntry) {\n      this.#intersectionObserverForAttributeTranslationsWithinViewport.unobserve(\n        observableElement\n      );\n      this.#intersectionObserverForAttributeTranslationsBeyondViewport.unobserve(\n        observableElement\n      );\n    }\n  }\n\n  /**\n   * Attempts to register an element with the attribute-translation intersection observers.\n   * If the element has no translatable attributes, it will not be registered for observation.\n   *\n   * @param {Element} element\n   * @param {Set<string> | null} [attributes]\n   */\n  #maybeObserveElementForAttributePrioritization(element, attributes) {\n    attributes = attributes ?? this.#getTranslatableAttributes(element);\n    if (!attributes) {\n      return;\n    }\n\n    // It is very important that we register the element with the In-Viewport\n    // observer before the Beyond-Viewport observer, to ensure that the In-Viewport\n    // observer callback is triggered first, otherwise we will be sending unnecessary\n    // cancellations for any nodes that lie within the bounds of both observers.\n    this.#intersectionObservedAttributeElements.set(element, attributes);\n    this.#intersectionObserverForAttributeTranslationsWithinViewport.observe(\n      element\n    );\n    this.#intersectionObserverForAttributeTranslationsBeyondViewport.observe(\n      element\n    );\n  }\n\n  /**\n   * Attempts to cancel a content translation request for the given node,\n   * only if the request has not already been sent to the TranslationsEngine.\n   *\n   * This function is intended to be used by the intersection observers to\n   * re-prioritize a translation. If a translation request has already been\n   * sent to the TranslationsEngine, in this case, it will soon be complete\n   * so it would be wasteful to fully cancel it solely to re-prioritize.\n   *\n   * In order to fully cancel a translation request, even if it has already been\n   * sent to the TranslationsEngine, as such is the use case for the mutation\n   * observer, then the `#maybePreventContentTranslation` function should be used instead.\n   *\n   * @param {Element} element\n   * @returns {{\n   *  preventedNodeSet?: Set<Node>,\n   *  cancelledFromSchedulerCount: number\n   * }}\n   */\n  #preventUnscheduledContentTranslations(element) {\n    /** @type {Set<Node> | undefined} */\n    let preventedNodeSet =\n      this.#queuedIntersectionPrunableContentElements.get(element);\n\n    if (preventedNodeSet) {\n      this.#queuedIntersectionPrunableContentElements.delete(element);\n    }\n\n    const pendingNodes = this.#pendingContentTranslations.get(element);\n    let cancelledFromSchedulerCount = 0;\n\n    if (!pendingNodes) {\n      return {\n        preventedNodeSet,\n        cancelledFromSchedulerCount,\n      };\n    }\n\n    /** @param {Node} node */\n    const addNodeToSet = node => {\n      if (!preventedNodeSet) {\n        preventedNodeSet = new Set();\n      }\n      preventedNodeSet.add(node);\n    };\n\n    for (const [node, translationId] of pendingNodes) {\n      if (this.#scheduler.preventUnscheduledTranslation(translationId)) {\n        addNodeToSet(node);\n      }\n    }\n\n    if (preventedNodeSet) {\n      for (const node of preventedNodeSet.keys()) {\n        pendingNodes.delete(node);\n        cancelledFromSchedulerCount++;\n      }\n    }\n\n    if (pendingNodes.size === 0) {\n      this.#pendingContentTranslations.delete(element);\n    }\n\n    return {\n      preventedNodeSet,\n      cancelledFromSchedulerCount,\n    };\n  }\n\n  /**\n   * Attempts to cancel all attribute translation requests for the given element,\n   * only if the requests have not already been sent to the TranslationsEngine.\n   *\n   * This function is intended to be used by the intersection observers to\n   * re-prioritize translations. If the translation requests have already been\n   * sent to the TranslationsEngine, in this case, they will soon be complete\n   * so it would be wasteful to fully cancel them solely to re-prioritize.\n   *\n   * In order to fully cancel an element's attribute translation requests, even\n   * if they have already been sent to the TranslationsEngine, as such is the use\n   * case for the mutation observer, then the `#maybePreventAttributeTranslations`\n   * function should be used instead.\n   *\n   * @param {Element} element\n   * @returns {{\n   *   preventedAttributeSet?: Set<string>,\n   *   cancelledFromSchedulerCount: number,\n   * }}\n   */\n  #preventUnscheduledAttributeTranslations(element) {\n    /** @type {Set<string> | undefined} */\n    let preventedAttributeSet =\n      this.#queuedIntersectionPrunableAttributeElements.get(element);\n\n    if (preventedAttributeSet) {\n      this.#queuedIntersectionPrunableAttributeElements.delete(element);\n    }\n\n    const pendingAttributes = this.#pendingAttributeTranslations.get(element);\n    let cancelledFromSchedulerCount = 0;\n\n    if (!pendingAttributes) {\n      return {\n        preventedAttributeSet,\n        cancelledFromSchedulerCount,\n      };\n    }\n\n    /** @param {string} attribute */\n    const addAttributeToSet = attribute => {\n      if (!preventedAttributeSet) {\n        preventedAttributeSet = new Set();\n      }\n      preventedAttributeSet.add(attribute);\n    };\n\n    for (const [attribute, translationId] of pendingAttributes) {\n      if (this.#scheduler.preventUnscheduledTranslation(translationId)) {\n        addAttributeToSet(attribute);\n      }\n    }\n\n    if (preventedAttributeSet) {\n      for (const attribute of preventedAttributeSet.keys()) {\n        pendingAttributes.delete(attribute);\n        cancelledFromSchedulerCount++;\n      }\n    }\n\n    if (pendingAttributes.size === 0) {\n      this.#pendingAttributeTranslations.delete(element);\n    }\n\n    return {\n      preventedAttributeSet,\n      cancelledFromSchedulerCount,\n    };\n  }\n\n  /**\n   * Determines whether the given node is eligible to have its text content updated.\n   *\n   * Updates to nodes within the DOM may happen asynchronously, so by the time that we are\n   * ready to update the content we need to check two conditions:\n   *\n   * 1) Has the fulfilled request that we have gone stale due to a newer, more-relevant request\n   *    that was scheduled for this same node?\n   *\n   * 2) Has this node already detached from the DOM before we updated its content, in which case\n   *    there is no point in moving forward with the update?\n   *\n   * @param {Element} element\n   * @param {Node} targetNode\n   * @param {number} translationId\n   *\n   * @returns {UpdateEligibility}\n   */\n  #determineNodeContentUpdateEligibility(element, targetNode, translationId) {\n    const pendingNodes = this.#pendingContentTranslations.get(element);\n\n    if (!pendingNodes || pendingNodes.get(targetNode) !== translationId) {\n      // This translation lost a race, and was deleted or re-submitted under a different id.\n      return \"stale\";\n    }\n\n    if (this.#nodesWithMutatedContent.has(targetNode)) {\n      // The target node has been mutated since the time we requested translation.\n      // The translated value that we have is no longer relevant.\n      return \"stale\";\n    }\n\n    if (isNodeDetached(targetNode)) {\n      // The node is detached from the DOM, there is no use in updating its content.\n      return \"detached\";\n    }\n\n    return \"valid\";\n  }\n\n  /**\n   * Determines whether the given element is eligible to have its attributes updated.\n   *\n   * Updates to elements within the DOM may happen asynchronously, so by the time that we are\n   * ready to update the attributes we need to check two conditions:\n   *\n   * 1) Has the fulfilled request that we have gone stale due to a newer, more-relevant request\n   *    that was scheduled for this same attribute on this element?\n   *\n   * 2) Has this element already detached from the DOM before we updated its attribute, in which\n   *    case there is no point moving forward with the update?\n   *\n   * @param {Element} element\n   * @param {string} attribute\n   * @param {number} translationId\n   *\n   * @returns {UpdateEligibility}\n   */\n  #determineElementAttributeUpdateEligibility(\n    element,\n    attribute,\n    translationId\n  ) {\n    const pendingAttributes = this.#pendingAttributeTranslations.get(element);\n\n    if (\n      !pendingAttributes ||\n      pendingAttributes.get(attribute) !== translationId\n    ) {\n      // A new request has been submitted for this attribute. This one is no longer relevant.\n      return \"stale\";\n    }\n\n    if (this.#elementsWithMutatedAttributes.get(element)?.has(attribute)) {\n      // This attribute has been mutated since the time we requested translation.\n      // The translated value that we have is no longer relevant.\n      return \"stale\";\n    }\n\n    if (isNodeDetached(element)) {\n      // This element is detached from the DOM: there is no point in updating it.\n      return \"detached\";\n    }\n\n    return \"valid\";\n  }\n}\n\n/**\n * The AntiStarvationStack is a stack-like data structure with a predefined batch size.\n * Requests are pushed to the stack one at a time, but they may only be popped in a batch.\n *\n * The stack keeps track of whether the net count of requests has increased or decreased\n * between each time it pops a batch of request. If the size of the stack has not decreased\n * since the previous time a batch was popped, then it means that more requests are being\n * pushed to the stack than are being popped from the stack, and the stack is considered\n * to have starving requests.\n *\n * This terminology is derived from the idea that if the stack is growing faster than it is\n * processing, then requests at the bottom of the stack will never be popped, and they will starve,\n * i.e. they will never have a chance to be processed.\n *\n *  - https://en.wikipedia.org/wiki/Starvation_(computer_science)\n *\n * In order to ensure fairness in processing, when the stack has starving requests it will pull\n * a predefined portion of the batch from the bottom of the stack, instead of only from the top.\n * This ensures that if the stack is growing faster than it can be processed, we are guaranteed\n * to eventually process the oldest requests in the stack, given enough time, and no request will\n * ever starve entirely.\n *\n * It is recommended that the starvation batch portion is less than or equal half of the batch size.\n * This ensures that priority is still given to newer requests, as is the intent of the stack, while\n * still ensuring fairness in scheduling.\n *\n * The following is a diagram of several calls to popBatch(), demonstrating both normal calls to\n * popBatch() as well as calls to popBatch() under starvation conditions:\n *\n * AntiStarvationStack: size == 9, #batchSize == 5, #starvationBatchPortion == 2\n *\n *             ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐\n *             └─┴─┴─┴─┴─┴─┴─┴─┴─┘\n * popBatch():         └────┬────┘\n *                          5\n *\n *             ┌─┬─┬─┬─┐\n *             └─┴─┴─┴─┘\n * push() x 7:         └──────┬──────┘\n *                            7\n *\n *             ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐\n *             └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘\n * popBatch(): └─┬─┘           └──┬──┘\n *               2                3\n *\n *                 ┌─┬─┬─┬─┬─┬─┐\n *                 └─┴─┴─┴─┴─┴─┘\n * push() x 4:                 └───┬───┘\n *                                 4\n *\n *                 ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐\n *                 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘\n * popBatch():               └────┬────┘\n *                                5\n *\n *                 ┌─┬─┬─┬─┬─┐\n *                 └─┴─┴─┴─┴─┘\n */\nclass AntiStarvationStack {\n  /**\n   * The array that represents the internal stack.\n   *\n   * @type {Array<TranslationRequest>}\n   */\n  #stack = [];\n\n  /**\n   * Keeps track of the size of the stack the previous time a batch was popped.\n   * This is used to determine if the stack contains any starving requests,\n   * i.e. more requests are being pushed to the stack than are being popped.\n   *\n   * @type {number}\n   */\n  #sizeBeforePreviousPop = 0;\n\n  /**\n   * The size of the batch that will be popped from the top of stack when no\n   * starvation is occurring, i.e. more requests are being popped than pushed.\n   *\n   * @type {number}\n   */\n  #batchSize = 2;\n\n  /**\n   * Returns the count of requests that are popped from this stack when calling popBatch().\n   *\n   * @see {AntiStarvationStack.popBatch}\n   *\n   * @returns {number}\n   */\n  get batchSize() {\n    return this.#batchSize;\n  }\n\n  /**\n   * The size of the batch that will be popped from the bottom of stack when the\n   * stack has starving requests, i.e. more requests are being pushed than popped.\n   *\n   * When the stack is starving, then (#batchSize - #starvationBatchPortion)\n   * nodes will still be removed from the top of the stack, but #starvationBatchPortion\n   * nodes will also be removed from the bottom of the stack to ensure fairness for\n   * continuing to process old requests in addition to new requests.\n   *\n   * @type {number}\n   */\n  #starvationBatchPortion = 1;\n\n  /**\n   * Constructs a new AntiStarvationStack.\n   *\n   * The given batchSize must be larger than the starvationBatchPortion.\n   *\n   * @param {number} batchSize\n   * @param {number} starvationBatchPortion\n   */\n  constructor(batchSize, starvationBatchPortion) {\n    this.#batchSize = batchSize;\n    this.#starvationBatchPortion = starvationBatchPortion;\n\n    if (this.#batchSize < 2) {\n      throw new Error(\"Batch size must be at least 2.\");\n    }\n\n    if (this.#starvationBatchPortion <= 0) {\n      throw new Error(\"Starvation batch portion must be greater than zero.\");\n    }\n\n    if (this.#batchSize < this.#starvationBatchPortion) {\n      throw new Error(\n        \"Batch size must not be smaller than starvation batch portion.\"\n      );\n    }\n  }\n\n  /**\n   * Returns the current count of requests in the stack.\n   *\n   * @returns {number}\n   */\n  get size() {\n    return this.#stack.length;\n  }\n\n  /**\n   * Pushes a translation request to the top of the stack.\n   *\n   * @param {TranslationRequest} request\n   */\n  push(request) {\n    this.#stack.push(request);\n  }\n\n  /**\n   * Pops at most #batchSize requests from the stack.\n   *\n   * If the stack is starving (i.e. the net count of requests in the stack has\n   * increased since the previous call to popBatch(), rather than decreased),\n   * then a portion of requests will be removed from the bottom of the stack\n   * to ensure fairness in scheduling.\n   *\n   * @returns {{ starvationDetected: boolean, requests: Array<TranslationRequest>}}\n   */\n  popBatch() {\n    const currentSize = this.size;\n    const starvationDetected =\n      // The stack was not empty the last time we popped.\n      this.#sizeBeforePreviousPop > 0 &&\n      // The net requests have not decreased since the last time we popped.\n      currentSize >= this.#sizeBeforePreviousPop &&\n      // The stack currently has more than one batch worth of requests.\n      currentSize > this.#batchSize;\n\n    this.#sizeBeforePreviousPop = currentSize;\n\n    if (currentSize === 0) {\n      return { starvationDetected, requests: [] };\n    }\n\n    let topBatchSize = this.#batchSize;\n    let bottomBatchSize = 0;\n\n    if (starvationDetected && currentSize > this.#batchSize) {\n      // The stack is growing faster than it is being processed,\n      // the stack contains more than one batch worth of requests.\n      // We will pull some from the bottom and the top to prevent starvation.\n      topBatchSize -= this.#starvationBatchPortion;\n      bottomBatchSize = this.#starvationBatchPortion;\n    }\n\n    /** @type {Array<TranslationRequest>} */\n    const requests = [];\n\n    for (let i = 0; i < topBatchSize && this.size > 0; i++) {\n      // @ts-ignore: this.#stack.pop() cannot return undefined here.\n      requests.push(this.#stack.pop());\n    }\n\n    // Removing requests from the front of an array like this has O(n) performance characteristics.\n    // An ideal solution here would utilize a deque with amortized O(1) popBack() and popFront()\n    // guarantees. Unfortunately, JavaScript lacks a standard deque implementation at this time.\n    //\n    // We are operating on small arrays, usually single or double digits in size, low hundreds at most.\n    // I have not found the performance characteristics here to be any sort of bottleneck; I rarely\n    // see this function show up in performance profiles, even when translating high-activity live\n    // stream comment sections, which is a prime scenario for starvation conditions.\n    //\n    // Until such a time that a deque is readily available in JavaScript, I do not feel the complexity\n    // of writing a custom deque implementation is justified for our use case here.\n    if (bottomBatchSize > 0) {\n      const bottomPortion = this.#stack.slice(0, bottomBatchSize);\n      requests.push(...bottomPortion);\n\n      // Retain the rest of the stack without the bottom portion.\n      this.#stack = this.#stack.slice(bottomBatchSize, this.size);\n    }\n\n    return { starvationDetected, requests };\n  }\n\n  /**\n   * Removes a request from the stack if it matches the given translationId.\n   *\n   * @param {number} translationId\n   * @returns {TranslationRequest | undefined}\n   */\n  remove(translationId) {\n    const index = this.#stack.findIndex(\n      request => translationId === request.translationId\n    );\n\n    if (index < 0) {\n      // No request was found matching this translationId.\n      // It may have already been sent to the TranslationsEngine.\n      return undefined;\n    }\n\n    const request = this.#stack[index];\n\n    // Removing requests from the middle of an array like this has O(n) performance characteristics.\n    // An ideal solution here would utilize a table-based strategy with amortized O(1) removal guarantees.\n    //\n    // Unfortunately, using a table structure such as Map would make every call to popBatch() have O(n),\n    // characteristics, even under non-starvation conditions, due to Map not having any double-ended\n    // iteration capabilities at this time.\n    //\n    // We are operating on small arrays, usually single or double digits in size, low hundreds at most.\n    // I have not found the performance characteristics here to be any sort of bottleneck; I rarely\n    // see this function show up in performance profiles, even when scrolling rapidly through pages,\n    // which is a prime scenario for cancelling requests and therefore removing them by their translationIds.\n    this.#stack.splice(index, 1);\n\n    return request;\n  }\n\n  /**\n   * Clears all entries from the stack.\n   */\n  clear() {\n    this.#stack = [];\n  }\n}\n\n/**\n * The TranslationScheduler orchestrates when translation requests are sent to the TranslationsEngine.\n *\n * The scheduler implements a stack-based, newest-first priority-scheduling algorithm, which ensures\n * that the most recent content that enters proximity to the viewport, whether due to user scrolling,\n * or due to dynamic content entering the page, is translated at the highest priority.\n *\n * Although the scheduler ensures that the highest-priority requests are translated first, it also\n * ensures scheduling fairness with guarantees that every request will eventually be scheduled,\n * regardless of age or priority, even if more requests are coming in than can be processed.\n *\n * Fairness is guaranteed by the use of an anti-starvation stack @see {AntiStarvationStack}.\n *\n * Requests may be cancelled from the scheduler at any time, even after they are sent to the\n * TranslationsEngine, though the earlier a request is cancelled, the cheaper it is to do so.\n */\nclass TranslationScheduler {\n  /**\n   * The priorities of the translation requests, where P0 is the highest and P7 is the lowest.\n   *\n   * The priorities are determined by the TranslationsDocument, and are dynamically assigned\n   * based on several factors including whether the request is for a content or an attribute\n   * translation, the location of the element with respect to the viewport, and the user's\n   * recent scrolling activity on the page.\n   */\n  static get P0() {\n    return 0;\n  }\n  static get P1() {\n    return 1;\n  }\n  static get P2() {\n    return 2;\n  }\n  static get P3() {\n    return 3;\n  }\n  static get P4() {\n    return 4;\n  }\n  static get P5() {\n    return 5;\n  }\n  static get P6() {\n    return 6;\n  }\n  static get P7() {\n    return 7;\n  }\n\n  /**\n   * The count of active requests must be lower than this threshold before we will allow\n   * sending any more requests to the TranslationsEngine.\n   *\n   * We want to strike a balance between being optimally reactive to changes that may\n   * change request priorities, such as the user scrolling, while also sending a constant\n   * flow of requests to the TranslationsEngine, minimizing CPU downtime in the worker between\n   * finishing the current batch of requests and beginning to process the next batch of requests.\n   *\n   * This number may need to be increased if the performance of the TranslationsEngine worker\n   * improves considerably, or if we ever have more than one worker translating in parallel.\n   *\n   * @type {number}\n   */\n  static get ACTIVE_REQUEST_THRESHOLD() {\n    return 1;\n  }\n\n  /**\n   * The port that sends translation requests to the TranslationsEngine.\n   *\n   * @type {MessagePort | null}\n   */\n  #port = null;\n\n  /**\n   * If a new port is needed, this callback will be invoked to request one\n   * from the actor. After the actor obtains it, it calls `acquirePort`.\n   *\n   * @type {() => void}\n   */\n  #actorRequestNewPort;\n\n  /**\n   * A map from the translationId to its corresponding TranslationRequest.\n   *\n   * This map contains only the requests that have been sent to the TranslationsEngine.\n   * Once the engine sends a translation response, we will match the translationId here\n   * to resolve or reject the request's promise, then remove it from the map.\n   *\n   * This map is mutually exclusive to the #unscheduledRequestsPriorityMap.\n   *\n   * @type {Map<number, TranslationRequest>}\n   */\n  #activeRequests = new Map();\n\n  /**\n   * A map from the translationId to the corresponding request's priority.\n   *\n   * This map contains only the requests that have not yet been sent to the TranslationsEngine.\n   * We use this map to look up which priority stack a request should be removed from if the\n   * request needs to be cancelled.\n   *\n   * Once the scheduler send the request to the TranslationsEngine, the entry for the translationId\n   * will be removed from this map, and an entry for the same id will be added to #activeRequests.\n   *\n   * @type {Map<number, number>}\n   */\n  #unscheduledRequestPriorities = new Map();\n\n  /**\n   * The stacks that correspond to the eight priorities a translation request can be assigned.\n   * The lower the number, the higher the priority. Each priority corresponds to an index in this array.\n   *\n   * @see {TranslationScheduler.P0}\n   * @see {TranslationScheduler.P1}\n   * @see {TranslationScheduler.P2}\n   * @see {TranslationScheduler.P3}\n   * @see {TranslationScheduler.P4}\n   * @see {TranslationScheduler.P5}\n   * @see {TranslationScheduler.P6}\n   * @see {TranslationScheduler.P7}\n   */\n  #priorityStacks = [\n    new AntiStarvationStack(2, 1), // p0 stack\n    new AntiStarvationStack(2, 1), // p1 stack\n    new AntiStarvationStack(2, 1), // p2 stack\n    new AntiStarvationStack(2, 1), // p3 stack\n    new AntiStarvationStack(2, 1), // p4 stack\n    new AntiStarvationStack(2, 1), // p5 stack\n    new AntiStarvationStack(2, 1), // p6 stack\n    new AntiStarvationStack(2, 1), // p7 stack\n  ];\n\n  #maxRequestsPerScheduleEvent = (() => {\n    let requestCount = 0;\n\n    for (const stack of this.#priorityStacks) {\n      requestCount += stack.batchSize;\n    }\n\n    return requestCount;\n  })();\n\n  /**\n   * Tracks the status of the translation engine.\n   *\n   * @type {EngineStatus}\n   */\n  #engineStatus = \"uninitialized\";\n\n  /**\n   * Read-only getter to retrieve the engine status.\n   *\n   * @returns {EngineStatus}\n   */\n  get engineStatus() {\n    return this.#engineStatus;\n  }\n\n  /**\n   * Whether the page is currently shown or not. If hidden, we pause processing\n   * and do not attempt to send new translation requests to the engine.\n   */\n  #isPageShown = true;\n\n  /**\n   * If a port is being requested, we store a reference to that promise\n   * (plus its resolve/reject) so that repeated requests are not re-sent.\n   *\n   * @type {{ promise: Promise<void>, resolve: Function, reject: Function } | null}\n   */\n  #portRequest = null;\n\n  /**\n   * Marks when we have a pending callback for scheduling more requests\n   * This ensures that we won't over-schedule requests from multiple calls.\n   *\n   * @type {boolean}\n   */\n  #hasPendingScheduleRequestsCallback = false;\n\n  /**\n   * The InnerWindowID value to report to profiler markers.\n   *\n   * @type {number}\n   */\n  #innerWindowId;\n\n  /**\n   * A cache of translations that have already been computed.\n   * This is cache is shared with the TranslationsDocument.\n   *\n   * @type {LRUCache}\n   */\n  #translationsCache;\n\n  /**\n   * Constructs a new TranslationScheduler.\n   *\n   * @param {MessagePort?} port - A port to send translation requests to the TranslationsEngine.\n   * @param {number} innerWindowId - The innerWindowId for profiler markers.\n   * @param {LRUCache} translationsCache - A cache of completed translations, shared with the TranslationsDocument.\n   * @param {() => void} actorRequestNewPort - The function to call to ask the actor for a new port.\n   */\n  constructor(port, innerWindowId, translationsCache, actorRequestNewPort) {\n    this.#innerWindowId = innerWindowId;\n    this.#translationsCache = translationsCache;\n    this.#actorRequestNewPort = actorRequestNewPort;\n\n    if (port) {\n      this.acquirePort(port);\n    }\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  hasPendingScheduleRequestsCallback() {\n    return this.#hasPendingScheduleRequestsCallback;\n  }\n\n  /**\n   * Attaches an onmessage handler to manage any communication with the TranslationsEngine.\n   * If we were waiting for a port (#portRequest), we resolve that once the engine indicates\n   * \"ready\" or reject if it indicates failure.\n   *\n   * @see {TranslationsDocument.acquirePort}\n   *\n   * @param {MessagePort} port\n   */\n  acquirePort(port) {\n    if (this.#port) {\n      // If we already have a port open but we somehow got a new one,\n      // discard the old and use the new. Typically not expected unless the engine\n      // had an error or the page re-requested a new port forcibly.\n      if (this.#engineStatus === \"ready\") {\n        lazy.console.error(\n          \"Received a new translation port while one already existed.\"\n        );\n      }\n      this.#discardPort();\n    }\n\n    this.#port = port;\n\n    const portRequest = this.#portRequest;\n\n    // Wire up message handling\n    port.onmessage = event => {\n      /** @type {{data: PortToPage}} */\n      const { data } = /** @type {any} */ (event);\n\n      switch (data.type) {\n        case \"TranslationsPort:TranslationResponse\": {\n          const { translationId, targetText } = data;\n          const request = this.#activeRequests.get(translationId);\n\n          if (request) {\n            this.#activeRequests.delete(translationId);\n            request.resolve(targetText);\n          }\n\n          break;\n        }\n        case \"TranslationsPort:GetEngineStatusResponse\": {\n          if (portRequest) {\n            const { resolve, reject } = portRequest;\n            if (data.status === \"ready\") {\n              resolve();\n            } else {\n              reject(new Error(\"The engine failed to load.\"));\n            }\n          }\n\n          this.#engineStatus = data.status;\n\n          if (data.status === \"ready\") {\n            this.maybeScheduleMoreTranslationRequests();\n          } else {\n            for (const translationId of this.#activeRequests.keys()) {\n              this.preventSingleTranslation(translationId);\n            }\n\n            for (const translationId of this.#unscheduledRequestPriorities.keys()) {\n              this.preventUnscheduledTranslation(translationId);\n            }\n          }\n\n          break;\n        }\n        case \"TranslationsPort:EngineTerminated\": {\n          this.#discardPort();\n          this.maybeScheduleMoreTranslationRequests();\n          break;\n        }\n        default: {\n          lazy.console.error(\"Unknown translations port message:\", data);\n          break;\n        }\n      }\n    };\n\n    // Ask for the engine status\n    port.postMessage({ type: \"TranslationsPort:GetEngineStatusRequest\" });\n  }\n\n  /**\n   * Returns a promise that will resolve when we have acquired a valid port.\n   *\n   * @returns {Promise<void>}\n   */\n  #getPortRequestPromise() {\n    if (this.#portRequest) {\n      // We already have a pending request to acquire a port.\n      return this.#portRequest.promise;\n    }\n\n    if (this.#engineStatus === \"ready\") {\n      // The engine is already ready for translating.\n      return Promise.resolve();\n    }\n\n    if (this.#port) {\n      // We already have a port: we don't need another one.\n      return Promise.resolve();\n    }\n\n    const portRequest = Promise.withResolvers();\n    this.#portRequest = portRequest;\n\n    // Ask the actor for a new port (which eventually calls `acquirePort`).\n    this.#actorRequestNewPort();\n\n    this.#portRequest.promise\n      .catch(error => {\n        lazy.console.error(error);\n      })\n      .finally(() => {\n        // If we haven't replaced #portRequest with another request,\n        // clear it out now that it succeeded.\n        if (portRequest === this.#portRequest) {\n          this.#portRequest = null;\n        }\n      });\n\n    return this.#portRequest.promise;\n  }\n\n  /**\n   * Close the port and remove any chance of further messages to the TranslationsEngine.\n   * Any active requests are moved back to the priority stacks from which they were scheduled.\n   */\n  #discardPort() {\n    this.#preserveActiveRequests();\n\n    if (this.#port) {\n      this.#port.close();\n      this.#port = null;\n      this.#portRequest = null;\n    }\n\n    this.#engineStatus = \"uninitialized\";\n  }\n\n  /**\n   * Called when the page becomes visible again, e.g. the user was on another tab\n   * and switched back to this page as the active tab. Any requests that were left\n   * in the stacks will resume to be scheduled.\n   */\n  async onShowPage() {\n    this.#isPageShown = true;\n    this.maybeScheduleMoreTranslationRequests();\n  }\n\n  /**\n   * Called when the page is hidden, e.g. the user moved to a different tab.\n   * Any active requests that had been sent to the TranslationsEngine will\n   * be Cancelled and moved back to the corresponding priority stacks that\n   * they came from.\n   */\n  async onHidePage() {\n    this.#isPageShown = false;\n\n    if (this.#portRequest) {\n      //this.#portRequest.reject();\n      // If the page is hidden while a port request is pending,\n      // wait for that request to finish so we can move any in-flight\n      // requests to the temp queue properly.\n      try {\n        await this.#portRequest.promise;\n      } catch {\n        // If the port request fails while hidden, not much to do.\n      }\n\n      if (this.#isPageShown) {\n        // The page was re-shown while we were awaiting the pending port request.\n        return;\n      }\n    }\n\n    // Discard the port to avoid engine usage while hidden.\n    this.#discardPort();\n  }\n\n  /**\n   * Creates a new TranslationRequest, adds it to the stack that corresponds to its priority,\n   * and returns a promise for the resolution or rejection of the request.\n   *\n   * @see {TranslationRequest}\n   *\n   * @param {Node} node - The node that corresponds to this translation request.\n   * @param {string} sourceText - The source text to translate for this request.\n   * @param {boolean} isHTML - True if the source text is HTML markup, false if it is plain text.\n   * @param {number} translationId - The translationId that corresponds to this request.\n   * @param {number} priority - The priority at which this request should be scheduled.\n   * @returns {Promise<string | null>}\n   *   The translated text, or null if the text is already translated, the request becomes stale, the translation fails.\n   */\n  createTranslationRequestPromise(\n    node,\n    sourceText,\n    isHTML,\n    translationId,\n    priority\n  ) {\n    const { promise, resolve, reject } = Promise.withResolvers();\n    this.#unscheduledRequestPriorities.set(translationId, priority);\n\n    this.#priorityStacks[priority].push({\n      node,\n      sourceText,\n      isHTML,\n      translationId,\n      priority,\n      resolve,\n      reject,\n    });\n\n    this.maybeScheduleMoreTranslationRequests();\n\n    return promise;\n  }\n\n  /**\n   * Attempts to cancel a translation request if it has not been sent to the TranslationsEngine.\n   *\n   * To fully cancel a request regardless of whether it has been scheduled or not,\n   * use the `cancelSingleTranslation` method.\n   *\n   * @see {TranslationScheduler.preventSingleTranslation}\n   *\n   * @param {number} translationId - The translationId of the request to cancel.\n   * @returns {boolean} - True if the request was Cancelled, otherwise false.\n   */\n  preventUnscheduledTranslation(translationId) {\n    const priority = this.#unscheduledRequestPriorities.get(translationId);\n\n    if (priority === undefined) {\n      // We were unable to retrieve an unscheduled priority for the given translationId.\n      // This request has likely already been sent to the TranslationsEngine.\n      return false;\n    }\n\n    const request = this.#priorityStacks[priority].remove(translationId);\n\n    if (request) {\n      request.resolve(null);\n    }\n\n    this.#unscheduledRequestPriorities.delete(translationId);\n\n    ChromeUtils.addProfilerMarker(\n      `TranslationScheduler Cancel P${priority}`,\n      { innerWindowId: this.#innerWindowId },\n      `Cancelled one unscheduled P${priority} translation.`\n    );\n\n    return true;\n  }\n\n  /**\n   * Cancel a translation request regardless of whether it has been sent to the TranslationsEngine.\n   *\n   * For a more conservative method to only cancel a request that has not yet been scheduled,\n   * use the `maybePreventUnscheduledTranslation` method.\n   *\n   * @see {TranslationScheduler.preventUnscheduledTranslation}\n   *\n   * @param {number} translationId - The translationId of the request to cancel.\n   * @returns {{\n   *  didPrevent: boolean,\n   *  didCancelFromScheduler: boolean,\n   *  didCancelFromEngine: boolean,\n   * }}\n   */\n  preventSingleTranslation(translationId) {\n    if (this.preventUnscheduledTranslation(translationId)) {\n      // We successfully canceled this request before it was scheduled: nothing more to do.\n      return {\n        didPrevent: true,\n        didCancelFromScheduler: true,\n        didCancelFromEngine: false,\n      };\n    }\n\n    const request = this.#activeRequests.get(translationId);\n\n    if (!request) {\n      // This translation completed before we got a chance to cancel it.\n      return {\n        didPrevent: false,\n        didCancelFromScheduler: false,\n        didCancelFromEngine: false,\n      };\n    }\n\n    // If the request is active, then it has been sent to the TranslationsEngine,\n    // so we must attempt to send a cancel request to the engine as well.\n    this.#port?.postMessage({\n      type: \"TranslationsPort:CancelSingleTranslation\",\n      translationId,\n    });\n\n    request.resolve(null);\n    this.#activeRequests.delete(translationId);\n\n    ChromeUtils.addProfilerMarker(\n      `TranslationScheduler Cancel P${request.priority}`,\n      { innerWindowId: this.#innerWindowId },\n      `Cancelled one active P${request.priority} translation.`\n    );\n\n    // We may have cancelled the only active request, which may not receive a response now.\n    // If so, we need to ensure that we continue to schedule more requests.\n    this.maybeScheduleMoreTranslationRequests();\n\n    return {\n      didPrevent: true,\n      didCancelFromScheduler: true,\n      didCancelFromEngine: true,\n    };\n  }\n\n  /**\n   * Returns any active translation request back to the priority stack from which they came.\n   * Whenever the scheduler resumes scheduling, these requests may be already fulfilled,\n   * resulting in a no-op, or they will be picked back up where they were left off.\n   */\n  #preserveActiveRequests() {\n    lazy.console.log(\n      `Pausing translations with ${this.#activeRequests.size} active translation requests.`\n    );\n\n    if (!this.#hasActiveTranslationRequests()) {\n      // There are no active requests to unschedule: nothing more to do.\n      return;\n    }\n\n    for (const request of this.#activeRequests.values()) {\n      const { translationId, priority } = request;\n\n      this.#priorityStacks[priority].push(request);\n      this.#unscheduledRequestPriorities.set(translationId, priority);\n    }\n\n    this.#activeRequests.clear();\n  }\n\n  /**\n   * Returns true if the scheduler has few enough quests that it is within the\n   * final batches that it will schedule until more requests come in.\n   *\n   * @returns {boolean}\n   */\n  isWithinFinalBatches() {\n    return (\n      this.#maxRequestsPerScheduleEvent >=\n      this.#pendingTranslationRequestCount()\n    );\n  }\n\n  /**\n   * Returns the count of pending translation requests, both active and unscheduled.\n   *\n   * @returns {number}\n   */\n  #pendingTranslationRequestCount() {\n    return this.#activeRequests.size + this.#unscheduledRequestPriorities.size;\n  }\n\n  /**\n   * Returns true if the scheduler has any requests have been sent to the TranslationsEngine,\n   * and have not yet received a response, otherwise false.\n   *\n   * @returns {boolean}\n   */\n  #hasActiveTranslationRequests() {\n    return this.#activeRequests.size > 0;\n  }\n\n  /**\n   * Returns true if the scheduler has any requests that have not yet been sent to the TranslationsEngine,\n   * and are waiting in a corresponding priority stack to be scheduled, otherwise false.\n   *\n   * @returns {boolean}\n   */\n  #hasUnscheduledTranslationRequests() {\n    return this.#unscheduledRequestPriorities.size > 0;\n  }\n\n  /**\n   * Returns true if the conditions are met to schedule more requests by sending them to the TranslationsEngine,\n   * otherwise false if the scheduler should wait longer before sending more requests over the port.\n   *\n   * @returns {boolean}\n   */\n  #shouldScheduleMoreTranslationRequests() {\n    if (!this.#isPageShown) {\n      // We should not spend CPU time if the page is hidden.\n      return false;\n    }\n\n    if (this.#portRequest) {\n      // We are still waiting for a port: we will try again if a port is acquired.\n      return false;\n    }\n\n    if (this.#port && this.#engineStatus === \"uninitialized\") {\n      // We have acquired a port, but we are still waiting for an engine status message.\n      // We will try again if the engine becomes ready.\n      return false;\n    }\n\n    if (this.#hasPendingScheduleRequestsCallback) {\n      // There is already a pending callback to schedule more requests.\n      return false;\n    }\n\n    if (\n      this.#activeRequests.size > TranslationScheduler.ACTIVE_REQUEST_THRESHOLD\n    ) {\n      // There are too many active requests to schedule any more right now.\n      return false;\n    }\n\n    if (!this.#hasUnscheduledTranslationRequests()) {\n      // There are no unscheduled requests to be sent to the TranslationsEngine.\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Schedules another batch of requests by sending them to the TranslationsEngine,\n   * only if it makes sense to do so.\n   */\n  maybeScheduleMoreTranslationRequests() {\n    if (!this.#shouldScheduleMoreTranslationRequests()) {\n      // The conditions are not currently right to schedule more requests.\n      return;\n    }\n\n    this.#hasPendingScheduleRequestsCallback = true;\n\n    lazy.setTimeout(() => {\n      this.#getPortRequestPromise()\n        .then(this.#scheduleMoreTranslationRequests)\n        .catch(error => {\n          lazy.console.error(error);\n          this.#hasPendingScheduleRequestsCallback = false;\n        });\n    }, 0);\n  }\n\n  /**\n   * Schedules a batch of requests from the given stack by sending them to the TranslationsEngine.\n   *\n   * @param {AntiStarvationStack} stack - The stack from which to schedule the batch of requests.\n   * @returns {boolean} - Returns true if starvation was detected in this stack, otherwise false.\n   */\n  #scheduleBatchFromStack(stack) {\n    const { starvationDetected, requests } = stack.popBatch();\n\n    for (const request of requests) {\n      this.#maybeScheduleTranslationRequest(request);\n    }\n\n    return starvationDetected;\n  }\n\n  /**\n   * Schedules another batch of requests from the priority stacks by sending them to the TranslationsEngine.\n   * How many requests are scheduled, and from which stacks, will depend on the current state of the stacks.\n   *\n   * This function is intentionally written as a lambda so that it can be passed as a\n   * callback without the need to explicitly bind `this` to the function object.\n   */\n  #scheduleMoreTranslationRequests = () => {\n    if (!this.#port) {\n      // We lost our port between when this function was registered on the event loop, and when it was invoked.\n      // The best we can do is possibly try again, if the conditions are still right.\n      this.#hasPendingScheduleRequestsCallback = false;\n      this.maybeScheduleMoreTranslationRequests();\n      return;\n    }\n\n    let stackSizesAtStart = null;\n    const activeRequestsAtStart = this.#activeRequests.size;\n    const unscheduledRequestsAtStart = this.#unscheduledRequestPriorities.size;\n    if (Services.profiler?.IsActive() || lazy.console.shouldLog(\"Debug\")) {\n      // We need to preserve the sizes prior to scheduling only if we are adding profiler markers,\n      // or if we are logging to console debug. Otherwise we shouldn't bother with these computations.\n      stackSizesAtStart = this.#priorityStacks.map(stack => stack.size);\n    }\n\n    // Schedule only as many requests as we are required to in order to achieve starvation fairness,\n    // starting with the highest-priority stack and moving toward the lower-priority stacks.\n    for (const stack of this.#priorityStacks) {\n      const starvationDetected = this.#scheduleBatchFromStack(stack);\n\n      if (stack.size === 0) {\n        // This stack is now empty, so we are clear to schedule more lower-priority requests.\n        continue;\n      }\n\n      if (starvationDetected) {\n        // This stack is starving (i.e. more requests are being added than are being scheduled),\n        // so we must process a batch of lower-priority requests on this cycle in order to keep\n        // the priority-scheduling algorithm fair, otherwise we could, in theory, only ever process\n        // the current-level stack if new requests of the same priority continue to come in at a high rate.\n        continue;\n      }\n\n      // We just scheduled a batch of requests from the highest-relevant-priority stack, and the count of requests\n      // in that stack is decreasing. We should break here so as not to schedule any lower-priority requests before\n      // we absolutely need to. The lower-priority requests may be justifiably cancelled before we get to them,\n      // such as being re-prioritized or removed if the user scrolls around the page. In the event that they are\n      // not cancelled, then they are guaranteed to be scheduled eventually, either due to starvation fairness,\n      // or simply when it is their turn after processing all of the higher-priority requests first.\n      break;\n    }\n\n    this.#maybeAddProfilerMarkersForStacks(stackSizesAtStart);\n    this.#maybeLogStackDataToConsoleDebug(\n      stackSizesAtStart,\n      activeRequestsAtStart,\n      unscheduledRequestsAtStart\n    );\n\n    this.#hasPendingScheduleRequestsCallback = false;\n  };\n\n  /**\n   * If actively profiling, adds a marker for how many requests wre scheduled from each stack, if any.\n   *\n   * Normally, we would rely on `ChromeUtils.addProfilerMarker()` itself to no-op if not profiling,\n   * however there are calculations and conditions for whether or not to post a marker, and scheduling\n   * happens quite frequently, so it is best to not waste time with these calculations if not profiling.\n   *\n   * @param {Array<number>?} stackSizesAtStart – The size of each stack prior to the slice of scheduling that just occurred.\n   */\n  #maybeAddProfilerMarkersForStacks(stackSizesAtStart) {\n    if (!stackSizesAtStart || !Services.profiler.IsActive()) {\n      return;\n    }\n\n    for (let priority = 0; priority < stackSizesAtStart.length; ++priority) {\n      const scheduledCount =\n        stackSizesAtStart[priority] - this.#priorityStacks[priority].size;\n\n      if (scheduledCount > 0) {\n        ChromeUtils.addProfilerMarker(\n          `TranslationScheduler Send P${priority}`,\n          { innerWindowId: this.#innerWindowId },\n          `Posted ${scheduledCount} P${priority} translation requests.`\n        );\n      }\n    }\n  }\n\n  /**\n   * If \"Debug\" is available, logs how many requests were scheduled from each stack on this scheduling pass, starting\n   * with the highest-priority stack and logging through to the lowest-priority stack that scheduled any request.\n   *\n   * Normally, we would rely on `lazy.console.debug()` itself to no-op if \"Debug\" does not lie within the max log level,\n   * however there are calculations and conditions related to formatting this log nicely in the console, and scheduling\n   * happens quite frequently, so it is best to not waste time with these calculations if we will not log them at all.\n   *\n   * Example:\n   *\n   * \"Scheduler(_1 | 422) [ __1, 165, 132, __1, 106, __1, __8, __8 ] => P0(__1), P1(__2)\"\n   *             ╻    ╻      ╻    ╻    ╻    ╻    ╻    ╻    ╻    ╻       ╻        ╻\n   *             │    │      │    │    │    │    │    │    │    │       │        │\n   *             │    │      │    │    │    │    │    │    │    │       │        2 P1 requests were scheduled in this batch.\n   *             │    │      │    │    │    │    │    │    │    │       │\n   *             │    │      │    │    │    │    │    │    │    │       1 P0 request was scheduled in this batch.\n   *             │    │      │    │    │    │    │    │    │    │\n   *             │    │      │    │    │    │    │    │    │    There are 8 P7 requests\n   *             │    │      │    │    │    │    │    │    │\n   *             │    │      │    │    │    │    │    │    There are 8 P6 requests.\n   *             │    │      │    │    │    │    │    │\n   *             │    │      │    │    │    │    │    There is 1 P5 request.\n   *             │    │      │    │    │    │    │\n   *             │    │      │    │    │    │    There are 106 P4 requests.\n   *             │    │      │    │    │    │\n   *             │    │      │    │    │    There is 1 P3 request.\n   *             │    │      │    │    │\n   *             │    │      │    │    There are 132 P2 requests.\n   *             │    │      │    │\n   *             │    │      │    There are 165 P1 requests.\n   *             │    │      │\n   *             │    │      There is 1 P0 request.\n   *             │    │\n   *             │    There are 422 pending requests.\n   *             │\n   *             There is 1 active request.\n   *\n   * @param {Array<number>?} stackSizesAtStart – The size of each stack prior to the slice of scheduling that just occurred.\n   * @param {number} activeRequestsAtStart - The number of active requests that the TranslationsEngine was processing at the\n   *                                         moment we scheduled more requests from the stacks.\n   * @param {number} unscheduledRequestsAtStart - The number of unscheduled requests that the TranslationsEngine was processing\n   *                                         at the moment we scheduled more requests from the stacks.\n   */\n  #maybeLogStackDataToConsoleDebug(\n    stackSizesAtStart,\n    activeRequestsAtStart,\n    unscheduledRequestsAtStart\n  ) {\n    if (!stackSizesAtStart || !lazy.console.shouldLog(\"Debug\")) {\n      return;\n    }\n\n    // Find the deepest priority stack that scheduled any requests.\n    let maxStackDepth;\n    for (let depth = stackSizesAtStart.length - 1; depth >= 0; --depth) {\n      if (this.#priorityStacks[depth].size < stackSizesAtStart[depth]) {\n        maxStackDepth = depth;\n        break;\n      }\n    }\n\n    if (maxStackDepth === undefined) {\n      // No requests were scheduled on this pass.\n      return;\n    }\n\n    const padLength = Math.max(\n      3,\n      ...stackSizesAtStart.map(n => String(n).length)\n    );\n\n    const segments = [];\n    for (let priority = 0; priority <= maxStackDepth; ++priority) {\n      const sizeAtStart = stackSizesAtStart[priority];\n      const currentSize = this.#priorityStacks[priority].size;\n      const scheduledCount = sizeAtStart - currentSize;\n\n      const formatted =\n        scheduledCount === 0\n          ? \"_\".repeat(padLength)\n          : String(scheduledCount).padStart(padLength, \"_\");\n\n      segments.push(`P${priority}(${formatted})`);\n    }\n\n    const activeRequestsPadLength = String(\n      this.#maxRequestsPerScheduleEvent\n    ).length;\n    const activeRequestsString =\n      activeRequestsAtStart === 0\n        ? \"_\".repeat(activeRequestsPadLength)\n        : String(activeRequestsAtStart).padStart(activeRequestsPadLength, \"_\");\n\n    const unscheduledRequestsString = String(\n      unscheduledRequestsAtStart\n    ).padStart(3, \"_\");\n\n    lazy.console.debug(\n      `Scheduler(${activeRequestsString} | ${unscheduledRequestsString}) ` +\n        TranslationScheduler.#formatSizesAtStart(stackSizesAtStart) +\n        ` => ${segments.join(\", \")}`\n    );\n  }\n\n  /**\n   * Formats the sizes of each priority stack into a string that is nice to look\n   * at in the JS console.\n   *\n   * Example:\n   *\n   * \"[ __1, 165, 132, __1, 106, __1, __8, __8 ]\"\n   * //  P0   P1   P2   P3   P4   P5   P6   P7\n   *\n   * @param {Array<number>} stackSizesAtStart\n   */\n  static #formatSizesAtStart(stackSizesAtStart) {\n    const padLength = Math.max(\n      3,\n      ...stackSizesAtStart.map(n => String(Math.abs(n)).length)\n    );\n\n    const segments = stackSizesAtStart.map(n =>\n      n === 0 ? \"_\".repeat(padLength) : String(n).padStart(padLength, \"_\")\n    );\n\n    return `[ ${segments.join(\", \")} ]`;\n  }\n\n  /**\n   * Schedules the translation request by sending it to the TranslationsEngine only\n   * if the node that is relevant to the request is not detached.\n   *\n   * @param {TranslationRequest} request\n   */\n  #maybeScheduleTranslationRequest(request) {\n    const { node } = request;\n\n    if (isNodeDetached(node)) {\n      // If the node is dead, there is no need to schedule it.\n      const { translationId, resolve } = request;\n\n      this.#unscheduledRequestPriorities.delete(translationId);\n      resolve(null);\n\n      return;\n    }\n\n    this.#scheduleTranslationRequest(request);\n  }\n\n  /**\n   * Schedules a translation request by sending it to the TranslationsEngine,\n   * marking the request as active.\n   *\n   * @param {TranslationRequest} request\n   */\n  #scheduleTranslationRequest(request) {\n    if (!this.#port) {\n      // This should never happen, since we should only be scheduling requests under\n      // circumstances in which we are certain that we have a valid port.\n      lazy.console.error(\n        \"Attempt to schedule a translation request without a port.\"\n      );\n\n      // If this should ever happen, the best thing we can do to recover is to put\n      // the request back onto its corresponding priority stack to be scheduled again.\n      const { priority } = request;\n      this.#priorityStacks[priority].push(request);\n\n      return;\n    }\n\n    const { translationId, sourceText, isHTML } = request;\n\n    this.#activeRequests.set(translationId, request);\n    this.#unscheduledRequestPriorities.delete(translationId);\n    if (this.#translationsCache.isAlreadyTranslated(sourceText, isHTML)) {\n      // Our cache indicates that the text that is being sent to translate is an exact\n      // match to the translated output text of a previous request. When this happens\n      // we should simply signal to the engine that this is a no-op, rather than\n      // attempting to re-translate text that is already in the target language.\n      //\n      // This can happen in cases where a website removes already-translated content,\n      // and then puts it back in the same spot, triggering our mutation observers.\n      //\n      // Wikipedia does this, for example, with the \"title\" attributes on hyperlinks\n      // nearly every time they are moused over.\n      this.#port.postMessage({\n        type: \"TranslationsPort:Passthrough\",\n        translationId,\n      });\n      return;\n    }\n\n    const cachedTranslation = this.#translationsCache.get(sourceText, isHTML);\n    if (cachedTranslation) {\n      // We already have a matching translated output for this source text, but\n      // it was not hot in the cache when this request was sent to the translator,\n      // otherwise the TranslationsDocument would have handled it directly.\n      //\n      // This may happen when several nodes with identical text get queued for translation\n      // all at the same time, while the cache was still cold, such as translating a nested\n      // comment section with multiple collapsed expandable threads that say \"2 replies\".\n      //\n      // We will signal to the engine to simply pass the cached translation along as\n      // the response instead of wasting CPU time trying to recompute the translation.\n      this.#port.postMessage({\n        type: \"TranslationsPort:CachedTranslation\",\n        translationId,\n        cachedTranslation,\n      });\n      return;\n    }\n\n    this.#port.postMessage({\n      type: \"TranslationsPort:TranslationRequest\",\n      translationId,\n      sourceText,\n      isHTML,\n    });\n  }\n\n  /**\n   * Cleans up everything, closing the port and removing all translation request data.\n   */\n  destroy() {\n    this.#port?.close();\n    this.#port = null;\n    this.#portRequest?.reject();\n    this.#portRequest = null;\n    this.#engineStatus = \"uninitialized\";\n\n    this.#activeRequests.clear();\n    this.#unscheduledRequestPriorities.clear();\n\n    for (const stack of this.#priorityStacks) {\n      stack.clear();\n    }\n  }\n}\n\n/**\n * Returns true if an HTML element is hidden based on factors such as collapsed state and\n * computed style, otherwise false.\n *\n * @param {HTMLElement} element\n * @returns {boolean}\n */\nfunction isHTMLElementHidden(element) {\n  // This is a cheap and easy check that will not compute style or force reflow.\n  if (element.hidden) {\n    // The element is explicitly hidden.\n    return true;\n  }\n\n  // Handle open/closed <details> elements. This will also not compute style or force reflow.\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/details\n  if (\n    // The element is within a closed <details>\n    element.closest(\"details:not([open])\") &&\n    // The element is not part of the <summary> of the <details>, which is always visible, even when closed.\n    !element.closest(\"summary\")\n  ) {\n    // The element is within a closed <details> and is not part of the <summary>, therefore it is not visible.\n    return true;\n  }\n\n  // This forces reflow, which has a performance cost, but this is also what JQuery uses for its :hidden and :visible.\n  // https://github.com/jquery/jquery/blob/bd6b453b7effa78b292812dbe218491624994526/src/css/hiddenVisibleSelectors.js#L1-L10\n  if (\n    !(\n      element.offsetWidth ||\n      element.offsetHeight ||\n      element.getClientRects().length\n    )\n  ) {\n    return true;\n  }\n\n  const { ownerGlobal } = element;\n  if (!ownerGlobal) {\n    // We cannot compute the style without ownerGlobal, so we will assume it is not visible.\n    return true;\n  }\n\n  // This flushes the style, which is a performance cost.\n  const style = ownerGlobal.getComputedStyle(element);\n  if (!style) {\n    // We were unable to compute the style, so we will assume it is not visible.\n    return true;\n  }\n\n  // This is an issue with the DOM library generation.\n  // @ts-expect-error Property 'display' does not exist on type 'CSSStyleDeclaration'.ts(2339)\n  const { display, visibility, opacity } = style;\n\n  return (\n    display === \"none\" ||\n    visibility === \"hidden\" ||\n    visibility === \"collapse\" ||\n    opacity === \"0\"\n  );\n}\n\n/**\n * This function returns the correct element to determine the\n * style of node.\n *\n * @param {Node} node\n *\n * @returns {HTMLElement | null}\n */\nfunction getHTMLElementForStyle(node) {\n  const element = asHTMLElement(node);\n  if (element) {\n    return element;\n  }\n\n  if (node.parentElement) {\n    return asHTMLElement(node.parentElement);\n  }\n\n  // For cases like text node where its parent is ShadowRoot,\n  // we'd like to use flattenedTreeParentNode\n  if (node.flattenedTreeParentNode) {\n    return asHTMLElement(node.flattenedTreeParentNode);\n  }\n\n  // If the text node is not connected or doesn't have a frame.\n  return null;\n}\n\n/**\n * Gets the spatial context of the node with respect to the viewport.\n *\n * If the node lies entirely to the left or entirely to the right of the viewport,\n * this takes precedence over whether the node is entirely above or below the viewport.\n *\n * For example, if a node is both entirely above, and entirely to the right of the\n * viewport, then the returned context will be \"right\".\n *\n * If any part of a node's bounding box lies within the viewport then the context\n * is considered \"within\".\n *\n * @param {Node} node\n *\n * @returns {NodeSpatialContext}\n */\nfunction getNodeSpatialContext(node) {\n  const window = node.ownerGlobal;\n  const document = node.ownerDocument;\n  if (!window || !document || !document.documentElement) {\n    // We won't be able to calculate the spatial context for this node.\n    return {};\n  }\n\n  const element = getHTMLElementForStyle(node);\n  if (!element) {\n    // We only calculate the spatial context for HTML elements.\n    return {};\n  }\n\n  if (isHTMLElementHidden(element)) {\n    // If the element is hidden, then the spatial context is not important.\n    return {};\n  }\n\n  const { top, right, bottom, left } = element.getBoundingClientRect();\n\n  const viewportHeight =\n    window.innerHeight || document.documentElement.clientHeight;\n  const viewportWidth =\n    window.innerWidth || document.documentElement.clientWidth;\n\n  /** @type {NodeSpatialContext} */\n  let spatialContext = { top, left, right, viewportContext: undefined };\n\n  if (right < 0) {\n    // The node is entirely to the left of the viewport.\n    spatialContext.viewportContext = \"left\";\n    return spatialContext;\n  }\n\n  if (left > viewportWidth) {\n    // The node is entirely to the right of the viewport.\n    spatialContext.viewportContext = \"right\";\n    return spatialContext;\n  }\n\n  if (bottom < 0) {\n    // The node is entirely above the viewport.\n    spatialContext.viewportContext = \"above\";\n    return spatialContext;\n  }\n\n  if (top > viewportHeight) {\n    // The node is entirely below the viewport.\n    spatialContext.viewportContext = \"below\";\n    return spatialContext;\n  }\n\n  // The node must be within the viewport.\n  spatialContext.viewportContext = \"within\";\n  return spatialContext;\n}\n\n/**\n * Actually perform the update of the element with the translated node. This step\n * will detach all of the \"live\" nodes, and match them up in the correct order as provided\n * by the translations engine.\n *\n * @param {Document} translationsDocument\n * @param {Element} element\n *\n * @returns {void}\n */\nfunction updateElement(translationsDocument, element) {\n  // This text should have the same layout as the target, but it's not completely\n  // guaranteed since the content page could change at any time, and the translation process is async.\n  //\n  // The document has the following structure:\n  //\n  // <html>\n  //   <head>\n  //   <body>{translated content}</body>\n  // </html>\n\n  const originalHTML = element.innerHTML;\n\n  /**\n   * The Set of translation IDs for nodes that have been cloned.\n   *\n   * @type {Set<string>}\n   */\n  const clonedNodes = new Set();\n\n  // Guard against unintended changes to the \"value\" of <option> elements during\n  // translation. This issue occurs because if an <option> element lacks an explicitly\n  // set \"value\" attribute, then the default \"value\" will be taken from the text content\n  // when requested.\n  //\n  // For example, <option>dog</option> might be translated to <option>perro</option>.\n  // Without an explicit \"value\", the implicit \"value\" would change from \"dog\" to \"perro\",\n  // and this can cause problems for submissions to queries etc.\n  //\n  // To prevent this, we ensure every translated <option> has an explicit \"value\"\n  // attribute, either preserving the original \"value\" or assigning it from the original\n  // text content. This results in <option>dog</option> being translated to\n  // <option value=\"dog\">perro</option>\n  //\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option#value\n  if (element.tagName === \"OPTION\") {\n    element.setAttribute(\n      \"value\",\n      /** @type {HTMLOptionElement} */ (element).value\n    );\n  }\n  for (const option of element.querySelectorAll(\"option\")) {\n    option.setAttribute(\"value\", option.value);\n  }\n\n  /**\n   * Build up a mapping of any element that has a \"value\" field that may change based\n   * on translations. In the recursive \"merge\" function below, we can remove <option>\n   * elements from <select> elements, which could cause the value attribute to change\n   * as the option is removed. This will need to be restored.\n   *\n   * @type {Map<Node, string>}\n   */\n  const nodeValues = new Map();\n  for (const select of element.querySelectorAll(\"select\")) {\n    nodeValues.set(select, select.value);\n  }\n\n  const firstChild = translationsDocument.body?.firstChild;\n  if (firstChild) {\n    merge(element, firstChild);\n  }\n\n  // Restore the <select> values.\n  if (element.tagName === \"SELECT\") {\n    /** @type {HTMLSelectElement} */ (element).value =\n      nodeValues.get(element) ?? \"\";\n  }\n  for (const select of element.querySelectorAll(\"select\")) {\n    select.value = nodeValues.get(select);\n  }\n\n  /**\n   * Merge the live tree with the translated tree by re-using elements from the live tree.\n   *\n   * @param {Element} liveTree\n   * @param {Node} translatedTree\n   */\n  function merge(liveTree, translatedTree) {\n    /** @type {Map<string, Element>} */\n    const liveElementsById = new Map();\n\n    /** @type {Array<Text>} */\n    const liveTextNodes = [];\n\n    // Remove all the nodes from the liveTree, and categorize them by Text node or\n    // Element node.\n    /** @type {Node | null} */\n    let node;\n    while ((node = liveTree.firstChild)) {\n      // This is a ChildNode with the `remove` method.\n      const childNode = /** @type {ChildNode} */ (\n        /** @type {unknown} */ (node)\n      );\n      childNode.remove();\n\n      const childElement = asElement(node);\n      const childTextNode = asTextNode(node);\n      const dataset = getDataset(childElement);\n      if (childElement && dataset) {\n        liveElementsById.set(dataset.mozTranslationsId, childElement);\n      } else if (childTextNode) {\n        liveTextNodes.push(childTextNode);\n      }\n    }\n\n    // The translated tree dictates the order.\n\n    /** @type {Node[]} */\n    const translatedNodes = [];\n    for (const childNode of translatedTree.childNodes) {\n      if (childNode) {\n        translatedNodes.push(childNode);\n      }\n    }\n\n    for (\n      let translatedIndex = 0;\n      translatedIndex < translatedNodes.length;\n      translatedIndex++\n    ) {\n      const translatedNode = ensureExists(translatedNodes[translatedIndex]);\n      const translatedTextNode = asTextNode(translatedNode);\n      const translatedElement = asElement(translatedNode);\n      const dataset = getDataset(translatedElement);\n\n      if (translatedTextNode) {\n        // Copy the translated text to the original Text node and re-append it.\n        let liveTextNode = liveTextNodes.shift();\n\n        if (liveTextNode) {\n          liveTextNode.data = translatedTextNode.data;\n        } else {\n          liveTextNode = translatedTextNode;\n        }\n\n        liveTree.appendChild(liveTextNode);\n      } else if (dataset) {\n        const liveElementId = dataset.mozTranslationsId;\n        // Element nodes try to use the already existing DOM nodes.\n\n        // Find the element in the live tree that matches the one in the translated tree.\n        let liveElement = liveElementsById.get(liveElementId);\n\n        if (!liveElement) {\n          lazy.console.warn(\"Could not find a corresponding live element\", {\n            path: createNodePath(translatedNode, translationsDocument.body),\n            liveElementId,\n            liveElementsById,\n            translatedNode,\n          });\n          continue;\n        }\n\n        // Has this element already been added to the list? Then duplicate it and re-add\n        // it as a clone. The Translations Engine can sometimes duplicate HTML.\n        if (liveElement.parentNode) {\n          liveElement = ensureExists(\n            asElement(liveElement.cloneNode(true /* deep clone */))\n          );\n          clonedNodes.add(liveElementId);\n          lazy.console.warn(\n            \"Cloning a node because it was already inserted earlier\",\n            {\n              path: createNodePath(translatedNode, translationsDocument.body),\n              translatedNode,\n              liveElement,\n            }\n          );\n        }\n\n        if (isNodeTextEmpty(translatedNode) && !isNodeTextEmpty(liveElement)) {\n          // The translated node has no text, but the original node does have text, so we should investigate.\n          //\n          // Note that it is perfectly fine if both the translated node and original node do not have text.\n          // This occurs when attributes are translated on the node, but no text content was translated.\n          //\n          // However, since we have a case where the original node has text and the translated node does not,\n          // this scenario may be caused by one of two situations:\n          //\n          //   1) The element was duplicated by translation but then not given text\n          //      content. This happens on Wikipedia articles for example.\n          //\n          //   2) The translator messed up and could not translate the text. This\n          //      happens on YouTube in the language selector. In that case, having the\n          //      original text is much better than no text at all.\n          //\n          // To make sure it is case 1) and not case 2), check whether this is the only occurrence.\n          for (let i = 0; i < translatedNodes.length; i++) {\n            if (translatedIndex === i) {\n              // This is the current node, not a sibling.\n              continue;\n            }\n            const sibling = translatedNodes[i];\n            const siblingDataset = getDataset(asElement(sibling));\n            if (\n              // Only consider other element nodes.\n              sibling.nodeType === Node.ELEMENT_NODE &&\n              // If the sibling's mozTranslationsId matches, then use the sibling's\n              // node instead.\n              liveElementId === siblingDataset?.mozTranslationsId\n            ) {\n              // This is case 1 from above. Remove this element's original text nodes,\n              // since a sibling text node now has all of the text nodes.\n              removeTextNodes(liveElement);\n            }\n          }\n\n          // Report this issue to the console.\n          lazy.console.warn(\n            \"The translated element has no text even though the original did.\",\n            {\n              path: createNodePath(translatedNode, translationsDocument.body),\n              translatedNode,\n              liveElement,\n            }\n          );\n        } else if (!isNodeTextEmpty(liveElement)) {\n          // There are still text nodes to find and update, recursively merge.\n          merge(liveElement, translatedNode);\n        }\n\n        // Put the live node back in the live branch. But now t has been synced with the\n        // translated text and order.\n        liveTree.appendChild(liveElement);\n      }\n    }\n\n    const unhandledElements = [...liveElementsById].filter(\n      ([, liveElement]) => !liveElement.parentNode\n    );\n\n    for (node of liveTree.querySelectorAll(\"*\")) {\n      const dataset = getDataset(asElement(node));\n      if (dataset) {\n        // Clean-up the live element ids.\n        delete dataset.mozTranslationsId;\n      }\n    }\n\n    if (unhandledElements.length) {\n      lazy.console.warn(\n        `${createNodePath(\n          translatedTree,\n          translationsDocument.body\n        )} Not all nodes unified`,\n        {\n          unhandledElements,\n          clonedNodes,\n          originalHTML,\n          translatedContent: translationsDocument.body?.innerHTML,\n          liveTree: liveTree.outerHTML,\n          translatedTree: asElement(translatedTree)?.outerHTML,\n        }\n      );\n    }\n  }\n}\n\n/**\n * For debug purposes, compute a string path to an element.\n *\n * e.g. \"div/div#header/p.bold.string/a\"\n *\n * @param {Node} node\n * @param {HTMLElement | null} [root]\n *\n * @returns {string}\n */\nfunction createNodePath(node, root) {\n  let path = \"\";\n  if (!node.ownerDocument) {\n    return path;\n  }\n  if (root === null) {\n    root = node.ownerDocument.body;\n  }\n  if (node.parentNode && node.parentNode !== root) {\n    path = createNodePath(node.parentNode, root);\n  }\n  path += `/${node.nodeName}`;\n\n  const element = asElement(node);\n  if (element) {\n    if (element.id) {\n      path += `#${element.id}`;\n    } else if (element.className) {\n      for (const className of element.classList) {\n        path += \".\" + className;\n      }\n    }\n  }\n  return path;\n}\n\n/**\n * Returns true if the content of this node's text is empty, otherwise false.\n *\n * @param {Node} node\n *\n * @returns {boolean}\n */\nfunction isNodeTextEmpty(node) {\n  const htmlElement = asHTMLElement(node);\n  if (htmlElement) {\n    return htmlElement.innerText.trim().length === 0;\n  }\n  if (node.nodeType === Node.TEXT_NODE && node.nodeValue) {\n    return node.nodeValue.trim().length === 0;\n  }\n  return true;\n}\n\n/**\n * Recursively removes text nodes from the given element and all of its children.\n *\n * @param {Node} node\n */\nfunction removeTextNodes(node) {\n  for (const child of node.childNodes) {\n    switch (child?.nodeType) {\n      case Node.TEXT_NODE: {\n        node.removeChild(child);\n        break;\n      }\n      case Node.ELEMENT_NODE: {\n        removeTextNodes(child);\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Test whether any of the direct child text nodes of are non-whitespace text nodes.\n *\n * For example:\n *   - `<p>test</p>`: yes\n *   - `<p> </p>`: no\n *   - `<p><b>test</b></p>`: no\n *\n * @param {Node} node\n *\n * @returns {boolean}\n */\nfunction hasNonWhitespaceTextNodes(node) {\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    // Only check element nodes.\n    return false;\n  }\n\n  for (const child of node.childNodes) {\n    const textNode = asTextNode(child);\n    if (textNode) {\n      if (!textNode.textContent?.trim()) {\n        // This is just whitespace.\n        continue;\n      }\n      // A text node with content was found.\n      return true;\n    }\n  }\n\n  // No text nodes were found.\n  return false;\n}\n\n/**\n * Like `#isExcludedNode` but looks at the full subtree. Used to see whether\n * we can submit a subtree, or whether we should split it into smaller\n * branches first to try to exclude more of the non-translatable content.\n *\n * @param {Node} node\n * @param {string} excludedNodeSelector\n *\n * @returns {boolean}\n */\nfunction containsExcludedNode(node, excludedNodeSelector) {\n  return Boolean(asElement(node)?.querySelector(excludedNodeSelector));\n}\n\n/**\n *\n * Check if this node or its parent's node is already included in the given Map or Set.\n *\n * @param {Node} node\n * @param { Map<Node, Set<Node>> } map\n *\n * @returns {boolean}\n */\nfunction nodeOrParentIncludesItself(node, map) {\n  if (map.size === 0) {\n    return false;\n  }\n\n  if (map.get(node)?.has(node)) {\n    return true;\n  }\n\n  // If the immediate parent is the body, it is allowed.\n  if (node.parentNode === node.ownerDocument?.body) {\n    return false;\n  }\n\n  // Accessing the parentNode is expensive here according to performance profiling. This\n  // is due to XrayWrappers. Minimize reading attributes by storing a reference to the\n  // `parentNode` in a named variable, rather than re-accessing it.\n\n  /** @type {Node | null} */\n  let parentNode;\n  let lastNode = node;\n  while ((parentNode = lastNode.parentNode)) {\n    if (map.get(parentNode)?.has(parentNode)) {\n      return true;\n    }\n    lastNode = parentNode;\n  }\n\n  return false;\n}\n\n/**\n * Reads the elements computed style and determines if the element is a block-like\n * element or not. Every element that lays out like a block should be sent in as one\n * cohesive unit to be translated.\n *\n * @param {Node} node\n *\n * @returns {boolean}\n */\nfunction getIsBlockLike(node) {\n  const element = asElement(node);\n  if (!element) {\n    return false;\n  }\n\n  const { ownerGlobal } = element;\n  if (!ownerGlobal) {\n    return false;\n  }\n\n  if (element.namespaceURI === \"http://www.w3.org/2000/svg\") {\n    // SVG elements will report as inline, but there is no block layout in SVG.\n    // Treat every SVG element as being block so that every node will be subdivided.\n    return true;\n  }\n\n  /** @type {Record<string, string>} */\n  // @ts-expect-error - This is a workaround for the CSSStyleDeclaration not being indexable.\n  const style = ownerGlobal.getComputedStyle(element) ?? { display: null };\n\n  return style.display !== \"inline\" && style.display !== \"none\";\n}\n\n/**\n * Determine if this element is an inline element or a block element. Inline elements\n * should be sent as a contiguous chunk of text, while block elements should be further\n * subdivided before sending them in for translation.\n *\n * @param {Node} node\n *\n * @returns {boolean}\n */\nfunction nodeNeedsSubdividing(node) {\n  const element = asElement(node);\n  if (!element) {\n    // Only elements need to be further subdivided.\n    return false;\n  }\n\n  for (let childNode of element.childNodes) {\n    if (!childNode) {\n      continue;\n    }\n    switch (childNode.nodeType) {\n      case Node.TEXT_NODE: {\n        // Keep checking for more inline or text nodes.\n        continue;\n      }\n      case Node.ELEMENT_NODE: {\n        if (getIsBlockLike(childNode)) {\n          // This node is a block node, so it needs further subdividing.\n          return true;\n        } else if (nodeNeedsSubdividing(childNode)) {\n          // This non-block-like node may contain other block-like nodes.\n          return true;\n        }\n\n        // Keep checking for more inline or text nodes.\n        continue;\n      }\n      default: {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Returns an iterator of a node's ancestors.\n *\n * @param {Node} node\n *\n * @returns {Generator<Node>}\n */\nfunction* getAncestorsIterator(node) {\n  const document = node.ownerDocument;\n  if (!document) {\n    return;\n  }\n  for (\n    let parent = node.parentNode;\n    parent && parent !== document.documentElement;\n    parent = parent.parentNode\n  ) {\n    yield parent;\n  }\n}\n\n/**\n * Determines whether an attribute on a given element is translatable based on the specified\n * criteria for TRANSLATABLE_ATTRIBUTES.\n *\n * @see TRANSLATABLE_ATTRIBUTES\n *\n * @param {Node} node - The DOM node on which the attribute is being checked.\n * @param {string} attribute - The attribute name to check for translatability.\n *\n * @returns {boolean}\n */\nfunction isAttributeTranslatable(node, attribute) {\n  const element = asHTMLElement(node);\n  if (!element) {\n    return false;\n  }\n\n  if (!element.hasAttribute(attribute)) {\n    // The element does not have this attribute, so there is nothing to translate.\n    return false;\n  }\n\n  if (!TRANSLATABLE_ATTRIBUTES.has(attribute)) {\n    // The attribute is not listed in our translatable attributes, so we will not translate it.\n    return false;\n  }\n\n  const criteria = TRANSLATABLE_ATTRIBUTES.get(attribute);\n\n  if (!criteria) {\n    // There are no further criteria specified for this attribute, so we translate this attribute for all elements.\n    return true;\n  }\n\n  // There are further criteria specified, so attempt to find a matching criterion for the given element.\n  return criteria.some(({ tagName, conditions }) => {\n    if (tagName !== element.tagName) {\n      // The tagName does not match the given element. Try the next criterion.\n      return false;\n    }\n\n    if (!conditions) {\n      // The tagName matches and there are no further conditions, so we always translate this attribute for this element.\n      return true;\n    }\n\n    // The tagName matches, but further conditions are specified. Attempt to find a matching condition.\n    return Object.entries(conditions).some(([key, values]) =>\n      values.some(value => element.getAttribute(key) === value)\n    );\n  });\n}\n\n/**\n * Returns true if the node is dead or detached from the DOM, otherwise false if the nod is still live.\n *\n * @param {Node} node\n *\n * @returns {boolean}\n */\nfunction isNodeDetached(node) {\n  return (\n    // This node is out of the DOM and already garbage collected.\n    Cu.isDeadWrapper(node) ||\n    // The node is detached, but not yet garbage collected,\n    // or it has been re-parented to a parent that itself is not connected.\n    !node.isConnected ||\n    // Normally you could just check `node.parentElement` to see if an element is\n    // part of the DOM, but the Chrome-only flattenedTreeParentNode is used to include\n    // Shadow DOM elements, which have a null parentElement.\n    !node.flattenedTreeParentNode\n  );\n}\n\n/**\n * Use TypeScript to determine if the Node is an Element.\n *\n * @param {Node | null | undefined} node\n *\n * @returns {Element | null}\n */\nfunction asElement(node) {\n  if (node?.nodeType === Node.ELEMENT_NODE) {\n    return /** @type {HTMLElement} */ (node);\n  }\n  return null;\n}\n\n/**\n * Use TypeScript to determine if the Node is an Element.\n *\n * @param {Node | null} node\n *\n * @returns {Text | null}\n */\nfunction asTextNode(node) {\n  if (node?.nodeType === Node.TEXT_NODE) {\n    return /** @type {Text} */ (node);\n  }\n  return null;\n}\n\n/**\n * Use TypeScript to determine if the Node is an HTMLElement.\n *\n * @param {Node | null} node\n *\n * @returns {HTMLElement | null}\n */\nfunction asHTMLElement(node) {\n  // This is a chrome-only function, and is the recommended function for chrome\n  // contexts. The TranslationsDocument could be used in non-chrome contexts in the\n  // future, so ensure that this doesn't break future implementations.\n  //\n  // See - https://firefox-source-docs.mozilla.org/code-quality/lint/linters/eslint-plugin-mozilla/rules/use-isInstance.html\n  if (HTMLElement.isInstance) {\n    if (HTMLElement.isInstance(node)) {\n      return /** @type {HTMLElement} */ (node);\n    }\n  } else if (\n    // eslint-disable-next-line mozilla/use-isInstance\n    node instanceof HTMLElement\n  ) {\n    return /** @type {HTMLElement} */ (node);\n  }\n  return null;\n}\n\n/**\n * @template T\n * @param {T | null | undefined} item\n *\n * @returns {T}\n */\nfunction ensureExists(item, message = \"Item did not exist\") {\n  if (item === null || item === undefined) {\n    throw new Error(message);\n  }\n  return item;\n}\n\n/**\n * Get the ShadowRoot from the chrome-only openOrClosedShadowRoot API.\n *\n * @param {Node} node\n *\n * @returns {ShadowRoot | null}\n */\nfunction getShadowRoot(node) {\n  return asElement(node)?.openOrClosedShadowRoot ?? null;\n}\n\n/**\n * Workaround the Gecko DOM TypeScript definition for dataset.\n *\n * @param {Element | null | undefined} element\n *\n * @returns {Record<string, string> | null}\n */\nfunction getDataset(element) {\n  // @ts-expect-error Type 'DOMStringMap' is not assignable to type 'Record<string, string>'.\n  return element?.dataset ?? null;\n}\n\n/**\n * Removes any data-moz-translations-id values from a node and its children.\n *\n * @param {Node} node\n */\nfunction removeMozTranslationsIds(node) {\n  const element = asHTMLElement(node);\n\n  if (!element) {\n    return;\n  }\n\n  if (isNodeDetached(element)) {\n    return;\n  }\n\n  const dataset = getDataset(element);\n\n  if (dataset) {\n    delete dataset.mozTranslationsId;\n  }\n\n  for (const childNode of element.querySelectorAll(\n    \"[data-moz-translations-id]\"\n  )) {\n    delete childNode.dataset.mozTranslationsId;\n  }\n}\n\n/**\n * Removes the entry pertaining to the inner key of a nested map structure,\n * ensuring that if the inner structure becomes empty, then the outer key\n * will also be removed from the outer structure.\n *\n * @typedef {Element} OuterKey\n * @typedef {Node | string} InnerKey\n * @typedef {number} Value\n *\n * @param {Map<OuterKey, (Set<InnerKey> | Map<InnerKey, Value>)>} outerMap\n * @param {OuterKey} outerKey\n * @param {InnerKey} innerKey\n *\n * @returns {{ didDeleteOuterEntry: boolean, didDeleteInnerEntry: boolean }}\n */\nfunction deleteFromNestedMap(outerMap, outerKey, innerKey) {\n  const innerStructure = outerMap.get(outerKey);\n\n  const didDeleteInnerEntry =\n    !!innerStructure && innerStructure.delete(innerKey);\n\n  const didDeleteOuterEntry = !innerStructure || innerStructure.size === 0;\n\n  if (didDeleteOuterEntry) {\n    // The inner structure is now empty after removing the inner-key entry.\n    // Ensure that the inner structure itself is removed from the outer map.\n    outerMap.delete(outerKey);\n  }\n\n  return { didDeleteOuterEntry, didDeleteInnerEntry };\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/translations-document.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/translations-engine.sys.mjs":
/*!*************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/translations-engine.sys.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TranslationsEngine: () => (/* binding */ TranslationsEngine),\n/* harmony export */   handleActorMessage: () => (/* binding */ handleActorMessage)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * This file lives in the translation engine's process and is in charge of managing the\n * lifecycle of the translations engines. This process is a singleton Web Content\n * process that can be created and destroyed as needed.\n *\n * The goal of the code in this file is to be as unprivileged as possible, which should\n * unlock Bug 1813789, which will make this file fully unprivileged.\n *\n * Each translation needs an engine for that specific language pair. This engine is\n * kept around as long as the CACHE_TIMEOUT_MS, after this if some keepAlive event does\n * not happen, the engine is destroyed. An engine may be destroyed even when a page is\n * still open and may need translations in the future. This is handled gracefully by\n * creating new engines and MessagePorts on the fly.\n *\n * The engine communicates directly with the content page via a MessagePort. Each end\n * of the port is transferred from the parent process to the content process, and this\n * engine process. This port is transitory, and may be closed at any time. Only when a\n * translation has been requested once (which is initiated by the parent process) can\n * the content process re-request translation ports. This ensures a rogue content process\n * only has the capabilities to perform tasks that the parent process has given it.\n *\n * The messaging flow can get a little convoluted to handle all of the correctness cases,\n * but ideally communication passes through the message port as much as possible. There\n * are many scenarios such as:\n *\n *  - Translation pages becoming idle\n *  - Tab changing causing \"pageshow\" and \"pagehide\" visibility changes\n *  - Translation actor destruction (this can happen long after the page has been\n *                                   navigated away from, but is still alive in the\n *                                   page history)\n *  - Error states\n *  - Engine Process being graceful shut down (no engines left)\n *  - Engine Process being killed by the OS.\n *\n * The following is a diagram that attempts to illustrate the structure of the processes\n * and the communication channels that exist between them.\n *\n * ┌─────────────────────────────────────────────────────────────┐\n * │ PARENT PROCESS                                              │\n * │                                                             │\n * │  [TranslationsParent]  ←────→  [TranslationsEngineParent]   │\n * │                  ↑                                    ↑     │\n * └──────────────────│────────────────────────────────────│─────┘\n *                    │ JSWindowActor IPC calls            │ JSProcessActor IPC calls\n *                    │                                    │\n * ┌──────────────────│────────┐                     ┌─────│─────────────────────────────┐\n * │ CONTENT PROCESS  │        │                     │     │    ENGINE PROCESS           │\n * │                  │        │                     │     ↓                             │\n * │  [french.html]   │        │                     │ [TranslationsEngineChild]         │\n * │        ↕         ↓        │                     │            ↕                      │\n * │  [TranslationsChild]      │                     │ [translations-engine.sys.mjs]     │\n * │  └──TranslationsDocument  │                     │    ├── \"fr to en\" engine          │\n * │     └──port1     « ═══════════ MessageChannel ════ » │   └── port2                  │\n * │                           │                     │    └── \"de to en\" engine (idle)   │\n * └───────────────────────────┘                     └───────────────────────────────────┘\n */\n\n// FIXME: Currently, `translations-engine.sys.mjs` is loaded with the system\n// principal within the sys.mjs context.\n//\n// There is some existing code which exported these methods in a global scope\n// from when this file was being loaded within a chrome .html document within\n// the content process, however this code no longer exists.\n//\n// This block re-exports various methods from the singleton TranslationsEngine\n// actor into this scope so they can be called as they were called before the\n// change to use a ProcessActor.\n//\n// In the future, this code could perhaps be modified to run within an\n// unprivileged Cu.Sandbox, with these specific methods re-exported into the\n// sandbox scope.\n\nconst engineActor = ChromeUtils.domProcessChild.getActor(\"TranslationsEngine\");\n\nconst TE_addProfilerMarker = engineActor.TE_addProfilerMarker.bind(engineActor);\nconst TE_getLogLevel = engineActor.TE_getLogLevel.bind(engineActor);\nconst TE_log = engineActor.TE_log.bind(engineActor);\nconst TE_logError = engineActor.TE_logError.bind(engineActor);\nconst TE_requestEnginePayload =\n  engineActor.TE_requestEnginePayload.bind(engineActor);\nconst TE_reportEnginePerformance =\n  engineActor.TE_reportEnginePerformance.bind(engineActor);\nconst TE_reportEngineStatus =\n  engineActor.TE_reportEngineStatus.bind(engineActor);\nconst TE_resolveForceShutdown =\n  engineActor.TE_resolveForceShutdown.bind(engineActor);\nconst TE_destroyEngineProcess =\n  engineActor.TE_destroyEngineProcess.bind(engineActor);\n\n// How long the cache remains alive between uses, in milliseconds. In automation the\n// engine is manually created and destroyed to avoid timing issues.\nconst CACHE_TIMEOUT_MS = 15_000;\n\n/**\n * @typedef {import(\"./translations-document.sys.mjs\").TranslationsDocument} TranslationsDocument\n * @typedef {import(\"../translations.js\").TranslationsEnginePayload} TranslationsEnginePayload\n * @typedef {import(\"../translations.js\").LanguagePair} LanguagePair\n */\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  clearTimeout: \"resource://gre/modules/Timer.sys.mjs\",\n  setTimeout: \"resource://gre/modules/Timer.sys.mjs\",\n  TranslationsUtils:\n    \"chrome://global/content/translations/TranslationsUtils.mjs\",\n});\n\n/**\n * The TranslationsEngine encapsulates the logic for translating messages. It can\n * only be set up for a single language pair. In order to change languages\n * a new engine should be constructed.\n *\n * The actual work for the translations happens in a worker. This class manages\n * instantiating and messaging the worker.\n *\n * Keep unused engines around in the TranslationsEngine.#cachedEngine cache in case\n * page navigation happens and we can re-use previous engines. The engines are very\n * heavy-weight, so get rid of them after a timeout. Once all are destroyed the\n * TranslationsEngineParent is notified that it can be destroyed.\n */\nclass TranslationsEngine {\n  /**\n   * Maps a language pair key to a cached engine. Engines are kept around for a timeout\n   * before they are removed so that they can be re-used during navigation.\n   *\n   * @type {Map<string, Promise<TranslationsEngine>>}\n   */\n  static #cachedEngines = new Map();\n\n  /**\n   * A DOMParser instance used for parsing HTML strings into DOM objects.\n   *\n   * @type {DOMParser}\n   */\n  static #domParser = new DOMParser();\n\n  /**\n   * The ID of a timer that keeps the engine alive in the cache.\n   *\n   * @see {#cachedEngines}\n   *\n   * @type {TimeoutID | null}\n   */\n  #keepAliveTimeout = null;\n\n  /**\n   * The Web Worker instance used to handle translation requests.\n   *\n   * @type {Worker}\n   */\n  #worker;\n\n  /**\n   * Multiple messages can be sent before a response is received. This ID is used to keep\n   * track of the messages. It is incremented on every use.\n   *\n   * @type {number}\n   */\n  #messageId = 0;\n\n  /**\n   * The total count of completed translation requests.\n   *\n   * @type {number}\n   */\n  #totalCompletedRequests = 0;\n\n  /**\n   * The total count of words translated across all requests.\n   *\n   * @type {number}\n   */\n  #totalTranslatedWords = 0;\n\n  /**\n   * The total milliseconds spent in active translation inference.\n   *\n   * @type {number}\n   */\n  #totalInferenceMilliseconds = 0;\n\n  /**\n   * A word segmenter instance corresponding to the language of the source text.\n   *\n   * @type {Intl.Segmenter | null}\n   */\n  #wordSegmenter = null;\n\n  /**\n   * Returns a getter function that will create a translations engine on the first\n   * call, and then return the cached one. After a timeout when the engine hasn't\n   * been used, it is destroyed.\n   *\n   * @param {LanguagePair} languagePair\n   * @param {number} innerWindowId\n   * @returns {Promise<TranslationsEngine>}\n   */\n  static getOrCreate(languagePair, innerWindowId) {\n    const languagePairKey =\n      lazy.TranslationsUtils.serializeLanguagePair(languagePair);\n    let enginePromise = TranslationsEngine.#cachedEngines.get(languagePairKey);\n\n    if (enginePromise) {\n      return enginePromise;\n    }\n\n    TE_log(`Creating a new engine for \"${languagePairKey}\".`);\n\n    // A new engine needs to be created.\n    enginePromise = TranslationsEngine.create(languagePair, innerWindowId);\n\n    TranslationsEngine.#cachedEngines.set(languagePairKey, enginePromise);\n\n    enginePromise.catch(error => {\n      TE_logError(\n        `The engine failed to load for translating \"${languagePairKey}\". Removing it from the cache.`,\n        error\n      );\n      // Remove the engine if it fails to initialize.\n      TranslationsEngine.#removeEngineFromCache(languagePairKey);\n    });\n\n    return enginePromise;\n  }\n\n  /**\n   * Removes the engine, and if it's the last, call the process to destroy itself.\n   *\n   * @param {string} languagePairKey\n   * @param {boolean} force - On forced shutdowns, it's not necessary to notify the\n   *                          parent process.\n   */\n  static #removeEngineFromCache(languagePairKey, force) {\n    TranslationsEngine.#cachedEngines.delete(languagePairKey);\n    if (TranslationsEngine.#cachedEngines.size === 0 && !force) {\n      TE_log(\"The last engine was removed, destroying this process.\");\n      TE_destroyEngineProcess();\n    }\n  }\n\n  /**\n   * Create a TranslationsEngine and bypass the cache.\n   *\n   * @param {LanguagePair} languagePair\n   * @param {number} innerWindowId\n   * @returns {Promise<TranslationsEngine>}\n   */\n  static async create(languagePair, innerWindowId) {\n    const startTime = ChromeUtils.now();\n    if (!languagePair.sourceLanguage || !languagePair.targetLanguage) {\n      throw new Error(\n        \"Attempt to create Translator with missing language tags.\"\n      );\n    }\n\n    const engine = new TranslationsEngine(\n      languagePair,\n      await TE_requestEnginePayload(languagePair)\n    );\n\n    await engine.isReady;\n\n    TE_addProfilerMarker({\n      startTime,\n      message: `Translations engine loaded for \"${lazy.TranslationsUtils.serializeLanguagePair(languagePair)}\"`,\n      innerWindowId,\n    });\n\n    return engine;\n  }\n\n  /**\n   * Signal to the engines that they are being forced to shutdown.\n   */\n  static forceShutdown() {\n    return Promise.allSettled(\n      [...TranslationsEngine.#cachedEngines].map(\n        async ([langPair, enginePromise]) => {\n          TE_log(`Force shutdown of the engine \"${langPair}\"`);\n          const engine = await enginePromise;\n          engine.terminate(true /* force */);\n        }\n      )\n    );\n  }\n\n  /**\n   * Terminates the engine and its worker after a timeout.\n   *\n   * @param {boolean} force\n   */\n  terminate = (force = false) => {\n    const message = `Terminating translations engine \"${this.languagePairKey}\".`;\n\n    this.#maybeReportEnginePerformance();\n    TE_addProfilerMarker({ message });\n    TE_log(message);\n    this.#worker.terminate();\n    this.#worker = null;\n    if (this.#keepAliveTimeout) {\n      lazy.clearTimeout(this.#keepAliveTimeout);\n    }\n    for (const [innerWindowId, data] of ports) {\n      const { sourceLanguage, targetLanguage, port } = data;\n      if (\n        sourceLanguage === this.sourceLanguage &&\n        targetLanguage === this.targetLanguage\n      ) {\n        // This port is still active but being closed.\n        ports.delete(innerWindowId);\n        port.postMessage({ type: \"TranslationsPort:EngineTerminated\" });\n        port.close();\n      }\n    }\n    TranslationsEngine.#removeEngineFromCache(this.languagePairKey, force);\n  };\n\n  /**\n   * The worker needs to be shutdown after some amount of time of not being used.\n   */\n  keepAlive() {\n    if (this.#keepAliveTimeout) {\n      // Clear any previous timeout.\n      lazy.clearTimeout(this.#keepAliveTimeout);\n    }\n    // In automated tests, the engine is manually destroyed.\n    if (!Cu.isInAutomation) {\n      this.#keepAliveTimeout = lazy.setTimeout(\n        this.terminate,\n        CACHE_TIMEOUT_MS\n      );\n    }\n  }\n\n  /**\n   * Reports this engine's performance metrics to telemetry if it\n   * has completed at least one successful translation request.\n   */\n  #maybeReportEnginePerformance() {\n    if (!this.#totalCompletedRequests) {\n      // This engine did not translate any requests to completion.\n      // There is nothing to report.\n      return;\n    }\n\n    const { sourceLanguage, targetLanguage } = this.languagePair;\n\n    TE_reportEnginePerformance({\n      sourceLanguage,\n      targetLanguage,\n      totalInferenceSeconds: this.#totalInferenceMilliseconds / 1000,\n      totalTranslatedWords: this.#totalTranslatedWords,\n      totalCompletedRequests: this.#totalCompletedRequests,\n    });\n  }\n\n  /**\n   * Construct and initialize the worker.\n   *\n   * @param {LanguagePair} languagePair\n   * @param {TranslationsEnginePayload} enginePayload - If there is no engine payload\n   *   then the engine will be mocked. This allows this class to be used in tests.\n   */\n  constructor(languagePair, enginePayload) {\n    /** @type {LanguagePair} */\n    this.languagePair = languagePair;\n    this.languagePairKey =\n      lazy.TranslationsUtils.serializeLanguagePair(languagePair);\n\n    this.#worker = new Worker(\n      \"chrome://global/content/translations/translations-engine.worker.js\"\n    );\n\n    /** @type {Promise<void>} */\n    this.isReady = new Promise((resolve, reject) => {\n      const onMessage = ({ data }) => {\n        TE_log(\"Received initialization message\", data);\n        if (data.type === \"initialization-success\") {\n          resolve();\n        } else if (data.type === \"initialization-error\") {\n          reject(data.error);\n        }\n        this.#worker.removeEventListener(\"message\", onMessage);\n      };\n      this.#worker.addEventListener(\"message\", onMessage);\n\n      try {\n        this.#wordSegmenter = new Intl.Segmenter(this.sourceLanguage, {\n          granularity: \"word\",\n        });\n      } catch (error) {\n        reject(error);\n      }\n\n      // Schedule the first timeout for keeping the engine alive.\n      this.keepAlive();\n    });\n\n    // Make sure the ArrayBuffers are transferred, not cloned.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects\n    const transferables = [];\n    if (enginePayload) {\n      transferables.push(enginePayload.bergamotWasmArrayBuffer);\n\n      for (const translationModelPayload of enginePayload.translationModelPayloads) {\n        const { languageModelFiles } = translationModelPayload;\n        for (const { buffer } of Object.values(languageModelFiles)) {\n          transferables.push(buffer);\n        }\n      }\n    }\n\n    const { sourceLanguage, targetLanguage } = languagePair;\n    this.#worker.postMessage(\n      {\n        type: \"initialize\",\n        sourceLanguage,\n        targetLanguage,\n        enginePayload,\n        messageId: this.#messageId++,\n        logLevel: TE_getLogLevel(),\n      },\n      transferables\n    );\n  }\n\n  /**\n   * Counts the number of words in the given source text.\n   *\n   * @param {string} sourceText - The text to be counted.\n   * @param {boolean} isHTML - Whether to parse the text as HTML.\n   * @returns {number} - The total count of word-like segments in the text.\n   */\n  #countWords(sourceText, isHTML) {\n    if (isHTML) {\n      sourceText = TranslationsEngine.#domParser.parseFromString(\n        sourceText,\n        \"text/html\"\n      ).documentElement.textContent;\n    }\n\n    let wordCount = 0;\n    for (const { isWordLike } of this.#wordSegmenter.segment(sourceText)) {\n      if (isWordLike) {\n        wordCount += 1;\n      }\n    }\n\n    return wordCount;\n  }\n\n  /**\n   * The implementation for translation. Use translateText or translateHTML for the\n   * public API.\n   *\n   * @param {string} sourceText\n   * @param {boolean} isHTML\n   * @param {number} innerWindowId\n   * @param {number} translationId\n   * @returns {Promise<string>}\n   *   A promise that resolves with the translated text.\n   */\n  translate(sourceText, isHTML, innerWindowId, translationId) {\n    this.keepAlive();\n\n    const messageId = this.#messageId++;\n\n    return new Promise((resolve, reject) => {\n      const onMessage = ({ data }) => {\n        if (\n          data.type === \"translations-discarded\" &&\n          data.innerWindowId === innerWindowId\n        ) {\n          // The page was unloaded, and we no longer need to listen for a response.\n          this.#worker.removeEventListener(\"message\", onMessage);\n          return;\n        }\n\n        if (data.messageId !== messageId) {\n          // Multiple translation requests can be sent before a response is received.\n          // Ensure that the response received here is the correct one.\n          return;\n        }\n\n        if (data.type === \"translation-response\") {\n          // Also keep the translation alive after getting a result, as many translations\n          // can queue up at once, and then it can take minutes to resolve them all.\n          this.keepAlive();\n\n          const { targetText, inferenceMilliseconds } = data;\n\n          resolve(targetText);\n\n          const sourceTextWordCount = this.#countWords(sourceText, isHTML);\n          this.#totalInferenceMilliseconds += inferenceMilliseconds;\n          this.#totalTranslatedWords += sourceTextWordCount;\n          this.#totalCompletedRequests += 1;\n        }\n        if (data.type === \"translation-error\") {\n          reject(data.error);\n        }\n        this.#worker.removeEventListener(\"message\", onMessage);\n      };\n\n      this.#worker.addEventListener(\"message\", onMessage);\n\n      this.#worker.postMessage({\n        type: \"translation-request\",\n        isHTML,\n        sourceText,\n        messageId,\n        translationId,\n        innerWindowId,\n      });\n    });\n  }\n\n  /**\n   * Applies a function only if a cached engine exists.\n   *\n   * @param {LanguagePair} languagePair\n   * @param {(engine: TranslationsEngine) => void} fn\n   */\n  static withCachedEngine(languagePair, fn) {\n    const engine = TranslationsEngine.#cachedEngines.get(\n      lazy.TranslationsUtils.serializeLanguagePair(languagePair)\n    );\n\n    if (engine) {\n      engine.then(fn).catch(() => {});\n    }\n  }\n\n  /**\n   * Stop processing the translation queue. All in-progress messages will be discarded.\n   *\n   * @param {number} innerWindowId\n   */\n  discardTranslationQueue(innerWindowId) {\n    this.#worker.postMessage({\n      type: \"discard-translation-queue\",\n      innerWindowId,\n    });\n  }\n\n  /**\n   * Cancel a single translation.\n   *\n   * @param {number} innerWindowId\n   * @param {id} translationId\n   */\n  cancelSingleTranslation(innerWindowId, translationId) {\n    this.#worker.postMessage({\n      type: \"cancel-single-translation\",\n      innerWindowId,\n      translationId,\n    });\n  }\n}\n\n/**\n * Maps the innerWindowId to the port.\n *\n * @type {Map<number, {\n *  languagePair: LanguagePair,\n *  port: MessagePort\n * }>}\n */\nconst ports = new Map();\n\n/**\n * Listen to the port to the content process for incoming messages, and pass\n * them to the TranslationsEngine manager. The other end of the port is held\n * in the content process by the TranslationsDocument.\n *\n * @param {LanguagePair} languagePair\n * @param {number} innerWindowId\n * @param {MessagePort} port\n */\nfunction listenForPortMessages(languagePair, innerWindowId, port) {\n    console.log(\"[dbg][issam][translations-engine.sys.mjs] ---- listenForPortMessages\", { languagePair, innerWindowId, port });\n  async function handleMessage({ data }) {\n    console.log(\"[dbg][issam][translations-engine.sys.mjs] ---- listenForPortMessages\", data);\n\n    switch (data.type) {\n      case \"TranslationsPort:GetEngineStatusRequest\": {\n        // This message gets sent first before the translation queue is processed.\n        // The engine is most likely to fail on the initial invocation. Any failure\n        // past the first one is not reported to the UI.\n        TranslationsEngine.getOrCreate(languagePair, innerWindowId).then(\n          () => {\n            TE_log(\"The engine is ready for translations.\", {\n              innerWindowId,\n            });\n            TE_reportEngineStatus(innerWindowId, \"ready\");\n            port.postMessage({\n              type: \"TranslationsPort:GetEngineStatusResponse\",\n              status: \"ready\",\n            });\n          },\n          error => {\n            console.error(error);\n            TE_reportEngineStatus(innerWindowId, \"error\");\n            port.postMessage({\n              type: \"TranslationsPort:GetEngineStatusResponse\",\n              status: \"error\",\n              error: String(error),\n            });\n            // After an error no more translation requests will be sent. Go ahead\n            // and close the port.\n            port.close();\n            ports.delete(innerWindowId);\n          }\n        );\n        break;\n      }\n      case \"TranslationsPort:Passthrough\": {\n        const { translationId } = data;\n\n        port.postMessage({\n          type: \"TranslationsPort:TranslationResponse\",\n          translationId,\n          targetText: null,\n        });\n\n        TE_addProfilerMarker({\n          innerWindowId,\n          type: \"Passthrough\",\n          message: `Handled passthrough translation`,\n        });\n\n        break;\n      }\n      case \"TranslationsPort:CachedTranslation\": {\n        const { cachedTranslation, translationId } = data;\n        port.postMessage({\n          type: \"TranslationsPort:TranslationResponse\",\n          translationId,\n          targetText: cachedTranslation,\n        });\n\n        TE_addProfilerMarker({\n          innerWindowId,\n          type: \"Cached\",\n          message: `Handled cached translation of ${cachedTranslation.length} code units`,\n        });\n\n        break;\n      }\n      case \"TranslationsPort:TranslationRequest\": {\n        const { sourceText, isHTML, translationId } = data;\n\n        const engine = await TranslationsEngine.getOrCreate(\n          languagePair,\n          innerWindowId\n        );\n\n        TE_addProfilerMarker({\n          innerWindowId,\n          type: \"Request\",\n          message: `Handled translation request of ${sourceText.length} code units`,\n        });\n\n        const targetText = await engine.translate(\n          sourceText,\n          isHTML,\n          innerWindowId,\n          translationId\n        );\n\n        port.postMessage({\n          type: \"TranslationsPort:TranslationResponse\",\n          translationId,\n          targetText,\n        });\n\n        break;\n      }\n      case \"TranslationsPort:CancelSingleTranslation\": {\n        const { translationId } = data;\n        TranslationsEngine.withCachedEngine(languagePair, engine => {\n          engine.cancelSingleTranslation(innerWindowId, translationId);\n        });\n\n        TE_addProfilerMarker({\n          innerWindowId,\n          type: \"Cancel\",\n          message: `Cancelled request for translationId ${translationId}`,\n        });\n        break;\n      }\n      case \"TranslationsPort:DiscardTranslations\": {\n        discardTranslations(innerWindowId);\n        TE_addProfilerMarker({\n          innerWindowId,\n          type: \"Discard\",\n          message: `Discarded all active translation requests`,\n        });\n        break;\n      }\n      default:\n        TE_logError(\"Unknown translations port message: \" + data.type);\n        break;\n    }\n  }\n\n  if (port.onmessage) {\n    TE_logError(\n      new Error(\"The MessagePort onmessage handler was already present.\")\n    );\n  }\n\n  port.onmessage = event => {\n    handleMessage(event).catch(error => TE_logError(error));\n  };\n}\n\n/**\n * Discards the queue and removes the port.\n *\n * @param {number} innerWindowId\n */\nfunction discardTranslations(innerWindowId) {\n  TE_log(\"Discarding translations, innerWindowId:\", innerWindowId);\n\n  const portData = ports.get(innerWindowId);\n  if (portData) {\n    const { port, languagePair } = portData;\n    port.close();\n    ports.delete(innerWindowId);\n\n    TranslationsEngine.withCachedEngine(languagePair, engine => {\n      engine.discardTranslationQueue(innerWindowId);\n    });\n  }\n}\n\n/**\n * Listen for events coming from the TranslationsEngine actor.\n */\nfunction handleActorMessage(data) {\n  switch (data.type) {\n    case \"StartTranslation\": {\n      const { languagePair, innerWindowId, port } = data;\n\n      TE_log(\n        \"Starting translation\",\n        lazy.TranslationsUtils.serializeLanguagePair(languagePair),\n        innerWindowId\n      );\n      listenForPortMessages(languagePair, innerWindowId, port);\n      console.log(\"[dbg][issam][translations-engine.sys.mjs] ---- handleActorMessage StartTranslation\");\n      console.log(\"[dbg][issam][translations-engine.sys.mjs] ---- handleActorMessage StartTranslation\", innerWindowId);\n      ports.set(innerWindowId, { port, languagePair });\n      console.log(\"[dbg][issam][translations-engine.sys.mjs] ---- handleActorMessage StartTranslation\", [...ports]);\n      break;\n    }\n    case \"DiscardTranslations\": {\n      const { innerWindowId } = data;\n      discardTranslations(innerWindowId);\n      break;\n    }\n    case \"ForceShutdown\": {\n      TranslationsEngine.forceShutdown().then(() => {\n        TE_resolveForceShutdown();\n      });\n      break;\n    }\n    default:\n      throw new Error(\"Unknown TranslationsEngineChromeToContent event.\");\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/translations-engine.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script sync recursive ./node_modules/script-loader/index.js! ^\\.\\/.*$":
/*!***************************************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/ sync ./node_modules/script-loader/index.js! ^\.\/.*$ ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./AddressMetaData.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs\",\n\t\"./AddressMetaDataExtension.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs\",\n\t\"./AddressMetaDataLoader.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs\",\n\t\"./AddressParser.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressParser.sys.mjs\",\n\t\"./AddressRecord.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs\",\n\t\"./AutofillFormFactory.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AutofillFormFactory.sys.mjs\",\n\t\"./AutofillTelemetry.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs\",\n\t\"./CC_Python_Update.py\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CC_Python_Update.py\",\n\t\"./Constants.ios.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs\",\n\t\"./CreditCard.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs\",\n\t\"./CreditCardRecord.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs\",\n\t\"./CreditCardRuleset.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs\",\n\t\"./EmptyModule.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/EmptyModule.sys.mjs\",\n\t\"./FieldScanner.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs\",\n\t\"./FormAutofill.ios.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs\",\n\t\"./FormAutofill.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs\",\n\t\"./FormAutofillChild.ios.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs\",\n\t\"./FormAutofillExtras.ios.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs\",\n\t\"./FormAutofillHandler.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs\",\n\t\"./FormAutofillHeuristics.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs\",\n\t\"./FormAutofillNameUtils.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs\",\n\t\"./FormAutofillSection.ios.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs\",\n\t\"./FormAutofillSection.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs\",\n\t\"./FormAutofillUtils.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\",\n\t\"./FormLikeFactory.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs\",\n\t\"./FormStateManager.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs\",\n\t\"./Helpers.ios.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs\",\n\t\"./HeuristicsRegExp.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs\",\n\t\"./LabelUtils.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs\",\n\t\"./LoginFormFactory.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginFormFactory.sys.mjs\",\n\t\"./LoginFormState.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginFormState.sys.mjs\",\n\t\"./LoginManager.shared.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.sys.mjs\",\n\t\"./NewPasswordModel.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/NewPasswordModel.sys.mjs\",\n\t\"./Overrides.ios\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js\",\n\t\"./Overrides.ios.js\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js\",\n\t\"./PasswordGenerator.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PasswordGenerator.sys.mjs\",\n\t\"./PasswordRulesParser.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PasswordRulesParser.sys.mjs\",\n\t\"./PhoneNumber.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs\",\n\t\"./PhoneNumberMetaData.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs\",\n\t\"./PhoneNumberNormalizer.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs\",\n\t\"./TranslationsHelpers.ios.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/TranslationsHelpers.ios.mjs\",\n\t\"./TranslationsUtils.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/TranslationsUtils.mjs\",\n\t\"./addressFormLayout.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/addressFormLayout.mjs\",\n\t\"./bergamot-translator\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js\",\n\t\"./bergamot-translator.js\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js\",\n\t\"./fathom.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/fathom.mjs\",\n\t\"./translations-document.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-document.sys.mjs\",\n\t\"./translations-engine.sys.mjs\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-engine.sys.mjs\",\n\t\"./translations-engine.worker\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js\",\n\t\"./translations-engine.worker.js\": \"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./firefox-ios/Client/Assets/CC_Script sync recursive ./node_modules/script-loader/index.js! ^\\\\.\\\\/.*$\";\n\n//# sourceURL=webpack://firefox-ios/_^\\.\\/.*$?./firefox-ios/Client/Assets/CC_Script/_sync_./node_modules/script-loader/index.js");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script sync .mjs$":
/*!**********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/ sync nonrecursive .mjs$ ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./AddressMetaData.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs\",\n\t\"./AddressMetaDataExtension.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs\",\n\t\"./AddressMetaDataLoader.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs\",\n\t\"./AddressParser.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/AddressParser.sys.mjs\",\n\t\"./AddressRecord.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs\",\n\t\"./AutofillFormFactory.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/AutofillFormFactory.sys.mjs\",\n\t\"./AutofillTelemetry.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs\",\n\t\"./Constants.ios.mjs\": \"./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs\",\n\t\"./CreditCard.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs\",\n\t\"./CreditCardRecord.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs\",\n\t\"./CreditCardRuleset.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs\",\n\t\"./EmptyModule.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/EmptyModule.sys.mjs\",\n\t\"./FieldScanner.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs\",\n\t\"./FormAutofill.ios.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs\",\n\t\"./FormAutofill.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs\",\n\t\"./FormAutofillChild.ios.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs\",\n\t\"./FormAutofillExtras.ios.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs\",\n\t\"./FormAutofillHandler.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs\",\n\t\"./FormAutofillHeuristics.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs\",\n\t\"./FormAutofillNameUtils.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs\",\n\t\"./FormAutofillSection.ios.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs\",\n\t\"./FormAutofillSection.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs\",\n\t\"./FormAutofillUtils.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\",\n\t\"./FormLikeFactory.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs\",\n\t\"./FormStateManager.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs\",\n\t\"./Helpers.ios.mjs\": \"./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs\",\n\t\"./HeuristicsRegExp.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs\",\n\t\"./LabelUtils.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs\",\n\t\"./LoginFormFactory.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/LoginFormFactory.sys.mjs\",\n\t\"./LoginFormState.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/LoginFormState.sys.mjs\",\n\t\"./LoginManager.shared.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.sys.mjs\",\n\t\"./NewPasswordModel.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/NewPasswordModel.sys.mjs\",\n\t\"./PasswordGenerator.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/PasswordGenerator.sys.mjs\",\n\t\"./PasswordRulesParser.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/PasswordRulesParser.sys.mjs\",\n\t\"./PhoneNumber.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs\",\n\t\"./PhoneNumberMetaData.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs\",\n\t\"./PhoneNumberNormalizer.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs\",\n\t\"./TranslationsHelpers.ios.mjs\": \"./firefox-ios/Client/Assets/CC_Script/TranslationsHelpers.ios.mjs\",\n\t\"./TranslationsUtils.mjs\": \"./firefox-ios/Client/Assets/CC_Script/TranslationsUtils.mjs\",\n\t\"./addressFormLayout.mjs\": \"./firefox-ios/Client/Assets/CC_Script/addressFormLayout.mjs\",\n\t\"./fathom.mjs\": \"./firefox-ios/Client/Assets/CC_Script/fathom.mjs\",\n\t\"./translations-document.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/translations-document.sys.mjs\",\n\t\"./translations-engine.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/translations-engine.sys.mjs\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./firefox-ios/Client/Assets/CC_Script sync .mjs$\";\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/_sync_nonrecursive_.mjs$?");

/***/ }),

/***/ "./firefox-ios/Client/Frontend/UserContent/UserScripts/TranslationsEngine/TranslationsEngine.js":
/*!******************************************************************************************************!*\
  !*** ./firefox-ios/Client/Frontend/UserContent/UserScripts/TranslationsEngine/TranslationsEngine.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var Assets_CC_Script_TranslationsHelpers_ios_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Assets/CC_Script/TranslationsHelpers.ios.mjs */ \"./firefox-ios/Client/Assets/CC_Script/TranslationsHelpers.ios.mjs\");\n/* harmony import */ var Assets_CC_Script_translations_engine_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Assets/CC_Script/translations-engine.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/translations-engine.sys.mjs\");\n\n\n\n/// TODO(Issam): We can make this a tiny lib where we import and create the bi-directional bridge for both sides.\nconst sendToPage = (message) => {\n  console.log(\"[dbg][issam][TranslationsEngine.js] sending back to page:\", message, window.webkit.messageHandlers.right.postMessage);\n  window.webkit.messageHandlers.right.postMessage(message.data);\n}\n\n\n// NOTE(Issam): We need a way to clean these up. Maybe from swift when webview is destroyed \n// We send over a ForceShutdown message.\nconst channels = new Map();\n\nwindow.receive = (message) => {\n  const id = message?.channelId;\n  // TODO(Issam): This is a bit hacky but works for now.\n  switch (message?.type) {\n    case \"StartTranslation\": {\n      // Create a fresh MessageChannel for each new translation start\n      // TODO(Issam): This might be wasteful maybe ??? Also when do we kill them ?\n      const channel = new MessageChannel();\n      channels.set(id, channel);\n      const { port1, port2 } = channel;\n      port2.onmessage = (msg) => sendToPage(msg);\n      (0,Assets_CC_Script_translations_engine_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.handleActorMessage)({ ...message, port: port1 });\n      break;\n    }\n    case \"DiscardTranslations\":\n    case \"ForceShutdown\": {\n      (0,Assets_CC_Script_translations_engine_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.handleActorMessage)(message);\n      // We need to delete this after we send over the messages and the engine is really done.\n      channels.delete(id);\n      break;\n    }\n    default: {\n      const channel = channels.get(id);\n      channel?.port2.postMessage(message);\n      break;\n    }\n  }\n}\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Frontend/UserContent/UserScripts/TranslationsEngine/TranslationsEngine.js?");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs":
/*!********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs ***!
  \********************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n// The data below is initially copied from\\n// https://chromium-i18n.appspot.com/ssl-aggregate-address\\n\\n// See https://github.com/googlei18n/libaddressinput/wiki/AddressValidationMetadata for\\n// documentation on how to use the data.\\n\\n// WARNING: DO NOT change any value or add additional properties in addressData.\\n// We only accept the metadata of the supported countries that is copied from libaddressinput directly.\\n// Please edit AddressMetaDataExtension.sys.mjs instead if you want to add new property as complement\\n// or overwrite the existing properties.\\n\\nexport const AddressMetaData = {\\n  \\\"data/AD\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/AD\\\",\\n    key: \\\"AD\\\",\\n    lang: \\\"ca\\\",\\n    languages: \\\"ca\\\",\\n    name: \\\"ANDORRA\\\",\\n    posturl:\\n      \\\"http://www.correos.es/comun/CodigosPostales/1010_s-CodPostal.asp?Provincia=\\\",\\n    sub_isoids: \\\"07~02~03~08~04~05~06\\\",\\n    sub_keys:\\n      \\\"Parròquia d'Andorra la Vella~Canillo~Encamp~Escaldes-Engordany~La Massana~Ordino~Sant Julià de Lòria\\\",\\n    sub_names:\\n      \\\"Andorra la Vella~Canillo~Encamp~Escaldes-Engordany~La Massana~Ordino~Sant Julià de Lòria\\\",\\n    sub_zipexs: \\\"AD500~AD100~AD200~AD700~AD400~AD300~AD600\\\",\\n    sub_zips: \\\"AD50[01]~AD10[01]~AD20[01]~AD70[01]~AD40[01]~AD30[01]~AD60[01]\\\",\\n    zip: \\\"AD[1-7]0\\\\\\\\d\\\",\\n    zipex: \\\"AD100,AD501,AD700\\\",\\n  },\\n  \\\"data/AE\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%S\\\",\\n    id: \\\"data/AE\\\",\\n    key: \\\"AE\\\",\\n    lang: \\\"ar\\\",\\n    languages: \\\"ar\\\",\\n    lfmt: \\\"%N%n%O%n%A%n%S\\\",\\n    name: \\\"UNITED ARAB EMIRATES\\\",\\n    require: \\\"AS\\\",\\n    state_name_type: \\\"emirate\\\",\\n    sub_isoids: \\\"AZ~SH~FU~UQ~DU~RK~AJ\\\",\\n    sub_keys:\\n      \\\"أبو ظبي~إمارة الشارقةّ~الفجيرة~ام القيوين~إمارة دبيّ~إمارة رأس الخيمة~عجمان\\\",\\n    sub_lnames:\\n      \\\"Abu Dhabi~Sharjah~Fujairah~Umm Al Quwain~Dubai~Ras al Khaimah~Ajman\\\",\\n    sub_names: \\\"أبو ظبي~الشارقة~الفجيرة~ام القيوين~دبي~رأس الخيمة~عجمان\\\",\\n  },\\n  \\\"data/AF\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%Z\\\",\\n    id: \\\"data/AF\\\",\\n    key: \\\"AF\\\",\\n    name: \\\"AFGHANISTAN\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1001,2601,3801\\\",\\n  },\\n  \\\"data/AG\\\": {\\n    id: \\\"data/AG\\\",\\n    key: \\\"AG\\\",\\n    name: \\\"ANTIGUA AND BARBUDA\\\",\\n    require: \\\"A\\\",\\n  },\\n  \\\"data/AI\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%Z\\\",\\n    id: \\\"data/AI\\\",\\n    key: \\\"AI\\\",\\n    name: \\\"ANGUILLA\\\",\\n    zip: \\\"(?:AI-)?2640\\\",\\n    zipex: \\\"2640\\\",\\n  },\\n  \\\"data/AL\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z%n%C\\\",\\n    id: \\\"data/AL\\\",\\n    key: \\\"AL\\\",\\n    name: \\\"ALBANIA\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1001,1017,3501\\\",\\n  },\\n  \\\"data/AM\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z%n%C%n%S\\\",\\n    id: \\\"data/AM\\\",\\n    key: \\\"AM\\\",\\n    lang: \\\"hy\\\",\\n    languages: \\\"hy\\\",\\n    lfmt: \\\"%N%n%O%n%A%n%Z%n%C%n%S\\\",\\n    name: \\\"ARMENIA\\\",\\n    sub_isoids: \\\"AG~AR~AV~GR~ER~LO~KT~SH~SU~VD~TV\\\",\\n    sub_keys:\\n      \\\"Արագածոտն~Արարատ~Արմավիր~Գեղարքունիք~Երևան~Լոռի~Կոտայք~Շիրակ~Սյունիք~Վայոց ձոր~Տավուշ\\\",\\n    sub_lnames:\\n      \\\"Aragatsotn~Ararat~Armavir~Gegharkunik~Yerevan~Lori~Kotayk~Shirak~Syunik~Vayots Dzor~Tavush\\\",\\n    sub_zipexs:\\n      \\\"0201,0514~0601,0823~0901,1149~1201,1626~0000,0099~1701,2117~2201,2506~2601,3126~3201,3519~3601,3810~3901,4216\\\",\\n    sub_zips:\\n      \\\"0[2-5]~0[6-8]~09|1[01]~1[2-6]~00~1[7-9]|2[01]~2[2-5]~2[6-9]|3[01]~3[2-5]~3[6-8]~39|4[0-2]\\\",\\n    zip: \\\"(?:37)?\\\\\\\\d{4}\\\",\\n    zipex: \\\"375010,0002,0010\\\",\\n  },\\n  \\\"data/AO\\\": { id: \\\"data/AO\\\", key: \\\"AO\\\", name: \\\"ANGOLA\\\" },\\n  \\\"data/AQ\\\": { id: \\\"data/AQ\\\", key: \\\"AQ\\\", name: \\\"ANTARCTICA\\\" },\\n  \\\"data/AR\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C%n%S\\\",\\n    id: \\\"data/AR\\\",\\n    key: \\\"AR\\\",\\n    lang: \\\"es\\\",\\n    languages: \\\"es\\\",\\n    name: \\\"ARGENTINA\\\",\\n    posturl: \\\"http://www.correoargentino.com.ar/formularios/cpa\\\",\\n    sub_isoids: \\\"B~K~H~U~C~X~W~E~P~Y~L~F~M~N~Q~R~A~J~D~Z~S~G~V~T\\\",\\n    sub_keys:\\n      \\\"Buenos Aires~Catamarca~Chaco~Chubut~Ciudad Autónoma de Buenos Aires~Córdoba~Corrientes~Entre Ríos~Formosa~Jujuy~La Pampa~La Rioja~Mendoza~Misiones~Neuquén~Río Negro~Salta~San Juan~San Luis~Santa Cruz~Santa Fe~Santiago del Estero~Tierra del Fuego~Tucumán\\\",\\n    sub_names:\\n      \\\"Buenos Aires~Catamarca~Chaco~Chubut~Ciudad Autónoma de Buenos Aires~Córdoba~Corrientes~Entre Ríos~Formosa~Jujuy~La Pampa~La Rioja~Mendoza~Misiones~Neuquén~Río Negro~Salta~San Juan~San Luis~Santa Cruz~Santa Fe~Santiago del Estero~Tierra del Fuego~Tucumán\\\",\\n    sub_zips:\\n      \\\"B?[1-36-8]~K?[45]~H?3~U?[89]~C?1~X?[235-8]~W?3~E?[1-3]~P?[37]~Y?4~L?[3568]~F?5~M?[56]~N?3~Q?[38]~R?[89]~A?[34]~J?5~D?[4-6]~Z?[89]~S?[2368]~G?[2-5]~V?9~T?[45]\\\",\\n    upper: \\\"ACZ\\\",\\n    zip: \\\"((?:[A-HJ-NP-Z])?\\\\\\\\d{4})([A-Z]{3})?\\\",\\n    zipex: \\\"C1070AAM,C1000WAM,B1000TBU,X5187XAB\\\",\\n  },\\n  \\\"data/AS\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %S %Z\\\",\\n    id: \\\"data/AS\\\",\\n    key: \\\"AS\\\",\\n    name: \\\"AMERICAN SAMOA\\\",\\n    posturl: \\\"http://zip4.usps.com/zip4/welcome.jsp\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"state\\\",\\n    upper: \\\"ACNOS\\\",\\n    zip: \\\"(96799)(?:[ \\\\\\\\-](\\\\\\\\d{4}))?\\\",\\n    zip_name_type: \\\"zip\\\",\\n    zipex: \\\"96799\\\",\\n  },\\n  \\\"data/AT\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%Z %C\\\",\\n    id: \\\"data/AT\\\",\\n    key: \\\"AT\\\",\\n    name: \\\"AUSTRIA\\\",\\n    posturl: \\\"http://www.post.at/post_subsite_postleitzahlfinder.php\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1010,3741\\\",\\n  },\\n  \\\"data/AU\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%C %S %Z\\\",\\n    id: \\\"data/AU\\\",\\n    key: \\\"AU\\\",\\n    lang: \\\"en\\\",\\n    languages: \\\"en\\\",\\n    locality_name_type: \\\"suburb\\\",\\n    name: \\\"AUSTRALIA\\\",\\n    posturl: \\\"http://www1.auspost.com.au/postcodes/\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"state\\\",\\n    sub_isoids: \\\"ACT~NSW~NT~QLD~SA~TAS~VIC~WA\\\",\\n    sub_keys: \\\"ACT~NSW~NT~QLD~SA~TAS~VIC~WA\\\",\\n    sub_names:\\n      \\\"Australian Capital Territory~New South Wales~Northern Territory~Queensland~South Australia~Tasmania~Victoria~Western Australia\\\",\\n    sub_zipexs:\\n      \\\"0200,2540,2618,2999~1000,2888,3585,3707~0800,0999~4000,9999~5000~7000,7999~3000,8000~6000,0872\\\",\\n    sub_zips:\\n      \\\"29|2540|260|261[0-8]|02|2620~1|2[0-57-8]|26[2-9]|261[189]|3500|358[56]|3644|3707~0[89]~[49]~5|0872~7~[38]~6|0872\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"2060,3171,6430,4000,4006,3001\\\",\\n  },\\n  \\\"data/AW\\\": { id: \\\"data/AW\\\", key: \\\"AW\\\", name: \\\"ARUBA\\\" },\\n  \\\"data/AZ\\\": {\\n    fmt: \\\"%N%n%O%n%A%nAZ %Z %C\\\",\\n    id: \\\"data/AZ\\\",\\n    key: \\\"AZ\\\",\\n    name: \\\"AZERBAIJAN\\\",\\n    postprefix: \\\"AZ \\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1000\\\",\\n  },\\n  \\\"data/BA\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/BA\\\",\\n    key: \\\"BA\\\",\\n    name: \\\"BOSNIA AND HERZEGOVINA\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"71000\\\",\\n  },\\n  \\\"data/BB\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C, %S %Z\\\",\\n    id: \\\"data/BB\\\",\\n    key: \\\"BB\\\",\\n    name: \\\"BARBADOS\\\",\\n    state_name_type: \\\"parish\\\",\\n    zip: \\\"BB\\\\\\\\d{5}\\\",\\n    zipex: \\\"BB23026,BB22025\\\",\\n  },\\n  \\\"data/BD\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C - %Z\\\",\\n    id: \\\"data/BD\\\",\\n    key: \\\"BD\\\",\\n    name: \\\"BANGLADESH\\\",\\n    posturl: \\\"http://www.bangladeshpost.gov.bd/PostCode.asp\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1340,1000\\\",\\n  },\\n  \\\"data/BE\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%Z %C\\\",\\n    id: \\\"data/BE\\\",\\n    key: \\\"BE\\\",\\n    name: \\\"BELGIUM\\\",\\n    posturl:\\n      \\\"http://www.post.be/site/nl/residential/customerservice/search/postal_codes.html\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"4000,1000\\\",\\n  },\\n  \\\"data/BF\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %X\\\",\\n    id: \\\"data/BF\\\",\\n    key: \\\"BF\\\",\\n    name: \\\"BURKINA FASO\\\",\\n  },\\n  \\\"data/BG\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/BG\\\",\\n    key: \\\"BG\\\",\\n    name: \\\"BULGARIA (REP.)\\\",\\n    posturl: \\\"http://www.bgpost.bg/?cid=5\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1000,1700\\\",\\n  },\\n  \\\"data/BH\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/BH\\\",\\n    key: \\\"BH\\\",\\n    name: \\\"BAHRAIN\\\",\\n    zip: \\\"(?:\\\\\\\\d|1[0-2])\\\\\\\\d{2}\\\",\\n    zipex: \\\"317\\\",\\n  },\\n  \\\"data/BI\\\": { id: \\\"data/BI\\\", key: \\\"BI\\\", name: \\\"BURUNDI\\\" },\\n  \\\"data/BJ\\\": { id: \\\"data/BJ\\\", key: \\\"BJ\\\", name: \\\"BENIN\\\", upper: \\\"AC\\\" },\\n  \\\"data/BL\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%Z %C %X\\\",\\n    id: \\\"data/BL\\\",\\n    key: \\\"BL\\\",\\n    name: \\\"SAINT BARTHELEMY\\\",\\n    posturl:\\n      \\\"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"ACX\\\",\\n    zip: \\\"9[78][01]\\\\\\\\d{2}\\\",\\n    zipex: \\\"97100\\\",\\n  },\\n  \\\"data/BM\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/BM\\\",\\n    key: \\\"BM\\\",\\n    name: \\\"BERMUDA\\\",\\n    posturl: \\\"http://www.landvaluation.bm/\\\",\\n    zip: \\\"[A-Z]{2} ?[A-Z0-9]{2}\\\",\\n    zipex: \\\"FL 07,HM GX,HM 12\\\",\\n  },\\n  \\\"data/BN\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/BN\\\",\\n    key: \\\"BN\\\",\\n    name: \\\"BRUNEI DARUSSALAM\\\",\\n    posturl: \\\"http://www.post.gov.bn/SitePages/postcodes.aspx\\\",\\n    zip: \\\"[A-Z]{2} ?\\\\\\\\d{4}\\\",\\n    zipex: \\\"BT2328,KA1131,BA1511\\\",\\n  },\\n  \\\"data/BO\\\": { id: \\\"data/BO\\\", key: \\\"BO\\\", name: \\\"BOLIVIA\\\", upper: \\\"AC\\\" },\\n  \\\"data/BQ\\\": {\\n    id: \\\"data/BQ\\\",\\n    key: \\\"BQ\\\",\\n    name: \\\"BONAIRE, SINT EUSTATIUS, AND SABA\\\",\\n  },\\n  \\\"data/BR\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%D%n%C-%S%n%Z\\\",\\n    id: \\\"data/BR\\\",\\n    key: \\\"BR\\\",\\n    lang: \\\"pt\\\",\\n    languages: \\\"pt\\\",\\n    name: \\\"BRAZIL\\\",\\n    posturl: \\\"http://www.buscacep.correios.com.br/\\\",\\n    require: \\\"ASCZ\\\",\\n    state_name_type: \\\"state\\\",\\n    sub_isoids:\\n      \\\"AC~AL~AP~AM~BA~CE~DF~ES~GO~MA~MT~MS~MG~PA~PB~PR~PE~PI~RJ~RN~RS~RO~RR~SC~SP~SE~TO\\\",\\n    sub_keys:\\n      \\\"AC~AL~AP~AM~BA~CE~DF~ES~GO~MA~MT~MS~MG~PA~PB~PR~PE~PI~RJ~RN~RS~RO~RR~SC~SP~SE~TO\\\",\\n    sub_mores:\\n      \\\"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\\\",\\n    sub_names:\\n      \\\"Acre~Alagoas~Amapá~Amazonas~Bahia~Ceará~Distrito Federal~Espírito Santo~Goiás~Maranhão~Mato Grosso~Mato Grosso do Sul~Minas Gerais~Pará~Paraíba~Paraná~Pernambuco~Piauí~Rio de Janeiro~Rio Grande do Norte~Rio Grande do Sul~Rondônia~Roraima~Santa Catarina~São Paulo~Sergipe~Tocantins\\\",\\n    sub_zipexs:\\n      \\\"69900-000,69999-999~57000-000,57999-999~68900-000,68999-999~69000-000,69400-123~40000-000,48999-999~60000-000,63999-999~70000-000,73500-123~29000-000,29999-999~72800-000,73700-123~65000-000,65999-999~78000-000,78899-999~79000-000,79999-999~30000-000,39999-999~66000-000,68899-999~58000-000,58999-999~80000-000,87999-999~50000-000,56999-999~64000-000,64999-999~20000-000,28999-999~59000-000,59999-999~90000-000,99999-999~76800-000,78900-000,78999-999~69300-000,69399-999~88000-000,89999-999~01000-000,13000-123~49000-000,49999-999~77000-000,77999-999\\\",\\n    sub_zips:\\n      \\\"699~57~689~69[0-24-8]~4[0-8]~6[0-3]~7[0-1]|72[0-7]|73[0-6]~29~72[89]|73[7-9]|7[4-6]~65~78[0-8]~79~3~6[6-7]|68[0-8]~58~8[0-7]~5[0-6]~64~2[0-8]~59~9~76[89]|789~693~8[89]~[01][1-9]~49~77\\\",\\n    sublocality_name_type: \\\"neighborhood\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{5}-?\\\\\\\\d{3}\\\",\\n    zipex: \\\"40301-110,70002-900\\\",\\n  },\\n  \\\"data/BS\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C, %S\\\",\\n    id: \\\"data/BS\\\",\\n    key: \\\"BS\\\",\\n    lang: \\\"en\\\",\\n    languages: \\\"en\\\",\\n    name: \\\"BAHAMAS\\\",\\n    state_name_type: \\\"island\\\",\\n    sub_isoids: \\\"~AK~~BY~BI~CI~~~EX~~HI~IN~LI~MG~~RI~RC~SS~SW\\\",\\n    sub_keys:\\n      \\\"Abaco~Acklins~Andros~Berry Islands~Bimini~Cat Island~Crooked Island~Eleuthera~Exuma~Grand Bahama~Harbour Island~Inagua~Long Island~Mayaguana~N.P.~Ragged Island~Rum Cay~San Salvador~Spanish Wells\\\",\\n    sub_names:\\n      \\\"Abaco Islands~Acklins~Andros Island~Berry Islands~Bimini~Cat Island~Crooked Island~Eleuthera~Exuma and Cays~Grand Bahama~Harbour Island~Inagua~Long Island~Mayaguana~New Providence~Ragged Island~Rum Cay~San Salvador~Spanish Wells\\\",\\n  },\\n  \\\"data/BT\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/BT\\\",\\n    key: \\\"BT\\\",\\n    name: \\\"BHUTAN\\\",\\n    posturl: \\\"http://www.bhutanpost.bt/postcodes/\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"11001,31101,35003\\\",\\n  },\\n  \\\"data/BV\\\": { id: \\\"data/BV\\\", key: \\\"BV\\\", name: \\\"BOUVET ISLAND\\\" },\\n  \\\"data/BW\\\": { id: \\\"data/BW\\\", key: \\\"BW\\\", name: \\\"BOTSWANA\\\" },\\n  \\\"data/BY\\\": {\\n    fmt: \\\"%S%n%Z %C%n%A%n%O%n%N\\\",\\n    id: \\\"data/BY\\\",\\n    key: \\\"BY\\\",\\n    name: \\\"BELARUS\\\",\\n    posturl: \\\"http://ex.belpost.by/addressbook/\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zipex: \\\"223016,225860,220050\\\",\\n  },\\n  \\\"data/BZ\\\": { id: \\\"data/BZ\\\", key: \\\"BZ\\\", name: \\\"BELIZE\\\" },\\n  \\\"data/CA\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %S %Z\\\",\\n    id: \\\"data/CA\\\",\\n    key: \\\"CA\\\",\\n    lang: \\\"en\\\",\\n    languages: \\\"en~fr\\\",\\n    name: \\\"CANADA\\\",\\n    posturl: \\\"https://www.canadapost.ca/cpo/mc/personal/postalcode/fpc.jsf\\\",\\n    require: \\\"ACSZ\\\",\\n    sub_isoids: \\\"AB~BC~MB~NB~NL~NT~NS~NU~ON~PE~QC~SK~YT\\\",\\n    sub_keys: \\\"AB~BC~MB~NB~NL~NT~NS~NU~ON~PE~QC~SK~YT\\\",\\n    sub_names:\\n      \\\"Alberta~British Columbia~Manitoba~New Brunswick~Newfoundland and Labrador~Northwest Territories~Nova Scotia~Nunavut~Ontario~Prince Edward Island~Quebec~Saskatchewan~Yukon\\\",\\n    sub_zips:\\n      \\\"T~V~R~E~A~X0E|X0G|X1A~B~X0A|X0B|X0C~K|L|M|N|P~C~G|H|J|K1A~S|R8A~Y\\\",\\n    upper: \\\"ACNOSZ\\\",\\n    zip: \\\"[ABCEGHJKLMNPRSTVXY]\\\\\\\\d[ABCEGHJ-NPRSTV-Z] ?\\\\\\\\d[ABCEGHJ-NPRSTV-Z]\\\\\\\\d\\\",\\n    zipex: \\\"H3Z 2Y7,V8X 3X4,T0L 1K0,T0H 1A0,K1A 0B1\\\",\\n  },\\n  \\\"data/CA--fr\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %S %Z\\\",\\n    id: \\\"data/CA--fr\\\",\\n    key: \\\"CA\\\",\\n    lang: \\\"fr\\\",\\n    name: \\\"CANADA\\\",\\n    posturl: \\\"https://www.canadapost.ca/cpo/mc/personal/postalcode/fpc.jsf\\\",\\n    require: \\\"ACSZ\\\",\\n    sub_isoids: \\\"AB~BC~PE~MB~NB~NS~NU~ON~QC~SK~NL~NT~YT\\\",\\n    sub_keys: \\\"AB~BC~PE~MB~NB~NS~NU~ON~QC~SK~NL~NT~YT\\\",\\n    sub_names:\\n      \\\"Alberta~Colombie-Britannique~Île-du-Prince-Édouard~Manitoba~Nouveau-Brunswick~Nouvelle-Écosse~Nunavut~Ontario~Québec~Saskatchewan~Terre-Neuve-et-Labrador~Territoires du Nord-Ouest~Yukon\\\",\\n    sub_zips:\\n      \\\"T~V~C~R~E~B~X0A|X0B|X0C~K|L|M|N|P~G|H|J|K1A~S|R8A~A~X0E|X0G|X1A~Y\\\",\\n    upper: \\\"ACNOSZ\\\",\\n    zip: \\\"[ABCEGHJKLMNPRSTVXY]\\\\\\\\d[ABCEGHJ-NPRSTV-Z] ?\\\\\\\\d[ABCEGHJ-NPRSTV-Z]\\\\\\\\d\\\",\\n    zipex: \\\"H3Z 2Y7,V8X 3X4,T0L 1K0,T0H 1A0,K1A 0B1\\\",\\n  },\\n  \\\"data/CC\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%C %S %Z\\\",\\n    id: \\\"data/CC\\\",\\n    key: \\\"CC\\\",\\n    name: \\\"COCOS (KEELING) ISLANDS\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"6799\\\",\\n    zipex: \\\"6799\\\",\\n  },\\n  \\\"data/CD\\\": { id: \\\"data/CD\\\", key: \\\"CD\\\", name: \\\"CONGO (DEM. REP.)\\\" },\\n  \\\"data/CF\\\": { id: \\\"data/CF\\\", key: \\\"CF\\\", name: \\\"CENTRAL AFRICAN REPUBLIC\\\" },\\n  \\\"data/CG\\\": { id: \\\"data/CG\\\", key: \\\"CG\\\", name: \\\"CONGO (REP.)\\\" },\\n  \\\"data/CH\\\": {\\n    fmt: \\\"%O%n%N%n%A%nCH-%Z %C\\\",\\n    id: \\\"data/CH\\\",\\n    key: \\\"CH\\\",\\n    name: \\\"SWITZERLAND\\\",\\n    postprefix: \\\"CH-\\\",\\n    posturl: \\\"http://www.post.ch/db/owa/pv_plz_pack/pr_main\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"2544,1211,1556,3030\\\",\\n  },\\n  \\\"data/CI\\\": {\\n    fmt: \\\"%N%n%O%n%X %A %C %X\\\",\\n    id: \\\"data/CI\\\",\\n    key: \\\"CI\\\",\\n    name: \\\"COTE D'IVOIRE\\\",\\n  },\\n  \\\"data/CK\\\": { id: \\\"data/CK\\\", key: \\\"CK\\\", name: \\\"COOK ISLANDS\\\" },\\n  \\\"data/CL\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C%n%S\\\",\\n    id: \\\"data/CL\\\",\\n    key: \\\"CL\\\",\\n    lang: \\\"es\\\",\\n    languages: \\\"es\\\",\\n    name: \\\"CHILE\\\",\\n    posturl: \\\"http://www.correos.cl/SitePages/home.aspx\\\",\\n    sub_isoids: \\\"AN~AR~AP~AT~AI~BI~CO~LI~LL~LR~MA~ML~RM~TA~VS\\\",\\n    sub_keys:\\n      \\\"Antofagasta~Araucanía~Arica y Parinacota~Atacama~Aysén~Biobío~Coquimbo~O'Higgins~Los Lagos~Los Ríos~Magallanes~Maule~Región Metropolitana~Tarapacá~Valparaíso\\\",\\n    sub_mores:\\n      \\\"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\\\",\\n    sub_names:\\n      \\\"Antofagasta~Araucanía~Arica y Parinacota~Atacama~Aysén del General Carlos Ibáñez del Campo~Biobío~Coquimbo~Libertador General Bernardo O'Higgins~Los Lagos~Los Ríos~Magallanes y de la Antártica Chilena~Maule~Metropolitana de Santiago~Tarapacá~Valparaíso\\\",\\n    zip: \\\"\\\\\\\\d{7}\\\",\\n    zipex: \\\"8340457,8720019,1230000,8329100\\\",\\n  },\\n  \\\"data/CM\\\": { id: \\\"data/CM\\\", key: \\\"CM\\\", name: \\\"CAMEROON\\\" },\\n  \\\"data/CN\\\": {\\n    fmt: \\\"%Z%n%S%C%D%n%A%n%O%n%N\\\",\\n    id: \\\"data/CN\\\",\\n    key: \\\"CN\\\",\\n    lang: \\\"zh\\\",\\n    languages: \\\"zh\\\",\\n    lfmt: \\\"%N%n%O%n%A%n%D%n%C%n%S, %Z\\\",\\n    name: \\\"CHINA\\\",\\n    posturl: \\\"http://www.ems.com.cn/serviceguide/you_bian_cha_xun.html\\\",\\n    require: \\\"ACSZ\\\",\\n    sub_isoids:\\n      \\\"34~92~11~50~35~62~44~45~52~46~13~41~23~42~43~22~32~36~21~15~64~63~37~14~61~31~51~71~12~54~91~65~53~33\\\",\\n    sub_keys:\\n      \\\"安徽省~澳门~北京市~重庆市~福建省~甘肃省~广东省~广西壮族自治区~贵州省~海南省~河北省~河南省~黑龙江省~湖北省~湖南省~吉林省~江苏省~江西省~辽宁省~内蒙古自治区~宁夏回族自治区~青海省~山东省~山西省~陕西省~上海市~四川省~台湾~天津市~西藏自治区~香港~新疆维吾尔自治区~云南省~浙江省\\\",\\n    sub_lnames:\\n      \\\"Anhui Sheng~Macau~Beijing Shi~Chongqing Shi~Fujian Sheng~Gansu Sheng~Guangdong Sheng~Guangxi Zhuangzuzizhiqu~Guizhou Sheng~Hainan Sheng~Hebei Sheng~Henan Sheng~Heilongjiang Sheng~Hubei Sheng~Hunan Sheng~Jilin Sheng~Jiangsu Sheng~Jiangxi Sheng~Liaoning Sheng~Neimenggu Zizhiqu~Ningxia Huizuzizhiqu~Qinghai Sheng~Shandong Sheng~Shanxi Sheng~Shaanxi Sheng~Shanghai Shi~Sichuan Sheng~Taiwan~Tianjin Shi~Xizang Zizhiqu~Hong Kong~Xinjiang Weiwuerzizhiqu~Yunnan Sheng~Zhejiang Sheng\\\",\\n    sub_mores:\\n      \\\"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\\\",\\n    sub_names:\\n      \\\"安徽省~澳门~北京市~重庆市~福建省~甘肃省~广东省~广西~贵州省~海南省~河北省~河南省~黑龙江省~湖北省~湖南省~吉林省~江苏省~江西省~辽宁省~内蒙古~宁夏~青海省~山东省~山西省~陕西省~上海市~四川省~台湾~天津市~西藏~香港~新疆~云南省~浙江省\\\",\\n    sub_xrequires: \\\"~A~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ACS~~~\\\",\\n    sub_xzips: \\\"~999078~~~~~~~~~~~~~~~~~~~~~~~~~~\\\\\\\\d{3}(\\\\\\\\d{2})?~~~999077~~~\\\",\\n    sublocality_name_type: \\\"district\\\",\\n    upper: \\\"S\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zipex: \\\"266033,317204,100096,100808\\\",\\n  },\\n  \\\"data/CO\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C, %S, %Z\\\",\\n    id: \\\"data/CO\\\",\\n    key: \\\"CO\\\",\\n    name: \\\"COLOMBIA\\\",\\n    posturl: \\\"http://www.codigopostal.gov.co/\\\",\\n    require: \\\"AS\\\",\\n    state_name_type: \\\"department\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zipex: \\\"111221,130001,760011\\\",\\n  },\\n  \\\"data/CR\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%S, %C%n%Z\\\",\\n    id: \\\"data/CR\\\",\\n    key: \\\"CR\\\",\\n    name: \\\"COSTA RICA\\\",\\n    posturl: \\\"https://www.correos.go.cr/nosotros/codigopostal/busqueda.html\\\",\\n    require: \\\"ACS\\\",\\n    zip: \\\"\\\\\\\\d{4,5}|\\\\\\\\d{3}-\\\\\\\\d{4}\\\",\\n    zipex: \\\"1000,2010,1001\\\",\\n  },\\n  \\\"data/CU\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %S%n%Z\\\",\\n    id: \\\"data/CU\\\",\\n    key: \\\"CU\\\",\\n    lang: \\\"es\\\",\\n    languages: \\\"es\\\",\\n    name: \\\"CUBA\\\",\\n    sub_isoids: \\\"15~09~08~06~12~14~11~99~03~10~04~16~01~07~13~05\\\",\\n    sub_keys:\\n      \\\"Artemisa~Camagüey~Ciego de Ávila~Cienfuegos~Granma~Guantánamo~Holguín~Isla de la Juventud~La Habana~Las Tunas~Matanzas~Mayabeque~Pinar del Río~Sancti Spíritus~Santiago de Cuba~Villa Clara\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"10700\\\",\\n  },\\n  \\\"data/CV\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C%n%S\\\",\\n    id: \\\"data/CV\\\",\\n    key: \\\"CV\\\",\\n    lang: \\\"pt\\\",\\n    languages: \\\"pt\\\",\\n    name: \\\"CAPE VERDE\\\",\\n    state_name_type: \\\"island\\\",\\n    sub_isoids: \\\"BV~BR~~MA~SL~~~~SV\\\",\\n    sub_keys:\\n      \\\"Boa Vista~Brava~Fogo~Maio~Sal~Santiago~Santo Antão~São Nicolau~São Vicente\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"7600\\\",\\n  },\\n  \\\"data/CW\\\": { id: \\\"data/CW\\\", key: \\\"CW\\\", name: \\\"CURACAO\\\" },\\n  \\\"data/CX\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%C %S %Z\\\",\\n    id: \\\"data/CX\\\",\\n    key: \\\"CX\\\",\\n    name: \\\"CHRISTMAS ISLAND\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"6798\\\",\\n    zipex: \\\"6798\\\",\\n  },\\n  \\\"data/CY\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/CY\\\",\\n    key: \\\"CY\\\",\\n    name: \\\"CYPRUS\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"2008,3304,1900\\\",\\n  },\\n  \\\"data/CZ\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/CZ\\\",\\n    key: \\\"CZ\\\",\\n    name: \\\"CZECH REP.\\\",\\n    posturl: \\\"http://psc.ceskaposta.cz/CleanForm.action\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{3} ?\\\\\\\\d{2}\\\",\\n    zipex: \\\"100 00,251 66,530 87,110 00,225 99\\\",\\n  },\\n  \\\"data/DE\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/DE\\\",\\n    key: \\\"DE\\\",\\n    name: \\\"GERMANY\\\",\\n    posturl: \\\"http://www.postdirekt.de/plzserver/\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"26133,53225\\\",\\n  },\\n  \\\"data/DJ\\\": { id: \\\"data/DJ\\\", key: \\\"DJ\\\", name: \\\"DJIBOUTI\\\" },\\n  \\\"data/DK\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/DK\\\",\\n    key: \\\"DK\\\",\\n    name: \\\"DENMARK\\\",\\n    posturl:\\n      \\\"http://www.postdanmark.dk/da/Privat/Kundeservice/postnummerkort/Sider/Find-postnummer.aspx\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"8660,1566\\\",\\n  },\\n  \\\"data/DM\\\": { id: \\\"data/DM\\\", key: \\\"DM\\\", name: \\\"DOMINICA\\\" },\\n  \\\"data/DO\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/DO\\\",\\n    key: \\\"DO\\\",\\n    name: \\\"DOMINICAN REP.\\\",\\n    posturl: \\\"http://inposdom.gob.do/codigo-postal/\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"11903,10101\\\",\\n  },\\n  \\\"data/DZ\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/DZ\\\",\\n    key: \\\"DZ\\\",\\n    name: \\\"ALGERIA\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"40304,16027\\\",\\n  },\\n  \\\"data/EC\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z%n%C\\\",\\n    id: \\\"data/EC\\\",\\n    key: \\\"EC\\\",\\n    name: \\\"ECUADOR\\\",\\n    posturl: \\\"http://www.codigopostal.gob.ec/\\\",\\n    upper: \\\"CZ\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zipex: \\\"090105,092301\\\",\\n  },\\n  \\\"data/EE\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/EE\\\",\\n    key: \\\"EE\\\",\\n    name: \\\"ESTONIA\\\",\\n    posturl: \\\"https://www.omniva.ee/era/sihtnumbrite_otsing\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"69501,11212\\\",\\n  },\\n  \\\"data/EG\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%S%n%Z\\\",\\n    id: \\\"data/EG\\\",\\n    key: \\\"EG\\\",\\n    lang: \\\"ar\\\",\\n    languages: \\\"ar\\\",\\n    lfmt: \\\"%N%n%O%n%A%n%C%n%S%n%Z\\\",\\n    name: \\\"EGYPT\\\",\\n    sub_isoids:\\n      \\\"ASN~AST~ALX~IS~LX~BA~BH~GZ~DK~SUZ~SHR~GH~FYM~C~KB~MNF~MN~WAD~BNS~PTS~JS~DT~SHG~SIN~KN~KFS~MT\\\",\\n    sub_keys:\\n      \\\"أسوان~أسيوط~الإسكندرية~الإسماعيلية~الأقصر~البحر الأحمر~البحيرة~الجيزة~الدقهلية~السويس~الشرقية~الغربية~الفيوم~القاهرة~القليوبية~المنوفية~المنيا~الوادي الجديد~بني سويف~بورسعيد~جنوب سيناء~دمياط~سوهاج~شمال سيناء~قنا~كفر الشيخ~مطروح\\\",\\n    sub_lnames:\\n      \\\"Aswan Governorate~Asyut Governorate~Alexandria Governorate~Ismailia Governorate~Luxor Governorate~Red Sea Governorate~El Beheira Governorate~Giza Governorate~Dakahlia Governorate~Suez Governorate~Ash Sharqia Governorate~Gharbia Governorate~Faiyum Governorate~Cairo Governorate~Qalyubia Governorate~Menofia Governorate~Menia Governorate~New Valley Governorate~Beni Suef Governorate~Port Said Governorate~South Sinai Governorate~Damietta Governorate~Sohag Governorate~North Sinai Governorate~Qena Governorate~Kafr El Sheikh Governorate~Matrouh Governorate\\\",\\n    sub_zipexs:\\n      \\\"81000~71000~21000,23000~41000~85000~84000~22000~12000~35000~43000~44000~31000~63000~11000~13000~32000~61000~72000~62000~42000~46000~34000~82000~45000~83000~33000~51000\\\",\\n    sub_zips:\\n      \\\"81~71~2[13]~41~85~84~22~12~35~43~44~31~63~11~13~32~61~72~62~42~46~34~82~45~83~33~51\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"12411,11599\\\",\\n  },\\n  \\\"data/EH\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/EH\\\",\\n    key: \\\"EH\\\",\\n    name: \\\"WESTERN SAHARA\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"70000,72000\\\",\\n  },\\n  \\\"data/ER\\\": { id: \\\"data/ER\\\", key: \\\"ER\\\", name: \\\"ERITREA\\\" },\\n  \\\"data/ES\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C %S\\\",\\n    id: \\\"data/ES\\\",\\n    key: \\\"ES\\\",\\n    lang: \\\"es\\\",\\n    languages: \\\"es~ca~gl~eu\\\",\\n    name: \\\"SPAIN\\\",\\n    posturl:\\n      \\\"http://www.correos.es/contenido/13-MenuRec2/04-MenuRec24/1010_s-CodPostal.asp\\\",\\n    require: \\\"ACSZ\\\",\\n    sub_keys:\\n      \\\"VI~AB~A~AL~O~AV~BA~B~BU~CC~CA~S~CS~CE~CR~CO~CU~GI~GR~GU~SS~H~HU~PM~J~C~LO~GC~LE~L~LU~M~MA~ML~MU~NA~OR~P~PO~SA~TF~SG~SE~SO~T~TE~TO~V~VA~BI~ZA~Z\\\",\\n    sub_names:\\n      \\\"Álava~Albacete~Alicante~Almería~Asturias~Ávila~Badajoz~Barcelona~Burgos~Cáceres~Cádiz~Cantabria~Castellón~Ceuta~Ciudad Real~Córdoba~Cuenca~Girona~Granada~Guadalajara~Guipúzcoa~Huelva~Huesca~Islas Baleares~Jaén~La Coruña~La Rioja~Las Palmas~León~Lérida~Lugo~Madrid~Málaga~Melilla~Murcia~Navarra~Ourense~Palencia~Pontevedra~Salamanca~Santa Cruz de Tenerife~Segovia~Sevilla~Soria~Tarragona~Teruel~Toledo~Valencia~Valladolid~Vizcaya~Zamora~Zaragoza\\\",\\n    sub_zips:\\n      \\\"01~02~03~04~33~05~06~08~09~10~11~39~12~51~13~14~16~17~18~19~20~21~22~07~23~15~26~35~24~25~27~28~29~52~30~31~32~34~36~37~38~40~41~42~43~44~45~46~47~48~49~50\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"28039,28300,28070\\\",\\n  },\\n  \\\"data/ES--ca\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C %S\\\",\\n    id: \\\"data/ES--ca\\\",\\n    key: \\\"ES\\\",\\n    lang: \\\"ca\\\",\\n    name: \\\"SPAIN\\\",\\n    posturl:\\n      \\\"http://www.correos.es/contenido/13-MenuRec2/04-MenuRec24/1010_s-CodPostal.asp\\\",\\n    require: \\\"ACSZ\\\",\\n    sub_keys:\\n      \\\"A~AB~AL~VI~O~AV~BA~B~BI~BU~CC~CA~S~CS~CE~CR~CO~CU~GI~GR~GU~SS~H~HU~PM~J~C~LO~GC~LE~L~LU~M~MA~ML~MU~NA~OR~P~PO~SA~TF~SG~SE~SO~T~TE~TO~V~VA~ZA~Z\\\",\\n    sub_names:\\n      \\\"Alacant~Albacete~Almeria~Araba~Asturias~Àvila~Badajoz~Barcelona~Bizkaia~Burgos~Cáceres~Cadis~Cantabria~Castelló~Ceuta~Ciudad Real~Córdoba~Cuenca~Girona~Granada~Guadalajara~Guipúscoa~Huelva~Huesca~Illes Balears~Jaén~La Corunya~La Rioja~Las Palmas~León~Lleida~Lugo~Madrid~Málaga~Melilla~Murcia~Navarra~Ourense~Palencia~Pontevedra~Salamanca~Santa Cruz de Tenerife~Segovia~Sevilla~Soria~Tarragona~Teruel~Toledo~València~Valladolid~Zamora~Zaragoza\\\",\\n    sub_zips:\\n      \\\"03~02~04~01~33~05~06~08~48~09~10~11~39~12~51~13~14~16~17~18~19~20~21~22~07~23~15~26~35~24~25~27~28~29~52~30~31~32~34~36~37~38~40~41~42~43~44~45~46~47~49~50\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"28039,28300,28070\\\",\\n  },\\n  \\\"data/ES--eu\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C %S\\\",\\n    id: \\\"data/ES--eu\\\",\\n    key: \\\"ES\\\",\\n    lang: \\\"eu\\\",\\n    name: \\\"SPAIN\\\",\\n    posturl:\\n      \\\"http://www.correos.es/contenido/13-MenuRec2/04-MenuRec24/1010_s-CodPostal.asp\\\",\\n    require: \\\"ACSZ\\\",\\n    sub_keys:\\n      \\\"A~AB~AL~VI~O~AV~BA~B~BI~BU~CC~CA~S~CS~CE~CR~C~CU~SS~GI~GR~GU~H~HU~PM~J~CO~LO~GC~LE~L~LU~M~MA~ML~MU~NA~OR~P~PO~SA~TF~SG~SE~SO~T~TE~TO~V~VA~ZA~Z\\\",\\n    sub_names:\\n      \\\"Alacant~Albacete~Almería~Araba~Asturias~Ávila~Badajoz~Barcelona~Bizkaia~Burgos~Cáceres~Cádiz~Cantabria~Castelló~Ceuta~Ciudad Real~Coruña~Cuenca~Gipuzkoa~Girona~Granada~Guadalajara~Huelva~Huesca~Illes Balears~Jaén~Kordoba~La Rioja~Las Palmas~León~Lleida~Lugo~Madrid~Málaga~Melilla~Murtzia~Nafarroa~Ourense~Palentzia~Pontevedra~Salamanca~Santa Cruz Tenerifekoa~Segovia~Sevilla~Soria~Tarragona~Teruel~Toledo~Valentzia~Valladolid~Zamora~Zaragoza\\\",\\n    sub_zips:\\n      \\\"03~02~04~01~33~05~06~08~48~09~10~11~39~12~51~13~15~16~20~17~18~19~21~22~07~23~14~26~35~24~25~27~28~29~52~30~31~32~34~36~37~38~40~41~42~43~44~45~46~47~49~50\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"28039,28300,28070\\\",\\n  },\\n  \\\"data/ES--gl\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C %S\\\",\\n    id: \\\"data/ES--gl\\\",\\n    key: \\\"ES\\\",\\n    lang: \\\"gl\\\",\\n    name: \\\"SPAIN\\\",\\n    posturl:\\n      \\\"http://www.correos.es/contenido/13-MenuRec2/04-MenuRec24/1010_s-CodPostal.asp\\\",\\n    require: \\\"ACSZ\\\",\\n    sub_keys:\\n      \\\"C~A~VI~AB~AL~GC~O~AV~BA~B~BI~BU~CC~CA~S~CS~CE~CR~CO~CU~GR~GU~SS~H~HU~PM~LO~LE~L~LU~M~MA~ML~MU~NA~OR~P~PO~SA~TF~SG~SE~SO~T~TE~TO~V~VA~J~GI~ZA~Z\\\",\\n    sub_names:\\n      \\\"A Coruña~Alacant~Álava~Albacete~Almería~As Palmas~Asturias~Ávila~Badaxoz~Barcelona~Biscaia~Burgos~Cáceres~Cádiz~Cantabria~Castelló~Ceuta~Cidade Real~Córdoba~Cuenca~Granada~Guadalajara~Guipúscoa~Huelva~Huesca~Illas Baleares~La Rioja~León~Lleida~Lugo~Madrid~Málaga~Melilla~Murcia~Navarra~Ourense~Palencia~Pontevedra~Salamanca~Santa Cruz de Tenerife~Segovia~Sevilla~Soria~Tarragona~Teruel~Toledo~Valencia~Valladolid~Xaén~Xirona~Zamora~Zaragoza\\\",\\n    sub_zips:\\n      \\\"15~03~01~02~04~35~33~05~06~08~48~09~10~11~39~12~51~13~14~16~18~19~20~21~22~07~26~24~25~27~28~29~52~30~31~32~34~36~37~38~40~41~42~43~44~45~46~47~23~17~49~50\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"28039,28300,28070\\\",\\n  },\\n  \\\"data/ET\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/ET\\\",\\n    key: \\\"ET\\\",\\n    name: \\\"ETHIOPIA\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1000\\\",\\n  },\\n  \\\"data/FI\\\": {\\n    fmt: \\\"%O%n%N%n%A%nFI-%Z %C\\\",\\n    id: \\\"data/FI\\\",\\n    key: \\\"FI\\\",\\n    name: \\\"FINLAND\\\",\\n    postprefix: \\\"FI-\\\",\\n    posturl: \\\"http://www.verkkoposti.com/e3/postinumeroluettelo\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"00550,00011\\\",\\n  },\\n  \\\"data/FJ\\\": { id: \\\"data/FJ\\\", key: \\\"FJ\\\", name: \\\"FIJI\\\" },\\n  \\\"data/FK\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%Z\\\",\\n    id: \\\"data/FK\\\",\\n    key: \\\"FK\\\",\\n    name: \\\"FALKLAND ISLANDS (MALVINAS)\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"CZ\\\",\\n    zip: \\\"FIQQ 1ZZ\\\",\\n    zipex: \\\"FIQQ 1ZZ\\\",\\n  },\\n  \\\"data/FM\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %S %Z\\\",\\n    id: \\\"data/FM\\\",\\n    key: \\\"FM\\\",\\n    name: \\\"MICRONESIA (Federated State of)\\\",\\n    posturl: \\\"http://zip4.usps.com/zip4/welcome.jsp\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"state\\\",\\n    upper: \\\"ACNOS\\\",\\n    zip: \\\"(9694[1-4])(?:[ \\\\\\\\-](\\\\\\\\d{4}))?\\\",\\n    zip_name_type: \\\"zip\\\",\\n    zipex: \\\"96941,96944\\\",\\n  },\\n  \\\"data/FO\\\": {\\n    fmt: \\\"%N%n%O%n%A%nFO%Z %C\\\",\\n    id: \\\"data/FO\\\",\\n    key: \\\"FO\\\",\\n    name: \\\"FAROE ISLANDS\\\",\\n    postprefix: \\\"FO\\\",\\n    posturl: \\\"http://www.postur.fo/\\\",\\n    zip: \\\"\\\\\\\\d{3}\\\",\\n    zipex: \\\"100\\\",\\n  },\\n  \\\"data/FR\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%Z %C %X\\\",\\n    id: \\\"data/FR\\\",\\n    key: \\\"FR\\\",\\n    name: \\\"FRANCE\\\",\\n    posturl:\\n      \\\"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"CX\\\",\\n    zip: \\\"\\\\\\\\d{2} ?\\\\\\\\d{3}\\\",\\n    zipex: \\\"33380,34092,33506\\\",\\n  },\\n  \\\"data/GA\\\": { id: \\\"data/GA\\\", key: \\\"GA\\\", name: \\\"GABON\\\" },\\n  \\\"data/GB\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%Z\\\",\\n    id: \\\"data/GB\\\",\\n    key: \\\"GB\\\",\\n    locality_name_type: \\\"post_town\\\",\\n    name: \\\"UNITED KINGDOM\\\",\\n    posturl: \\\"http://www.royalmail.com/postcode-finder\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"CZ\\\",\\n    zip: \\\"GIR ?0AA|(?:(?:AB|AL|B|BA|BB|BD|BF|BH|BL|BN|BR|BS|BT|BX|CA|CB|CF|CH|CM|CO|CR|CT|CV|CW|DA|DD|DE|DG|DH|DL|DN|DT|DY|E|EC|EH|EN|EX|FK|FY|G|GL|GY|GU|HA|HD|HG|HP|HR|HS|HU|HX|IG|IM|IP|IV|JE|KA|KT|KW|KY|L|LA|LD|LE|LL|LN|LS|LU|M|ME|MK|ML|N|NE|NG|NN|NP|NR|NW|OL|OX|PA|PE|PH|PL|PO|PR|RG|RH|RM|S|SA|SE|SG|SK|SL|SM|SN|SO|SP|SR|SS|ST|SW|SY|TA|TD|TF|TN|TQ|TR|TS|TW|UB|W|WA|WC|WD|WF|WN|WR|WS|WV|YO|ZE)(?:\\\\\\\\d[\\\\\\\\dA-Z]? ?\\\\\\\\d[ABD-HJLN-UW-Z]{2}))|BFPO ?\\\\\\\\d{1,4}\\\",\\n    zipex:\\n      \\\"EC1Y 8SY,GIR 0AA,M2 5BQ,M34 4AB,CR0 2YR,DN16 9AA,W1A 4ZZ,EC1A 1HQ,OX14 4PG,BS18 8HF,NR25 7HG,RH6 0NP,BH23 6AA,B6 5BA,SO23 9AP,PO1 3AX,BFPO 61\\\",\\n  },\\n  \\\"data/GD\\\": { id: \\\"data/GD\\\", key: \\\"GD\\\", name: \\\"GRENADA (WEST INDIES)\\\" },\\n  \\\"data/GE\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/GE\\\",\\n    key: \\\"GE\\\",\\n    name: \\\"GEORGIA\\\",\\n    posturl: \\\"http://www.georgianpost.ge/index.php?page=10\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"0101\\\",\\n  },\\n  \\\"data/GF\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%Z %C %X\\\",\\n    id: \\\"data/GF\\\",\\n    key: \\\"GF\\\",\\n    name: \\\"FRENCH GUIANA\\\",\\n    posturl:\\n      \\\"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"ACX\\\",\\n    zip: \\\"9[78]3\\\\\\\\d{2}\\\",\\n    zipex: \\\"97300\\\",\\n  },\\n  \\\"data/GG\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%nGUERNSEY%n%Z\\\",\\n    id: \\\"data/GG\\\",\\n    key: \\\"GG\\\",\\n    name: \\\"CHANNEL ISLANDS\\\",\\n    posturl: \\\"http://www.guernseypost.com/postcode_finder/\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"CZ\\\",\\n    zip: \\\"GY\\\\\\\\d[\\\\\\\\dA-Z]? ?\\\\\\\\d[ABD-HJLN-UW-Z]{2}\\\",\\n    zipex: \\\"GY1 1AA,GY2 2BT\\\",\\n  },\\n  \\\"data/GH\\\": { id: \\\"data/GH\\\", key: \\\"GH\\\", name: \\\"GHANA\\\" },\\n  \\\"data/GI\\\": {\\n    fmt: \\\"%N%n%O%n%A%nGIBRALTAR%n%Z\\\",\\n    id: \\\"data/GI\\\",\\n    key: \\\"GI\\\",\\n    name: \\\"GIBRALTAR\\\",\\n    require: \\\"A\\\",\\n    zip: \\\"GX11 1AA\\\",\\n    zipex: \\\"GX11 1AA\\\",\\n  },\\n  \\\"data/GL\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/GL\\\",\\n    key: \\\"GL\\\",\\n    name: \\\"GREENLAND\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"39\\\\\\\\d{2}\\\",\\n    zipex: \\\"3900,3950,3911\\\",\\n  },\\n  \\\"data/GM\\\": { id: \\\"data/GM\\\", key: \\\"GM\\\", name: \\\"GAMBIA\\\" },\\n  \\\"data/GN\\\": {\\n    fmt: \\\"%N%n%O%n%Z %A %C\\\",\\n    id: \\\"data/GN\\\",\\n    key: \\\"GN\\\",\\n    name: \\\"GUINEA\\\",\\n    zip: \\\"\\\\\\\\d{3}\\\",\\n    zipex: \\\"001,200,100\\\",\\n  },\\n  \\\"data/GP\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%Z %C %X\\\",\\n    id: \\\"data/GP\\\",\\n    key: \\\"GP\\\",\\n    name: \\\"GUADELOUPE\\\",\\n    posturl:\\n      \\\"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"ACX\\\",\\n    zip: \\\"9[78][01]\\\\\\\\d{2}\\\",\\n    zipex: \\\"97100\\\",\\n  },\\n  \\\"data/GQ\\\": { id: \\\"data/GQ\\\", key: \\\"GQ\\\", name: \\\"EQUATORIAL GUINEA\\\" },\\n  \\\"data/GR\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/GR\\\",\\n    key: \\\"GR\\\",\\n    name: \\\"GREECE\\\",\\n    posturl: \\\"http://www.elta.gr/findapostcode.aspx\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{3} ?\\\\\\\\d{2}\\\",\\n    zipex: \\\"151 24,151 10,101 88\\\",\\n  },\\n  \\\"data/GS\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%n%C%n%Z\\\",\\n    id: \\\"data/GS\\\",\\n    key: \\\"GS\\\",\\n    name: \\\"SOUTH GEORGIA\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"CZ\\\",\\n    zip: \\\"SIQQ 1ZZ\\\",\\n    zipex: \\\"SIQQ 1ZZ\\\",\\n  },\\n  \\\"data/GT\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z- %C\\\",\\n    id: \\\"data/GT\\\",\\n    key: \\\"GT\\\",\\n    name: \\\"GUATEMALA\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"09001,01501\\\",\\n  },\\n  \\\"data/GU\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/GU\\\",\\n    key: \\\"GU\\\",\\n    name: \\\"GUAM\\\",\\n    posturl: \\\"http://zip4.usps.com/zip4/welcome.jsp\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"ACNO\\\",\\n    zip: \\\"(969(?:[12]\\\\\\\\d|3[12]))(?:[ \\\\\\\\-](\\\\\\\\d{4}))?\\\",\\n    zip_name_type: \\\"zip\\\",\\n    zipex: \\\"96910,96931\\\",\\n  },\\n  \\\"data/GW\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/GW\\\",\\n    key: \\\"GW\\\",\\n    name: \\\"GUINEA-BISSAU\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1000,1011\\\",\\n  },\\n  \\\"data/GY\\\": { id: \\\"data/GY\\\", key: \\\"GY\\\", name: \\\"GUYANA\\\" },\\n  \\\"data/HK\\\": {\\n    fmt: \\\"%S%n%C%n%A%n%O%n%N\\\",\\n    id: \\\"data/HK\\\",\\n    key: \\\"HK\\\",\\n    lang: \\\"zh-Hant\\\",\\n    languages: \\\"zh-Hant~en\\\",\\n    lfmt: \\\"%N%n%O%n%A%n%C%n%S\\\",\\n    locality_name_type: \\\"district\\\",\\n    name: \\\"HONG KONG\\\",\\n    require: \\\"AS\\\",\\n    state_name_type: \\\"area\\\",\\n    sub_keys: \\\"Kowloon~Hong Kong Island~New Territories\\\",\\n    sub_mores: \\\"true~true~true\\\",\\n    sub_names: \\\"九龍~香港島~新界\\\",\\n    upper: \\\"S\\\",\\n  },\\n  \\\"data/HK--en\\\": {\\n    fmt: \\\"%S%n%C%n%A%n%O%n%N\\\",\\n    id: \\\"data/HK--en\\\",\\n    key: \\\"HK\\\",\\n    lang: \\\"en\\\",\\n    lfmt: \\\"%N%n%O%n%A%n%C%n%S\\\",\\n    locality_name_type: \\\"district\\\",\\n    name: \\\"HONG KONG\\\",\\n    require: \\\"AS\\\",\\n    state_name_type: \\\"area\\\",\\n    sub_keys: \\\"Hong Kong Island~Kowloon~New Territories\\\",\\n    sub_lnames: \\\"Hong Kong Island~Kowloon~New Territories\\\",\\n    sub_mores: \\\"true~true~true\\\",\\n    upper: \\\"S\\\",\\n  },\\n  \\\"data/HM\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%C %S %Z\\\",\\n    id: \\\"data/HM\\\",\\n    key: \\\"HM\\\",\\n    name: \\\"HEARD AND MCDONALD ISLANDS\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"7050\\\",\\n  },\\n  \\\"data/HN\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C, %S%n%Z\\\",\\n    id: \\\"data/HN\\\",\\n    key: \\\"HN\\\",\\n    name: \\\"HONDURAS\\\",\\n    require: \\\"ACS\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"31301\\\",\\n  },\\n  \\\"data/HR\\\": {\\n    fmt: \\\"%N%n%O%n%A%nHR-%Z %C\\\",\\n    id: \\\"data/HR\\\",\\n    key: \\\"HR\\\",\\n    name: \\\"CROATIA\\\",\\n    postprefix: \\\"HR-\\\",\\n    posturl: \\\"http://www.posta.hr/default.aspx?pretpum\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"10000,21001,10002\\\",\\n  },\\n  \\\"data/HT\\\": {\\n    fmt: \\\"%N%n%O%n%A%nHT%Z %C\\\",\\n    id: \\\"data/HT\\\",\\n    key: \\\"HT\\\",\\n    name: \\\"HAITI\\\",\\n    postprefix: \\\"HT\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"6120,5310,6110,8510\\\",\\n  },\\n  \\\"data/HU\\\": {\\n    fmt: \\\"%N%n%O%n%C%n%A%n%Z\\\",\\n    id: \\\"data/HU\\\",\\n    key: \\\"HU\\\",\\n    name: \\\"HUNGARY (Rep.)\\\",\\n    posturl: \\\"http://posta.hu/ugyfelszolgalat/iranyitoszam_kereso\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"ACNO\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1037,2380,1540\\\",\\n  },\\n  \\\"data/ID\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%S %Z\\\",\\n    id: \\\"data/ID\\\",\\n    key: \\\"ID\\\",\\n    lang: \\\"id\\\",\\n    languages: \\\"id\\\",\\n    name: \\\"INDONESIA\\\",\\n    require: \\\"AS\\\",\\n    sub_isoids:\\n      \\\"AC~BA~BT~BE~YO~JK~GO~JA~JB~JT~JI~KB~KS~KT~KI~KU~BB~KR~LA~MA~MU~NB~NT~PA~PB~RI~SR~SN~ST~SG~SA~SB~SS~SU\\\",\\n    sub_keys:\\n      \\\"Aceh~Bali~Banten~Bengkulu~Daerah Istimewa Yogyakarta~DKI Jakarta~Gorontalo~Jambi~Jawa Barat~Jawa Tengah~Jawa Timur~Kalimantan Barat~Kalimantan Selatan~Kalimantan Tengah~Kalimantan Timur~Kalimantan Utara~Kepulauan Bangka Belitung~Kepulauan Riau~Lampung~Maluku~Maluku Utara~Nusa Tenggara Barat~Nusa Tenggara Timur~Papua~Papua Barat~Riau~Sulawesi Barat~Sulawesi Selatan~Sulawesi Tengah~Sulawesi Tenggara~Sulawesi Utara~Sumatera Barat~Sumatera Selatan~Sumatera Utara\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"40115\\\",\\n  },\\n  \\\"data/IE\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%D%n%C%n%S %Z\\\",\\n    id: \\\"data/IE\\\",\\n    key: \\\"IE\\\",\\n    lang: \\\"en\\\",\\n    languages: \\\"en\\\",\\n    name: \\\"IRELAND\\\",\\n    posturl: \\\"https://finder.eircode.ie\\\",\\n    state_name_type: \\\"county\\\",\\n    sub_isoids:\\n      \\\"CW~CN~CE~C~DL~D~G~KY~KE~KK~LS~LM~LK~LD~LH~MO~MH~MN~OY~RN~SO~TA~WD~WH~WX~WW\\\",\\n    sub_keys:\\n      \\\"Co. Carlow~Co. Cavan~Co. Clare~Co. Cork~Co. Donegal~Co. Dublin~Co. Galway~Co. Kerry~Co. Kildare~Co. Kilkenny~Co. Laois~Co. Leitrim~Co. Limerick~Co. Longford~Co. Louth~Co. Mayo~Co. Meath~Co. Monaghan~Co. Offaly~Co. Roscommon~Co. Sligo~Co. Tipperary~Co. Waterford~Co. Westmeath~Co. Wexford~Co. Wicklow\\\",\\n    sublocality_name_type: \\\"townland\\\",\\n    zip: \\\"[\\\\\\\\dA-Z]{3} ?[\\\\\\\\dA-Z]{4}\\\",\\n    zip_name_type: \\\"eircode\\\",\\n    zipex: \\\"A65 F4E2\\\",\\n  },\\n  \\\"data/IL\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/IL\\\",\\n    key: \\\"IL\\\",\\n    name: \\\"ISRAEL\\\",\\n    posturl: \\\"http://www.israelpost.co.il/zipcode.nsf/demozip?openform\\\",\\n    zip: \\\"\\\\\\\\d{5}(?:\\\\\\\\d{2})?\\\",\\n    zipex: \\\"9614303\\\",\\n  },\\n  \\\"data/IM\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%Z\\\",\\n    id: \\\"data/IM\\\",\\n    key: \\\"IM\\\",\\n    name: \\\"ISLE OF MAN\\\",\\n    posturl: \\\"https://www.iompost.com/tools-forms/postcode-finder/\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"CZ\\\",\\n    zip: \\\"IM\\\\\\\\d[\\\\\\\\dA-Z]? ?\\\\\\\\d[ABD-HJLN-UW-Z]{2}\\\",\\n    zipex: \\\"IM2 1AA,IM99 1PS\\\",\\n  },\\n  \\\"data/IN\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z%n%S\\\",\\n    id: \\\"data/IN\\\",\\n    key: \\\"IN\\\",\\n    lang: \\\"en\\\",\\n    languages: \\\"en~hi\\\",\\n    name: \\\"INDIA\\\",\\n    posturl: \\\"https://www.indiapost.gov.in/vas/pages/FindPinCode.aspx\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"state\\\",\\n    sub_isoids:\\n      \\\"AN~AP~AR~AS~BR~CH~CT~DN~DD~DL~GA~GJ~HR~HP~JK~JH~KA~KL~LD~MP~MH~MN~ML~MZ~NL~OR~PY~PB~RJ~SK~TN~TG~TR~UP~UT~WB\\\",\\n    sub_keys:\\n      \\\"Andaman and Nicobar Islands~Andhra Pradesh~Arunachal Pradesh~Assam~Bihar~Chandigarh~Chhattisgarh~Dadra and Nagar Haveli~Daman and Diu~Delhi~Goa~Gujarat~Haryana~Himachal Pradesh~Jammu and Kashmir~Jharkhand~Karnataka~Kerala~Lakshadweep~Madhya Pradesh~Maharashtra~Manipur~Meghalaya~Mizoram~Nagaland~Odisha~Puducherry~Punjab~Rajasthan~Sikkim~Tamil Nadu~Telangana~Tripura~Uttar Pradesh~Uttarakhand~West Bengal\\\",\\n    sub_names:\\n      \\\"Andaman & Nicobar~Andhra Pradesh~Arunachal Pradesh~Assam~Bihar~Chandigarh~Chhattisgarh~Dadra & Nagar Haveli~Daman & Diu~Delhi~Goa~Gujarat~Haryana~Himachal Pradesh~Jammu & Kashmir~Jharkhand~Karnataka~Kerala~Lakshadweep~Madhya Pradesh~Maharashtra~Manipur~Meghalaya~Mizoram~Nagaland~Odisha~Puducherry~Punjab~Rajasthan~Sikkim~Tamil Nadu~Telangana~Tripura~Uttar Pradesh~Uttarakhand~West Bengal\\\",\\n    sub_zips:\\n      \\\"744~5[0-3]~79[0-2]~78~8[0-5]~16|1440[3-9]~49~396~396~11~403~3[6-9]~1[23]~17~1[89]~81[4-9]|82|83[0-5]~5[4-9]|53[7-9]~6[7-9]|6010|607008|777~682~4[5-8]|490~4[0-4]~79[56]~79[34]~796~79[78]~7[5-7]~60[579]~1[456]~3[0-4]~737|750~6[0-6]|536~5[0-3]~799~2[0-35-8]|24[0-7]|26[12]~24[46-9]|254|26[23]~7[0-4]\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zip_name_type: \\\"pin\\\",\\n    zipex: \\\"110034,110001\\\",\\n  },\\n  \\\"data/IN--hi\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z%n%S\\\",\\n    id: \\\"data/IN--hi\\\",\\n    key: \\\"IN\\\",\\n    lang: \\\"hi\\\",\\n    name: \\\"INDIA\\\",\\n    posturl: \\\"https://www.indiapost.gov.in/vas/pages/FindPinCode.aspx\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"state\\\",\\n    sub_isoids:\\n      \\\"AN~AR~AS~AP~UP~UT~OR~KA~KL~GJ~GA~CH~CT~JK~JH~TN~TG~TR~DD~DN~DL~NL~PB~WB~PY~BR~MN~MP~MH~MZ~ML~RJ~LD~SK~HR~HP\\\",\\n    sub_keys:\\n      \\\"Andaman & Nicobar~Arunachal Pradesh~Assam~Andhra Pradesh~Uttar Pradesh~Uttarakhand~Odisha~Karnataka~Kerala~Gujarat~Goa~Chandigarh~Chhattisgarh~Jammu & Kashmir~Jharkhand~Tamil Nadu~Telangana~Tripura~Daman & Diu~Dadra & Nagar Haveli~Delhi~Nagaland~Punjab~West Bengal~Puducherry~Bihar~Manipur~Madhya Pradesh~Maharashtra~Mizoram~Meghalaya~Rajasthan~Lakshadweep~Sikkim~Haryana~Himachal Pradesh\\\",\\n    sub_names:\\n      \\\"अंडमान और निकोबार द्वीपसमूह~अरुणाचल प्रदेश~असम~आंध्र प्रदेश~उत्तर प्रदेश~उत्तराखण्ड~ओड़िशा~कर्नाटक~केरल~गुजरात~गोआ~चंडीगढ़~छत्तीसगढ़~जम्मू और कश्मीर~झारखण्ड~तमिल नाडु~तेलंगाना~त्रिपुरा~दमन और दीव~दादरा और नगर हवेली~दिल्ली~नागालैंड~पंजाब~पश्चिम बंगाल~पांडिचेरी~बिहार~मणिपुर~मध्य प्रदेश~महाराष्ट्र~मिजोरम~मेघालय~राजस्थान~लक्षद्वीप~सिक्किम~हरियाणा~हिमाचल प्रदेश\\\",\\n    sub_zips:\\n      \\\"744~79[0-2]~78~5[0-3]~2[0-35-8]|24[0-7]|26[12]~24[46-9]|254|26[23]~7[5-7]~5[4-9]|53[7-9]~6[7-9]|6010|607008|777~3[6-9]~403~16|1440[3-9]~49~1[89]~81[4-9]|82|83[0-5]~6[0-6]|536~5[0-3]~799~396~396~11~79[78]~1[456]~7[0-4]~60[579]~8[0-5]~79[56]~4[5-8]|490~4[0-4]~796~79[34]~3[0-4]~682~737|750~1[23]~17\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zip_name_type: \\\"pin\\\",\\n    zipex: \\\"110034,110001\\\",\\n  },\\n  \\\"data/IO\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%Z\\\",\\n    id: \\\"data/IO\\\",\\n    key: \\\"IO\\\",\\n    name: \\\"BRITISH INDIAN OCEAN TERRITORY\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"CZ\\\",\\n    zip: \\\"BBND 1ZZ\\\",\\n    zipex: \\\"BBND 1ZZ\\\",\\n  },\\n  \\\"data/IQ\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%C, %S%n%Z\\\",\\n    id: \\\"data/IQ\\\",\\n    key: \\\"IQ\\\",\\n    name: \\\"IRAQ\\\",\\n    require: \\\"ACS\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"31001\\\",\\n  },\\n  \\\"data/IR\\\": {\\n    fmt: \\\"%O%n%N%n%S%n%C, %D%n%A%n%Z\\\",\\n    id: \\\"data/IR\\\",\\n    key: \\\"IR\\\",\\n    lang: \\\"fa\\\",\\n    languages: \\\"fa\\\",\\n    name: \\\"IRAN\\\",\\n    sub_isoids:\\n      \\\"01~02~03~04~32~05~06~07~08~29~30~31~10~11~12~13~14~28~26~16~15~17~18~27~19~20~21~22~23~24~25\\\",\\n    sub_keys:\\n      \\\"استان آذربایجان شرقی~استان آذربایجان غربی~استان اردبیل~استان اصفهان~استان البرز~استان ایلام~استان بوشهر~استان تهران~استان چهارمحال و بختیاری~استان خراسان جنوبی~استان خراسان رضوی~استان خراسان شمالی~استان خوزستان~استان زنجان~استان سمنان~استان سیستان و بلوچستان~استان فارس~استان قزوین~استان قم~استان کردستان~استان کرمان~استان کرمانشاه~استان کهگیلویه و بویراحمد~استان گلستان~استان گیلان~استان لرستان~استان مازندران~استان مرکزی~استان هرمزگان~استان همدان~استان یزد\\\",\\n    sub_lnames:\\n      \\\"East Azerbaijan Province~West Azerbaijan Province~Ardabil Province~Isfahan Province~Alborz Province~Ilam Province~Bushehr Province~Tehran Province~Chaharmahal and Bakhtiari Province~South Khorasan Province~Razavi Khorasan Province~North Khorasan Province~Khuzestan Province~Zanjan Province~Semnan Province~Sistan and Baluchestan Province~Fars Province~Qazvin Province~Qom Province~Kurdistan Province~Kerman Province~Kermanshah Province~Kohgiluyeh and Boyer-Ahmad Province~Golestan Province~Gilan Province~Lorestan Province~Mazandaran Province~Markazi Province~Hormozgan Province~Hamadan Province~Yazd Province\\\",\\n    sublocality_name_type: \\\"neighborhood\\\",\\n    zip: \\\"\\\\\\\\d{5}-?\\\\\\\\d{5}\\\",\\n    zipex: \\\"11936-12345\\\",\\n  },\\n  \\\"data/IS\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/IS\\\",\\n    key: \\\"IS\\\",\\n    name: \\\"ICELAND\\\",\\n    posturl: \\\"http://www.postur.is/einstaklingar/posthus/postnumer/\\\",\\n    zip: \\\"\\\\\\\\d{3}\\\",\\n    zipex: \\\"320,121,220,110\\\",\\n  },\\n  \\\"data/IT\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C %S\\\",\\n    id: \\\"data/IT\\\",\\n    key: \\\"IT\\\",\\n    lang: \\\"it\\\",\\n    languages: \\\"it\\\",\\n    name: \\\"ITALY\\\",\\n    posturl: \\\"http://www.poste.it/online/cercacap/\\\",\\n    require: \\\"ACSZ\\\",\\n    sub_isoids:\\n      \\\"AG~AL~AN~AO~AR~AP~AT~AV~BA~BT~BL~BN~BG~BI~BO~BZ~BS~BR~CA~CL~CB~CI~CE~CT~CZ~CH~CO~CS~CR~KR~CN~EN~FM~FE~FI~FG~FC~FR~GE~GO~GR~IM~IS~AQ~SP~LT~LE~LC~LI~LO~LU~MC~MN~MS~MT~VS~ME~MI~MO~MB~NA~NO~NU~OG~OT~OR~PD~PA~PR~PV~PG~PU~PE~PC~PI~PT~PN~PZ~PO~RG~RA~RC~RE~RI~RN~RM~RO~SA~SS~SV~SI~SR~SO~TA~TE~TR~TO~TP~TN~TV~TS~UD~VA~VE~VB~VC~VR~VV~VI~VT\\\",\\n    sub_keys:\\n      \\\"AG~AL~AN~AO~AR~AP~AT~AV~BA~BT~BL~BN~BG~BI~BO~BZ~BS~BR~CA~CL~CB~CI~CE~CT~CZ~CH~CO~CS~CR~KR~CN~EN~FM~FE~FI~FG~FC~FR~GE~GO~GR~IM~IS~AQ~SP~LT~LE~LC~LI~LO~LU~MC~MN~MS~MT~VS~ME~MI~MO~MB~NA~NO~NU~OG~OT~OR~PD~PA~PR~PV~PG~PU~PE~PC~PI~PT~PN~PZ~PO~RG~RA~RC~RE~RI~RN~RM~RO~SA~SS~SV~SI~SR~SO~TA~TE~TR~TO~TP~TN~TV~TS~UD~VA~VE~VB~VC~VR~VV~VI~VT\\\",\\n    sub_names:\\n      \\\"Agrigento~Alessandria~Ancona~Aosta~Arezzo~Ascoli Piceno~Asti~Avellino~Bari~Barletta-Andria-Trani~Belluno~Benevento~Bergamo~Biella~Bologna~Bolzano~Brescia~Brindisi~Cagliari~Caltanissetta~Campobasso~Carbonia-Iglesias~Caserta~Catania~Catanzaro~Chieti~Como~Cosenza~Cremona~Crotone~Cuneo~Enna~Fermo~Ferrara~Firenze~Foggia~Forlì-Cesena~Frosinone~Genova~Gorizia~Grosseto~Imperia~Isernia~L'Aquila~La Spezia~Latina~Lecce~Lecco~Livorno~Lodi~Lucca~Macerata~Mantova~Massa-Carrara~Matera~Medio Campidano~Messina~Milano~Modena~Monza e Brianza~Napoli~Novara~Nuoro~Ogliastra~Olbia-Tempio~Oristano~Padova~Palermo~Parma~Pavia~Perugia~Pesaro e Urbino~Pescara~Piacenza~Pisa~Pistoia~Pordenone~Potenza~Prato~Ragusa~Ravenna~Reggio Calabria~Reggio Emilia~Rieti~Rimini~Roma~Rovigo~Salerno~Sassari~Savona~Siena~Siracusa~Sondrio~Taranto~Teramo~Terni~Torino~Trapani~Trento~Treviso~Trieste~Udine~Varese~Venezia~Verbano-Cusio-Ossola~Vercelli~Verona~Vibo Valentia~Vicenza~Viterbo\\\",\\n    sub_zips:\\n      \\\"92~15~60~11~52~63~14~83~70~76[01]~32~82~24~13[89]~40~39~25~72~0912[1-9]|0913[0-4]|0901[0289]|0902[03468]|0903[0234]|0904|0803[035]|08043~93~860[1-4]|86100~0901[013-7]~81~95~88[01]~66~22~87~26[01]~88[89]~12|18025~94~638|63900~44~50~71~47[015]~03~16~34[01]7~58~18~860[7-9]|86170~67~19~04~73~23[89]~57~26[89]~55~62~46~54~75~0902[012579]|0903[015-9]|09040~98~20~41~208|20900~80~28[01]~080[1-3]|08100~08037|0804[024-9]~08020|0702|0703[08]~090[7-9]|09170|0801[039]|0803[04]~35~90~43~27~06~61~65~29~56~51~330[7-9]|33170~85~59~97~48~89[01]~42~02~47[89]~00~45~84~070[14]|0703[0-79]|07100~17|12071~53~96~23[01]~74~64~05~10~91~38~31~3401|341[0-689]|34062~330[1-5]|33100~21~30~28[89]~13[01]~37~89[89]~36~01\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"00144,47037,39049\\\",\\n  },\\n  \\\"data/JE\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%nJERSEY%n%Z\\\",\\n    id: \\\"data/JE\\\",\\n    key: \\\"JE\\\",\\n    name: \\\"CHANNEL ISLANDS\\\",\\n    posturl: \\\"http://www.jerseypost.com/tools/postcode-address-finder/\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"CZ\\\",\\n    zip: \\\"JE\\\\\\\\d[\\\\\\\\dA-Z]? ?\\\\\\\\d[ABD-HJLN-UW-Z]{2}\\\",\\n    zipex: \\\"JE1 1AA,JE2 2BT\\\",\\n  },\\n  \\\"data/JM\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%S %X\\\",\\n    id: \\\"data/JM\\\",\\n    key: \\\"JM\\\",\\n    lang: \\\"en\\\",\\n    languages: \\\"en\\\",\\n    name: \\\"JAMAICA\\\",\\n    require: \\\"ACS\\\",\\n    state_name_type: \\\"parish\\\",\\n    sub_isoids: \\\"13~09~01~12~04~02~06~14~11~08~05~03~07~10\\\",\\n    sub_keys:\\n      \\\"Clarendon~Hanover~Kingston~Manchester~Portland~St. Andrew~St. Ann~St. Catherine~St. Elizabeth~St. James~St. Mary~St. Thomas~Trelawny~Westmoreland\\\",\\n  },\\n  \\\"data/JO\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/JO\\\",\\n    key: \\\"JO\\\",\\n    name: \\\"JORDAN\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"11937,11190\\\",\\n  },\\n  \\\"data/JP\\\": {\\n    fmt: \\\"〒%Z%n%S%n%A%n%O%n%N\\\",\\n    id: \\\"data/JP\\\",\\n    key: \\\"JP\\\",\\n    lang: \\\"ja\\\",\\n    languages: \\\"ja\\\",\\n    lfmt: \\\"%N%n%O%n%A, %S%n%Z\\\",\\n    name: \\\"JAPAN\\\",\\n    posturl: \\\"http://www.post.japanpost.jp/zipcode/\\\",\\n    require: \\\"ASZ\\\",\\n    state_name_type: \\\"prefecture\\\",\\n    sub_isoids:\\n      \\\"01~02~03~04~05~06~07~08~09~10~11~12~13~14~15~16~17~18~19~20~21~22~23~24~25~26~27~28~29~30~31~32~33~34~35~36~37~38~39~40~41~42~43~44~45~46~47\\\",\\n    sub_keys:\\n      \\\"北海道~青森県~岩手県~宮城県~秋田県~山形県~福島県~茨城県~栃木県~群馬県~埼玉県~千葉県~東京都~神奈川県~新潟県~富山県~石川県~福井県~山梨県~長野県~岐阜県~静岡県~愛知県~三重県~滋賀県~京都府~大阪府~兵庫県~奈良県~和歌山県~鳥取県~島根県~岡山県~広島県~山口県~徳島県~香川県~愛媛県~高知県~福岡県~佐賀県~長崎県~熊本県~大分県~宮崎県~鹿児島県~沖縄県\\\",\\n    sub_lnames:\\n      \\\"Hokkaido~Aomori~Iwate~Miyagi~Akita~Yamagata~Fukushima~Ibaraki~Tochigi~Gunma~Saitama~Chiba~Tokyo~Kanagawa~Niigata~Toyama~Ishikawa~Fukui~Yamanashi~Nagano~Gifu~Shizuoka~Aichi~Mie~Shiga~Kyoto~Osaka~Hyogo~Nara~Wakayama~Tottori~Shimane~Okayama~Hiroshima~Yamaguchi~Tokushima~Kagawa~Ehime~Kochi~Fukuoka~Saga~Nagasaki~Kumamoto~Oita~Miyazaki~Kagoshima~Okinawa\\\",\\n    sub_zips:\\n      \\\"0[4-9]|00[1-7]~03|018~02~98~01~99~9[67]~3[01]~32|311|349~37|38[49]~3[3-6]~2[6-9]~1[0-8]|19[0-8]|20~2[1-5]|199~9[45]|389~93~92|939~91|922~40~3[89]|949~50~4[1-9]~4[4-9]|431~51|498|647~52~6[0-2]|520~5[3-9]|618|630~6[5-7]|563~63|64[78]~64|519~68~69|68[45]~7[01]~7[23]~7[45]~77~76~79~78~8[0-3]|871~84~85|81[17]|848~86~87|839~88~89~90\\\",\\n    upper: \\\"S\\\",\\n    zip: \\\"\\\\\\\\d{3}-?\\\\\\\\d{4}\\\",\\n    zipex: \\\"154-0023,350-1106,951-8073,112-0001,208-0032,231-0012\\\",\\n  },\\n  \\\"data/KE\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%Z\\\",\\n    id: \\\"data/KE\\\",\\n    key: \\\"KE\\\",\\n    name: \\\"KENYA\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"20100,00100\\\",\\n  },\\n  \\\"data/KG\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/KG\\\",\\n    key: \\\"KG\\\",\\n    name: \\\"KYRGYZSTAN\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zipex: \\\"720001\\\",\\n  },\\n  \\\"data/KH\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/KH\\\",\\n    key: \\\"KH\\\",\\n    name: \\\"CAMBODIA\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"12203,14206,12000\\\",\\n  },\\n  \\\"data/KI\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%S%n%C\\\",\\n    id: \\\"data/KI\\\",\\n    key: \\\"KI\\\",\\n    name: \\\"KIRIBATI\\\",\\n    state_name_type: \\\"island\\\",\\n    upper: \\\"ACNOS\\\",\\n  },\\n  \\\"data/KM\\\": { id: \\\"data/KM\\\", key: \\\"KM\\\", name: \\\"COMOROS\\\", upper: \\\"AC\\\" },\\n  \\\"data/KN\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C, %S\\\",\\n    id: \\\"data/KN\\\",\\n    key: \\\"KN\\\",\\n    lang: \\\"en\\\",\\n    languages: \\\"en\\\",\\n    name: \\\"SAINT KITTS AND NEVIS\\\",\\n    require: \\\"ACS\\\",\\n    state_name_type: \\\"island\\\",\\n    sub_isoids: \\\"N~K\\\",\\n    sub_keys: \\\"Nevis~St. Kitts\\\",\\n  },\\n  \\\"data/KP\\\": {\\n    fmt: \\\"%Z%n%S%n%C%n%A%n%O%n%N\\\",\\n    id: \\\"data/KP\\\",\\n    key: \\\"KP\\\",\\n    lang: \\\"ko\\\",\\n    languages: \\\"ko\\\",\\n    lfmt: \\\"%N%n%O%n%A%n%C%n%S, %Z\\\",\\n    name: \\\"NORTH KOREA\\\",\\n    sub_isoids: \\\"07~13~10~04~02~03~01~08~09~05~06\\\",\\n    sub_keys:\\n      \\\"강원도~라선 특별시~량강도~자강도~평안 남도~평안 북도~평양 직할시~함경 남도~함경 북도~황해남도~황해북도\\\",\\n    sub_lnames:\\n      \\\"Kangwon~Rason~Ryanggang~Chagang~South Pyongan~North Pyongan~Pyongyang~South Hamgyong~North Hamgyong~South Hwanghae~North Hwanghae\\\",\\n  },\\n  \\\"data/KR\\\": {\\n    fmt: \\\"%S %C%D%n%A%n%O%n%N%n%Z\\\",\\n    id: \\\"data/KR\\\",\\n    key: \\\"KR\\\",\\n    lang: \\\"ko\\\",\\n    languages: \\\"ko\\\",\\n    lfmt: \\\"%N%n%O%n%A%n%D%n%C%n%S%n%Z\\\",\\n    name: \\\"SOUTH KOREA\\\",\\n    posturl: \\\"http://www.epost.go.kr/search/zipcode/search5.jsp\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"do_si\\\",\\n    sub_isoids: \\\"42~41~48~47~29~27~30~26~11~50~31~28~46~45~49~44~43\\\",\\n    sub_keys:\\n      \\\"강원도~경기도~경상남도~경상북도~광주광역시~대구광역시~대전광역시~부산광역시~서울특별시~세종특별자치시~울산광역시~인천광역시~전라남도~전라북도~제주특별자치도~충청남도~충청북도\\\",\\n    sub_lnames:\\n      \\\"Gangwon-do~Gyeonggi-do~Gyeongsangnam-do~Gyeongsangbuk-do~Gwangju~Daegu~Daejeon~Busan~Seoul~Sejong~Ulsan~Incheon~Jeollanam-do~Jeollabuk-do~Jeju-do~Chungcheongnam-do~Chungcheongbuk-do\\\",\\n    sub_mores:\\n      \\\"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\\\",\\n    sub_names:\\n      \\\"강원~경기~경남~경북~광주~대구~대전~부산~서울~세종~울산~인천~전남~전북~제주~충남~충북\\\",\\n    sub_zipexs:\\n      \\\"25627~12410~53286~38540~62394~42456~34316~46706~06321~30065~44782~23024~59222~56445~63563~32832~28006\\\",\\n    sub_zips:\\n      \\\"2[456]\\\\\\\\d{2}~1[0-8]\\\\\\\\d{2}~5[0-3]\\\\\\\\d{2}~(?:3[6-9]|40)\\\\\\\\d{2}~6[12]\\\\\\\\d{2}~4[12]\\\\\\\\d{2}~3[45]\\\\\\\\d{2}~4[6-9]\\\\\\\\d{2}~0[1-8]\\\\\\\\d{2}~30[01]\\\\\\\\d~4[45]\\\\\\\\d{2}~2[1-3]\\\\\\\\d{2}~5[7-9]\\\\\\\\d{2}~5[4-6]\\\\\\\\d{2}~63[0-356]\\\\\\\\d~3[1-3]\\\\\\\\d{2}~2[789]\\\\\\\\d{2}\\\",\\n    sublocality_name_type: \\\"district\\\",\\n    upper: \\\"Z\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"03051\\\",\\n  },\\n  \\\"data/KW\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/KW\\\",\\n    key: \\\"KW\\\",\\n    name: \\\"KUWAIT\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"54541,54551,54404,13009\\\",\\n  },\\n  \\\"data/KY\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%S %Z\\\",\\n    id: \\\"data/KY\\\",\\n    key: \\\"KY\\\",\\n    lang: \\\"en\\\",\\n    languages: \\\"en\\\",\\n    name: \\\"CAYMAN ISLANDS\\\",\\n    posturl: \\\"http://www.caymanpost.gov.ky/\\\",\\n    require: \\\"AS\\\",\\n    state_name_type: \\\"island\\\",\\n    sub_keys: \\\"Cayman Brac~Grand Cayman~Little Cayman\\\",\\n    zip: \\\"KY\\\\\\\\d-\\\\\\\\d{4}\\\",\\n    zipex: \\\"KY1-1100,KY1-1702,KY2-2101\\\",\\n  },\\n  \\\"data/KZ\\\": {\\n    fmt: \\\"%Z%n%S%n%C%n%A%n%O%n%N\\\",\\n    id: \\\"data/KZ\\\",\\n    key: \\\"KZ\\\",\\n    name: \\\"KAZAKHSTAN\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zipex: \\\"040900,050012\\\",\\n  },\\n  \\\"data/LA\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/LA\\\",\\n    key: \\\"LA\\\",\\n    name: \\\"LAO (PEOPLE'S DEM. REP.)\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"01160,01000\\\",\\n  },\\n  \\\"data/LB\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/LB\\\",\\n    key: \\\"LB\\\",\\n    name: \\\"LEBANON\\\",\\n    zip: \\\"(?:\\\\\\\\d{4})(?: ?(?:\\\\\\\\d{4}))?\\\",\\n    zipex: \\\"2038 3054,1107 2810,1000\\\",\\n  },\\n  \\\"data/LC\\\": { id: \\\"data/LC\\\", key: \\\"LC\\\", name: \\\"SAINT LUCIA\\\" },\\n  \\\"data/LI\\\": {\\n    fmt: \\\"%O%n%N%n%A%nFL-%Z %C\\\",\\n    id: \\\"data/LI\\\",\\n    key: \\\"LI\\\",\\n    name: \\\"LIECHTENSTEIN\\\",\\n    postprefix: \\\"FL-\\\",\\n    posturl: \\\"http://www.post.ch/db/owa/pv_plz_pack/pr_main\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"948[5-9]|949[0-8]\\\",\\n    zipex: \\\"9496,9491,9490,9485\\\",\\n  },\\n  \\\"data/LK\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%Z\\\",\\n    id: \\\"data/LK\\\",\\n    key: \\\"LK\\\",\\n    name: \\\"SRI LANKA\\\",\\n    posturl: \\\"http://www.slpost.gov.lk/\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"20000,00100\\\",\\n  },\\n  \\\"data/LR\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/LR\\\",\\n    key: \\\"LR\\\",\\n    name: \\\"LIBERIA\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1000\\\",\\n  },\\n  \\\"data/LS\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/LS\\\",\\n    key: \\\"LS\\\",\\n    name: \\\"LESOTHO\\\",\\n    zip: \\\"\\\\\\\\d{3}\\\",\\n    zipex: \\\"100\\\",\\n  },\\n  \\\"data/LT\\\": {\\n    fmt: \\\"%O%n%N%n%A%nLT-%Z %C\\\",\\n    id: \\\"data/LT\\\",\\n    key: \\\"LT\\\",\\n    name: \\\"LITHUANIA\\\",\\n    postprefix: \\\"LT-\\\",\\n    posturl: \\\"http://www.post.lt/lt/?id=316\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"04340,03500\\\",\\n  },\\n  \\\"data/LU\\\": {\\n    fmt: \\\"%O%n%N%n%A%nL-%Z %C\\\",\\n    id: \\\"data/LU\\\",\\n    key: \\\"LU\\\",\\n    name: \\\"LUXEMBOURG\\\",\\n    postprefix: \\\"L-\\\",\\n    posturl:\\n      \\\"https://www.post.lu/fr/grandes-entreprises/solutions-postales/rechercher-un-code-postal\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"4750,2998\\\",\\n  },\\n  \\\"data/LV\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C, %Z\\\",\\n    id: \\\"data/LV\\\",\\n    key: \\\"LV\\\",\\n    name: \\\"LATVIA\\\",\\n    posturl: \\\"http://www.pasts.lv/lv/uzzinas/nodalas/\\\",\\n    zip: \\\"LV-\\\\\\\\d{4}\\\",\\n    zipex: \\\"LV-1073,LV-1000\\\",\\n  },\\n  \\\"data/LY\\\": { id: \\\"data/LY\\\", key: \\\"LY\\\", name: \\\"LIBYA\\\" },\\n  \\\"data/MA\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/MA\\\",\\n    key: \\\"MA\\\",\\n    name: \\\"MOROCCO\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"53000,10000,20050,16052\\\",\\n  },\\n  \\\"data/MC\\\": {\\n    fmt: \\\"%N%n%O%n%A%nMC-%Z %C %X\\\",\\n    id: \\\"data/MC\\\",\\n    key: \\\"MC\\\",\\n    name: \\\"MONACO\\\",\\n    postprefix: \\\"MC-\\\",\\n    zip: \\\"980\\\\\\\\d{2}\\\",\\n    zipex: \\\"98000,98020,98011,98001\\\",\\n  },\\n  \\\"data/MD\\\": {\\n    fmt: \\\"%N%n%O%n%A%nMD-%Z %C\\\",\\n    id: \\\"data/MD\\\",\\n    key: \\\"MD\\\",\\n    name: \\\"Rep. MOLDOVA\\\",\\n    postprefix: \\\"MD-\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"2012,2019\\\",\\n  },\\n  \\\"data/ME\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/ME\\\",\\n    key: \\\"ME\\\",\\n    name: \\\"MONTENEGRO\\\",\\n    zip: \\\"8\\\\\\\\d{4}\\\",\\n    zipex: \\\"81257,81258,81217,84314,85366\\\",\\n  },\\n  \\\"data/MF\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%Z %C %X\\\",\\n    id: \\\"data/MF\\\",\\n    key: \\\"MF\\\",\\n    name: \\\"SAINT MARTIN\\\",\\n    posturl:\\n      \\\"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"ACX\\\",\\n    zip: \\\"9[78][01]\\\\\\\\d{2}\\\",\\n    zipex: \\\"97100\\\",\\n  },\\n  \\\"data/MG\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/MG\\\",\\n    key: \\\"MG\\\",\\n    name: \\\"MADAGASCAR\\\",\\n    zip: \\\"\\\\\\\\d{3}\\\",\\n    zipex: \\\"501,101\\\",\\n  },\\n  \\\"data/MH\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %S %Z\\\",\\n    id: \\\"data/MH\\\",\\n    key: \\\"MH\\\",\\n    name: \\\"MARSHALL ISLANDS\\\",\\n    posturl: \\\"http://zip4.usps.com/zip4/welcome.jsp\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"state\\\",\\n    upper: \\\"ACNOS\\\",\\n    zip: \\\"(969[67]\\\\\\\\d)(?:[ \\\\\\\\-](\\\\\\\\d{4}))?\\\",\\n    zip_name_type: \\\"zip\\\",\\n    zipex: \\\"96960,96970\\\",\\n  },\\n  \\\"data/MK\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/MK\\\",\\n    key: \\\"MK\\\",\\n    name: \\\"MACEDONIA\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1314,1321,1443,1062\\\",\\n  },\\n  \\\"data/ML\\\": { id: \\\"data/ML\\\", key: \\\"ML\\\", name: \\\"MALI\\\" },\\n  \\\"data/MM\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C, %Z\\\",\\n    id: \\\"data/MM\\\",\\n    key: \\\"MM\\\",\\n    name: \\\"MYANMAR\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"11181\\\",\\n  },\\n  \\\"data/MN\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%S %Z\\\",\\n    id: \\\"data/MN\\\",\\n    key: \\\"MN\\\",\\n    name: \\\"MONGOLIA\\\",\\n    posturl: \\\"http://www.zipcode.mn/\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"65030,65270\\\",\\n  },\\n  \\\"data/MO\\\": {\\n    fmt: \\\"%A%n%O%n%N\\\",\\n    id: \\\"data/MO\\\",\\n    key: \\\"MO\\\",\\n    lfmt: \\\"%N%n%O%n%A\\\",\\n    name: \\\"MACAO\\\",\\n    require: \\\"A\\\",\\n  },\\n  \\\"data/MP\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %S %Z\\\",\\n    id: \\\"data/MP\\\",\\n    key: \\\"MP\\\",\\n    name: \\\"NORTHERN MARIANA ISLANDS\\\",\\n    posturl: \\\"http://zip4.usps.com/zip4/welcome.jsp\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"state\\\",\\n    upper: \\\"ACNOS\\\",\\n    zip: \\\"(9695[012])(?:[ \\\\\\\\-](\\\\\\\\d{4}))?\\\",\\n    zip_name_type: \\\"zip\\\",\\n    zipex: \\\"96950,96951,96952\\\",\\n  },\\n  \\\"data/MQ\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%Z %C %X\\\",\\n    id: \\\"data/MQ\\\",\\n    key: \\\"MQ\\\",\\n    name: \\\"MARTINIQUE\\\",\\n    posturl:\\n      \\\"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"ACX\\\",\\n    zip: \\\"9[78]2\\\\\\\\d{2}\\\",\\n    zipex: \\\"97220\\\",\\n  },\\n  \\\"data/MR\\\": { id: \\\"data/MR\\\", key: \\\"MR\\\", name: \\\"MAURITANIA\\\", upper: \\\"AC\\\" },\\n  \\\"data/MS\\\": { id: \\\"data/MS\\\", key: \\\"MS\\\", name: \\\"MONTSERRAT\\\" },\\n  \\\"data/MT\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/MT\\\",\\n    key: \\\"MT\\\",\\n    name: \\\"MALTA\\\",\\n    posturl: \\\"http://postcodes.maltapost.com/\\\",\\n    upper: \\\"CZ\\\",\\n    zip: \\\"[A-Z]{3} ?\\\\\\\\d{2,4}\\\",\\n    zipex: \\\"NXR 01,ZTN 05,GPO 01,BZN 1130,SPB 6031,VCT 1753\\\",\\n  },\\n  \\\"data/MU\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z%n%C\\\",\\n    id: \\\"data/MU\\\",\\n    key: \\\"MU\\\",\\n    name: \\\"MAURITIUS\\\",\\n    upper: \\\"CZ\\\",\\n    zip: \\\"\\\\\\\\d{3}(?:\\\\\\\\d{2}|[A-Z]{2}\\\\\\\\d{3})\\\",\\n    zipex: \\\"42602\\\",\\n  },\\n  \\\"data/MV\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/MV\\\",\\n    key: \\\"MV\\\",\\n    name: \\\"MALDIVES\\\",\\n    posturl: \\\"http://www.maldivespost.com/?lid=10\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"20026\\\",\\n  },\\n  \\\"data/MW\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %X\\\",\\n    id: \\\"data/MW\\\",\\n    key: \\\"MW\\\",\\n    name: \\\"MALAWI\\\",\\n  },\\n  \\\"data/MX\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%D%n%Z %C, %S\\\",\\n    id: \\\"data/MX\\\",\\n    key: \\\"MX\\\",\\n    lang: \\\"es\\\",\\n    languages: \\\"es\\\",\\n    name: \\\"MEXICO\\\",\\n    posturl:\\n      \\\"http://www.correosdemexico.gob.mx/ServiciosLinea/Paginas/ccpostales.aspx\\\",\\n    require: \\\"ACZ\\\",\\n    state_name_type: \\\"state\\\",\\n    sub_isoids:\\n      \\\"AGU~BCN~BCS~CAM~CHP~CHH~CMX~COA~COL~DUR~MEX~GUA~GRO~HID~JAL~MIC~MOR~NAY~NLE~OAX~PUE~QUE~ROO~SLP~SIN~SON~TAB~TAM~TLA~VER~YUC~ZAC\\\",\\n    sub_keys:\\n      \\\"Ags.~B.C.~B.C.S.~Camp.~Chis.~Chih.~CDMX~Coah.~Col.~Dgo.~Méx.~Gto.~Gro.~Hgo.~Jal.~Mich.~Mor.~Nay.~N.L.~Oax.~Pue.~Qro.~Q.R.~S.L.P.~Sin.~Son.~Tab.~Tamps.~Tlax.~Ver.~Yuc.~Zac.\\\",\\n    sub_names:\\n      \\\"Aguascalientes~Baja California~Baja California Sur~Campeche~Chiapas~Chihuahua~Ciudad de México~Coahuila de Zaragoza~Colima~Durango~Estado de México~Guanajuato~Guerrero~Hidalgo~Jalisco~Michoacán~Morelos~Nayarit~Nuevo León~Oaxaca~Puebla~Querétaro~Quintana Roo~San Luis Potosí~Sinaloa~Sonora~Tabasco~Tamaulipas~Tlaxcala~Veracruz~Yucatán~Zacatecas\\\",\\n    sub_zipexs:\\n      \\\"20000,20999~21000,22999~23000,23999~24000,24999~29000,30999~31000,33999~00000,16999~25000,27999~28000,28999~34000,35999~50000,57999~36000,38999~39000,41999~42000,43999~44000,49999~58000,61999~62000,62999~63000,63999~64000,67999~68000,71999~72000,75999~76000,76999~77000,77999~78000,79999~80000,82999~83000,85999~86000,86999~87000,89999~90000,90999~91000,96999~97000,97999~98000,99999\\\",\\n    sub_zips:\\n      \\\"20~2[12]~23~24~29|30~3[1-3]~0|1[0-6]~2[5-7]~28~3[45]~5[0-7]~3[6-8]~39|4[01]~4[23]~4[4-9]~5[89]|6[01]~62~63~6[4-7]~6[89]|7[01]~7[2-5]~76~77~7[89]~8[0-2]~8[3-5]~86~8[7-9]~90~9[1-6]~97~9[89]\\\",\\n    sublocality_name_type: \\\"neighborhood\\\",\\n    upper: \\\"CSZ\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"02860,77520,06082\\\",\\n  },\\n  \\\"data/MY\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%D%n%Z %C%n%S\\\",\\n    id: \\\"data/MY\\\",\\n    key: \\\"MY\\\",\\n    lang: \\\"ms\\\",\\n    languages: \\\"ms\\\",\\n    name: \\\"MALAYSIA\\\",\\n    posturl: \\\"http://www.pos.com.my\\\",\\n    require: \\\"ACZ\\\",\\n    state_name_type: \\\"state\\\",\\n    sub_isoids: \\\"01~02~03~14~15~04~05~06~08~09~07~16~12~13~10~11\\\",\\n    sub_keys:\\n      \\\"Johor~Kedah~Kelantan~Kuala Lumpur~Labuan~Melaka~Negeri Sembilan~Pahang~Perak~Perlis~Pulau Pinang~Putrajaya~Sabah~Sarawak~Selangor~Terengganu\\\",\\n    sub_zipexs:\\n      \\\"79000,86999~05000,09999,34950~15000,18599~50000,60000~87000,87999~75000,78399~70000,73599~25000,28999,39000,49000,69000~30000,36899,39000~01000,02799~10000,14999~62000,62999~88000,91999~93000,98999~40000,48999,63000,68199~20000,24999\\\",\\n    sub_zips:\\n      \\\"79|8[0-6]~0[5-9]|34950~1[5-9]~5|60~87~7[5-8]~7[0-4]~2[5-8]|[346]9~3[0-6]|39000~0[12]~1[0-4]~62~8[89]|9[01]~9[3-8]~4[0-8]|6[3-8]~2[0-4]\\\",\\n    sublocality_name_type: \\\"village_township\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"43000,50754,88990,50670\\\",\\n  },\\n  \\\"data/MZ\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C%S\\\",\\n    id: \\\"data/MZ\\\",\\n    key: \\\"MZ\\\",\\n    lang: \\\"pt\\\",\\n    languages: \\\"pt\\\",\\n    name: \\\"MOZAMBIQUE\\\",\\n    sub_isoids: \\\"P~MPM~G~I~B~L~N~A~S~T~Q\\\",\\n    sub_keys:\\n      \\\"Cabo Delgado~Cidade de Maputo~Gaza~Inhambane~Manica~Maputo~Nampula~Niassa~Sofala~Tete~Zambezia\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1102,1119,3212\\\",\\n  },\\n  \\\"data/NA\\\": { id: \\\"data/NA\\\", key: \\\"NA\\\", name: \\\"NAMIBIA\\\" },\\n  \\\"data/NC\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%Z %C %X\\\",\\n    id: \\\"data/NC\\\",\\n    key: \\\"NC\\\",\\n    name: \\\"NEW CALEDONIA\\\",\\n    posturl:\\n      \\\"http://poste.opt.nc/index.php?option=com_content&view=article&id=80&Itemid=131\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"ACX\\\",\\n    zip: \\\"988\\\\\\\\d{2}\\\",\\n    zipex: \\\"98814,98800,98810\\\",\\n  },\\n  \\\"data/NE\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/NE\\\",\\n    key: \\\"NE\\\",\\n    name: \\\"NIGER\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"8001\\\",\\n  },\\n  \\\"data/NF\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%C %S %Z\\\",\\n    id: \\\"data/NF\\\",\\n    key: \\\"NF\\\",\\n    name: \\\"NORFOLK ISLAND\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"2899\\\",\\n    zipex: \\\"2899\\\",\\n  },\\n  \\\"data/NG\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%D%n%C %Z%n%S\\\",\\n    id: \\\"data/NG\\\",\\n    key: \\\"NG\\\",\\n    lang: \\\"en\\\",\\n    languages: \\\"en\\\",\\n    name: \\\"NIGERIA\\\",\\n    posturl: \\\"http://www.nigeriapostcodes.com/\\\",\\n    state_name_type: \\\"state\\\",\\n    sub_isoids:\\n      \\\"AB~AD~AK~AN~BA~BY~BE~BO~CR~DE~EB~ED~EK~EN~FC~GO~IM~JI~KD~KN~KT~KE~KO~KW~LA~NA~NI~OG~ON~OS~OY~PL~RI~SO~TA~YO~ZA\\\",\\n    sub_keys:\\n      \\\"Abia~Adamawa~Akwa Ibom~Anambra~Bauchi~Bayelsa~Benue~Borno~Cross River~Delta~Ebonyi~Edo~Ekiti~Enugu~Federal Capital Territory~Gombe~Imo~Jigawa~Kaduna~Kano~Katsina~Kebbi~Kogi~Kwara~Lagos~Nasarawa~Niger~Ogun State~Ondo~Osun~Oyo~Plateau~Rivers~Sokoto~Taraba~Yobe~Zamfara\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zipex: \\\"930283,300001,931104\\\",\\n  },\\n  \\\"data/NI\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z%n%C, %S\\\",\\n    id: \\\"data/NI\\\",\\n    key: \\\"NI\\\",\\n    lang: \\\"es\\\",\\n    languages: \\\"es\\\",\\n    name: \\\"NICARAGUA\\\",\\n    posturl: \\\"http://www.correos.gob.ni/index.php/codigo-postal-2\\\",\\n    state_name_type: \\\"department\\\",\\n    sub_isoids: \\\"BO~CA~CI~CO~ES~GR~JI~LE~MD~MN~MS~MT~NS~AN~AS~SJ~RI\\\",\\n    sub_keys:\\n      \\\"Boaco~Carazo~Chinandega~Chontales~Esteli~Granada~Jinotega~Leon~Madriz~Managua~Masaya~Matagalpa~Nueva Segovia~Raan~Raas~Rio San Juan~Rivas\\\",\\n    sub_zips:\\n      \\\"5[12]~4[56]~2[5-7]~5[56]~3[12]~4[34]~6[56]~2[12]~3[45]~1[0-6]~4[12]~6[1-3]~3[7-9]~7[12]~8[1-3]~9[12]~4[78]\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"52000\\\",\\n  },\\n  \\\"data/NL\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%Z %C\\\",\\n    id: \\\"data/NL\\\",\\n    key: \\\"NL\\\",\\n    name: \\\"NETHERLANDS\\\",\\n    posturl: \\\"http://www.postnl.nl/voorthuis/\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{4} ?[A-Z]{2}\\\",\\n    zipex: \\\"1234 AB,2490 AA\\\",\\n  },\\n  \\\"data/NO\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/NO\\\",\\n    key: \\\"NO\\\",\\n    locality_name_type: \\\"post_town\\\",\\n    name: \\\"NORWAY\\\",\\n    posturl: \\\"http://adressesok.posten.no/nb/postal_codes/search\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"0025,0107,6631\\\",\\n  },\\n  \\\"data/NP\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/NP\\\",\\n    key: \\\"NP\\\",\\n    name: \\\"NEPAL\\\",\\n    posturl: \\\"http://www.gpo.gov.np/Home/Postalcode\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"44601\\\",\\n  },\\n  \\\"data/NR\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%S\\\",\\n    id: \\\"data/NR\\\",\\n    key: \\\"NR\\\",\\n    lang: \\\"en\\\",\\n    languages: \\\"en\\\",\\n    name: \\\"NAURU CENTRAL PACIFIC\\\",\\n    require: \\\"AS\\\",\\n    state_name_type: \\\"district\\\",\\n    sub_isoids: \\\"01~02~03~04~05~06~07~08~09~10~11~12~13~14\\\",\\n    sub_keys:\\n      \\\"Aiwo District~Anabar District~Anetan District~Anibare District~Baiti District~Boe District~Buada District~Denigomodu District~Ewa District~Ijuw District~Meneng District~Nibok District~Uaboe District~Yaren District\\\",\\n  },\\n  \\\"data/NU\\\": { id: \\\"data/NU\\\", key: \\\"NU\\\", name: \\\"NIUE\\\" },\\n  \\\"data/NZ\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%D%n%C %Z\\\",\\n    id: \\\"data/NZ\\\",\\n    key: \\\"NZ\\\",\\n    name: \\\"NEW ZEALAND\\\",\\n    posturl:\\n      \\\"http://www.nzpost.co.nz/Cultures/en-NZ/OnlineTools/PostCodeFinder/\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"6001,6015,6332,8252,1030\\\",\\n  },\\n  \\\"data/OM\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z%n%C\\\",\\n    id: \\\"data/OM\\\",\\n    key: \\\"OM\\\",\\n    name: \\\"OMAN\\\",\\n    zip: \\\"(?:PC )?\\\\\\\\d{3}\\\",\\n    zipex: \\\"133,112,111\\\",\\n  },\\n  \\\"data/PA\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%S\\\",\\n    id: \\\"data/PA\\\",\\n    key: \\\"PA\\\",\\n    name: \\\"PANAMA (REP.)\\\",\\n    upper: \\\"CS\\\",\\n  },\\n  \\\"data/PE\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z%n%S\\\",\\n    id: \\\"data/PE\\\",\\n    key: \\\"PE\\\",\\n    lang: \\\"es\\\",\\n    languages: \\\"es\\\",\\n    locality_name_type: \\\"district\\\",\\n    name: \\\"PERU\\\",\\n    posturl: \\\"http://www.serpost.com.pe/cpostal/codigo\\\",\\n    sub_isoids:\\n      \\\"AMA~ANC~APU~ARE~AYA~CAJ~CAL~CUS~LIM~HUV~HUC~ICA~JUN~LAL~LAM~LOR~MDD~MOQ~LMA~PAS~PIU~PUN~SAM~TAC~TUM~UCA\\\",\\n    sub_keys:\\n      \\\"Amazonas~Áncash~Apurímac~Arequipa~Ayacucho~Cajamarca~Callao~Cuzco~Gobierno Regional de Lima~Huancavelica~Huánuco~Ica~Junín~La Libertad~Lambayeque~Loreto~Madre de Dios~Moquegua~Municipalidad Metropolitana de Lima~Pasco~Piura~Puno~San Martín~Tacna~Tumbes~Ucayali\\\",\\n    zip: \\\"(?:LIMA \\\\\\\\d{1,2}|CALLAO 0?\\\\\\\\d)|[0-2]\\\\\\\\d{4}\\\",\\n    zipex: \\\"LIMA 23,LIMA 42,CALLAO 2,02001\\\",\\n  },\\n  \\\"data/PF\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C %S\\\",\\n    id: \\\"data/PF\\\",\\n    key: \\\"PF\\\",\\n    name: \\\"FRENCH POLYNESIA\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"island\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"987\\\\\\\\d{2}\\\",\\n    zipex: \\\"98709\\\",\\n  },\\n  \\\"data/PG\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z %S\\\",\\n    id: \\\"data/PG\\\",\\n    key: \\\"PG\\\",\\n    name: \\\"PAPUA NEW GUINEA\\\",\\n    require: \\\"ACS\\\",\\n    zip: \\\"\\\\\\\\d{3}\\\",\\n    zipex: \\\"111\\\",\\n  },\\n  \\\"data/PH\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%D, %C%n%Z %S\\\",\\n    id: \\\"data/PH\\\",\\n    key: \\\"PH\\\",\\n    lang: \\\"en\\\",\\n    languages: \\\"en\\\",\\n    name: \\\"PHILIPPINES\\\",\\n    posturl: \\\"http://www.philpost.gov.ph/\\\",\\n    sub_isoids:\\n      \\\"ABR~AGN~AGS~AKL~ALB~ANT~APA~AUR~BAS~BAN~BTN~BTG~BEN~BIL~BOH~BUK~BUL~CAG~CAN~CAS~CAM~CAP~CAT~CAV~CEB~COM~NCO~DAV~DAS~DVO~DAO~DIN~EAS~GUI~IFU~ILN~ILS~ILI~ISA~KAL~LUN~LAG~LAN~LAS~LEY~MAG~MAD~MAS~00~MDC~MDR~MSC~MSR~MOU~NEC~NER~NSA~NUE~NUV~PLW~PAM~PAN~QUE~QUI~RIZ~ROM~WSA~SAR~SIG~SOR~SCO~SLE~SUK~SLU~SUN~SUR~TAR~TAW~ZMB~ZAN~ZAS~ZSI\\\",\\n    sub_keys:\\n      \\\"Abra~Agusan del Norte~Agusan del Sur~Aklan~Albay~Antique~Apayao~Aurora~Basilan~Bataan~Batanes~Batangas~Benguet~Biliran~Bohol~Bukidnon~Bulacan~Cagayan~Camarines Norte~Camarines Sur~Camiguin~Capiz~Catanduanes~Cavite~Cebu~Compostela Valley~Cotabato~Davao del Norte~Davao del Sur~Davao Occidental~Davao Oriental~Dinagat Islands~Eastern Samar~Guimaras~Ifugao~Ilocos Norte~Ilocos Sur~Iloilo~Isabela~Kalinga~La Union~Laguna~Lanao del Norte~Lanao del Sur~Leyte~Maguindanao~Marinduque~Masbate~Metro Manila~Mindoro Occidental~Mindoro Oriental~Misamis Occidental~Misamis Oriental~Mountain Province~Negros Occidental~Negros Oriental~Northern Samar~Nueva Ecija~Nueva Vizcaya~Palawan~Pampanga~Pangasinan~Quezon Province~Quirino~Rizal~Romblon~Samar~Sarangani~Siquijor~Sorsogon~South Cotabato~Southern Leyte~Sultan Kudarat~Sulu~Surigao del Norte~Surigao del Sur~Tarlac~Tawi-Tawi~Zambales~Zamboanga del Norte~Zamboanga del Sur~Zamboanga Sibuguey\\\",\\n    sub_zipexs:\\n      \\\"2800,2826~8600,8611~8500,8513~5600,5616~4500,4517~5700,5717~3800,3806,3808~3200,3207~7300,7306~2100,2114~3900,3905~4200,4234~2600,2615~6543,6550~6300,6337~8700,8723~3000,3024~3500,3528~4600,4612~4400,4436~9100,9104~5800,5816~4800,4810~4100,4126~6000,6053~8800,8810~9400,9417~8100,8120~8000,8010~8015,8013~8200,8210~8426,8412~6800,6822~5044,5046~3600,3610~2900,2922~2700,2733~5000,5043~3300,3336~3807,3809,3814~2500,2520~4000,4033~9200,9223~9300,9321,9700,9716~6500,6542~9600,9619~4900,4905~5400,5421~~5100,5111~5200,5214~7200,7215~9000,9025~2616,2625~6100,6132~6200,6224~6400,6423~3100,3133~3700,3714~5300,5322~2000,2022~2400,2447~4300,4342~3400,3405~1850,1990~5500,5516~6700,6725~8015~6225,6230~4700,4715~9500,9513~6600,6613~9800,9811~7400,7416~8400,8425~8300,8319~2300,2318~7500,7509~2200,2213~7100,7124~7000,7043~7000,7043\\\",\\n    sub_zips:\\n      \\\"28[0-2]~86[01]~85[01]~56[01]~45[01]~57[01]~380[0-68]~320~730~21[01]~390~42[0-3]~26(0|1[0-5])~65(4[3-9]|5)~63[0-3]~87[0-2]~30[0-2]~35[0-2]~46[01]~44[0-3]~910~58[01]~48[01]~41[0-2]~60[0-5]~88[01]~94[01]~81[0-2]~80[01]~801[1-5]~82[01]~84[12]~68[0-2]~504[4-6]~36[01]~29[0-2]~27[0-3]~50([0-3]|4[0-3])~33[0-3]~38(0[79]|1[0-4])~25[0-2]~40[0-3]~92[0-2]~9(3[0-2]|7[01])~65([0-3]|4[0-2])~96[01]~490~54[0-2]~~51[01]~52[01]~72[01]~90[0-2]~26(1[6-9]|2[0-5])~61[0-3]~62[0-2]~64[0-2]~31[0-3]~37[01]~53[0-2]~20[0-2]~24[0-4]~43[0-4]~340~1[89]~55[01]~67[0-2]~8015~62(2[5-9]|30)~47[01]~95[01]~66[10]~98[01]~74[01]~84[0-2]~83[01]~23[01]~750~22[01]~71[0-2]~70[0-4]~70[0-4]\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1008,1050,1135,1207,2000,1000\\\",\\n  },\\n  \\\"data/PK\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C-%Z\\\",\\n    id: \\\"data/PK\\\",\\n    key: \\\"PK\\\",\\n    name: \\\"PAKISTAN\\\",\\n    posturl: \\\"http://www.pakpost.gov.pk/postcode.php\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"44000\\\",\\n  },\\n  \\\"data/PL\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/PL\\\",\\n    key: \\\"PL\\\",\\n    name: \\\"POLAND\\\",\\n    posturl: \\\"http://kody.poczta-polska.pl/\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{2}-\\\\\\\\d{3}\\\",\\n    zipex: \\\"00-950,05-470,48-300,32-015,00-940\\\",\\n  },\\n  \\\"data/PM\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%Z %C %X\\\",\\n    id: \\\"data/PM\\\",\\n    key: \\\"PM\\\",\\n    name: \\\"ST. PIERRE AND MIQUELON\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"ACX\\\",\\n    zip: \\\"9[78]5\\\\\\\\d{2}\\\",\\n    zipex: \\\"97500\\\",\\n  },\\n  \\\"data/PN\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%Z\\\",\\n    id: \\\"data/PN\\\",\\n    key: \\\"PN\\\",\\n    name: \\\"PITCAIRN\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"CZ\\\",\\n    zip: \\\"PCRN 1ZZ\\\",\\n    zipex: \\\"PCRN 1ZZ\\\",\\n  },\\n  \\\"data/PR\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C PR %Z\\\",\\n    id: \\\"data/PR\\\",\\n    key: \\\"PR\\\",\\n    name: \\\"PUERTO RICO\\\",\\n    postprefix: \\\"PR \\\",\\n    posturl: \\\"http://zip4.usps.com/zip4/welcome.jsp\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"ACNO\\\",\\n    zip: \\\"(00[679]\\\\\\\\d{2})(?:[ \\\\\\\\-](\\\\\\\\d{4}))?\\\",\\n    zip_name_type: \\\"zip\\\",\\n    zipex: \\\"00930\\\",\\n  },\\n  \\\"data/PT\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/PT\\\",\\n    key: \\\"PT\\\",\\n    name: \\\"PORTUGAL\\\",\\n    posturl: \\\"http://www.ctt.pt/feapl_2/app/open/tools.jspx?tool=1\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{4}-\\\\\\\\d{3}\\\",\\n    zipex: \\\"2725-079,1250-096,1201-950,2860-571,1208-148\\\",\\n  },\\n  \\\"data/PW\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %S %Z\\\",\\n    id: \\\"data/PW\\\",\\n    key: \\\"PW\\\",\\n    name: \\\"PALAU\\\",\\n    posturl: \\\"http://zip4.usps.com/zip4/welcome.jsp\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"state\\\",\\n    upper: \\\"ACNOS\\\",\\n    zip: \\\"(969(?:39|40))(?:[ \\\\\\\\-](\\\\\\\\d{4}))?\\\",\\n    zip_name_type: \\\"zip\\\",\\n    zipex: \\\"96940\\\",\\n  },\\n  \\\"data/PY\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/PY\\\",\\n    key: \\\"PY\\\",\\n    name: \\\"PARAGUAY\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1536,1538,1209\\\",\\n  },\\n  \\\"data/QA\\\": { id: \\\"data/QA\\\", key: \\\"QA\\\", name: \\\"QATAR\\\", upper: \\\"AC\\\" },\\n  \\\"data/RE\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%Z %C %X\\\",\\n    id: \\\"data/RE\\\",\\n    key: \\\"RE\\\",\\n    name: \\\"REUNION\\\",\\n    posturl:\\n      \\\"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"ACX\\\",\\n    zip: \\\"9[78]4\\\\\\\\d{2}\\\",\\n    zipex: \\\"97400\\\",\\n  },\\n  \\\"data/RO\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/RO\\\",\\n    key: \\\"RO\\\",\\n    name: \\\"ROMANIA\\\",\\n    posturl: \\\"http://www.posta-romana.ro/zip_codes\\\",\\n    upper: \\\"AC\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zipex: \\\"060274,061357,200716\\\",\\n  },\\n  \\\"data/RS\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/RS\\\",\\n    key: \\\"RS\\\",\\n    name: \\\"REPUBLIC OF SERBIA\\\",\\n    posturl:\\n      \\\"http://www.posta.rs/struktura/lat/aplikacije/pronadji/nadji-postu.asp\\\",\\n    zip: \\\"\\\\\\\\d{5,6}\\\",\\n    zipex: \\\"106314\\\",\\n  },\\n  \\\"data/RU\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%S%n%Z\\\",\\n    id: \\\"data/RU\\\",\\n    key: \\\"RU\\\",\\n    lang: \\\"ru\\\",\\n    languages: \\\"ru\\\",\\n    lfmt: \\\"%N%n%O%n%A%n%C%n%S%n%Z\\\",\\n    name: \\\"RUSSIAN FEDERATION\\\",\\n    posturl: \\\"http://info.russianpost.ru/servlet/department\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"oblast\\\",\\n    sub_isoids:\\n      \\\"ALT~AMU~ARK~AST~BEL~BRY~VLA~VGG~VLG~VOR~YEV~ZAB~IVA~IRK~KB~KGD~KLU~KAM~KC~KEM~KIR~KOS~KDA~KYA~KGN~KRS~LEN~LIP~MAG~MOW~MOS~MUR~NEN~NIZ~NGR~NVS~OMS~ORE~ORL~PNZ~PER~PRI~PSK~AD~AL~BA~BU~DA~IN~KL~KR~KO~~ME~MO~SA~SE~TA~TY~UD~KK~ROS~RYA~SAM~SPE~SAR~SAK~SVE~~SMO~STA~TAM~TVE~TOM~TUL~TYU~ULY~KHA~KHM~CHE~CE~CU~CHU~YAN~YAR\\\",\\n    sub_keys:\\n      \\\"Алтайский край~Амурская область~Архангельская область~Астраханская область~Белгородская область~Брянская область~Владимирская область~Волгоградская область~Вологодская область~Воронежская область~Еврейская автономная область~Забайкальский край~Ивановская область~Иркутская область~Кабардино-Балкарская Республика~Калининградская область~Калужская область~Камчатский край~Карачаево-Черкесская Республика~Кемеровская область~Кировская область~Костромская область~Краснодарский край~Красноярский край~Курганская область~Курская область~Ленинградская область~Липецкая область~Магаданская область~Москва~Московская область~Мурманская область~Ненецкий автономный округ~Нижегородская область~Новгородская область~Новосибирская область~Омская область~Оренбургская область~Орловская область~Пензенская область~Пермский край~Приморский край~Псковская область~Республика Адыгея~Республика Алтай~Республика Башкортостан~Республика Бурятия~Республика Дагестан~Республика Ингушетия~Республика Калмыкия~Республика Карелия~Республика Коми~Автономна Республіка Крим~Республика Марий Эл~Республика Мордовия~Республика Саха (Якутия)~Республика Северная Осетия-Алания~Республика Татарстан~Республика Тыва~Республика Удмуртия~Республика Хакасия~Ростовская область~Рязанская область~Самарская область~Санкт-Петербург~Саратовская область~Сахалинская область~Свердловская область~Севастополь~Смоленская область~Ставропольский край~Тамбовская область~Тверская область~Томская область~Тульская область~Тюменская область~Ульяновская область~Хабаровский край~Ханты-Мансийский автономный округ~Челябинская область~Чеченская Республика~Чувашская Республика~Чукотский автономный округ~Ямало-Ненецкий автономный округ~Ярославская область\\\",\\n    sub_lnames:\\n      \\\"Altayskiy kray~Amurskaya oblast'~Arkhangelskaya oblast'~Astrakhanskaya oblast'~Belgorodskaya oblast'~Bryanskaya oblast'~Vladimirskaya oblast'~Volgogradskaya oblast'~Vologodskaya oblast'~Voronezhskaya oblast'~Evreyskaya avtonomnaya oblast'~Zabaykalskiy kray~Ivanovskaya oblast'~Irkutskaya oblast'~Kabardino-Balkarskaya Republits~Kaliningradskaya oblast'~Kaluzhskaya oblast'~Kamchatskiy kray~Karachaevo-Cherkesskaya Republits~Kemerovskaya oblast'~Kirovskaya oblast'~Kostromskaya oblast'~Krasnodarskiy kray~Krasnoyarskiy kray~Kurganskaya oblast'~Kurskaya oblast'~Leningradskaya oblast'~Lipetskaya oblast'~Magadanskaya oblast'~Moskva~Moskovskaya oblast'~Murmanskaya oblast'~Nenetskiy~Nizhegorodskaya oblast'~Novgorodskaya oblast'~Novosibirskaya oblast'~Omskaya oblast'~Orenburgskaya oblast'~Orlovskaya oblast'~Penzenskaya oblast'~Permskiy kray~Primorskiy kray~Pskovskaya oblast'~Respublika Adygeya~Altay Republits~Bashkortostan Republits~Buryatiya Republits~Dagestan Republits~Ingushetiya Republits~Respublika Kalmykiya~Kareliya Republits~Komi Republits~Respublika Krym~Respublika Mariy El~Respublika Mordoviya~Sakha (Yakutiya) Republits~Respublika Severnaya Osetiya-Alaniya~Respublika Tatarstan~Tyva Republits~Respublika Udmurtiya~Khakasiya Republits~Rostovskaya oblast'~Ryazanskaya oblast'~Samarskaya oblast'~Sankt-Peterburg~Saratovskaya oblast'~Sakhalinskaya oblast'~Sverdlovskaya oblast'~Sevastopol'~Smolenskaya oblast'~Stavropolskiy kray~Tambovskaya oblast'~Tverskaya oblast'~Tomskaya oblast'~Tulskaya oblast'~Tyumenskaya oblast'~Ulyanovskaya oblast'~Khabarovskiy kray~Khanty-Mansiyskiy avtonomnyy okrug~Chelyabinskaya oblast'~Chechenskaya Republits~Chuvashia~Chukotskiy~Yamalo-Nenetskiy~Yaroslavskaya oblast'\\\",\\n    sub_names:\\n      \\\"Алтайский край~Амурская область~Архангельская область~Астраханская область~Белгородская область~Брянская область~Владимирская область~Волгоградская область~Вологодская область~Воронежская область~Еврейская автономная область~Забайкальский край~Ивановская область~Иркутская область~Кабардино-Балкарская Республика~Калининградская область~Калужская область~Камчатский край~Карачаево-Черкесская Республика~Кемеровская область~Кировская область~Костромская область~Краснодарский край~Красноярский край~Курганская область~Курская область~Ленинградская область~Липецкая область~Магаданская область~Москва~Московская область~Мурманская область~Ненецкий автономный округ~Нижегородская область~Новгородская область~Новосибирская область~Омская область~Оренбургская область~Орловская область~Пензенская область~Пермский край~Приморский край~Псковская область~Республика Адыгея~Республика Алтай~Республика Башкортостан~Республика Бурятия~Республика Дагестан~Республика Ингушетия~Республика Калмыкия~Республика Карелия~Республика Коми~Республика Крым~Республика Марий Эл~Республика Мордовия~Республика Саха (Якутия)~Республика Северная Осетия-Алания~Республика Татарстан~Республика Тыва~Республика Удмуртия~Республика Хакасия~Ростовская область~Рязанская область~Самарская область~Санкт-Петербург~Саратовская область~Сахалинская область~Свердловская область~Севастополь~Смоленская область~Ставропольский край~Тамбовская область~Тверская область~Томская область~Тульская область~Тюменская область~Ульяновская область~Хабаровский край~Ханты-Мансийский автономный округ~Челябинская область~Чеченская Республика~Чувашская Республика~Чукотский автономный округ~Ямало-Ненецкий автономный округ~Ярославская область\\\",\\n    sub_zips:\\n      \\\"65[6-9]~67[56]~16[3-5]~41[4-6]~30[89]~24[1-3]~60[0-2]~40[0-4]~16[0-2]~39[4-7]~679~6(?:7[2-4]|87)~15[3-5]~66[4-9]~36[01]~23[6-8]~24[89]~68[348]~369~65[0-4]~61[0-3]~15[67]~35[0-4]~6(?:6[0-3]|4[78])~64[01]~30[5-7]~18[78]~39[89]~68[56]~1(?:0[1-9]|1|2|3[0-5]|4[0-4])~14[0-4]~18[34]~166~60[3-7]~17[3-5]~63[0-3]~64[4-6]~46[0-2]~30[23]~44[0-2]~61[4-9]~69[0-2]~18[0-2]~385~649~45[0-3]~67[01]~36[78]~386~35[89]~18[56]~16[7-9]~29[5-8]~42[45]~43[01]~67[78]~36[23]~42[0-3]~66[78]~42[67]~655~34[4-7]~39[01]~44[3-6]~19~41[0-3]~69[34]~62[0-4]~299~21[4-6]~35[5-7]~39[23]~17[0-2]~63[4-6]~30[01]~62[5-7]~43[23]~68[0-2]~628~45[4-7]~36[4-6]~42[89]~689~629~15[0-2]\\\",\\n    upper: \\\"AC\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zipex: \\\"247112,103375,188300\\\",\\n  },\\n  \\\"data/RW\\\": { id: \\\"data/RW\\\", key: \\\"RW\\\", name: \\\"RWANDA\\\", upper: \\\"AC\\\" },\\n  \\\"data/SA\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/SA\\\",\\n    key: \\\"SA\\\",\\n    name: \\\"SAUDI ARABIA\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"11564,11187,11142\\\",\\n  },\\n  \\\"data/SB\\\": { id: \\\"data/SB\\\", key: \\\"SB\\\", name: \\\"SOLOMON ISLANDS\\\" },\\n  \\\"data/SC\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%S\\\",\\n    id: \\\"data/SC\\\",\\n    key: \\\"SC\\\",\\n    name: \\\"SEYCHELLES\\\",\\n    state_name_type: \\\"island\\\",\\n    upper: \\\"S\\\",\\n  },\\n  \\\"data/SD\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%Z\\\",\\n    id: \\\"data/SD\\\",\\n    key: \\\"SD\\\",\\n    locality_name_type: \\\"district\\\",\\n    name: \\\"SUDAN\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"11042,11113\\\",\\n  },\\n  \\\"data/SE\\\": {\\n    fmt: \\\"%O%n%N%n%A%nSE-%Z %C\\\",\\n    id: \\\"data/SE\\\",\\n    key: \\\"SE\\\",\\n    locality_name_type: \\\"post_town\\\",\\n    name: \\\"SWEDEN\\\",\\n    postprefix: \\\"SE-\\\",\\n    posturl:\\n      \\\"http://www.posten.se/sv/Kundservice/Sidor/Sok-postnummer-resultat.aspx\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{3} ?\\\\\\\\d{2}\\\",\\n    zipex: \\\"11455,12345,10500\\\",\\n  },\\n  \\\"data/SG\\\": {\\n    fmt: \\\"%N%n%O%n%A%nSINGAPORE %Z\\\",\\n    id: \\\"data/SG\\\",\\n    key: \\\"SG\\\",\\n    name: \\\"REP. OF SINGAPORE\\\",\\n    posturl: \\\"https://www.singpost.com/find-postal-code\\\",\\n    require: \\\"AZ\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zipex: \\\"546080,308125,408600\\\",\\n  },\\n  \\\"data/SH\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%Z\\\",\\n    id: \\\"data/SH\\\",\\n    key: \\\"SH\\\",\\n    name: \\\"SAINT HELENA\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"CZ\\\",\\n    zip: \\\"(?:ASCN|STHL) 1ZZ\\\",\\n    zipex: \\\"STHL 1ZZ\\\",\\n  },\\n  \\\"data/SI\\\": {\\n    fmt: \\\"%N%n%O%n%A%nSI-%Z %C\\\",\\n    id: \\\"data/SI\\\",\\n    key: \\\"SI\\\",\\n    name: \\\"SLOVENIA\\\",\\n    postprefix: \\\"SI-\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"4000,1001,2500\\\",\\n  },\\n  \\\"data/SK\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/SK\\\",\\n    key: \\\"SK\\\",\\n    name: \\\"SLOVAKIA\\\",\\n    posturl: \\\"http://psc.posta.sk\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{3} ?\\\\\\\\d{2}\\\",\\n    zipex: \\\"010 01,023 14,972 48,921 01,975 99\\\",\\n  },\\n  \\\"data/SL\\\": { id: \\\"data/SL\\\", key: \\\"SL\\\", name: \\\"SIERRA LEONE\\\" },\\n  \\\"data/SM\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/SM\\\",\\n    key: \\\"SM\\\",\\n    name: \\\"SAN MARINO\\\",\\n    posturl: \\\"http://www.poste.it/online/cercacap/\\\",\\n    require: \\\"AZ\\\",\\n    zip: \\\"4789\\\\\\\\d\\\",\\n    zipex: \\\"47890,47891,47895,47899\\\",\\n  },\\n  \\\"data/SN\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/SN\\\",\\n    key: \\\"SN\\\",\\n    name: \\\"SENEGAL\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"12500,46024,16556,10000\\\",\\n  },\\n  \\\"data/SO\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C, %S %Z\\\",\\n    id: \\\"data/SO\\\",\\n    key: \\\"SO\\\",\\n    lang: \\\"so\\\",\\n    languages: \\\"so\\\",\\n    name: \\\"SOMALIA\\\",\\n    require: \\\"ACS\\\",\\n    sub_isoids: \\\"AW~BK~BN~BR~BY~GA~GE~HI~JD~JH~MU~NU~SA~SD~SH~SO~TO~WO\\\",\\n    sub_keys: \\\"AD~BK~BN~BR~BY~GG~GD~HR~JD~JH~MD~NG~SG~SD~SH~SL~TG~WG\\\",\\n    sub_names:\\n      \\\"Awdal~Bakool~Banaadir~Bari~Bay~Galguduud~Gedo~Hiiraan~Jubbada Dhexe~Jubbada Hoose~Mudug~Nugaal~Sanaag~Shabeellaha Dhexe~Shabeellaha Hoose~Sool~Togdheer~Woqooyi Galbeed\\\",\\n    upper: \\\"ACS\\\",\\n    zip: \\\"[A-Z]{2} ?\\\\\\\\d{5}\\\",\\n    zipex: \\\"JH 09010,AD 11010\\\",\\n  },\\n  \\\"data/SR\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%S\\\",\\n    id: \\\"data/SR\\\",\\n    key: \\\"SR\\\",\\n    lang: \\\"nl\\\",\\n    languages: \\\"nl\\\",\\n    name: \\\"SURINAME\\\",\\n    sub_isoids: \\\"BR~CM~CR~MA~NI~PR~PM~SA~SI~WA\\\",\\n    sub_keys:\\n      \\\"Brokopondo~Commewijne~Coronie~Marowijne~Nickerie~Para~Paramaribo~Saramacca~Sipaliwini~Wanica\\\",\\n    upper: \\\"AS\\\",\\n  },\\n  \\\"data/SS\\\": { id: \\\"data/SS\\\", key: \\\"SS\\\", name: \\\"SOUTH SUDAN\\\" },\\n  \\\"data/ST\\\": { id: \\\"data/ST\\\", key: \\\"ST\\\", name: \\\"SAO TOME AND PRINCIPE\\\" },\\n  \\\"data/SV\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z-%C%n%S\\\",\\n    id: \\\"data/SV\\\",\\n    key: \\\"SV\\\",\\n    lang: \\\"es\\\",\\n    languages: \\\"es\\\",\\n    name: \\\"EL SALVADOR\\\",\\n    require: \\\"ACS\\\",\\n    sub_isoids: \\\"AH~CA~CH~CU~LI~PA~UN~MO~SM~SS~SV~SA~SO~US\\\",\\n    sub_keys:\\n      \\\"Ahuachapan~Cabanas~Calatenango~Cuscatlan~La Libertad~La Paz~La Union~Morazan~San Miguel~San Salvador~San Vicente~Santa Ana~Sonsonate~Usulutan\\\",\\n    sub_names:\\n      \\\"Ahuachapán~Cabañas~Chalatenango~Cuscatlán~La Libertad~La Paz~La Unión~Morazán~San Miguel~San Salvador~San Vicente~Santa Ana~Sonsonate~Usulután\\\",\\n    sub_zipexs:\\n      \\\"CP 2101~CP 1201~CP 1301~CP 1401~CP 1501~CP 1601~CP 3101~CP 3201~CP 3301~CP 1101~CP 1701~CP 2201~CP 2301~CP 3401\\\",\\n    sub_zips:\\n      \\\"CP 21~CP 12~CP 13~CP 14~CP 15~CP 16~CP 31~CP 32~CP 33~CP 11~CP 17~CP 22~CP 23~CP 34\\\",\\n    upper: \\\"CSZ\\\",\\n    zip: \\\"CP [1-3][1-7][0-2]\\\\\\\\d\\\",\\n    zipex: \\\"CP 1101\\\",\\n  },\\n  \\\"data/SX\\\": { id: \\\"data/SX\\\", key: \\\"SX\\\", name: \\\"SINT MAARTEN\\\" },\\n  \\\"data/SY\\\": {\\n    id: \\\"data/SY\\\",\\n    key: \\\"SY\\\",\\n    locality_name_type: \\\"district\\\",\\n    name: \\\"SYRIA\\\",\\n  },\\n  \\\"data/SZ\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%Z\\\",\\n    id: \\\"data/SZ\\\",\\n    key: \\\"SZ\\\",\\n    name: \\\"SWAZILAND\\\",\\n    posturl: \\\"http://www.sptc.co.sz/swazipost/codes/index.php\\\",\\n    upper: \\\"ACZ\\\",\\n    zip: \\\"[HLMS]\\\\\\\\d{3}\\\",\\n    zipex: \\\"H100\\\",\\n  },\\n  \\\"data/TC\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%Z\\\",\\n    id: \\\"data/TC\\\",\\n    key: \\\"TC\\\",\\n    name: \\\"TURKS AND CAICOS ISLANDS\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"CZ\\\",\\n    zip: \\\"TKCA 1ZZ\\\",\\n    zipex: \\\"TKCA 1ZZ\\\",\\n  },\\n  \\\"data/TD\\\": { id: \\\"data/TD\\\", key: \\\"TD\\\", name: \\\"CHAD\\\" },\\n  \\\"data/TF\\\": { id: \\\"data/TF\\\", key: \\\"TF\\\", name: \\\"FRENCH SOUTHERN TERRITORIES\\\" },\\n  \\\"data/TG\\\": { id: \\\"data/TG\\\", key: \\\"TG\\\", name: \\\"TOGO\\\" },\\n  \\\"data/TH\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%D %C%n%S %Z\\\",\\n    id: \\\"data/TH\\\",\\n    key: \\\"TH\\\",\\n    lang: \\\"th\\\",\\n    languages: \\\"th\\\",\\n    lfmt: \\\"%N%n%O%n%A%n%D, %C%n%S %Z\\\",\\n    name: \\\"THAILAND\\\",\\n    sub_isoids:\\n      \\\"81~10~71~46~62~40~38~22~24~20~18~36~86~57~50~92~23~63~26~73~48~30~80~60~12~96~55~31~13~77~25~94~14~56~82~93~66~65~76~67~54~83~44~49~58~35~95~45~85~21~70~16~52~51~42~33~47~90~91~11~75~74~27~19~17~64~72~84~32~43~39~15~37~41~53~61~34\\\",\\n    sub_keys:\\n      \\\"กระบี่~กรุงเทพมหานคร~กาญจนบุรี~กาฬสินธุ์~กำแพงเพชร~ขอนแก่น~จังหวัด บึงกาฬ~จันทบุรี~ฉะเชิงเทรา~ชลบุรี~ชัยนาท~ชัยภูมิ~ชุมพร~เชียงราย~เชียงใหม่~ตรัง~ตราด~ตาก~นครนายก~นครปฐม~นครพนม~นครราชสีมา~นครศรีธรรมราช~นครสวรรค์~นนทบุรี~นราธิวาส~น่าน~บุรีรัมย์~ปทุมธานี~ประจวบคีรีขันธ์~ปราจีนบุรี~ปัตตานี~พระนครศรีอยุธยา~พะเยา~พังงา~พัทลุง~พิจิตร~พิษณุโลก~เพชรบุรี~เพชรบูรณ์~แพร่~ภูเก็ต~มหาสารคาม~มุกดาหาร~แม่ฮ่องสอน~ยโสธร~ยะลา~ร้อยเอ็ด~ระนอง~ระยอง~ราชบุรี~ลพบุรี~ลำปาง~ลำพูน~เลย~ศรีสะเกษ~สกลนคร~สงขลา~สตูล~สมุทรปราการ~สมุทรสงคราม~สมุทรสาคร~สระแก้ว~สระบุรี~สิงห์บุรี~สุโขทัย~สุพรรณบุรี~สุราษฎร์ธานี~สุรินทร์~หนองคาย~หนองบัวลำภู~อ่างทอง~อำนาจเจริญ~อุดรธานี~อุตรดิตถ์~อุทัยธานี~อุบลราชธานี\\\",\\n    sub_lnames:\\n      \\\"Krabi~Bangkok~Kanchanaburi~Kalasin~Kamphaeng Phet~Khon Kaen~Bueng Kan~Chanthaburi~Chachoengsao~Chon Buri~Chai Nat~Chaiyaphum~Chumpon~Chiang Rai~Chiang Mai~Trang~Trat~Tak~Nakhon Nayok~Nakhon Pathom~Nakhon Phanom~Nakhon Ratchasima~Nakhon Si Thammarat~Nakhon Sawan~Nonthaburi~Narathiwat~Nan~Buri Ram~Pathum Thani~Prachuap Khiri Khan~Prachin Buri~Pattani~Phra Nakhon Si Ayutthaya~Phayao~Phang Nga~Phattalung~Phichit~Phitsanulok~Phetchaburi~Phetchabun~Phrae~Phuket~Maha Sarakham~Mukdahan~Mae Hong Son~Yasothon~Yala~Roi Et~Ranong~Rayong~Ratchaburi~Lop Buri~Lampang~Lamphun~Loei~Si Sa Ket~Sakon Nakhon~Songkhla~Satun~Samut Prakan~Samut Songkhram~Samut Sakhon~Sa Kaeo~Saraburi~Sing Buri~Sukhothai~Suphanburi~Surat Thani~Surin~Nong Khai~Nong Bua Lam Phu~Ang Thong~Amnat Charoen~Udon Thani~Uttaradit~Uthai Thani~Ubon Ratchathani\\\",\\n    sub_zips:\\n      \\\"81~10~71~46~62~40~~22~24~20~17~36~86~57~50~92~23~63~26~73~48~30~80~60~11~96~55~31~12~77~25~94~13~56~82~93~66~65~76~67~54~83~44~49~58~35~95~45~85~21~70~15~52~51~42~33~47~90~91~10~75~74~27~18~16~64~72~84~32~43~39~14~37~41~53~61~34\\\",\\n    upper: \\\"S\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"10150,10210\\\",\\n  },\\n  \\\"data/TJ\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/TJ\\\",\\n    key: \\\"TJ\\\",\\n    name: \\\"TAJIKISTAN\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zipex: \\\"735450,734025\\\",\\n  },\\n  \\\"data/TK\\\": { id: \\\"data/TK\\\", key: \\\"TK\\\", name: \\\"TOKELAU\\\" },\\n  \\\"data/TL\\\": { id: \\\"data/TL\\\", key: \\\"TL\\\", name: \\\"TIMOR-LESTE\\\" },\\n  \\\"data/TM\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/TM\\\",\\n    key: \\\"TM\\\",\\n    name: \\\"TURKMENISTAN\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zipex: \\\"744000\\\",\\n  },\\n  \\\"data/TN\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/TN\\\",\\n    key: \\\"TN\\\",\\n    name: \\\"TUNISIA\\\",\\n    posturl: \\\"http://www.poste.tn/codes.php\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1002,8129,3100,1030\\\",\\n  },\\n  \\\"data/TO\\\": { id: \\\"data/TO\\\", key: \\\"TO\\\", name: \\\"TONGA\\\" },\\n  \\\"data/TR\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C/%S\\\",\\n    id: \\\"data/TR\\\",\\n    key: \\\"TR\\\",\\n    lang: \\\"tr\\\",\\n    languages: \\\"tr\\\",\\n    locality_name_type: \\\"district\\\",\\n    name: \\\"TURKEY\\\",\\n    posturl: \\\"http://postakodu.ptt.gov.tr/\\\",\\n    require: \\\"ACZ\\\",\\n    sub_isoids:\\n      \\\"01~02~03~04~68~05~06~07~75~08~09~10~74~72~69~11~12~13~14~15~16~17~18~19~20~21~81~22~23~24~25~26~27~28~29~30~31~76~32~34~35~46~78~70~36~37~38~71~39~40~79~41~42~43~44~45~47~33~48~49~50~51~52~80~53~54~55~56~57~58~63~73~59~60~61~62~64~65~77~66~67\\\",\\n    sub_keys:\\n      \\\"Adana~Adıyaman~Afyon~Ağrı~Aksaray~Amasya~Ankara~Antalya~Ardahan~Artvin~Aydın~Balıkesir~Bartın~Batman~Bayburt~Bilecik~Bingöl~Bitlis~Bolu~Burdur~Bursa~Çanakkale~Çankırı~Çorum~Denizli~Diyarbakır~Düzce~Edirne~Elazığ~Erzincan~Erzurum~Eskişehir~Gaziantep~Giresun~Gümüşhane~Hakkari~Hatay~Iğdır~Isparta~İstanbul~İzmir~Kahramanmaraş~Karabük~Karaman~Kars~Kastamonu~Kayseri~Kırıkkale~Kırklareli~Kırşehir~Kilis~Kocaeli~Konya~Kütahya~Malatya~Manisa~Mardin~Mersin~Muğla~Muş~Nevşehir~Niğde~Ordu~Osmaniye~Rize~Sakarya~Samsun~Siirt~Sinop~Sivas~Şanlıurfa~Şırnak~Tekirdağ~Tokat~Trabzon~Tunceli~Uşak~Van~Yalova~Yozgat~Zonguldak\\\",\\n    sub_zips:\\n      \\\"01~02~03~04~68~05~06~07~75~08~09~10~74~72~69~11~12~13~14~15~16~17~18~19~20~21~81~22~23~24~25~26~27~28~29~30~31~76~32~34~35~46~78~70~36~37~38~71~39~40~79~41~42~43~44~45~47~33~48~49~50~51~52~80~53~54~55~56~57~58~63~73~59~60~61~62~64~65~77~66~67\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"01960,06101\\\",\\n  },\\n  \\\"data/TT\\\": { id: \\\"data/TT\\\", key: \\\"TT\\\", name: \\\"TRINIDAD AND TOBAGO\\\" },\\n  \\\"data/TV\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%S\\\",\\n    id: \\\"data/TV\\\",\\n    key: \\\"TV\\\",\\n    lang: \\\"tyv\\\",\\n    languages: \\\"tyv\\\",\\n    name: \\\"TUVALU\\\",\\n    state_name_type: \\\"island\\\",\\n    sub_isoids: \\\"FUN~NMG~NMA~~NIT~NUI~NKF~NKL~VAI\\\",\\n    sub_keys:\\n      \\\"Funafuti~Nanumanga~Nanumea~Niulakita~Niutao~Nui~Nukufetau~Nukulaelae~Vaitupu\\\",\\n    upper: \\\"ACS\\\",\\n  },\\n  \\\"data/TW\\\": {\\n    fmt: \\\"%Z%n%S%C%n%A%n%O%n%N\\\",\\n    id: \\\"data/TW\\\",\\n    key: \\\"TW\\\",\\n    lang: \\\"zh-Hant\\\",\\n    languages: \\\"zh-Hant\\\",\\n    lfmt: \\\"%N%n%O%n%A%n%C, %S %Z\\\",\\n    name: \\\"TAIWAN\\\",\\n    posturl:\\n      \\\"http://www.post.gov.tw/post/internet/f_searchzone/index.jsp?ID=190102\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"county\\\",\\n    sub_isoids:\\n      \\\"TXG~TPE~TTT~TNN~ILA~HUA~~NAN~PIF~MIA~TAO~KHH~KEE~~YUN~NWT~HSZ~HSQ~CYI~CYQ~CHA~PEN\\\",\\n    sub_keys:\\n      \\\"台中市~台北市~台東縣~台南市~宜蘭縣~花蓮縣~金門縣~南投縣~屏東縣~苗栗縣~桃園市~高雄市~基隆市~連江縣~雲林縣~新北市~新竹市~新竹縣~嘉義市~嘉義縣~彰化縣~澎湖縣\\\",\\n    sub_lnames:\\n      \\\"Taichung City~Taipei City~Taitung County~Tainan City~Yilan County~Hualien County~Kinmen County~Nantou County~Pingtung County~Miaoli County~Taoyuan City~Kaohsiung City~Keelung City~Lienchiang County~Yunlin County~New Taipei City~Hsinchu City~Hsinchu County~Chiayi City~Chiayi County~Changhua County~Penghu County\\\",\\n    sub_mores:\\n      \\\"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\\\",\\n    sub_zipexs:\\n      \\\"400,408,411,439~100,119~950,966~700,745~260,272~970,983~890,896~540,558~900,947~350,369~320,338~800,815,817,852~200,206~209,212~630,655~207,208,220,253~~302,315~~602,625~500,530~880,885\\\",\\n    sub_zips:\\n      \\\"4[0-3]~1[01]~9[56]~7[0-4]~2[67]~9[78]~89~5[45]~9[0-4]~3[56]~3[23]~8[02-5]|81[1-579]~20[0-6]~209|21[012]~6[3-5]~20[78]|2[2345]~300~30[2-8]|31~600~60[1-9]|6[12]~5[0123]~88\\\",\\n    zip: \\\"\\\\\\\\d{3}(?:\\\\\\\\d{2})?\\\",\\n    zipex: \\\"104,106,10603,40867\\\",\\n  },\\n  \\\"data/TZ\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/TZ\\\",\\n    key: \\\"TZ\\\",\\n    name: \\\"TANZANIA (UNITED REP.)\\\",\\n    zip: \\\"\\\\\\\\d{4,5}\\\",\\n    zipex: \\\"6090,34413\\\",\\n  },\\n  \\\"data/UA\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%S%n%Z\\\",\\n    id: \\\"data/UA\\\",\\n    key: \\\"UA\\\",\\n    lang: \\\"uk\\\",\\n    languages: \\\"uk\\\",\\n    lfmt: \\\"%N%n%O%n%A%n%C%n%S%n%Z\\\",\\n    name: \\\"UKRAINE\\\",\\n    posturl: \\\"http://services.ukrposhta.com/postindex_new/\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"oblast\\\",\\n    sub_isoids:\\n      \\\"43~05~07~12~14~18~21~23~26~30~32~35~09~46~48~51~53~56~40~59~61~63~65~68~71~77~74\\\",\\n    sub_keys:\\n      \\\"Автономна Республіка Крим~Вінницька область~Волинська область~Дніпропетровська область~Донецька область~Житомирська область~Закарпатська область~Запорізька область~Івано-Франківська область~місто Київ~Київська область~Кіровоградська область~Луганська область~Львівська область~Миколаївська область~Одеська область~Полтавська область~Рівненська область~місто Севастополь~Сумська область~Тернопільська область~Харківська область~Херсонська область~Хмельницька область~Черкаська область~Чернівецька область~Чернігівська область\\\",\\n    sub_lnames:\\n      \\\"Crimea~Vinnyts'ka oblast~Volyns'ka oblast~Dnipropetrovsk oblast~Donetsk oblast~Zhytomyrs'ka oblast~Zakarpats'ka oblast~Zaporiz'ka oblast~Ivano-Frankivs'ka oblast~Kyiv city~Kiev oblast~Kirovohrads'ka oblast~Luhans'ka oblast~Lviv oblast~Mykolaivs'ka oblast~Odessa oblast~Poltavs'ka oblast~Rivnens'ka oblast~Sevastopol' city~Sums'ka oblast~Ternopil's'ka oblast~Kharkiv oblast~Khersons'ka oblast~Khmel'nyts'ka oblast~Cherkas'ka oblast~Chernivets'ka oblast~Chernihivs'ka oblast\\\",\\n    sub_names:\\n      \\\"Автономна Республіка Крим~Вінницька область~Волинська область~Дніпропетровська область~Донецька область~Житомирська область~Закарпатська область~Запорізька область~Івано-Франківська область~Київ~Київська область~Кіровоградська область~Луганська область~Львівська область~Миколаївська область~Одеська область~Полтавська область~Рівненська область~Севастополь~Сумська область~Тернопільська область~Харківська область~Херсонська область~Хмельницька область~Черкаська область~Чернівецька область~Чернігівська область\\\",\\n    sub_zips:\\n      \\\"9[5-8]~2[1-4]~4[3-5]~49|5[0-3]~8[3-7]~1[0-3]~8[89]|90~69|7[0-2]~7[6-8]~0[1-6]~0[7-9]~2[5-8]~9[1-4]~79|8[0-2]~5[4-7]~6[5-8]~3[6-9]~3[3-5]~99~4[0-2]~4[6-8]~6[1-4]~7[3-5]~29|3[0-2]~1[89]|20~5[89]|60~1[4-7]\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"15432,01055,01001\\\",\\n  },\\n  \\\"data/UG\\\": { id: \\\"data/UG\\\", key: \\\"UG\\\", name: \\\"UGANDA\\\" },\\n  \\\"data/US\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C, %S %Z\\\",\\n    id: \\\"data/US\\\",\\n    key: \\\"US\\\",\\n    lang: \\\"en\\\",\\n    languages: \\\"en\\\",\\n    name: \\\"UNITED STATES\\\",\\n    posturl: \\\"https://tools.usps.com/go/ZipLookupAction!input.action\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"state\\\",\\n    sub_isoids:\\n      \\\"AL~AK~~AZ~AR~~~~CA~CO~CT~DE~DC~FL~GA~~HI~ID~IL~IN~IA~KS~KY~LA~ME~~MD~MA~MI~~MN~MS~MO~MT~NE~NV~NH~NJ~NM~NY~NC~ND~~OH~OK~OR~~PA~~RI~SC~SD~TN~TX~UT~VT~~VA~WA~WV~WI~WY\\\",\\n    sub_keys:\\n      \\\"AL~AK~AS~AZ~AR~AA~AE~AP~CA~CO~CT~DE~DC~FL~GA~GU~HI~ID~IL~IN~IA~KS~KY~LA~ME~MH~MD~MA~MI~FM~MN~MS~MO~MT~NE~NV~NH~NJ~NM~NY~NC~ND~MP~OH~OK~OR~PW~PA~PR~RI~SC~SD~TN~TX~UT~VT~VI~VA~WA~WV~WI~WY\\\",\\n    sub_names:\\n      \\\"Alabama~Alaska~American Samoa~Arizona~Arkansas~Armed Forces (AA)~Armed Forces (AE)~Armed Forces (AP)~California~Colorado~Connecticut~Delaware~District of Columbia~Florida~Georgia~Guam~Hawaii~Idaho~Illinois~Indiana~Iowa~Kansas~Kentucky~Louisiana~Maine~Marshall Islands~Maryland~Massachusetts~Michigan~Micronesia~Minnesota~Mississippi~Missouri~Montana~Nebraska~Nevada~New Hampshire~New Jersey~New Mexico~New York~North Carolina~North Dakota~Northern Mariana Islands~Ohio~Oklahoma~Oregon~Palau~Pennsylvania~Puerto Rico~Rhode Island~South Carolina~South Dakota~Tennessee~Texas~Utah~Vermont~Virgin Islands~Virginia~Washington~West Virginia~Wisconsin~Wyoming\\\",\\n    sub_zipexs:\\n      \\\"35000,36999~99500,99999~96799~85000,86999~71600,72999~34000,34099~09000,09999~96200,96699~90000,96199~80000,81999~06000,06999~19700,19999~20000,56999~32000,34999~30000,39901~96910,96932~96700,96899~83200,83999~60000,62999~46000,47999~50000,52999~66000,67999~40000,42799~70000,71599~03900,04999~96960,96979~20600,21999~01000,05544~48000,49999~96941,96944~55000,56799~38600,39799~63000,65999~59000,59999~68000,69999~88900,89999~03000,03899~07000,08999~87000,88499~10000,00544~27000,28999~58000,58999~96950,96952~43000,45999~73000,74999~97000,97999~96940~15000,19699~00600,00999~02800,02999~29000,29999~57000,57999~37000,38599~75000,73344~84000,84999~05000,05999~00800,00899~20100,24699~98000,99499~24700,26999~53000,54999~82000,83414\\\",\\n    sub_zips:\\n      \\\"3[56]~99[5-9]~96799~8[56]~71[6-9]|72~340~09~96[2-6]~9[0-5]|96[01]~8[01]~06~19[7-9]~20[02-5]|569~3[23]|34[1-9]~3[01]|398|39901~969([1-2]\\\\\\\\d|3[12])~967[0-8]|9679[0-8]|968~83[2-9]~6[0-2]~4[67]~5[0-2]~6[67]~4[01]|42[0-7]~70|71[0-5]~039|04~969[67]~20[6-9]|21~01|02[0-7]|05501|05544~4[89]~9694[1-4]~55|56[0-7]~38[6-9]|39[0-7]~6[3-5]~59~6[89]~889|89~03[0-8]~0[78]~87|88[0-4]~1[0-4]|06390|00501|00544~2[78]~58~9695[0-2]~4[3-5]~7[34]~97~969(39|40)~1[5-8]|19[0-6]~00[679]~02[89]~29~57~37|38[0-5]~7[5-9]|885|73301|73344~84~05~008~201|2[23]|24[0-6]~98|99[0-4]~24[7-9]|2[56]~5[34]~82|83[01]|83414\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"(\\\\\\\\d{5})(?:[ \\\\\\\\-](\\\\\\\\d{4}))?\\\",\\n    zip_name_type: \\\"zip\\\",\\n    zipex: \\\"95014,22162-1010\\\",\\n  },\\n  \\\"data/UY\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C %S\\\",\\n    id: \\\"data/UY\\\",\\n    key: \\\"UY\\\",\\n    lang: \\\"es\\\",\\n    languages: \\\"es\\\",\\n    name: \\\"URUGUAY\\\",\\n    posturl:\\n      \\\"http://www.correo.com.uy/index.asp?codPag=codPost&switchMapa=codPost\\\",\\n    sub_isoids: \\\"AR~CA~CL~CO~DU~FS~FD~LA~MA~MO~PA~RN~RV~RO~SA~SJ~SO~TA~TT\\\",\\n    sub_keys:\\n      \\\"Artigas~Canelones~Cerro Largo~Colonia~Durazno~Flores~Florida~Lavalleja~Maldonado~Montevideo~Paysandú~Río Negro~Rivera~Rocha~Salto~San José~Soriano~Tacuarembó~Treinta y Tres\\\",\\n    sub_zips:\\n      \\\"55~9[01]|1[456]~37~70|75204~97~85~94|9060|97005~30~20~1|91600~60~65|60002~40~27~50~80~75|70003~45~33|30203|30204|30302|37007\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"11600\\\",\\n  },\\n  \\\"data/UZ\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C%n%S\\\",\\n    id: \\\"data/UZ\\\",\\n    key: \\\"UZ\\\",\\n    name: \\\"UZBEKISTAN\\\",\\n    posturl: \\\"http://www.pochta.uz/ru/uslugi/indexsearch.html\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{6}\\\",\\n    zipex: \\\"702100,700000\\\",\\n  },\\n  \\\"data/VA\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/VA\\\",\\n    key: \\\"VA\\\",\\n    name: \\\"VATICAN\\\",\\n    zip: \\\"00120\\\",\\n    zipex: \\\"00120\\\",\\n  },\\n  \\\"data/VC\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z\\\",\\n    id: \\\"data/VC\\\",\\n    key: \\\"VC\\\",\\n    name: \\\"SAINT VINCENT AND THE GRENADINES (ANTILLES)\\\",\\n    posturl:\\n      \\\"http://www.svgpost.gov.vc/?option=com_content&view=article&id=3&Itemid=16\\\",\\n    zip: \\\"VC\\\\\\\\d{4}\\\",\\n    zipex: \\\"VC0100,VC0110,VC0400\\\",\\n  },\\n  \\\"data/VE\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %Z, %S\\\",\\n    id: \\\"data/VE\\\",\\n    key: \\\"VE\\\",\\n    lang: \\\"es\\\",\\n    languages: \\\"es\\\",\\n    name: \\\"VENEZUELA\\\",\\n    posturl: \\\"http://www.ipostel.gob.ve/index.php/oficinas-postales\\\",\\n    require: \\\"ACS\\\",\\n    state_name_type: \\\"state\\\",\\n    sub_isoids: \\\"Z~B~C~D~E~F~G~H~Y~W~A~I~J~K~L~M~N~O~P~R~S~T~X~U~V\\\",\\n    sub_keys:\\n      \\\"Amazonas~Anzoátegui~Apure~Aragua~Barinas~Bolívar~Carabobo~Cojedes~Delta Amacuro~Dependencias Federales~Distrito Federal~Falcón~Guárico~Lara~Mérida~Miranda~Monagas~Nueva Esparta~Portuguesa~Sucre~Táchira~Trujillo~Vargas~Yaracuy~Zulia\\\",\\n    upper: \\\"CS\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"1010,3001,8011,1020\\\",\\n  },\\n  \\\"data/VG\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%Z\\\",\\n    id: \\\"data/VG\\\",\\n    key: \\\"VG\\\",\\n    name: \\\"VIRGIN ISLANDS (BRITISH)\\\",\\n    require: \\\"A\\\",\\n    zip: \\\"VG\\\\\\\\d{4}\\\",\\n    zipex: \\\"VG1110,VG1150,VG1160\\\",\\n  },\\n  \\\"data/VI\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C %S %Z\\\",\\n    id: \\\"data/VI\\\",\\n    key: \\\"VI\\\",\\n    name: \\\"VIRGIN ISLANDS (U.S.)\\\",\\n    posturl: \\\"http://zip4.usps.com/zip4/welcome.jsp\\\",\\n    require: \\\"ACSZ\\\",\\n    state_name_type: \\\"state\\\",\\n    upper: \\\"ACNOS\\\",\\n    zip: \\\"(008(?:(?:[0-4]\\\\\\\\d)|(?:5[01])))(?:[ \\\\\\\\-](\\\\\\\\d{4}))?\\\",\\n    zip_name_type: \\\"zip\\\",\\n    zipex: \\\"00802-1222,00850-9802\\\",\\n  },\\n  \\\"data/VN\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%C%n%S %Z\\\",\\n    id: \\\"data/VN\\\",\\n    key: \\\"VN\\\",\\n    lang: \\\"vi\\\",\\n    languages: \\\"vi\\\",\\n    lfmt: \\\"%N%n%O%n%A%n%C%n%S %Z\\\",\\n    name: \\\"VIET NAM\\\",\\n    posturl: \\\"http://postcode.vnpost.vn/services/search.aspx\\\",\\n    sub_isoids:\\n      \\\"44~43~55~54~53~56~50~57~31~58~40~59~04~CT~DN~33~72~71~39~45~30~03~63~HN~23~61~HP~73~14~66~34~47~28~01~09~02~35~41~67~22~18~36~68~32~24~27~29~13~25~52~05~37~20~69~21~SG~26~46~51~07~49~70~06\\\",\\n    sub_keys:\\n      \\\"An Giang~Bà Rịa–Vũng Tàu~Bạc Liêu~Bắc Giang~Bắc Kạn~Bắc Ninh~Bến Tre~Bình Dương~Bình Định~Bình Phước~Bình Thuận~Cà Mau~Cao Bằng~Cần Thơ~Đà Nẵng~Đắk Lắk~Đăk Nông~Điện Biên~Đồng Nai~Đồng Tháp~Gia Lai~Hà Giang~Hà Nam~Hà Nội~Hà Tĩnh~Hải Dương~Hải Phòng~Hậu Giang~Hòa Bình~Hưng Yên~Khánh Hòa~Kiên Giang~Kon Tum~Lai Châu~Lạng Sơn~Lào Cai~Lâm Đồng~Long An~Nam Định~Nghệ An~Ninh Bình~Ninh Thuận~Phú Thọ~Phú Yên~Quảng Bình~Quảng Nam~Quảng Ngãi~Quảng Ninh~Quảng Trị~Sóc Trăng~Sơn La~Tây Ninh~Thái Bình~Thái Nguyên~Thanh Hóa~Thành phố Hồ Chí Minh~Thừa Thiên–Huế~Tiền Giang~Trà Vinh~Tuyên Quang~Vĩnh Long~Vĩnh Phúc~Yên Bái\\\",\\n    sub_lnames:\\n      \\\"An Giang Province~Ba Ria-Vung Tau Province~Bac Lieu Province~Bac Giang Province~Bac Kan Province~Bac Ninh Province~Ben Tre Province~Binh Duong Province~Binh Dinh Province~Binh Phuoc Province~Binh Thuan Province~Ca Mau Province~Cao Bang Province~Can Tho City~Da Nang City~Dak Lak Province~Dak Nong Province~Dien Bien Province~Dong Nai Province~Dong Thap Province~Gia Lai Province~Ha Giang Province~Ha Nam Province~Hanoi City~Ha Tinh Province~Hai Duong Province~Haiphong City~Hau Giang Province~Hoa Binh Province~Hung Yen Province~Khanh Hoa Province~Kien Giang Province~Kon Tum Province~Lai Chau Province~Lang Song Province~Lao Cai Province~Lam Dong Province~Long An Province~Nam Dinh Province~Nghe An Province~Ninh Binh Province~Ninh Thuan Province~Phu Tho Province~Phu Yen Province~Quang Binh Province~Quang Nam Province~Quang Ngai Province~Quang Ninh Province~Quang Tri Province~Soc Trang Province~Son La Province~Tay Ninh Province~Thai Binh Province~Thai Nguyen Province~Thanh Hoa Province~Ho Chi Minh City~Thua Thien-Hue Province~Tien Giang Province~Tra Vinh Province~Tuyen Quang Province~Vinh Long Province~Vinh Phuc Province~Yen Bai Province\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\\\\\\d?\\\",\\n    zipex: \\\"70010,55999\\\",\\n  },\\n  \\\"data/VU\\\": { id: \\\"data/VU\\\", key: \\\"VU\\\", name: \\\"VANUATU\\\" },\\n  \\\"data/WF\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%Z %C %X\\\",\\n    id: \\\"data/WF\\\",\\n    key: \\\"WF\\\",\\n    name: \\\"WALLIS AND FUTUNA ISLANDS\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"ACX\\\",\\n    zip: \\\"986\\\\\\\\d{2}\\\",\\n    zipex: \\\"98600\\\",\\n  },\\n  \\\"data/WS\\\": { id: \\\"data/WS\\\", key: \\\"WS\\\", name: \\\"SAMOA\\\" },\\n  \\\"data/XK\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/XK\\\",\\n    key: \\\"XK\\\",\\n    name: \\\"KOSOVO\\\",\\n    zip: \\\"[1-7]\\\\\\\\d{4}\\\",\\n    zipex: \\\"10000\\\",\\n  },\\n  \\\"data/YE\\\": { id: \\\"data/YE\\\", key: \\\"YE\\\", name: \\\"YEMEN\\\" },\\n  \\\"data/YT\\\": {\\n    fmt: \\\"%O%n%N%n%A%n%Z %C %X\\\",\\n    id: \\\"data/YT\\\",\\n    key: \\\"YT\\\",\\n    name: \\\"MAYOTTE\\\",\\n    require: \\\"ACZ\\\",\\n    upper: \\\"ACX\\\",\\n    zip: \\\"976\\\\\\\\d{2}\\\",\\n    zipex: \\\"97600\\\",\\n  },\\n  \\\"data/ZA\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%D%n%C%n%Z\\\",\\n    id: \\\"data/ZA\\\",\\n    key: \\\"ZA\\\",\\n    name: \\\"SOUTH AFRICA\\\",\\n    posturl: \\\"https://www.postoffice.co.za/Questions/postalcode.html\\\",\\n    require: \\\"ACZ\\\",\\n    zip: \\\"\\\\\\\\d{4}\\\",\\n    zipex: \\\"0083,1451,0001\\\",\\n  },\\n  \\\"data/ZM\\\": {\\n    fmt: \\\"%N%n%O%n%A%n%Z %C\\\",\\n    id: \\\"data/ZM\\\",\\n    key: \\\"ZM\\\",\\n    name: \\\"ZAMBIA\\\",\\n    zip: \\\"\\\\\\\\d{5}\\\",\\n    zipex: \\\"50100,50101\\\",\\n  },\\n  \\\"data/ZW\\\": { id: \\\"data/ZW\\\", key: \\\"ZW\\\", name: \\\"ZIMBABWE\\\" },\\n};\\nexport default AddressMetaData;\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs ***!
  \*****************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nexport const AddressMetaDataExtension = {\\n  \\\"data/AF\\\": {\\n    alpha_3_code: \\\"AFG\\\",\\n  },\\n  \\\"data/AX\\\": {\\n    alpha_3_code: \\\"ALA\\\",\\n  },\\n  \\\"data/AL\\\": {\\n    alpha_3_code: \\\"ALB\\\",\\n  },\\n  \\\"data/DZ\\\": {\\n    alpha_3_code: \\\"DZA\\\",\\n  },\\n  \\\"data/AS\\\": {\\n    alpha_3_code: \\\"ASM\\\",\\n  },\\n  \\\"data/AD\\\": {\\n    alpha_3_code: \\\"AND\\\",\\n  },\\n  \\\"data/AO\\\": {\\n    alpha_3_code: \\\"AGO\\\",\\n  },\\n  \\\"data/AI\\\": {\\n    alpha_3_code: \\\"AIA\\\",\\n  },\\n  \\\"data/AQ\\\": {\\n    alpha_3_code: \\\"ATA\\\",\\n  },\\n  \\\"data/AG\\\": {\\n    alpha_3_code: \\\"ATG\\\",\\n  },\\n  \\\"data/AR\\\": {\\n    alpha_3_code: \\\"ARG\\\",\\n  },\\n  \\\"data/AM\\\": {\\n    alpha_3_code: \\\"ARM\\\",\\n  },\\n  \\\"data/AW\\\": {\\n    alpha_3_code: \\\"ABW\\\",\\n  },\\n  \\\"data/AU\\\": {\\n    alpha_3_code: \\\"AUS\\\",\\n  },\\n  \\\"data/AT\\\": {\\n    alpha_3_code: \\\"AUT\\\",\\n  },\\n  \\\"data/AZ\\\": {\\n    alpha_3_code: \\\"AZE\\\",\\n  },\\n  \\\"data/BS\\\": {\\n    alpha_3_code: \\\"BHS\\\",\\n  },\\n  \\\"data/BH\\\": {\\n    alpha_3_code: \\\"BHR\\\",\\n  },\\n  \\\"data/BD\\\": {\\n    alpha_3_code: \\\"BGD\\\",\\n  },\\n  \\\"data/BB\\\": {\\n    alpha_3_code: \\\"BRB\\\",\\n  },\\n  \\\"data/BY\\\": {\\n    alpha_3_code: \\\"BLR\\\",\\n  },\\n  \\\"data/BE\\\": {\\n    alpha_3_code: \\\"BEL\\\",\\n  },\\n  \\\"data/BZ\\\": {\\n    alpha_3_code: \\\"BLZ\\\",\\n  },\\n  \\\"data/BJ\\\": {\\n    alpha_3_code: \\\"BEN\\\",\\n  },\\n  \\\"data/BM\\\": {\\n    alpha_3_code: \\\"BMU\\\",\\n  },\\n  \\\"data/BT\\\": {\\n    alpha_3_code: \\\"BTN\\\",\\n  },\\n  \\\"data/BO\\\": {\\n    alpha_3_code: \\\"BOL\\\",\\n  },\\n  \\\"data/BQ\\\": {\\n    alpha_3_code: \\\"BES\\\",\\n  },\\n  \\\"data/BA\\\": {\\n    alpha_3_code: \\\"BIH\\\",\\n  },\\n  \\\"data/BW\\\": {\\n    alpha_3_code: \\\"BWA\\\",\\n  },\\n  \\\"data/BV\\\": {\\n    alpha_3_code: \\\"BVT\\\",\\n  },\\n  \\\"data/BR\\\": {\\n    alpha_3_code: \\\"BRA\\\",\\n  },\\n  \\\"data/IO\\\": {\\n    alpha_3_code: \\\"IOT\\\",\\n  },\\n  \\\"data/BN\\\": {\\n    alpha_3_code: \\\"BRN\\\",\\n  },\\n  \\\"data/BG\\\": {\\n    alpha_3_code: \\\"BGR\\\",\\n  },\\n  \\\"data/BF\\\": {\\n    alpha_3_code: \\\"BFA\\\",\\n  },\\n  \\\"data/BI\\\": {\\n    alpha_3_code: \\\"BDI\\\",\\n  },\\n  \\\"data/CV\\\": {\\n    alpha_3_code: \\\"CPV\\\",\\n  },\\n  \\\"data/KH\\\": {\\n    alpha_3_code: \\\"KHM\\\",\\n  },\\n  \\\"data/CM\\\": {\\n    alpha_3_code: \\\"CMR\\\",\\n  },\\n  \\\"data/CA\\\": {\\n    alpha_3_code: \\\"CAN\\\",\\n  },\\n  \\\"data/KY\\\": {\\n    alpha_3_code: \\\"CYM\\\",\\n  },\\n  \\\"data/CF\\\": {\\n    alpha_3_code: \\\"CAF\\\",\\n  },\\n  \\\"data/TD\\\": {\\n    alpha_3_code: \\\"TCD\\\",\\n  },\\n  \\\"data/CL\\\": {\\n    alpha_3_code: \\\"CHL\\\",\\n  },\\n  \\\"data/CN\\\": {\\n    alpha_3_code: \\\"CHN\\\",\\n  },\\n  \\\"data/CX\\\": {\\n    alpha_3_code: \\\"CXR\\\",\\n  },\\n  \\\"data/CC\\\": {\\n    alpha_3_code: \\\"CCK\\\",\\n  },\\n  \\\"data/CO\\\": {\\n    alpha_3_code: \\\"COL\\\",\\n  },\\n  \\\"data/KM\\\": {\\n    alpha_3_code: \\\"COM\\\",\\n  },\\n  \\\"data/CG\\\": {\\n    alpha_3_code: \\\"COG\\\",\\n  },\\n  \\\"data/CD\\\": {\\n    alpha_3_code: \\\"COD\\\",\\n  },\\n  \\\"data/CK\\\": {\\n    alpha_3_code: \\\"COK\\\",\\n  },\\n  \\\"data/CR\\\": {\\n    alpha_3_code: \\\"CRI\\\",\\n  },\\n  \\\"data/CI\\\": {\\n    alpha_3_code: \\\"CIV\\\",\\n  },\\n  \\\"data/HR\\\": {\\n    alpha_3_code: \\\"HRV\\\",\\n  },\\n  \\\"data/CU\\\": {\\n    alpha_3_code: \\\"CUB\\\",\\n  },\\n  \\\"data/CW\\\": {\\n    alpha_3_code: \\\"CUW\\\",\\n  },\\n  \\\"data/CY\\\": {\\n    alpha_3_code: \\\"CYP\\\",\\n  },\\n  \\\"data/CZ\\\": {\\n    alpha_3_code: \\\"CZE\\\",\\n  },\\n  \\\"data/DK\\\": {\\n    alpha_3_code: \\\"DNK\\\",\\n  },\\n  \\\"data/DJ\\\": {\\n    alpha_3_code: \\\"DJI\\\",\\n  },\\n  \\\"data/DM\\\": {\\n    alpha_3_code: \\\"DMA\\\",\\n  },\\n  \\\"data/DO\\\": {\\n    alpha_3_code: \\\"DOM\\\",\\n  },\\n  \\\"data/EC\\\": {\\n    alpha_3_code: \\\"ECU\\\",\\n  },\\n  \\\"data/EG\\\": {\\n    alpha_3_code: \\\"EGY\\\",\\n  },\\n  \\\"data/SV\\\": {\\n    alpha_3_code: \\\"SLV\\\",\\n  },\\n  \\\"data/GQ\\\": {\\n    alpha_3_code: \\\"GNQ\\\",\\n  },\\n  \\\"data/ER\\\": {\\n    alpha_3_code: \\\"ERI\\\",\\n  },\\n  \\\"data/EE\\\": {\\n    alpha_3_code: \\\"EST\\\",\\n  },\\n  \\\"data/SZ\\\": {\\n    alpha_3_code: \\\"SWZ\\\",\\n  },\\n  \\\"data/ET\\\": {\\n    alpha_3_code: \\\"ETH\\\",\\n  },\\n  \\\"data/FK\\\": {\\n    alpha_3_code: \\\"FLK\\\",\\n  },\\n  \\\"data/FO\\\": {\\n    alpha_3_code: \\\"FRO\\\",\\n  },\\n  \\\"data/FJ\\\": {\\n    alpha_3_code: \\\"FJI\\\",\\n  },\\n  \\\"data/FI\\\": {\\n    alpha_3_code: \\\"FIN\\\",\\n  },\\n  \\\"data/FR\\\": {\\n    alpha_3_code: \\\"FRA\\\",\\n  },\\n  \\\"data/GF\\\": {\\n    alpha_3_code: \\\"GUF\\\",\\n  },\\n  \\\"data/PF\\\": {\\n    alpha_3_code: \\\"PYF\\\",\\n  },\\n  \\\"data/TF\\\": {\\n    alpha_3_code: \\\"ATF\\\",\\n  },\\n  \\\"data/GA\\\": {\\n    alpha_3_code: \\\"GAB\\\",\\n  },\\n  \\\"data/GM\\\": {\\n    alpha_3_code: \\\"GMB\\\",\\n  },\\n  \\\"data/GE\\\": {\\n    alpha_3_code: \\\"GEO\\\",\\n  },\\n  \\\"data/DE\\\": {\\n    alpha_3_code: \\\"DEU\\\",\\n    address_reversed: true,\\n  },\\n  \\\"data/GH\\\": {\\n    alpha_3_code: \\\"GHA\\\",\\n  },\\n  \\\"data/GI\\\": {\\n    alpha_3_code: \\\"GIB\\\",\\n  },\\n  \\\"data/GR\\\": {\\n    alpha_3_code: \\\"GRC\\\",\\n  },\\n  \\\"data/GL\\\": {\\n    alpha_3_code: \\\"GRL\\\",\\n  },\\n  \\\"data/GD\\\": {\\n    alpha_3_code: \\\"GRD\\\",\\n  },\\n  \\\"data/GP\\\": {\\n    alpha_3_code: \\\"GLP\\\",\\n  },\\n  \\\"data/GU\\\": {\\n    alpha_3_code: \\\"GUM\\\",\\n  },\\n  \\\"data/GT\\\": {\\n    alpha_3_code: \\\"GTM\\\",\\n  },\\n  \\\"data/GG\\\": {\\n    alpha_3_code: \\\"GGY\\\",\\n  },\\n  \\\"data/GN\\\": {\\n    alpha_3_code: \\\"GIN\\\",\\n  },\\n  \\\"data/GW\\\": {\\n    alpha_3_code: \\\"GNB\\\",\\n  },\\n  \\\"data/GY\\\": {\\n    alpha_3_code: \\\"GUY\\\",\\n  },\\n  \\\"data/HT\\\": {\\n    alpha_3_code: \\\"HTI\\\",\\n  },\\n  \\\"data/HM\\\": {\\n    alpha_3_code: \\\"HMD\\\",\\n  },\\n  \\\"data/VA\\\": {\\n    alpha_3_code: \\\"VAT\\\",\\n  },\\n  \\\"data/HN\\\": {\\n    alpha_3_code: \\\"HND\\\",\\n  },\\n  \\\"data/HK\\\": {\\n    alpha_3_code: \\\"HKG\\\",\\n  },\\n  \\\"data/HU\\\": {\\n    alpha_3_code: \\\"HUN\\\",\\n  },\\n  \\\"data/IS\\\": {\\n    alpha_3_code: \\\"ISL\\\",\\n  },\\n  \\\"data/IN\\\": {\\n    alpha_3_code: \\\"IND\\\",\\n  },\\n  \\\"data/ID\\\": {\\n    alpha_3_code: \\\"IDN\\\",\\n  },\\n  \\\"data/IR\\\": {\\n    alpha_3_code: \\\"IRN\\\",\\n  },\\n  \\\"data/IQ\\\": {\\n    alpha_3_code: \\\"IRQ\\\",\\n  },\\n  \\\"data/IE\\\": {\\n    alpha_3_code: \\\"IRL\\\",\\n  },\\n  \\\"data/IM\\\": {\\n    alpha_3_code: \\\"IMN\\\",\\n  },\\n  \\\"data/IL\\\": {\\n    alpha_3_code: \\\"ISR\\\",\\n  },\\n  \\\"data/IT\\\": {\\n    alpha_3_code: \\\"ITA\\\",\\n  },\\n  \\\"data/JM\\\": {\\n    alpha_3_code: \\\"JAM\\\",\\n  },\\n  \\\"data/JP\\\": {\\n    alpha_3_code: \\\"JPN\\\",\\n  },\\n  \\\"data/JE\\\": {\\n    alpha_3_code: \\\"JEY\\\",\\n  },\\n  \\\"data/JO\\\": {\\n    alpha_3_code: \\\"JOR\\\",\\n  },\\n  \\\"data/KZ\\\": {\\n    alpha_3_code: \\\"KAZ\\\",\\n  },\\n  \\\"data/KE\\\": {\\n    alpha_3_code: \\\"KEN\\\",\\n  },\\n  \\\"data/KI\\\": {\\n    alpha_3_code: \\\"KIR\\\",\\n  },\\n  \\\"data/KP\\\": {\\n    alpha_3_code: \\\"PRK\\\",\\n  },\\n  \\\"data/KR\\\": {\\n    alpha_3_code: \\\"KOR\\\",\\n  },\\n  \\\"data/KW\\\": {\\n    alpha_3_code: \\\"KWT\\\",\\n  },\\n  \\\"data/KG\\\": {\\n    alpha_3_code: \\\"KGZ\\\",\\n  },\\n  \\\"data/LA\\\": {\\n    alpha_3_code: \\\"LAO\\\",\\n  },\\n  \\\"data/LV\\\": {\\n    alpha_3_code: \\\"LVA\\\",\\n  },\\n  \\\"data/LB\\\": {\\n    alpha_3_code: \\\"LBN\\\",\\n  },\\n  \\\"data/LS\\\": {\\n    alpha_3_code: \\\"LSO\\\",\\n  },\\n  \\\"data/LR\\\": {\\n    alpha_3_code: \\\"LBR\\\",\\n  },\\n  \\\"data/LY\\\": {\\n    alpha_3_code: \\\"LBY\\\",\\n  },\\n  \\\"data/LI\\\": {\\n    alpha_3_code: \\\"LIE\\\",\\n  },\\n  \\\"data/LT\\\": {\\n    alpha_3_code: \\\"LTU\\\",\\n  },\\n  \\\"data/LU\\\": {\\n    alpha_3_code: \\\"LUX\\\",\\n  },\\n  \\\"data/MO\\\": {\\n    alpha_3_code: \\\"MAC\\\",\\n  },\\n  \\\"data/MG\\\": {\\n    alpha_3_code: \\\"MDG\\\",\\n  },\\n  \\\"data/MW\\\": {\\n    alpha_3_code: \\\"MWI\\\",\\n  },\\n  \\\"data/MY\\\": {\\n    alpha_3_code: \\\"MYS\\\",\\n  },\\n  \\\"data/MV\\\": {\\n    alpha_3_code: \\\"MDV\\\",\\n  },\\n  \\\"data/ML\\\": {\\n    alpha_3_code: \\\"MLI\\\",\\n  },\\n  \\\"data/MT\\\": {\\n    alpha_3_code: \\\"MLT\\\",\\n  },\\n  \\\"data/MH\\\": {\\n    alpha_3_code: \\\"MHL\\\",\\n  },\\n  \\\"data/MQ\\\": {\\n    alpha_3_code: \\\"MTQ\\\",\\n  },\\n  \\\"data/MR\\\": {\\n    alpha_3_code: \\\"MRT\\\",\\n  },\\n  \\\"data/MU\\\": {\\n    alpha_3_code: \\\"MUS\\\",\\n  },\\n  \\\"data/YT\\\": {\\n    alpha_3_code: \\\"MYT\\\",\\n  },\\n  \\\"data/MX\\\": {\\n    alpha_3_code: \\\"MEX\\\",\\n  },\\n  \\\"data/FM\\\": {\\n    alpha_3_code: \\\"FSM\\\",\\n  },\\n  \\\"data/MD\\\": {\\n    alpha_3_code: \\\"MDA\\\",\\n  },\\n  \\\"data/MC\\\": {\\n    alpha_3_code: \\\"MCO\\\",\\n  },\\n  \\\"data/MN\\\": {\\n    alpha_3_code: \\\"MNG\\\",\\n  },\\n  \\\"data/ME\\\": {\\n    alpha_3_code: \\\"MNE\\\",\\n  },\\n  \\\"data/MS\\\": {\\n    alpha_3_code: \\\"MSR\\\",\\n  },\\n  \\\"data/MA\\\": {\\n    alpha_3_code: \\\"MAR\\\",\\n  },\\n  \\\"data/MZ\\\": {\\n    alpha_3_code: \\\"MOZ\\\",\\n  },\\n  \\\"data/MM\\\": {\\n    alpha_3_code: \\\"MMR\\\",\\n  },\\n  \\\"data/NA\\\": {\\n    alpha_3_code: \\\"NAM\\\",\\n  },\\n  \\\"data/NR\\\": {\\n    alpha_3_code: \\\"NRU\\\",\\n  },\\n  \\\"data/NP\\\": {\\n    alpha_3_code: \\\"NPL\\\",\\n  },\\n  \\\"data/NL\\\": {\\n    alpha_3_code: \\\"NLD\\\",\\n  },\\n  \\\"data/NC\\\": {\\n    alpha_3_code: \\\"NCL\\\",\\n  },\\n  \\\"data/NZ\\\": {\\n    alpha_3_code: \\\"NZL\\\",\\n  },\\n  \\\"data/NI\\\": {\\n    alpha_3_code: \\\"NIC\\\",\\n  },\\n  \\\"data/NE\\\": {\\n    alpha_3_code: \\\"NER\\\",\\n  },\\n  \\\"data/NG\\\": {\\n    alpha_3_code: \\\"NGA\\\",\\n  },\\n  \\\"data/NU\\\": {\\n    alpha_3_code: \\\"NIU\\\",\\n  },\\n  \\\"data/NF\\\": {\\n    alpha_3_code: \\\"NFK\\\",\\n  },\\n  \\\"data/MK\\\": {\\n    alpha_3_code: \\\"MKD\\\",\\n  },\\n  \\\"data/MP\\\": {\\n    alpha_3_code: \\\"MNP\\\",\\n  },\\n  \\\"data/NO\\\": {\\n    alpha_3_code: \\\"NOR\\\",\\n  },\\n  \\\"data/OM\\\": {\\n    alpha_3_code: \\\"OMN\\\",\\n  },\\n  \\\"data/PK\\\": {\\n    alpha_3_code: \\\"PAK\\\",\\n  },\\n  \\\"data/PW\\\": {\\n    alpha_3_code: \\\"PLW\\\",\\n  },\\n  \\\"data/PS\\\": {\\n    alpha_3_code: \\\"PSE\\\",\\n  },\\n  \\\"data/PA\\\": {\\n    alpha_3_code: \\\"PAN\\\",\\n  },\\n  \\\"data/PG\\\": {\\n    alpha_3_code: \\\"PNG\\\",\\n  },\\n  \\\"data/PY\\\": {\\n    alpha_3_code: \\\"PRY\\\",\\n  },\\n  \\\"data/PE\\\": {\\n    alpha_3_code: \\\"PER\\\",\\n  },\\n  \\\"data/PH\\\": {\\n    alpha_3_code: \\\"PHL\\\",\\n  },\\n  \\\"data/PN\\\": {\\n    alpha_3_code: \\\"PCN\\\",\\n  },\\n  \\\"data/PL\\\": {\\n    alpha_3_code: \\\"POL\\\",\\n  },\\n  \\\"data/PT\\\": {\\n    alpha_3_code: \\\"PRT\\\",\\n  },\\n  \\\"data/PR\\\": {\\n    alpha_3_code: \\\"PRI\\\",\\n  },\\n  \\\"data/QA\\\": {\\n    alpha_3_code: \\\"QAT\\\",\\n  },\\n  \\\"data/RE\\\": {\\n    alpha_3_code: \\\"REU\\\",\\n  },\\n  \\\"data/RO\\\": {\\n    alpha_3_code: \\\"ROU\\\",\\n  },\\n  \\\"data/RU\\\": {\\n    alpha_3_code: \\\"RUS\\\",\\n  },\\n  \\\"data/RW\\\": {\\n    alpha_3_code: \\\"RWA\\\",\\n  },\\n  \\\"data/BL\\\": {\\n    alpha_3_code: \\\"BLM\\\",\\n  },\\n  \\\"data/SH\\\": {\\n    alpha_3_code: \\\"SHN\\\",\\n  },\\n  \\\"data/KN\\\": {\\n    alpha_3_code: \\\"KNA\\\",\\n  },\\n  \\\"data/LC\\\": {\\n    alpha_3_code: \\\"LCA\\\",\\n  },\\n  \\\"data/MF\\\": {\\n    alpha_3_code: \\\"MAF\\\",\\n  },\\n  \\\"data/PM\\\": {\\n    alpha_3_code: \\\"SPM\\\",\\n  },\\n  \\\"data/VC\\\": {\\n    alpha_3_code: \\\"VCT\\\",\\n  },\\n  \\\"data/WS\\\": {\\n    alpha_3_code: \\\"WSM\\\",\\n  },\\n  \\\"data/SM\\\": {\\n    alpha_3_code: \\\"SMR\\\",\\n  },\\n  \\\"data/ST\\\": {\\n    alpha_3_code: \\\"STP\\\",\\n  },\\n  \\\"data/SA\\\": {\\n    alpha_3_code: \\\"SAU\\\",\\n  },\\n  \\\"data/SN\\\": {\\n    alpha_3_code: \\\"SEN\\\",\\n  },\\n  \\\"data/RS\\\": {\\n    alpha_3_code: \\\"SRB\\\",\\n  },\\n  \\\"data/SC\\\": {\\n    alpha_3_code: \\\"SYC\\\",\\n  },\\n  \\\"data/SL\\\": {\\n    alpha_3_code: \\\"SLE\\\",\\n  },\\n  \\\"data/SG\\\": {\\n    alpha_3_code: \\\"SGP\\\",\\n  },\\n  \\\"data/SX\\\": {\\n    alpha_3_code: \\\"SXM\\\",\\n  },\\n  \\\"data/SK\\\": {\\n    alpha_3_code: \\\"SVK\\\",\\n  },\\n  \\\"data/SI\\\": {\\n    alpha_3_code: \\\"SVN\\\",\\n  },\\n  \\\"data/SB\\\": {\\n    alpha_3_code: \\\"SLB\\\",\\n  },\\n  \\\"data/SO\\\": {\\n    alpha_3_code: \\\"SOM\\\",\\n  },\\n  \\\"data/ZA\\\": {\\n    alpha_3_code: \\\"ZAF\\\",\\n  },\\n  \\\"data/GS\\\": {\\n    alpha_3_code: \\\"SGS\\\",\\n  },\\n  \\\"data/SS\\\": {\\n    alpha_3_code: \\\"SSD\\\",\\n  },\\n  \\\"data/ES\\\": {\\n    alpha_3_code: \\\"ESP\\\",\\n  },\\n  \\\"data/LK\\\": {\\n    alpha_3_code: \\\"LKA\\\",\\n  },\\n  \\\"data/SD\\\": {\\n    alpha_3_code: \\\"SDN\\\",\\n  },\\n  \\\"data/SR\\\": {\\n    alpha_3_code: \\\"SUR\\\",\\n  },\\n  \\\"data/SJ\\\": {\\n    alpha_3_code: \\\"SJM\\\",\\n  },\\n  \\\"data/SE\\\": {\\n    alpha_3_code: \\\"SWE\\\",\\n  },\\n  \\\"data/CH\\\": {\\n    alpha_3_code: \\\"CHE\\\",\\n  },\\n  \\\"data/SY\\\": {\\n    alpha_3_code: \\\"SYR\\\",\\n  },\\n  \\\"data/TW\\\": {\\n    alpha_3_code: \\\"TWN\\\",\\n  },\\n  \\\"data/TJ\\\": {\\n    alpha_3_code: \\\"TJK\\\",\\n  },\\n  \\\"data/TZ\\\": {\\n    alpha_3_code: \\\"TZA\\\",\\n  },\\n  \\\"data/TH\\\": {\\n    alpha_3_code: \\\"THA\\\",\\n  },\\n  \\\"data/TL\\\": {\\n    alpha_3_code: \\\"TLS\\\",\\n  },\\n  \\\"data/TG\\\": {\\n    alpha_3_code: \\\"TGO\\\",\\n  },\\n  \\\"data/TK\\\": {\\n    alpha_3_code: \\\"TKL\\\",\\n  },\\n  \\\"data/TO\\\": {\\n    alpha_3_code: \\\"TON\\\",\\n  },\\n  \\\"data/TT\\\": {\\n    alpha_3_code: \\\"TTO\\\",\\n  },\\n  \\\"data/TN\\\": {\\n    alpha_3_code: \\\"TUN\\\",\\n  },\\n  \\\"data/TR\\\": {\\n    alpha_3_code: \\\"TUR\\\",\\n  },\\n  \\\"data/TM\\\": {\\n    alpha_3_code: \\\"TKM\\\",\\n  },\\n  \\\"data/TC\\\": {\\n    alpha_3_code: \\\"TCA\\\",\\n  },\\n  \\\"data/TV\\\": {\\n    alpha_3_code: \\\"TUV\\\",\\n  },\\n  \\\"data/UG\\\": {\\n    alpha_3_code: \\\"UGA\\\",\\n  },\\n  \\\"data/UA\\\": {\\n    alpha_3_code: \\\"UKR\\\",\\n  },\\n  \\\"data/AE\\\": {\\n    alpha_3_code: \\\"ARE\\\",\\n  },\\n  \\\"data/GB\\\": {\\n    alpha_3_code: \\\"GBR\\\",\\n  },\\n  \\\"data/US\\\": {\\n    alternative_names: [\\n      \\\"US\\\",\\n      \\\"United States of America\\\",\\n      \\\"United States\\\",\\n      \\\"America\\\",\\n      \\\"U.S.\\\",\\n      \\\"USA\\\",\\n      \\\"U.S.A.\\\",\\n      \\\"U.S.A\\\",\\n    ],\\n    alpha_3_code: \\\"USA\\\",\\n  },\\n  \\\"data/UM\\\": {\\n    alpha_3_code: \\\"UMI\\\",\\n  },\\n  \\\"data/UY\\\": {\\n    alpha_3_code: \\\"URY\\\",\\n  },\\n  \\\"data/UZ\\\": {\\n    alpha_3_code: \\\"UZB\\\",\\n  },\\n  \\\"data/VU\\\": {\\n    alpha_3_code: \\\"VUT\\\",\\n  },\\n  \\\"data/VE\\\": {\\n    alpha_3_code: \\\"VEN\\\",\\n  },\\n  \\\"data/VN\\\": {\\n    alpha_3_code: \\\"VNM\\\",\\n  },\\n  \\\"data/VG\\\": {\\n    alpha_3_code: \\\"VGB\\\",\\n  },\\n  \\\"data/VI\\\": {\\n    alpha_3_code: \\\"VIR\\\",\\n  },\\n  \\\"data/WF\\\": {\\n    alpha_3_code: \\\"WLF\\\",\\n  },\\n  \\\"data/EH\\\": {\\n    alpha_3_code: \\\"ESH\\\",\\n  },\\n  \\\"data/YE\\\": {\\n    alpha_3_code: \\\"YEM\\\",\\n  },\\n  \\\"data/ZM\\\": {\\n    alpha_3_code: \\\"ZMB\\\",\\n  },\\n  \\\"data/ZW\\\": {\\n    alpha_3_code: \\\"ZWE\\\",\\n  },\\n};\\n\\nexport default AddressMetaDataExtension;\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs ***!
  \**************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nconst lazy = {};\\nChromeUtils.defineESModuleGetters(lazy, {\\n  AddressMetaData: \\\"resource://gre/modules/shared/AddressMetaData.sys.mjs\\\",\\n  AddressMetaDataExtension:\\n    \\\"resource://gre/modules/shared/AddressMetaDataExtension.sys.mjs\\\",\\n});\\n\\nexport class AddressMetaDataLoader {\\n  // Status of address data loading. We'll load all the countries with basic level 1\\n  // information while requesting conutry information, and set country to true.\\n  // Level 1 Set is for recording which country's level 1/level 2 data is loaded,\\n  // since we only load this when getCountryAddressData called with level 1 parameter.\\n  static dataLoaded = {\\n    country: false,\\n    level1: new Set(),\\n  };\\n\\n  static addressData = {};\\n\\n  static DATA_PREFIX = \\\"data/\\\";\\n\\n  /**\\n   * Load address meta data and extension into one object.\\n   *\\n   * @returns {object}\\n   *          An object containing address data object with properties from extension.\\n   */\\n  static loadAddressMetaData() {\\n    const addressMetaData = lazy.AddressMetaData;\\n\\n    for (const key in lazy.AddressMetaDataExtension) {\\n      let addressDataForKey = addressMetaData[key];\\n      if (!addressDataForKey) {\\n        addressDataForKey = addressMetaData[key] = {};\\n      }\\n\\n      Object.assign(addressDataForKey, lazy.AddressMetaDataExtension[key]);\\n    }\\n    return addressMetaData;\\n  }\\n\\n  /**\\n   * Convert certain properties' string value into array. We should make sure\\n   * the cached data is parsed.\\n   *\\n   * @param   {object} data Original metadata from addressReferences.\\n   * @returns {object} parsed metadata with property value that converts to array.\\n   */\\n  static #parse(data) {\\n    if (!data) {\\n      return null;\\n    }\\n\\n    const properties = [\\n      \\\"languages\\\",\\n      \\\"sub_keys\\\",\\n      \\\"sub_isoids\\\",\\n      \\\"sub_names\\\",\\n      \\\"sub_lnames\\\",\\n    ];\\n    for (const key of properties) {\\n      if (!data[key]) {\\n        continue;\\n      }\\n      // No need to normalize data if the value is array already.\\n      if (Array.isArray(data[key])) {\\n        return data;\\n      }\\n\\n      data[key] = data[key].split(\\\"~\\\");\\n    }\\n    return data;\\n  }\\n\\n  /**\\n   * We'll cache addressData in the loader once the data loaded from scripts.\\n   * It'll become the example below after loading addressReferences with extension:\\n   * addressData: {\\n   *               \\\"data/US\\\": {\\\"lang\\\": [\\\"en\\\"], ...// Data defined in libaddressinput metadata\\n   *                           \\\"alternative_names\\\": ... // Data defined in extension }\\n   *               \\\"data/CA\\\": {} // Other supported country metadata\\n   *               \\\"data/TW\\\": {} // Other supported country metadata\\n   *               \\\"data/TW/台北市\\\": {} // Other supported country level 1 metadata\\n   *              }\\n   *\\n   * @param   {string} country\\n   * @param   {string?} level1\\n   * @returns {object} Default locale metadata\\n   */\\n  static #loadData(country, level1 = null) {\\n    // Load the addressData if needed\\n    if (!this.dataLoaded.country) {\\n      this.addressData = this.loadAddressMetaData();\\n      this.dataLoaded.country = true;\\n    }\\n    if (!level1) {\\n      return this.#parse(this.addressData[`${this.DATA_PREFIX}${country}`]);\\n    }\\n    // If level1 is set, load addressReferences under country folder with specific\\n    // country/level 1 for level 2 information.\\n    if (!this.dataLoaded.level1.has(country)) {\\n      Object.assign(this.addressData, this.loadAddressMetaData());\\n      this.dataLoaded.level1.add(country);\\n    }\\n    return this.#parse(\\n      this.addressData[`${this.DATA_PREFIX}${country}/${level1}`]\\n    );\\n  }\\n\\n  /**\\n   * Return the region metadata with default locale and other locales (if exists).\\n   *\\n   * @param   {string} country\\n   * @param   {string?} level1\\n   * @returns {object} Return default locale and other locales metadata.\\n   */\\n  static getData(country, level1 = null) {\\n    const defaultLocale = this.#loadData(country, level1);\\n    if (!defaultLocale) {\\n      return null;\\n    }\\n\\n    const countryData = this.#parse(\\n      this.addressData[`${this.DATA_PREFIX}${country}`]\\n    );\\n    let locales = [];\\n    // TODO: Should be able to support multi-locale level 1/ level 2 metadata query\\n    //      in Bug 1421886\\n    if (countryData.languages) {\\n      const list = countryData.languages.filter(\\n        key => key !== countryData.lang\\n      );\\n      locales = list.map(key =>\\n        this.#parse(this.addressData[`${defaultLocale.id}--${key}`])\\n      );\\n    }\\n    return { defaultLocale, locales };\\n  }\\n\\n  /**\\n   * Return an array containing countries alpha2 codes.\\n   *\\n   * @returns {Array} Return an array containing countries alpha2 codes.\\n   */\\n  static get #countryCodes() {\\n    return Object.keys(lazy.AddressMetaDataExtension).map(dataKey =>\\n      dataKey.replace(this.DATA_PREFIX, \\\"\\\")\\n    );\\n  }\\n\\n  static getCountries(locales = []) {\\n    const displayNames = new Intl.DisplayNames(locales, {\\n      type: \\\"region\\\",\\n      fallback: \\\"none\\\",\\n    });\\n    const countriesMap = new Map();\\n    for (const countryCode of this.#countryCodes) {\\n      countriesMap.set(countryCode, displayNames.of(countryCode));\\n    }\\n    return countriesMap;\\n  }\\n}\\n\\nexport default AddressMetaDataLoader;\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressParser.sys.mjs":
/*!******************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressParser.sys.mjs ***!
  \******************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* eslint-disable no-useless-concat */\\n/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n// NamedCaptureGroup class represents a named capturing group in a regular expression\\nclass NamedCaptureGroup {\\n  // The named of this capturing group\\n  #name = null;\\n\\n  // The capturing group\\n  #capture = null;\\n\\n  // The matched result\\n  #match = null;\\n\\n  constructor(name, capture) {\\n    this.#name = name;\\n    this.#capture = capture;\\n  }\\n\\n  get name() {\\n    return this.#name;\\n  }\\n\\n  get capture() {\\n    return this.#capture;\\n  }\\n\\n  get match() {\\n    return this.#match;\\n  }\\n\\n  // Setter for the matched result based on the match groups\\n  setMatch(matchGroups) {\\n    this.#match = matchGroups[this.#name];\\n  }\\n}\\n\\n// Base class for different part of a street address regular expression.\\n// The regular expression is constructed with prefix, pattern, suffix\\n// and separator to extract \\\"value\\\" part.\\n// For examplem, when we write \\\"apt 4.\\\" to for floor number, its prefix is `apt`,\\n// suffix is `.` and value to represent apartment number is `4`.\\nclass StreetAddressPartRegExp extends NamedCaptureGroup {\\n  constructor(name, prefix, pattern, suffix, sep, optional = false) {\\n    prefix = prefix ?? \\\"\\\";\\n    suffix = suffix ?? \\\"\\\";\\n    super(\\n      name,\\n      `((?:${prefix})(?<${name}>${pattern})(?:${suffix})(?:${sep})+)${\\n        optional ? \\\"?\\\" : \\\"\\\"\\n      }`\\n    );\\n  }\\n}\\n\\n// A regular expression to match the street number portion of a street address,\\nclass StreetNumberRegExp extends StreetAddressPartRegExp {\\n  static PREFIX = \\\"((no|°|º|number)(\\\\\\\\.|-|\\\\\\\\s)*)?\\\"; // From chromium source\\n\\n  static PATTERN = \\\"\\\\\\\\d+\\\\\\\\w?\\\";\\n\\n  // TODO: possible suffix : (th\\\\\\\\.|\\\\\\\\.)?\\n  static SUFFIX = null;\\n\\n  constructor(sep, optional) {\\n    super(\\n      StreetNumberRegExp.name,\\n      StreetNumberRegExp.PREFIX,\\n      StreetNumberRegExp.PATTERN,\\n      StreetNumberRegExp.SUFFIX,\\n      sep,\\n      optional\\n    );\\n  }\\n}\\n\\n// A regular expression to match the street name portion of a street address,\\nclass StreetNameRegExp extends StreetAddressPartRegExp {\\n  static PREFIX = null;\\n\\n  static PATTERN = \\\"(?:[^\\\\\\\\s,]+(?:[^\\\\\\\\S\\\\\\\\r\\\\\\\\n]+[^\\\\\\\\s,]+)*?)\\\"; // From chromium source\\n\\n  // TODO: Should we consider suffix like (ave|st)?\\n  static SUFFIX = null;\\n\\n  constructor(sep, optional) {\\n    super(\\n      StreetNameRegExp.name,\\n      StreetNameRegExp.PREFIX,\\n      StreetNameRegExp.PATTERN,\\n      StreetNameRegExp.SUFFIX,\\n      sep,\\n      optional\\n    );\\n  }\\n}\\n\\n// A regular expression to match the apartment number portion of a street address,\\nclass ApartmentNumberRegExp extends StreetAddressPartRegExp {\\n  static keyword = \\\"apt|apartment|wohnung|apto|-\\\" + \\\"|unit|suite|ste|#|room\\\"; // From chromium source // Firefox specific\\n  static PREFIX = `(${ApartmentNumberRegExp.keyword})(\\\\\\\\.|\\\\\\\\s|-)*`;\\n\\n  static PATTERN = \\\"\\\\\\\\w*([-|\\\\\\\\/]\\\\\\\\w*)?\\\";\\n\\n  static SUFFIX = \\\"(\\\\\\\\.|\\\\\\\\s|-)*(ª)?\\\"; // From chromium source\\n\\n  constructor(sep, optional) {\\n    super(\\n      ApartmentNumberRegExp.name,\\n      ApartmentNumberRegExp.PREFIX,\\n      ApartmentNumberRegExp.PATTERN,\\n      ApartmentNumberRegExp.SUFFIX,\\n      sep,\\n      optional\\n    );\\n  }\\n}\\n\\n// A regular expression to match the floor number portion of a street address,\\nclass FloorNumberRegExp extends StreetAddressPartRegExp {\\n  static keyword =\\n    \\\"floor|flur|fl|og|obergeschoss|ug|untergeschoss|geschoss|andar|piso|º\\\" + // From chromium source\\n    \\\"|level|lvl\\\"; // Firefox specific\\n  static PREFIX = `(${FloorNumberRegExp.keyword})?(\\\\\\\\.|\\\\\\\\s|-)*`; // TODO\\n  static PATTERN = \\\"\\\\\\\\d{1,3}\\\\\\\\w?\\\";\\n  static SUFFIX = `(st|nd|rd|th)?(\\\\\\\\.|\\\\\\\\s|-)*(${FloorNumberRegExp.keyword})?`; // TODO\\n\\n  constructor(sep, optional) {\\n    super(\\n      FloorNumberRegExp.name,\\n      FloorNumberRegExp.PREFIX,\\n      FloorNumberRegExp.PATTERN,\\n      FloorNumberRegExp.SUFFIX,\\n      sep,\\n      optional\\n    );\\n  }\\n}\\n\\n/**\\n * Class represents a street address with the following fields:\\n * - street number\\n * - street name\\n * - apartment number\\n * - floor number\\n */\\nexport class StructuredStreetAddress {\\n  #street_number = null;\\n  #street_name = null;\\n  #apartment_number = null;\\n  #floor_number = null;\\n\\n  // If name_first is true, then the street name is given first,\\n  // otherwise the street number is given first.\\n  constructor(\\n    name_first,\\n    street_number,\\n    street_name,\\n    apartment_number,\\n    floor_number\\n  ) {\\n    this.#street_number = name_first\\n      ? street_name?.toString()\\n      : street_number?.toString();\\n    this.#street_name = name_first\\n      ? street_number?.toString()\\n      : street_name?.toString();\\n    this.#apartment_number = apartment_number?.toString();\\n    this.#floor_number = floor_number?.toString();\\n  }\\n\\n  get street_number() {\\n    return this.#street_number;\\n  }\\n\\n  get street_name() {\\n    return this.#street_name;\\n  }\\n\\n  get apartment_number() {\\n    return this.#apartment_number;\\n  }\\n\\n  get floor_number() {\\n    return this.#floor_number;\\n  }\\n\\n  toString() {\\n    return `\\n      street number: ${this.#street_number}\\\\n\\n      street name: ${this.#street_name}\\\\n\\n      apartment number: ${this.#apartment_number}\\\\n\\n      floor number: ${this.#floor_number}\\\\n\\n    `;\\n  }\\n}\\n\\nexport class AddressParser {\\n  /**\\n   * Parse street address with the following pattern.\\n   * street number, street name, apartment number(optional), floor number(optional)\\n   * For example, 2 Harrison St #175 floor 2\\n   *\\n   * @param {string} address The street address to be parsed.\\n   * @returns {StructuredStreetAddress}\\n   */\\n  static parseStreetAddress(address) {\\n    if (!address) {\\n      return null;\\n    }\\n\\n    const separator = \\\"(\\\\\\\\s|,|$)\\\";\\n\\n    const regexpes = [\\n      new StreetNumberRegExp(separator),\\n      new StreetNameRegExp(separator),\\n      new ApartmentNumberRegExp(separator, true),\\n      new FloorNumberRegExp(separator, true),\\n    ];\\n\\n    if (AddressParser.parse(address, regexpes)) {\\n      return new StructuredStreetAddress(\\n        false,\\n        ...regexpes.map(regexp => regexp.match)\\n      );\\n    }\\n\\n    // Swap the street number and name.\\n    const regexpesReverse = [\\n      regexpes[1],\\n      regexpes[0],\\n      regexpes[2],\\n      regexpes[3],\\n    ];\\n\\n    if (AddressParser.parse(address, regexpesReverse)) {\\n      return new StructuredStreetAddress(\\n        true,\\n        ...regexpesReverse.map(regexp => regexp.match)\\n      );\\n    }\\n\\n    return null;\\n  }\\n\\n  static parse(address, regexpes) {\\n    const options = {\\n      trim: true,\\n      merge_whitespace: true,\\n    };\\n    address = AddressParser.normalizeString(address, options);\\n\\n    const match = address.match(\\n      new RegExp(`^(${regexpes.map(regexp => regexp.capture).join(\\\"\\\")})$`, \\\"i\\\")\\n    );\\n    if (!match) {\\n      return null;\\n    }\\n\\n    regexpes.forEach(regexp => regexp.setMatch(match.groups));\\n    return regexpes.reduce((acc, current) => {\\n      return { ...acc, [current.name]: current.match };\\n    }, {});\\n  }\\n\\n  static normalizeString(s, options) {\\n    if (typeof s != \\\"string\\\") {\\n      return s;\\n    }\\n\\n    if (options.ignore_case) {\\n      s = s.toLowerCase();\\n    }\\n\\n    // process punctuation before whitespace because if a punctuation\\n    // is replaced with whitespace, we might want to merge it later\\n    if (options.remove_punctuation) {\\n      s = AddressParser.replacePunctuation(s, \\\"\\\");\\n    } else if (\\\"replace_punctuation\\\" in options) {\\n      const replace = options.replace_punctuation;\\n      s = AddressParser.replacePunctuation(s, replace);\\n    }\\n\\n    // process whitespace\\n    if (options.merge_whitespace) {\\n      s = AddressParser.mergeWhitespace(s);\\n    } else if (options.remove_whitespace) {\\n      s = AddressParser.removeWhitespace(s);\\n    }\\n\\n    return s.trim();\\n  }\\n\\n  static replacePunctuation(s, replace) {\\n    const regex = /\\\\p{Punctuation}/gu;\\n    return s?.replace(regex, replace);\\n  }\\n\\n  static removePunctuation(s) {\\n    return s?.replace(/[.,\\\\/#!$%\\\\^&\\\\*;:{}=\\\\-_~()]/g, \\\"\\\");\\n  }\\n\\n  static replaceControlCharacters(s) {\\n    return s?.replace(/[\\\\t\\\\n\\\\r]/g, \\\" \\\");\\n  }\\n\\n  static removeWhitespace(s) {\\n    return s?.replace(/[\\\\s]/g, \\\"\\\");\\n  }\\n\\n  static mergeWhitespace(s) {\\n    return s?.replace(/\\\\s{2,}/g, \\\" \\\");\\n  }\\n}\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressParser.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs":
/*!******************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs ***!
  \******************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* eslint-disable no-useless-concat */\\n/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nimport { FormAutofillNameUtils } from \\\"resource://gre/modules/shared/FormAutofillNameUtils.sys.mjs\\\";\\nimport { FormAutofillUtils } from \\\"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\\\";\\nimport { PhoneNumber } from \\\"resource://gre/modules/shared/PhoneNumber.sys.mjs\\\";\\nimport { FormAutofill } from \\\"resource://autofill/FormAutofill.sys.mjs\\\";\\n\\n/**\\n * The AddressRecord class serves to handle and normalize internal address records.\\n * AddressRecord is used for processing and consistent data representation.\\n */\\nexport class AddressRecord {\\n  static NAME_COMPONENTS = [\\\"given-name\\\", \\\"additional-name\\\", \\\"family-name\\\"];\\n\\n  static STREET_ADDRESS_COMPONENTS = [\\n    \\\"address-line1\\\",\\n    \\\"address-line2\\\",\\n    \\\"address-line3\\\",\\n  ];\\n  static TEL_COMPONENTS = [\\n    \\\"tel-country-code\\\",\\n    \\\"tel-national\\\",\\n    \\\"tel-area-code\\\",\\n    \\\"tel-local\\\",\\n    \\\"tel-local-prefix\\\",\\n    \\\"tel-local-suffix\\\",\\n  ];\\n\\n  static computeFields(address) {\\n    this.#computeNameFields(address);\\n    this.#computeAddressLineFields(address);\\n    this.#computeCountryFields(address);\\n    this.#computeTelFields(address);\\n  }\\n\\n  static #computeNameFields(address) {\\n    // Compute split names\\n    if (!(\\\"given-name\\\" in address)) {\\n      const nameParts = FormAutofillNameUtils.splitName(address.name);\\n      address[\\\"given-name\\\"] = nameParts.given;\\n      address[\\\"additional-name\\\"] = nameParts.middle;\\n      address[\\\"family-name\\\"] = nameParts.family;\\n    }\\n  }\\n\\n  static #computeAddressLineFields(address) {\\n    // Compute address lines\\n    if (!(\\\"address-line1\\\" in address)) {\\n      let streetAddress = [];\\n      if (address[\\\"street-address\\\"]) {\\n        streetAddress = address[\\\"street-address\\\"]\\n          .split(\\\"\\\\n\\\")\\n          .map(s => s.trim());\\n      }\\n      for (let i = 0; i < 3; i++) {\\n        address[`address-line${i + 1}`] = streetAddress[i] || \\\"\\\";\\n      }\\n      if (streetAddress.length > 3) {\\n        address[\\\"address-line3\\\"] = FormAutofillUtils.toOneLineAddress(\\n          streetAddress.slice(2)\\n        );\\n      }\\n    }\\n  }\\n\\n  static #computeCountryFields(address) {\\n    // Compute country name\\n    if (!(\\\"country-name\\\" in address)) {\\n      address[\\\"country-name\\\"] =\\n        FormAutofill.countries.get(address.country) ?? \\\"\\\";\\n    }\\n  }\\n\\n  static #computeTelFields(address) {\\n    // Compute tel\\n    if (!(\\\"tel-national\\\" in address)) {\\n      if (address.tel) {\\n        let tel = PhoneNumber.Parse(\\n          address.tel,\\n          address.country || FormAutofill.DEFAULT_REGION\\n        );\\n        if (tel) {\\n          if (tel.countryCode) {\\n            address[\\\"tel-country-code\\\"] = tel.countryCode;\\n          }\\n          if (tel.nationalNumber) {\\n            address[\\\"tel-national\\\"] = tel.nationalNumber;\\n          }\\n\\n          // PhoneNumberUtils doesn't support parsing the components of a telephone\\n          // number so we hard coded the parser for US numbers only. We will need\\n          // to figure out how to parse numbers from other regions when we support\\n          // new countries in the future.\\n          if (tel.nationalNumber && tel.countryCode == \\\"+1\\\") {\\n            let telComponents = tel.nationalNumber.match(\\n              /(\\\\d{3})((\\\\d{3})(\\\\d{4}))$/\\n            );\\n            if (telComponents) {\\n              address[\\\"tel-area-code\\\"] = telComponents[1];\\n              address[\\\"tel-local\\\"] = telComponents[2];\\n              address[\\\"tel-local-prefix\\\"] = telComponents[3];\\n              address[\\\"tel-local-suffix\\\"] = telComponents[4];\\n            }\\n          }\\n        } else {\\n          // Treat \\\"tel\\\" as \\\"tel-national\\\" directly if it can't be parsed.\\n          address[\\\"tel-national\\\"] = address.tel;\\n        }\\n      }\\n\\n      this.TEL_COMPONENTS.forEach(c => {\\n        address[c] = address[c] || \\\"\\\";\\n      });\\n    }\\n  }\\n}\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AutofillFormFactory.sys.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AutofillFormFactory.sys.mjs ***!
  \************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n/**\\n * A factory to generate AutofillForm objects that represent a set of autofillable fields\\n * which aren't necessarily marked up with a <form> element.\\n */\\n\\nconst lazy = {};\\n\\nChromeUtils.defineESModuleGetters(lazy, {\\n  FormLikeFactory: \\\"resource://gre/modules/FormLikeFactory.sys.mjs\\\",\\n});\\n\\nexport const AutofillFormFactory = {\\n  findRootForField(element) {\\n    let ignoreForm;\\n    try {\\n      const bc = element.ownerGlobal.browsingContext;\\n      ignoreForm = bc != bc.top;\\n    } catch {\\n      ignoreForm = false;\\n    }\\n    return lazy.FormLikeFactory.findRootForField(element, { ignoreForm });\\n  },\\n\\n  createFromForm(aForm) {\\n    return lazy.FormLikeFactory.createFromForm(aForm);\\n  },\\n\\n  createFromField(aField) {\\n    let ignoreForm;\\n    try {\\n      const bc = aField.ownerGlobal.browsingContext;\\n      ignoreForm = bc != bc.top;\\n    } catch {\\n      ignoreForm = false;\\n    }\\n    return lazy.FormLikeFactory.createFromField(aField, { ignoreForm });\\n  },\\n};\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AutofillFormFactory.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs ***!
  \**********************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nimport { FormAutofillUtils } from \\\"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\\\";\\n\\nconst { FIELD_STATES } = FormAutofillUtils;\\n\\nclass AutofillTelemetryBase {\\n  SUPPORTED_FIELDS = {};\\n\\n  EVENT_CATEGORY = null;\\n  EVENT_OBJECT_FORM_INTERACTION = null;\\n\\n  HISTOGRAM_NUM_USES = null;\\n  HISTOGRAM_PROFILE_NUM_USES = null;\\n  HISTOGRAM_PROFILE_NUM_USES_KEY = null;\\n\\n  #initFormEventExtra(value) {\\n    let extra = {};\\n    for (const field of Object.values(this.SUPPORTED_FIELDS)) {\\n      extra[field] = value;\\n    }\\n    return extra;\\n  }\\n\\n  #setFormEventExtra(extra, key, value) {\\n    if (!this.SUPPORTED_FIELDS[key]) {\\n      return;\\n    }\\n\\n    extra[this.SUPPORTED_FIELDS[key]] = value;\\n  }\\n\\n  recordFormDetected(flowId, fieldDetails) {\\n    let extra = this.#initFormEventExtra(\\\"false\\\");\\n\\n    let identified = new Set();\\n    fieldDetails.forEach(detail => {\\n      identified.add(detail.fieldName);\\n\\n      if (detail.reason == \\\"autocomplete\\\") {\\n        this.#setFormEventExtra(extra, detail.fieldName, \\\"true\\\");\\n      } else {\\n        // confidence exists only when a field is identified by fathom.\\n        let confidence =\\n          detail.confidence > 0 ? Math.floor(100 * detail.confidence) / 100 : 0;\\n\\n        this.#setFormEventExtra(\\n          extra,\\n          detail.fieldName,\\n          confidence ? confidence.toString() : \\\"0\\\"\\n        );\\n      }\\n    });\\n\\n    this.recordFormEvent(\\\"detected\\\", flowId, extra);\\n    try {\\n      this.recordIframeLayoutDetection(flowId, fieldDetails);\\n    } catch {}\\n  }\\n\\n  recordPopupShown(flowId, fieldDetails) {\\n    const extra = { field_name: fieldDetails[0].fieldName };\\n    this.recordFormEvent(\\\"popup_shown\\\", flowId, extra);\\n  }\\n\\n  setUpFormFilledExtra(fieldDetails, data) {\\n    // Calculate values for telemetry\\n    const extra = this.#initFormEventExtra(\\\"unavailable\\\");\\n\\n    for (const fieldDetail of fieldDetails) {\\n      // It is possible that we don't autofill a field because it is cross-origin.\\n      // When that happens, the data will not include that element.\\n      let { filledState, filledValue, isFilledOnFieldsUpdate } =\\n        data.get(fieldDetail.elementId) ?? {};\\n      switch (filledState) {\\n        case FIELD_STATES.AUTO_FILLED:\\n          filledState = isFilledOnFieldsUpdate\\n            ? \\\"filled_on_fields_update\\\"\\n            : \\\"filled\\\";\\n          break;\\n        case FIELD_STATES.NORMAL:\\n        default:\\n          filledState =\\n            fieldDetail.localName == \\\"select\\\" || filledValue?.length\\n              ? \\\"user_filled\\\"\\n              : \\\"not_filled\\\";\\n          break;\\n      }\\n      this.#setFormEventExtra(extra, fieldDetail.fieldName, filledState);\\n    }\\n    return extra;\\n  }\\n\\n  recordFormFilled(flowId, fieldDetails, data) {\\n    const extra = this.setUpFormFilledExtra(fieldDetails, data);\\n    this.recordFormEvent(\\\"filled\\\", flowId, extra);\\n  }\\n\\n  recordFormFilledOnFieldsUpdate(flowId, fieldDetails, data) {\\n    const extra = this.setUpFormFilledExtra(fieldDetails, data);\\n    this.recordFormEvent(\\\"filled_on_fields_update\\\", flowId, extra);\\n  }\\n\\n  recordFilledModified(flowId, fieldDetails) {\\n    const extra = { field_name: fieldDetails[0].fieldName };\\n    this.recordFormEvent(\\\"filled_modified\\\", flowId, extra);\\n  }\\n\\n  recordFormSubmitted(flowId, fieldDetails, data) {\\n    const extra = this.#initFormEventExtra(\\\"unavailable\\\");\\n\\n    for (const fieldDetail of fieldDetails) {\\n      let { filledState, filledValue } = data.get(fieldDetail.elementId) ?? {};\\n      switch (filledState) {\\n        case FIELD_STATES.AUTO_FILLED:\\n          filledState = \\\"autofilled\\\";\\n          break;\\n        case FIELD_STATES.NORMAL:\\n        default:\\n          filledState =\\n            fieldDetail.localName == \\\"select\\\" || filledValue?.length\\n              ? \\\"user_filled\\\"\\n              : \\\"not_filled\\\";\\n          break;\\n      }\\n      this.#setFormEventExtra(extra, fieldDetail.fieldName, filledState);\\n    }\\n\\n    this.recordFormEvent(\\\"submitted\\\", flowId, extra);\\n  }\\n\\n  recordFormCleared(flowId, fieldDetails) {\\n    const extra = { field_name: fieldDetails[0].fieldName };\\n\\n    // Note that when a form is cleared, we also record `filled_modified` events\\n    // for all the fields that have been cleared.\\n    this.recordFormEvent(\\\"cleared\\\", flowId, extra);\\n  }\\n\\n  recordFormEvent(_method, _flowId, _extra) {\\n    throw new Error(\\\"Not implemented.\\\");\\n  }\\n\\n  recordFormInteractionEvent(method, flowId, fieldDetails, data) {\\n    if (!this.EVENT_OBJECT_FORM_INTERACTION) {\\n      return undefined;\\n    }\\n    switch (method) {\\n      case \\\"detected\\\":\\n        return this.recordFormDetected(flowId, fieldDetails);\\n      case \\\"popup_shown\\\":\\n        return this.recordPopupShown(flowId, fieldDetails);\\n      case \\\"filled\\\":\\n        return this.recordFormFilled(flowId, fieldDetails, data);\\n      case \\\"filled_on_fields_update\\\":\\n        return this.recordFormFilledOnFieldsUpdate(flowId, fieldDetails, data);\\n      case \\\"filled_modified\\\":\\n        return this.recordFilledModified(flowId, fieldDetails);\\n      case \\\"submitted\\\":\\n        return this.recordFormSubmitted(flowId, fieldDetails, data);\\n      case \\\"cleared\\\":\\n        return this.recordFormCleared(flowId, fieldDetails);\\n    }\\n    return undefined;\\n  }\\n\\n  recordDoorhangerEvent(method, object, flowId) {\\n    const eventName = `${method}_${object}`.replace(/(_[a-z])/g, c =>\\n      c[1].toUpperCase()\\n    );\\n    Glean[this.EVENT_CATEGORY][eventName]?.record({ value: flowId });\\n  }\\n\\n  recordManageEvent(method) {\\n    const eventName =\\n      method.replace(/(_[a-z])/g, c => c[1].toUpperCase()) + \\\"Manage\\\";\\n    Glean[this.EVENT_CATEGORY][eventName]?.record();\\n  }\\n\\n  recordAutofillProfileCount(_count) {\\n    throw new Error(\\\"Not implemented.\\\");\\n  }\\n\\n  recordNumberOfUse(records) {\\n    let histogram = Services.telemetry.getKeyedHistogramById(\\n      this.HISTOGRAM_PROFILE_NUM_USES\\n    );\\n    histogram.clear();\\n\\n    for (let record of records) {\\n      histogram.add(this.HISTOGRAM_PROFILE_NUM_USES_KEY, record.timesUsed);\\n    }\\n  }\\n\\n  recordIframeLayoutDetection(flowId, fieldDetails) {\\n    const fieldsInMainFrame = [];\\n    const fieldsInIframe = [];\\n    const fieldsInSandboxedIframe = [];\\n    const fieldsInCrossOrignIframe = [];\\n\\n    const iframes = new Set();\\n    for (const fieldDetail of fieldDetails) {\\n      const bc = BrowsingContext.get(fieldDetail.browsingContextId);\\n      if (bc.top == bc) {\\n        fieldsInMainFrame.push(fieldDetail);\\n        continue;\\n      }\\n\\n      iframes.add(bc);\\n      fieldsInIframe.push(fieldDetail);\\n      if (bc.sandboxFlags != 0) {\\n        fieldsInSandboxedIframe.push(fieldDetail);\\n      }\\n\\n      if (!FormAutofillUtils.isBCSameOriginWithTop(bc)) {\\n        fieldsInCrossOrignIframe.push(fieldDetail);\\n      }\\n    }\\n\\n    const extra = {\\n      category: this.EVENT_CATEGORY,\\n      flow_id: flowId,\\n      iframe_count: iframes.size,\\n      main_frame: fieldsInMainFrame.map(f => f.fieldName).toString(),\\n      iframe: fieldsInIframe.map(f => f.fieldName).toString(),\\n      cross_origin: fieldsInCrossOrignIframe.map(f => f.fieldName).toString(),\\n      sandboxed: fieldsInSandboxedIframe.map(f => f.fieldName).toString(),\\n    };\\n\\n    Glean.formautofill.iframeLayoutDetection.record(extra);\\n  }\\n}\\n\\nexport class AddressTelemetry extends AutofillTelemetryBase {\\n  EVENT_CATEGORY = \\\"address\\\";\\n  EVENT_OBJECT_FORM_INTERACTION = \\\"AddressForm\\\";\\n  EVENT_OBJECT_FORM_INTERACTION_EXT = \\\"AddressFormExt\\\";\\n\\n  HISTOGRAM_PROFILE_NUM_USES = \\\"AUTOFILL_PROFILE_NUM_USES\\\";\\n  HISTOGRAM_PROFILE_NUM_USES_KEY = \\\"address\\\";\\n\\n  // Fields that are recorded in `address_form` and `address_form_ext` telemetry\\n  SUPPORTED_FIELDS = {\\n    \\\"street-address\\\": \\\"street_address\\\",\\n    \\\"address-line1\\\": \\\"address_line1\\\",\\n    \\\"address-line2\\\": \\\"address_line2\\\",\\n    \\\"address-line3\\\": \\\"address_line3\\\",\\n    \\\"address-level1\\\": \\\"address_level1\\\",\\n    \\\"address-level2\\\": \\\"address_level2\\\",\\n    \\\"postal-code\\\": \\\"postal_code\\\",\\n    country: \\\"country\\\",\\n    name: \\\"name\\\",\\n    \\\"given-name\\\": \\\"given_name\\\",\\n    \\\"additional-name\\\": \\\"additional_name\\\",\\n    \\\"family-name\\\": \\\"family_name\\\",\\n    email: \\\"email\\\",\\n    organization: \\\"organization\\\",\\n    tel: \\\"tel\\\",\\n  };\\n\\n  // Fields that are recorded in `address_form` event telemetry extra_keys\\n  static SUPPORTED_FIELDS_IN_FORM = [\\n    \\\"street_address\\\",\\n    \\\"address_line1\\\",\\n    \\\"address_line2\\\",\\n    \\\"address_line3\\\",\\n    \\\"address_level2\\\",\\n    \\\"address_level1\\\",\\n    \\\"postal_code\\\",\\n    \\\"country\\\",\\n  ];\\n\\n  // Fields that are recorded in `address_form_ext` event telemetry extra_keys\\n  static SUPPORTED_FIELDS_IN_FORM_EXT = [\\n    \\\"name\\\",\\n    \\\"given_name\\\",\\n    \\\"additional_name\\\",\\n    \\\"family_name\\\",\\n    \\\"email\\\",\\n    \\\"organization\\\",\\n    \\\"tel\\\",\\n  ];\\n\\n  recordFormEvent(method, flowId, extra) {\\n    let extExtra = {};\\n    if ([\\\"detected\\\", \\\"filled\\\", \\\"submitted\\\"].includes(method)) {\\n      for (const [key, value] of Object.entries(extra)) {\\n        if (AddressTelemetry.SUPPORTED_FIELDS_IN_FORM_EXT.includes(key)) {\\n          extExtra[key] = value;\\n          delete extra[key];\\n        }\\n      }\\n    }\\n\\n    const eventMethod = method.replace(/(_[a-z])/g, c => c[1].toUpperCase());\\n    Glean.address[eventMethod + this.EVENT_OBJECT_FORM_INTERACTION]?.record({\\n      value: flowId,\\n      ...extra,\\n    });\\n\\n    if (Object.keys(extExtra).length) {\\n      Glean.address[\\n        eventMethod + this.EVENT_OBJECT_FORM_INTERACTION_EXT\\n      ]?.record({ value: flowId, ...extExtra });\\n    }\\n  }\\n\\n  recordAutofillProfileCount(count) {\\n    Glean.formautofillAddresses.autofillProfilesCount.set(count);\\n  }\\n}\\n\\nclass CreditCardTelemetry extends AutofillTelemetryBase {\\n  EVENT_CATEGORY = \\\"creditcard\\\";\\n  EVENT_OBJECT_FORM_INTERACTION = \\\"CcFormV2\\\";\\n\\n  HISTOGRAM_NUM_USES = \\\"CREDITCARD_NUM_USES\\\";\\n  HISTOGRAM_PROFILE_NUM_USES = \\\"AUTOFILL_PROFILE_NUM_USES\\\";\\n  HISTOGRAM_PROFILE_NUM_USES_KEY = \\\"credit_card\\\";\\n\\n  // Mapping of field name used in formautofill code to the field name\\n  // used in the telemetry.\\n  SUPPORTED_FIELDS = {\\n    \\\"cc-name\\\": \\\"cc_name\\\",\\n    \\\"cc-number\\\": \\\"cc_number\\\",\\n    \\\"cc-type\\\": \\\"cc_type\\\",\\n    \\\"cc-exp\\\": \\\"cc_exp\\\",\\n    \\\"cc-exp-month\\\": \\\"cc_exp_month\\\",\\n    \\\"cc-exp-year\\\": \\\"cc_exp_year\\\",\\n  };\\n  recordFormEvent(method, flowId, aExtra) {\\n    // Don't modify the passed-in aExtra as it's reused.\\n    const extra = Object.assign({ value: flowId }, aExtra);\\n    const eventMethod = method.replace(/(_[a-z])/g, c => c[1].toUpperCase());\\n    Glean.creditcard[eventMethod + this.EVENT_OBJECT_FORM_INTERACTION]?.record(\\n      extra\\n    );\\n  }\\n\\n  recordFormDetected(flowId, fieldDetails) {\\n    super.recordFormDetected(flowId, fieldDetails);\\n    this.recordCcNumberFieldsCount(fieldDetails);\\n  }\\n\\n  /**\\n   * Collect the amount of consecutive cc number fields to help decide\\n   * whether to support filling other field counts besides 1 and 4 fields\\n   */\\n  recordCcNumberFieldsCount(fieldDetails) {\\n    const recordCount = count => {\\n      const label = \\\"cc_number_fields_\\\" + (count > 4 ? \\\"other\\\" : count);\\n      Glean.creditcard.detectedCcNumberFieldsCount[label].add(1);\\n    };\\n\\n    let consecutiveCcNumberCount = 0;\\n    for (const { fieldName, reason } of fieldDetails) {\\n      if (fieldName == \\\"cc-number\\\" && reason == \\\"autocomplete\\\") {\\n        consecutiveCcNumberCount++;\\n      } else if (consecutiveCcNumberCount) {\\n        recordCount(consecutiveCcNumberCount);\\n        consecutiveCcNumberCount = 0;\\n      }\\n    }\\n\\n    if (consecutiveCcNumberCount) {\\n      recordCount(consecutiveCcNumberCount);\\n    }\\n  }\\n\\n  recordNumberOfUse(records) {\\n    super.recordNumberOfUse(records);\\n\\n    if (!this.HISTOGRAM_NUM_USES) {\\n      return;\\n    }\\n\\n    let histogram = Services.telemetry.getHistogramById(\\n      this.HISTOGRAM_NUM_USES\\n    );\\n    histogram.clear();\\n\\n    for (let record of records) {\\n      histogram.add(record.timesUsed);\\n    }\\n  }\\n\\n  recordAutofillProfileCount(count) {\\n    Glean.formautofillCreditcards.autofillProfilesCount.set(count);\\n  }\\n}\\n\\nexport class AutofillTelemetry {\\n  static #creditCardTelemetry = new CreditCardTelemetry();\\n  static #addressTelemetry = new AddressTelemetry();\\n\\n  // const for `type` parameter used in the utility functions\\n  static ADDRESS = \\\"address\\\";\\n  static CREDIT_CARD = \\\"creditcard\\\";\\n\\n  static #getTelemetryByFieldDetail(fieldDetail) {\\n    return FormAutofillUtils.isAddressField(fieldDetail.fieldName)\\n      ? this.#addressTelemetry\\n      : this.#creditCardTelemetry;\\n  }\\n\\n  static #getTelemetryByType(type) {\\n    return type == AutofillTelemetry.CREDIT_CARD\\n      ? this.#creditCardTelemetry\\n      : this.#addressTelemetry;\\n  }\\n\\n  /**\\n   * Utility functions for `doorhanger` event (defined in Events.yaml)\\n   *\\n   * Category: address or creditcard\\n   * Event name: doorhanger\\n   */\\n  static recordDoorhangerShown(type, object, flowId) {\\n    const telemetry = this.#getTelemetryByType(type);\\n    telemetry.recordDoorhangerEvent(\\\"show\\\", object, flowId);\\n  }\\n\\n  static recordDoorhangerClicked(type, method, object, flowId) {\\n    const telemetry = this.#getTelemetryByType(type);\\n\\n    // We don't have `create` method in telemetry, we treat `create` as `save`\\n    switch (method) {\\n      case \\\"create\\\":\\n        method = \\\"save\\\";\\n        break;\\n      case \\\"open-pref\\\":\\n        method = \\\"pref\\\";\\n        break;\\n      case \\\"learn-more\\\":\\n        method = \\\"learn_more\\\";\\n        break;\\n    }\\n\\n    telemetry.recordDoorhangerEvent(method, object, flowId);\\n  }\\n\\n  /**\\n   * Utility functions for form event (defined in Events.yaml)\\n   *\\n   * Category: address or creditcard\\n   * Event name: cc_form_v2, or address_form\\n   */\\n\\n  static recordFormInteractionEvent(method, flowId, fieldDetails, data) {\\n    const telemetry = this.#getTelemetryByFieldDetail(fieldDetails[0]);\\n    telemetry.recordFormInteractionEvent(method, flowId, fieldDetails, data);\\n  }\\n\\n  static recordManageEvent(type, method) {\\n    const telemetry = this.#getTelemetryByType(type);\\n    telemetry.recordManageEvent(method);\\n  }\\n\\n  static recordAutofillProfileCount(type, count) {\\n    const telemetry = this.#getTelemetryByType(type);\\n    telemetry.recordAutofillProfileCount(count);\\n  }\\n\\n  /**\\n   * Utility functions for address/credit card number of use\\n   */\\n  static recordNumberOfUse(type, records) {\\n    const telemetry = this.#getTelemetryByType(type);\\n    telemetry.recordNumberOfUse(records);\\n  }\\n\\n  static recordFormSubmissionHeuristicCount(label) {\\n    Glean.formautofill.formSubmissionHeuristic[label].add(1);\\n  }\\n}\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CC_Python_Update.py":
/*!****************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CC_Python_Update.py ***!
  \****************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"import requests\\nimport filecmp\\nimport shutil\\nimport os\\n\\nMOZILLA_CENTRAL_URL = \\\"https://hg.mozilla.org/mozilla-central/raw-file/tip/\\\"\\nGITHUB_ACTIONS_PATH = \\\"./firefox-ios/Client/Assets/CC_Script/\\\"\\nGITHUB_ACTIONS_TMP_PATH = f\\\"{GITHUB_ACTIONS_PATH}tmp/\\\"\\n\\n\\nFILES_TO_DOWNLOAD = [\\n    \\\"browser/extensions/formautofill/content/addressFormLayout.mjs\\\",\\n    \\\"toolkit/components/formautofill/Constants.ios.mjs\\\",\\n    \\\"toolkit/modules/CreditCard.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/AutofillFormFactory.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/CreditCardRuleset.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/CreditCardRecord.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/FieldScanner.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/FormAutofill.ios.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/FormAutofill.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/FormAutofillChild.ios.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/AddressMetaData.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/AddressMetaDataExtension.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/AddressMetaDataLoader.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/AddressRecord.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/AddressParser.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/AutofillTelemetry.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/FormAutofillHandler.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/FormAutofillHeuristics.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/FormAutofillNameUtils.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/FormAutofillSection.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/FormAutofillUtils.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/PhoneNumber.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/PhoneNumberMetaData.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/PhoneNumberNormalizer.sys.mjs\\\",\\n    \\\"toolkit/modules/FormLikeFactory.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/FormStateManager.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/Helpers.ios.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/HeuristicsRegExp.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/shared/LabelUtils.sys.mjs\\\",\\n    \\\"toolkit/components/formautofill/Overrides.ios.js\\\",\\n    \\\"toolkit/modules/third_party/fathom/fathom.mjs\\\",\\n    \\\"toolkit/components/passwordmgr/shared/LoginFormFactory.sys.mjs\\\",\\n    \\\"toolkit/components/passwordmgr/shared/NewPasswordModel.sys.mjs\\\",\\n    \\\"toolkit/components/passwordmgr/shared/PasswordGenerator.sys.mjs\\\",\\n    \\\"toolkit/components/passwordmgr/shared/PasswordRulesParser.sys.mjs\\\",\\n    \\\"toolkit/components/passwordmgr/LoginManager.shared.sys.mjs\\\",\\n]\\n\\n\\n# Methods related to file download, compare, copy contents and removal\\n\\ndef downloadTemporaryFileToCompare(file_info):\\n    reqHeader = {\\\"Cache-Control\\\": \\\"no-cache\\\", \\\"Pragma\\\": \\\"no-cache\\\"}\\n    try:\\n        response = requests.get(file_info[\\\"url\\\"], stream=True, headers=reqHeader)\\n        if response.status_code != 200:\\n            print(f\\\"Failed to download file: {file_info['url']}. Response status code: {response.status_code}\\\")\\n            return False\\n        try:\\n            with open(file_info[\\\"tmp_path\\\"], \\\"wb\\\") as f:\\n                for chunk in response.iter_content():\\n                    f.write(chunk)\\n            return True\\n        except:\\n            print(\\\"Could not write to the file\\\")\\n    except requests.exceptions.HTTPError as err:\\n        raise SystemExit(err)\\n\\ndef compare_file(file1, file2):\\n    result = filecmp.cmp(file1, file2)\\n    print(\\\"comparing two files -> ?\\\", result)\\n    return result\\n\\ndef copyContents(fromFile, toFile):\\n    print(\\\"copying contents\\\")\\n    with open(fromFile, \\\"rb\\\") as f2, open(toFile, \\\"wb\\\") as f1:\\n        shutil.copyfileobj(f2, f1)\\n\\ndef removeFile(fileToRemove):\\n    if os.path.exists(fileToRemove):\\n        os.remove(fileToRemove)\\n        return True\\n    else:\\n        print(\\\"Nothing to remove, all clear\\\")\\n        return False\\n\\ndef getFileInfo(path):\\n    filename = os.path.basename(path)\\n    return {\\n        \\\"filename\\\": filename,\\n        \\\"url\\\": MOZILLA_CENTRAL_URL + path,\\n        \\\"path\\\": GITHUB_ACTIONS_PATH + filename,\\n        \\\"tmp_path\\\": GITHUB_ACTIONS_TMP_PATH + filename,\\n    }\\n\\ndef removeTmpFiles():\\n    for file in FILES_TO_DOWNLOAD:\\n        removeFile(GITHUB_ACTIONS_TMP_PATH + file)\\n\\ndef createTmpDirectory():\\n    if os.path.exists(GITHUB_ACTIONS_TMP_PATH) == False:\\n        os.mkdir(GITHUB_ACTIONS_TMP_PATH)\\n\\ndef removeTmpDirectory():\\n    if os.path.exists(GITHUB_ACTIONS_TMP_PATH):\\n        os.rmdir(GITHUB_ACTIONS_TMP_PATH)\\n\\n# main\\ndef main():\\n    # create tmp directory\\n    createTmpDirectory()\\n\\n    for file in FILES_TO_DOWNLOAD:\\n        file_info = getFileInfo(file)\\n        # download file to compare changes\\n        downloaded = downloadTemporaryFileToCompare(file_info)\\n\\n        # This can happen if the file was removed and doesn't exist anymore on central\\n        # We don't want to fail if that's the case\\n        if not downloaded:\\n            print(f\\\"Skipping file: {file_info['filename']}\\\")\\n            continue\\n\\n        # move file if it does not exist\\n        if os.path.exists(file_info[\\\"path\\\"]) == False:\\n            shutil.move(file_info[\\\"tmp_path\\\"], file_info[\\\"path\\\"])\\n        else:\\n            # compare if there are any changes with the file\\n            # downloaded vs what we currently have on disk\\n            compare_file_result = compare_file(file_info[\\\"tmp_path\\\"], file_info[\\\"path\\\"])\\n            if compare_file_result == False:\\n                copyContents(file_info[\\\"tmp_path\\\"], file_info[\\\"path\\\"])\\n            else:\\n                print(\\\"No change, do nothing\\\")\\n\\n        # remove temp downloaded file for cleanup\\n        removeFile(file_info[\\\"tmp_path\\\"])\\n\\n    # cleanup tmp directory\\n    removeTmpDirectory()\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/CC_Python_Update.py?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs":
/*!**************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs ***!
  \**************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nconst IOS_DEFAULT_PREFERENCES = {\\n  \\\"extensions.formautofill.creditCards.heuristics.mode\\\": 1,\\n  \\\"extensions.formautofill.creditCards.heuristics.fathom.confidenceThreshold\\\": 0.5,\\n  \\\"extensions.formautofill.creditCards.heuristics.fathom.highConfidenceThreshold\\\": 0.95,\\n  \\\"extensions.formautofill.creditCards.heuristics.fathom.testConfidence\\\": 0,\\n  \\\"extensions.formautofill.creditCards.heuristics.fathom.types\\\":\\n    \\\"cc-number,cc-name\\\",\\n  \\\"extensions.formautofill.addresses.capture.requiredFields\\\":\\n    \\\"street-address,postal-code,address-level1,address-level2\\\",\\n  \\\"extensions.formautofill.loglevel\\\": \\\"Warn\\\",\\n  \\\"extensions.formautofill.addresses.supported\\\": \\\"off\\\",\\n  \\\"extensions.formautofill.creditCards.supported\\\": \\\"detect\\\",\\n  \\\"browser.search.region\\\": \\\"US\\\",\\n  \\\"extensions.formautofill.creditCards.supportedCountries\\\": \\\"US,CA,GB,FR,DE\\\",\\n  \\\"extensions.formautofill.addresses.enabled\\\": true,\\n  \\\"extensions.formautofill.addresses.experiments.enabled\\\": true,\\n  \\\"extensions.formautofill.addresses.capture.enabled\\\": false,\\n  \\\"extensions.formautofill.addresses.supportedCountries\\\": \\\"\\\",\\n  \\\"extensions.formautofill.creditCards.enabled\\\": true,\\n  \\\"extensions.formautofill.reauth.enabled\\\": true,\\n  \\\"extensions.formautofill.creditCards.hideui\\\": false,\\n  \\\"extensions.formautofill.supportRTL\\\": false,\\n  \\\"extensions.formautofill.creditCards.ignoreAutocompleteOff\\\": true,\\n  \\\"extensions.formautofill.addresses.ignoreAutocompleteOff\\\": true,\\n  \\\"extensions.formautofill.heuristics.enabled\\\": true,\\n  \\\"extensions.formautofill.section.enabled\\\": true,\\n  \\\"extensions.formautofill.heuristics.captureOnFormRemoval\\\": false,\\n  \\\"extensions.formautofill.heuristics.captureOnPageNavigation\\\": false,\\n  \\\"extensions.formautofill.heuristics.detectDynamicFormChanges\\\": false,\\n  \\\"extensions.formautofill.heuristics.fillOnDynamicFormChanges\\\": false,\\n  \\\"extensions.formautofill.focusOnAutofill\\\": false,\\n  \\\"extensions.formautofill.test.ignoreVisibilityCheck\\\": false,\\n  \\\"extensions.formautofill.heuristics.autofillSameOriginWithTop\\\": false,\\n  \\\"signon.generation.confidenceThreshold\\\": 0.75,\\n  \\\"extensions.formautofill.ml.experiment.enabled\\\": false,\\n};\\n\\n// Used Mimic the behavior of .getAutocompleteInfo()\\n// List from: https://searchfox.org/mozilla-central/source/dom/base/AutocompleteFieldList.h#89-149\\n// Also found here: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete\\nconst VALID_AUTOCOMPLETE_FIELDS = [\\n  \\\"off\\\",\\n  \\\"on\\\",\\n  \\\"name\\\",\\n  \\\"honorific-prefix\\\",\\n  \\\"given-name\\\",\\n  \\\"additional-name\\\",\\n  \\\"family-name\\\",\\n  \\\"honorific-suffix\\\",\\n  \\\"nickname\\\",\\n  \\\"email\\\",\\n  \\\"username\\\",\\n  \\\"new-password\\\",\\n  \\\"current-password\\\",\\n  \\\"one-time-code\\\",\\n  \\\"organization-title\\\",\\n  \\\"organization\\\",\\n  \\\"street-address\\\",\\n  \\\"address-line1\\\",\\n  \\\"address-line2\\\",\\n  \\\"address-line3\\\",\\n  \\\"address-level4\\\",\\n  \\\"address-level3\\\",\\n  \\\"address-level2\\\",\\n  \\\"address-level1\\\",\\n  \\\"country\\\",\\n  \\\"country-name\\\",\\n  \\\"postal-code\\\",\\n  \\\"cc-name\\\",\\n  \\\"cc-given-name\\\",\\n  \\\"cc-additional-name\\\",\\n  \\\"cc-family-name\\\",\\n  \\\"cc-number\\\",\\n  \\\"cc-exp\\\",\\n  \\\"cc-exp-month\\\",\\n  \\\"cc-exp-year\\\",\\n  \\\"cc-csc\\\",\\n  \\\"cc-type\\\",\\n  \\\"transaction-currency\\\",\\n  \\\"transaction-amount\\\",\\n  \\\"language\\\",\\n  \\\"bday\\\",\\n  \\\"bday-day\\\",\\n  \\\"bday-month\\\",\\n  \\\"bday-year\\\",\\n  \\\"sex\\\",\\n  \\\"tel\\\",\\n  \\\"tel-country-code\\\",\\n  \\\"tel-national\\\",\\n  \\\"tel-area-code\\\",\\n  \\\"tel-local\\\",\\n  \\\"tel-extension\\\",\\n  \\\"impp\\\",\\n  \\\"url\\\",\\n  \\\"photo\\\",\\n];\\n\\nexport const IOSAppConstants = Object.freeze({\\n  platform: \\\"ios\\\",\\n  prefs: IOS_DEFAULT_PREFERENCES,\\n  validAutocompleteFields: VALID_AUTOCOMPLETE_FIELDS,\\n});\\n\\nexport default IOSAppConstants;\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs ***!
  \***************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n// The list of known and supported credit card network ids (\\\"types\\\")\\n// This list mirrors the networks from dom/payments/BasicCardPayment.cpp\\n// and is defined by https://www.w3.org/Payments/card-network-ids\\nconst SUPPORTED_NETWORKS = Object.freeze([\\n  \\\"amex\\\",\\n  \\\"cartebancaire\\\",\\n  \\\"diners\\\",\\n  \\\"discover\\\",\\n  \\\"jcb\\\",\\n  \\\"mastercard\\\",\\n  \\\"mir\\\",\\n  \\\"unionpay\\\",\\n  \\\"visa\\\",\\n]);\\n\\n// This lists stores lower cased variations of popular credit card network\\n// names for matching against strings.\\nexport const NETWORK_NAMES = {\\n  \\\"american express\\\": \\\"amex\\\",\\n  \\\"master card\\\": \\\"mastercard\\\",\\n  \\\"union pay\\\": \\\"unionpay\\\",\\n};\\n\\n// Based on https://en.wikipedia.org/wiki/Payment_card_number\\n//\\n// Notice:\\n//   - CarteBancaire (`4035`, `4360`) is now recognized as Visa.\\n//   - UnionPay (`63--`) is now recognized as Discover.\\n// This means that the order matters.\\n// First we'll try to match more specific card,\\n// and if that doesn't match we'll test against the more generic range.\\nconst CREDIT_CARD_IIN = [\\n  { type: \\\"amex\\\", start: 34, end: 34, len: 15 },\\n  { type: \\\"amex\\\", start: 37, end: 37, len: 15 },\\n  { type: \\\"cartebancaire\\\", start: 4035, end: 4035, len: 16 },\\n  { type: \\\"cartebancaire\\\", start: 4360, end: 4360, len: 16 },\\n  // We diverge from Wikipedia here, because Diners card\\n  // support length of 14-19.\\n  { type: \\\"diners\\\", start: 300, end: 305, len: [14, 19] },\\n  { type: \\\"diners\\\", start: 3095, end: 3095, len: [14, 19] },\\n  { type: \\\"diners\\\", start: 36, end: 36, len: [14, 19] },\\n  { type: \\\"diners\\\", start: 38, end: 39, len: [14, 19] },\\n  { type: \\\"discover\\\", start: 6011, end: 6011, len: [16, 19] },\\n  { type: \\\"discover\\\", start: 622126, end: 622925, len: [16, 19] },\\n  { type: \\\"discover\\\", start: 624000, end: 626999, len: [16, 19] },\\n  { type: \\\"discover\\\", start: 628200, end: 628899, len: [16, 19] },\\n  { type: \\\"discover\\\", start: 64, end: 65, len: [16, 19] },\\n  { type: \\\"jcb\\\", start: 3528, end: 3589, len: [16, 19] },\\n  { type: \\\"mastercard\\\", start: 2221, end: 2720, len: 16 },\\n  { type: \\\"mastercard\\\", start: 51, end: 55, len: 16 },\\n  { type: \\\"mir\\\", start: 2200, end: 2204, len: 16 },\\n  { type: \\\"unionpay\\\", start: 62, end: 62, len: [16, 19] },\\n  { type: \\\"unionpay\\\", start: 81, end: 81, len: [16, 19] },\\n  { type: \\\"visa\\\", start: 4, end: 4, len: 16 },\\n].sort((a, b) => b.start - a.start);\\n\\nexport class CreditCard {\\n  /**\\n   * A CreditCard object represents a credit card, with\\n   * number, name, expiration, network, and CCV.\\n   * The number is the only required information when creating\\n   * an object, all other members are optional. The number\\n   * is validated during construction and will throw if invalid.\\n   *\\n   * @param {string} name, optional\\n   * @param {string} number\\n   * @param {string} expirationString, optional\\n   * @param {string|number} expirationMonth, optional\\n   * @param {string|number} expirationYear, optional\\n   * @param {string} network, optional\\n   * @param {string|number} ccv, optional\\n   * @param {string} encryptedNumber, optional\\n   * @throws if number is an invalid credit card number\\n   */\\n  constructor({\\n    name,\\n    number,\\n    expirationString,\\n    expirationMonth,\\n    expirationYear,\\n    network,\\n    ccv,\\n    encryptedNumber,\\n  }) {\\n    this._name = name;\\n    this._unmodifiedNumber = number;\\n    this._encryptedNumber = encryptedNumber;\\n    this._ccv = ccv;\\n    this.number = number;\\n    let { month, year } = CreditCard.normalizeExpiration({\\n      expirationString,\\n      expirationMonth,\\n      expirationYear,\\n    });\\n    this._expirationMonth = month;\\n    this._expirationYear = year;\\n    this.network = network;\\n  }\\n\\n  set name(value) {\\n    this._name = value;\\n  }\\n\\n  set expirationMonth(value) {\\n    if (typeof value == \\\"undefined\\\") {\\n      this._expirationMonth = undefined;\\n      return;\\n    }\\n    this._expirationMonth = CreditCard.normalizeExpirationMonth(value);\\n  }\\n\\n  get expirationMonth() {\\n    return this._expirationMonth;\\n  }\\n\\n  set expirationYear(value) {\\n    if (typeof value == \\\"undefined\\\") {\\n      this._expirationYear = undefined;\\n      return;\\n    }\\n    this._expirationYear = CreditCard.normalizeExpirationYear(value);\\n  }\\n\\n  get expirationYear() {\\n    return this._expirationYear;\\n  }\\n\\n  set expirationString(value) {\\n    let { month, year } = CreditCard.parseExpirationString(value);\\n    this.expirationMonth = month;\\n    this.expirationYear = year;\\n  }\\n\\n  set ccv(value) {\\n    this._ccv = value;\\n  }\\n\\n  get number() {\\n    return this._number;\\n  }\\n\\n  /**\\n   * Sets the number member of a CreditCard object. If the number\\n   * is not valid according to the Luhn algorithm then the member\\n   * will get set to the empty string before throwing an exception.\\n   *\\n   * @param {string} value\\n   * @throws if the value is an invalid credit card number\\n   */\\n  set number(value) {\\n    if (value) {\\n      let normalizedNumber = CreditCard.normalizeCardNumber(value);\\n      // Based on the information on wiki[1], the shortest valid length should be\\n      // 12 digits (Maestro).\\n      // [1] https://en.wikipedia.org/wiki/Payment_card_number\\n      normalizedNumber = normalizedNumber.match(/^\\\\d{12,}$/)\\n        ? normalizedNumber\\n        : \\\"\\\";\\n      this._number = normalizedNumber;\\n    } else {\\n      this._number = \\\"\\\";\\n    }\\n\\n    if (value && !this.isValidNumber()) {\\n      this._number = \\\"\\\";\\n      throw new Error(\\\"Invalid credit card number\\\");\\n    }\\n  }\\n\\n  get network() {\\n    return this._network;\\n  }\\n\\n  set network(value) {\\n    this._network = value || undefined;\\n  }\\n\\n  // Implements the Luhn checksum algorithm as described at\\n  // http://wikipedia.org/wiki/Luhn_algorithm\\n  // Number digit lengths vary with network, but should fall within 12-19 range. [2]\\n  // More details at https://en.wikipedia.org/wiki/Payment_card_number\\n  isValidNumber() {\\n    if (!this._number) {\\n      return false;\\n    }\\n\\n    // Remove dashes and whitespace\\n    const number = CreditCard.normalizeCardNumber(this._number);\\n\\n    const len = number.length;\\n    if (len < 12 || len > 19) {\\n      return false;\\n    }\\n\\n    if (!/^\\\\d+$/.test(number)) {\\n      return false;\\n    }\\n\\n    let total = 0;\\n    for (let i = 0; i < len; i++) {\\n      let ch = parseInt(number[len - i - 1], 10);\\n      if (i % 2 == 1) {\\n        // Double it, add digits together if > 10\\n        ch *= 2;\\n        if (ch > 9) {\\n          ch -= 9;\\n        }\\n      }\\n      total += ch;\\n    }\\n    return total % 10 == 0;\\n  }\\n\\n  /**\\n   * Normalizes a credit card number.\\n   * @param {string} number\\n   * @return {string | null}\\n   * @memberof CreditCard\\n   */\\n  static normalizeCardNumber(number) {\\n    if (!number) {\\n      return null;\\n    }\\n    return number.replace(/[\\\\-\\\\s]/g, \\\"\\\");\\n  }\\n\\n  /**\\n   * Attempts to match the number against known network identifiers.\\n   *\\n   * @param {string} ccNumber Credit card number with no spaces or special characters in it.\\n   *\\n   * @returns {string|null}\\n   */\\n  static getType(ccNumber) {\\n    if (!ccNumber) {\\n      return null;\\n    }\\n\\n    for (let i = 0; i < CREDIT_CARD_IIN.length; i++) {\\n      const range = CREDIT_CARD_IIN[i];\\n      if (typeof range.len == \\\"number\\\") {\\n        if (range.len != ccNumber.length) {\\n          continue;\\n        }\\n      } else if (\\n        ccNumber.length < range.len[0] ||\\n        ccNumber.length > range.len[1]\\n      ) {\\n        continue;\\n      }\\n\\n      const prefixLength = Math.floor(Math.log10(range.start)) + 1;\\n      const prefix = parseInt(ccNumber.substring(0, prefixLength), 10);\\n      if (prefix >= range.start && prefix <= range.end) {\\n        return range.type;\\n      }\\n    }\\n    return null;\\n  }\\n\\n  /**\\n   * Attempts to retrieve a card network identifier based\\n   * on a name.\\n   *\\n   * @param {string|undefined|null} name\\n   *\\n   * @returns {string|null}\\n   */\\n  static getNetworkFromName(name) {\\n    if (!name) {\\n      return null;\\n    }\\n    let lcName = name.trim().toLowerCase().normalize(\\\"NFKC\\\");\\n    if (SUPPORTED_NETWORKS.includes(lcName)) {\\n      return lcName;\\n    }\\n    for (let term in NETWORK_NAMES) {\\n      if (lcName.includes(term)) {\\n        return NETWORK_NAMES[term];\\n      }\\n    }\\n    return null;\\n  }\\n\\n  /**\\n   * Returns true if the card number is valid and the\\n   * expiration date has not passed. Otherwise false.\\n   *\\n   * @returns {boolean}\\n   */\\n  isValid() {\\n    if (!this.isValidNumber()) {\\n      return false;\\n    }\\n\\n    let currentDate = new Date();\\n    let currentYear = currentDate.getFullYear();\\n    if (this._expirationYear > currentYear) {\\n      return true;\\n    }\\n\\n    // getMonth is 0-based, so add 1 because credit cards are 1-based\\n    let currentMonth = currentDate.getMonth() + 1;\\n    return (\\n      this._expirationYear == currentYear &&\\n      this._expirationMonth >= currentMonth\\n    );\\n  }\\n\\n  get maskedNumber() {\\n    return CreditCard.getMaskedNumber(this._number);\\n  }\\n\\n  get longMaskedNumber() {\\n    return CreditCard.getLongMaskedNumber(this._number);\\n  }\\n\\n  /**\\n   * Get credit card display label. It should display masked numbers, the\\n   * cardholder's name, and the expiration date, separated by a commas.\\n   * In addition, the card type is provided in the accessibility label.\\n   */\\n  static getLabelInfo({ number, name, month, year, type }) {\\n    let formatSelector = [\\\"number\\\"];\\n    if (name) {\\n      formatSelector.push(\\\"name\\\");\\n    }\\n    if (month && year) {\\n      formatSelector.push(\\\"expiration\\\");\\n    }\\n    let stringId = `credit-card-label-${formatSelector.join(\\\"-\\\")}-2`;\\n    return {\\n      id: stringId,\\n      args: {\\n        number: CreditCard.getMaskedNumber(number),\\n        name,\\n        month: month?.toString(),\\n        year: year?.toString(),\\n        type,\\n      },\\n    };\\n  }\\n\\n  /**\\n   *\\n   * Please use getLabelInfo above, as it allows for localization.\\n   * @deprecated\\n   */\\n  static getLabel({ number, name }) {\\n    let parts = [];\\n\\n    if (number) {\\n      parts.push(CreditCard.getMaskedNumber(number));\\n    }\\n    if (name) {\\n      parts.push(name);\\n    }\\n    return parts.join(\\\", \\\");\\n  }\\n\\n  static normalizeExpirationMonth(month) {\\n    month = parseInt(month, 10);\\n    if (isNaN(month) || month < 1 || month > 12) {\\n      return undefined;\\n    }\\n    return month;\\n  }\\n\\n  static normalizeExpirationYear(year) {\\n    year = parseInt(year, 10);\\n    if (isNaN(year) || year < 0) {\\n      return undefined;\\n    }\\n    if (year < 100) {\\n      year += 2000;\\n    }\\n    return year;\\n  }\\n\\n  static parseExpirationString(expirationString) {\\n    let rules = [\\n      {\\n        regex: /(?:^|\\\\D)(\\\\d{2})(\\\\d{2})(?!\\\\d)/,\\n      },\\n      {\\n        regex: /(?:^|\\\\D)(\\\\d{4})[-/](\\\\d{1,2})(?!\\\\d)/,\\n        yearIndex: 0,\\n        monthIndex: 1,\\n      },\\n      {\\n        regex: /(?:^|\\\\D)(\\\\d{1,2})[-/](\\\\d{4})(?!\\\\d)/,\\n        yearIndex: 1,\\n        monthIndex: 0,\\n      },\\n      {\\n        regex: /(?:^|\\\\D)(\\\\d{1,2})[-/](\\\\d{1,2})(?!\\\\d)/,\\n      },\\n      {\\n        regex: /(?:^|\\\\D)(\\\\d{2})(\\\\d{2})(?!\\\\d)/,\\n      },\\n    ];\\n\\n    expirationString = expirationString.replaceAll(\\\" \\\", \\\"\\\");\\n    for (let rule of rules) {\\n      let result = rule.regex.exec(expirationString);\\n      if (!result) {\\n        continue;\\n      }\\n\\n      let year, month;\\n      const parsedResults = [parseInt(result[1], 10), parseInt(result[2], 10)];\\n      if (!rule.yearIndex || !rule.monthIndex) {\\n        month = parsedResults[0];\\n        if (month > 12) {\\n          year = parsedResults[0];\\n          month = parsedResults[1];\\n        } else {\\n          year = parsedResults[1];\\n        }\\n      } else {\\n        year = parsedResults[rule.yearIndex];\\n        month = parsedResults[rule.monthIndex];\\n      }\\n\\n      if (month >= 1 && month <= 12 && (year < 100 || year > 2000)) {\\n        return { month, year };\\n      }\\n    }\\n    return { month: undefined, year: undefined };\\n  }\\n\\n  static normalizeExpiration({\\n    expirationString,\\n    expirationMonth,\\n    expirationYear,\\n  }) {\\n    // Only prefer the string version if missing one or both parsed formats.\\n    let parsedExpiration = {};\\n    if (expirationString && (!expirationMonth || !expirationYear)) {\\n      parsedExpiration = CreditCard.parseExpirationString(expirationString);\\n    }\\n    return {\\n      month: CreditCard.normalizeExpirationMonth(\\n        parsedExpiration.month || expirationMonth\\n      ),\\n      year: CreditCard.normalizeExpirationYear(\\n        parsedExpiration.year || expirationYear\\n      ),\\n    };\\n  }\\n\\n  static formatMaskedNumber(maskedNumber) {\\n    return \\\"*\\\".repeat(4) + maskedNumber.substr(-4);\\n  }\\n\\n  static getMaskedNumber(number) {\\n    return \\\"*\\\".repeat(4) + \\\" \\\" + number.substr(-4);\\n  }\\n\\n  static getLongMaskedNumber(number) {\\n    return \\\"*\\\".repeat(number.length - 4) + number.substr(-4);\\n  }\\n\\n  static getCreditCardLogo(network) {\\n    const PATH = \\\"chrome://formautofill/content/\\\";\\n    const THIRD_PARTY_PATH = PATH + \\\"third-party/\\\";\\n    switch (network) {\\n      case \\\"amex\\\":\\n        return THIRD_PARTY_PATH + \\\"cc-logo-amex.png\\\";\\n      case \\\"cartebancaire\\\":\\n        return THIRD_PARTY_PATH + \\\"cc-logo-cartebancaire.png\\\";\\n      case \\\"diners\\\":\\n        return THIRD_PARTY_PATH + \\\"cc-logo-diners.svg\\\";\\n      case \\\"discover\\\":\\n        return THIRD_PARTY_PATH + \\\"cc-logo-discover.png\\\";\\n      case \\\"jcb\\\":\\n        return THIRD_PARTY_PATH + \\\"cc-logo-jcb.svg\\\";\\n      case \\\"mastercard\\\":\\n        return THIRD_PARTY_PATH + \\\"cc-logo-mastercard.svg\\\";\\n      case \\\"mir\\\":\\n        return THIRD_PARTY_PATH + \\\"cc-logo-mir.svg\\\";\\n      case \\\"unionpay\\\":\\n        return THIRD_PARTY_PATH + \\\"cc-logo-unionpay.svg\\\";\\n      case \\\"visa\\\":\\n        return THIRD_PARTY_PATH + \\\"cc-logo-visa.svg\\\";\\n      default:\\n        return PATH + \\\"icon-credit-card-generic.svg\\\";\\n    }\\n  }\\n\\n  /*\\n   * Validates the number according to the Luhn algorithm. This\\n   * method does not throw an exception if the number is invalid.\\n   */\\n  static isValidNumber(number) {\\n    try {\\n      new CreditCard({ number });\\n    } catch (ex) {\\n      return false;\\n    }\\n    return true;\\n  }\\n\\n  static isValidNetwork(network) {\\n    return SUPPORTED_NETWORKS.includes(network);\\n  }\\n\\n  static getSupportedNetworks() {\\n    return SUPPORTED_NETWORKS;\\n  }\\n\\n  /**\\n   * Localised names for supported networks are available in\\n   * `browser/preferences/formAutofill.ftl`.\\n   */\\n  static getNetworkL10nId(network) {\\n    return this.isValidNetwork(network)\\n      ? `autofill-card-network-${network}`\\n      : null;\\n  }\\n}\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs ***!
  \*********************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* eslint-disable no-useless-concat */\\n/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nimport { CreditCard } from \\\"resource://gre/modules/CreditCard.sys.mjs\\\";\\nimport { FormAutofillNameUtils } from \\\"resource://gre/modules/shared/FormAutofillNameUtils.sys.mjs\\\";\\n\\n/**\\n * The CreditCardRecord class serves to handle and normalize internal credit card records.\\n * Unlike the CreditCard class, which represents actual card data, CreditCardRecord is used\\n * for processing and consistent data representation.\\n */\\nexport class CreditCardRecord {\\n  static normalizeFields(creditCard) {\\n    this.#normalizeCCNameFields(creditCard);\\n    this.#normalizeCCNumberFields(creditCard);\\n    this.#normalizeCCExpirationDateFields(creditCard);\\n    this.#normalizeCCTypeFields(creditCard);\\n  }\\n\\n  static #normalizeCCNameFields(creditCard) {\\n    if (!creditCard[\\\"cc-name\\\"]) {\\n      creditCard[\\\"cc-name\\\"] = FormAutofillNameUtils.joinNameParts({\\n        given: creditCard[\\\"cc-given-name\\\"] ?? \\\"\\\",\\n        middle: creditCard[\\\"cc-additional-name\\\"] ?? \\\"\\\",\\n        family: creditCard[\\\"cc-family-name\\\"] ?? \\\"\\\",\\n      });\\n    }\\n\\n    delete creditCard[\\\"cc-given-name\\\"];\\n    delete creditCard[\\\"cc-additional-name\\\"];\\n    delete creditCard[\\\"cc-family-name\\\"];\\n  }\\n\\n  static #normalizeCCNumberFields(creditCard) {\\n    if (!(\\\"cc-number\\\" in creditCard)) {\\n      return;\\n    }\\n\\n    if (!CreditCard.isValidNumber(creditCard[\\\"cc-number\\\"])) {\\n      delete creditCard[\\\"cc-number\\\"];\\n      return;\\n    }\\n\\n    const card = new CreditCard({ number: creditCard[\\\"cc-number\\\"] });\\n    creditCard[\\\"cc-number\\\"] = card.number;\\n  }\\n\\n  static #normalizeCCExpirationDateFields(creditCard) {\\n    let normalizedExpiration = CreditCard.normalizeExpiration({\\n      expirationMonth: creditCard[\\\"cc-exp-month\\\"],\\n      expirationYear: creditCard[\\\"cc-exp-year\\\"],\\n      expirationString: creditCard[\\\"cc-exp\\\"],\\n    });\\n\\n    creditCard[\\\"cc-exp-month\\\"] = normalizedExpiration.month ?? \\\"\\\";\\n    creditCard[\\\"cc-exp-year\\\"] = normalizedExpiration.year ?? \\\"\\\";\\n    delete creditCard[\\\"cc-exp\\\"];\\n  }\\n\\n  static #normalizeCCTypeFields(creditCard) {\\n    // Let's overwrite the credit card type with auto-detect algorithm\\n    creditCard[\\\"cc-type\\\"] = CreditCard.getType(creditCard[\\\"cc-number\\\"]) ?? \\\"\\\";\\n  }\\n}\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs ***!
  \**********************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n/**\\n * Fathom ML model for identifying the fields of credit-card forms\\n *\\n * This is developed out-of-tree at https://github.com/mozilla-services/fathom-\\n * form-autofill, where there is also over a GB of training, validation, and\\n * testing data. To make changes, do your edits there (whether adding new\\n * training pages, adding new rules, or both), retrain and evaluate as\\n * documented at https://mozilla.github.io/fathom/training.html, paste the\\n * coefficients emitted by the trainer into the ruleset, and finally copy the\\n * ruleset's \\\"CODE TO COPY INTO PRODUCTION\\\" section to this file's \\\"CODE FROM\\n * TRAINING REPOSITORY\\\" section.\\n */\\n\\n/**\\n * CODE UNIQUE TO PRODUCTION--NOT IN THE TRAINING REPOSITORY:\\n */\\n\\nimport {\\n  element as clickedElement,\\n  out,\\n  rule,\\n  ruleset,\\n  score,\\n  type,\\n} from \\\"resource://gre/modules/third_party/fathom/fathom.mjs\\\";\\nimport { XPCOMUtils } from \\\"resource://gre/modules/XPCOMUtils.sys.mjs\\\";\\nimport { FormAutofillUtils } from \\\"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\\\";\\nimport {\\n  CreditCard,\\n  NETWORK_NAMES,\\n} from \\\"resource://gre/modules/CreditCard.sys.mjs\\\";\\n\\nimport { FormLikeFactory } from \\\"resource://gre/modules/FormLikeFactory.sys.mjs\\\";\\nimport { LabelUtils } from \\\"resource://gre/modules/shared/LabelUtils.sys.mjs\\\";\\n\\n/**\\n * Callthrough abstraction to allow .getAutocompleteInfo() to be mocked out\\n * during training\\n *\\n * @param {Element} element DOM element to get info about\\n * @returns {object} Page-author-provided autocomplete metadata\\n */\\nfunction getAutocompleteInfo(element) {\\n  return element.getAutocompleteInfo();\\n}\\n\\n/**\\n * @param {string} selector A CSS selector that prunes away ineligible elements\\n * @returns {Lhs} An LHS yielding the element the user has clicked or, if\\n *  pruned, none\\n */\\nfunction queriedOrClickedElements(selector) {\\n  return clickedElement(selector);\\n}\\n\\n/**\\n * START OF CODE PASTED FROM TRAINING REPOSITORY\\n */\\n\\nvar FathomHeuristicsRegExp = {\\n  RULES: {\\n    \\\"cc-name\\\": undefined,\\n    \\\"cc-number\\\": undefined,\\n    \\\"cc-exp-month\\\": undefined,\\n    \\\"cc-exp-year\\\": undefined,\\n    \\\"cc-exp\\\": undefined,\\n    \\\"cc-type\\\": undefined,\\n  },\\n\\n  RULE_SETS: [\\n    {\\n      /* eslint-disable */\\n      // Let us keep our consistent wrapping.\\n      \\\"cc-name\\\":\\n        // Firefox-specific rules\\n        \\\"account.*holder.*name\\\" +\\n        \\\"|^(credit[-\\\\\\\\s]?card|card).*name\\\" +\\n        // de-DE\\n        \\\"|^(kredit)?(karten|konto)inhaber\\\" +\\n        \\\"|^(name).*karte\\\" +\\n        // fr-FR\\n        \\\"|nom.*(titulaire|détenteur)\\\" +\\n        \\\"|(titulaire|détenteur).*(carte)\\\" +\\n        // it-IT\\n        \\\"|titolare.*carta\\\" +\\n        // pl-PL\\n        \\\"|posiadacz.*karty\\\" +\\n        // es-ES\\n        \\\"|nombre.*(titular|tarjeta)\\\" +\\n        // nl-NL\\n        \\\"|naam.*op.*kaart\\\" +\\n        // Rules from Bitwarden\\n        \\\"|cc-?name\\\" +\\n        \\\"|card-?name\\\" +\\n        \\\"|cardholder-?name\\\" +\\n        \\\"|(^nom$)\\\" +\\n        // Rules are from Chromium source codes\\n        \\\"|card.?(?:holder|owner)|name.*(\\\\\\\\b)?on(\\\\\\\\b)?.*card\\\" +\\n        \\\"|(?:card|cc).?name|cc.?full.?name\\\" +\\n        \\\"|(?:card|cc).?owner\\\" +\\n        \\\"|nom.*carte\\\" + // fr-FR\\n        \\\"|nome.*cart\\\" + // it-IT\\n        \\\"|名前\\\" + // ja-JP\\n        \\\"|Имя.*карты\\\" + // ru\\n        \\\"|信用卡开户名|开户名|持卡人姓名\\\" + // zh-CN\\n        \\\"|持卡人姓名\\\", // zh-TW\\n\\n      \\\"cc-number\\\":\\n        // Firefox-specific rules\\n        // de-DE\\n        \\\"(cc|kk)nr\\\" +\\n        \\\"|(kredit)?(karten)(nummer|nr)\\\" +\\n        // it-IT\\n        \\\"|numero.*carta\\\" +\\n        // fr-FR\\n        \\\"|(numero|número|numéro).*(carte)\\\" +\\n        // pl-PL\\n        \\\"|numer.*karty\\\" +\\n        // es-ES\\n        \\\"|(número|numero).*tarjeta\\\" +\\n        // nl-NL\\n        \\\"|kaartnummer\\\" +\\n        // Rules from Bitwarden\\n        \\\"|cc-?number\\\" +\\n        \\\"|cc-?num\\\" +\\n        \\\"|card-?number\\\" +\\n        \\\"|card-?num\\\" +\\n        \\\"|cc-?no\\\" +\\n        \\\"|card-?no\\\" +\\n        \\\"|numero-?carte\\\" +\\n        \\\"|num-?carte\\\" +\\n        \\\"|cb-?num\\\" +\\n        // Rules are from Chromium source codes\\n        \\\"|(add)?(?:card|cc|acct).?(?:number|#|no|num)\\\" +\\n        \\\"|カード番号\\\" + // ja-JP\\n        \\\"|Номер.*карты\\\" + // ru\\n        \\\"|信用卡号|信用卡号码\\\" + // zh-CN\\n        \\\"|信用卡卡號\\\" + // zh-TW\\n        \\\"|카드\\\", // ko-KR\\n\\n      \\\"cc-exp\\\":\\n        // Firefox-specific rules\\n        \\\"mm\\\\\\\\s*(\\\\/|\\\\\\\\|-)\\\\\\\\s*(yy|jj|aa)\\\" +\\n        \\\"|(month|mois)\\\\\\\\s*(\\\\/|\\\\\\\\|-|et)\\\\\\\\s*(year|année)\\\" +\\n        // de-DE\\n        // fr-FR\\n        // Rules from Bitwarden\\n        \\\"|(^cc-?exp$)\\\" +\\n        \\\"|(^card-?exp$)\\\" +\\n        \\\"|(^cc-?expiration$)\\\" +\\n        \\\"|(^card-?expiration$)\\\" +\\n        \\\"|(^cc-?ex$)\\\" +\\n        \\\"|(^card-?ex$)\\\" +\\n        \\\"|(^card-?expire$)\\\" +\\n        \\\"|(^card-?expiry$)\\\" +\\n        \\\"|(^validite$)\\\" +\\n        \\\"|(^expiration$)\\\" +\\n        \\\"|(^expiry$)\\\" +\\n        \\\"|mm-?yy\\\" +\\n        \\\"|mm-?yyyy\\\" +\\n        \\\"|yy-?mm\\\" +\\n        \\\"|yyyy-?mm\\\" +\\n        \\\"|expiration-?date\\\" +\\n        \\\"|payment-?card-?expiration\\\" +\\n        \\\"|(^payment-?cc-?date$)\\\" +\\n        // Rules are from Chromium source codes\\n        \\\"|expir|exp.*date|^expfield$\\\" +\\n        \\\"|ablaufdatum|gueltig|gültig\\\" + // de-DE\\n        \\\"|fecha\\\" + // es\\n        \\\"|date.*exp\\\" + // fr-FR\\n        \\\"|scadenza\\\" + // it-IT\\n        \\\"|有効期限\\\" + // ja-JP\\n        \\\"|validade\\\" + // pt-BR, pt-PT\\n        \\\"|Срок действия карты\\\", // ru\\n\\n      \\\"cc-exp-month\\\":\\n        // Firefox-specific rules\\n        \\\"(cc|kk)month\\\" + // de-DE\\n        // Rules from Bitwarden\\n        \\\"|(^exp-?month$)\\\" +\\n        \\\"|(^cc-?exp-?month$)\\\" +\\n        \\\"|(^cc-?month$)\\\" +\\n        \\\"|(^card-?month$)\\\" +\\n        \\\"|(^cc-?mo$)\\\" +\\n        \\\"|(^card-?mo$)\\\" +\\n        \\\"|(^exp-?mo$)\\\" +\\n        \\\"|(^card-?exp-?mo$)\\\" +\\n        \\\"|(^cc-?exp-?mo$)\\\" +\\n        \\\"|(^card-?expiration-?month$)\\\" +\\n        \\\"|(^expiration-?month$)\\\" +\\n        \\\"|(^cc-?mm$)\\\" +\\n        \\\"|(^cc-?m$)\\\" +\\n        \\\"|(^card-?mm$)\\\" +\\n        \\\"|(^card-?m$)\\\" +\\n        \\\"|(^card-?exp-?mm$)\\\" +\\n        \\\"|(^cc-?exp-?mm$)\\\" +\\n        \\\"|(^exp-?mm$)\\\" +\\n        \\\"|(^exp-?m$)\\\" +\\n        \\\"|(^expire-?month$)\\\" +\\n        \\\"|(^expire-?mo$)\\\" +\\n        \\\"|(^expiry-?month$)\\\" +\\n        \\\"|(^expiry-?mo$)\\\" +\\n        \\\"|(^card-?expire-?month$)\\\" +\\n        \\\"|(^card-?expire-?mo$)\\\" +\\n        \\\"|(^card-?expiry-?month$)\\\" +\\n        \\\"|(^card-?expiry-?mo$)\\\" +\\n        \\\"|(^mois-?validite$)\\\" +\\n        \\\"|(^mois-?expiration$)\\\" +\\n        \\\"|(^m-?validite$)\\\" +\\n        \\\"|(^m-?expiration$)\\\" +\\n        \\\"|(^expiry-?date-?field-?month$)\\\" +\\n        \\\"|(^expiration-?date-?month$)\\\" +\\n        \\\"|(^expiration-?date-?mm$)\\\" +\\n        \\\"|(^exp-?mon$)\\\" +\\n        \\\"|(^validity-?mo$)\\\" +\\n        \\\"|(^exp-?date-?mo$)\\\" +\\n        \\\"|(^cb-?date-?mois$)\\\" +\\n        \\\"|(^date-?m$)\\\" +\\n        // Rules are from Chromium source codes\\n        \\\"|exp.*mo|ccmonth|cardmonth|addmonth\\\" +\\n        \\\"|monat\\\" + // de-DE\\n        // \\\"|fecha\\\" + // es\\n        // \\\"|date.*exp\\\" + // fr-FR\\n        // \\\"|scadenza\\\" + // it-IT\\n        // \\\"|有効期限\\\" + // ja-JP\\n        // \\\"|validade\\\" + // pt-BR, pt-PT\\n        // \\\"|Срок действия карты\\\" + // ru\\n        \\\"|月\\\", // zh-CN\\n\\n      \\\"cc-exp-year\\\":\\n        // Firefox-specific rules\\n        \\\"(cc|kk)year\\\" + // de-DE\\n        // Rules from Bitwarden\\n        \\\"|(^exp-?year$)\\\" +\\n        \\\"|(^cc-?exp-?year$)\\\" +\\n        \\\"|(^cc-?year$)\\\" +\\n        \\\"|(^card-?year$)\\\" +\\n        \\\"|(^cc-?yr$)\\\" +\\n        \\\"|(^card-?yr$)\\\" +\\n        \\\"|(^exp-?yr$)\\\" +\\n        \\\"|(^card-?exp-?yr$)\\\" +\\n        \\\"|(^cc-?exp-?yr$)\\\" +\\n        \\\"|(^card-?expiration-?year$)\\\" +\\n        \\\"|(^expiration-?year$)\\\" +\\n        \\\"|(^cc-?yy$)\\\" +\\n        \\\"|(^cc-?y$)\\\" +\\n        \\\"|(^card-?yy$)\\\" +\\n        \\\"|(^card-?y$)\\\" +\\n        \\\"|(^card-?exp-?yy$)\\\" +\\n        \\\"|(^cc-?exp-?yy$)\\\" +\\n        \\\"|(^exp-?yy$)\\\" +\\n        \\\"|(^exp-?y$)\\\" +\\n        \\\"|(^cc-?yyyy$)\\\" +\\n        \\\"|(^card-?yyyy$)\\\" +\\n        \\\"|(^card-?exp-?yyyy$)\\\" +\\n        \\\"|(^cc-?exp-?yyyy$)\\\" +\\n        \\\"|(^expire-?year$)\\\" +\\n        \\\"|(^expire-?yr$)\\\" +\\n        \\\"|(^expiry-?year$)\\\" +\\n        \\\"|(^expiry-?yr$)\\\" +\\n        \\\"|(^card-?expire-?year$)\\\" +\\n        \\\"|(^card-?expire-?yr$)\\\" +\\n        \\\"|(^card-?expiry-?year$)\\\" +\\n        \\\"|(^card-?expiry-?yr$)\\\" +\\n        \\\"|(^an-?validite$)\\\" +\\n        \\\"|(^an-?expiration$)\\\" +\\n        \\\"|(^annee-?validite$)\\\" +\\n        \\\"|(^annee-?expiration$)\\\" +\\n        \\\"|(^expiry-?date-?field-?year$)\\\" +\\n        \\\"|(^expiration-?date-?year$)\\\" +\\n        \\\"|(^cb-?date-?ann$)\\\" +\\n        \\\"|(^expiration-?date-?yy$)\\\" +\\n        \\\"|(^expiration-?date-?yyyy$)\\\" +\\n        \\\"|(^validity-?year$)\\\" +\\n        \\\"|(^exp-?date-?year$)\\\" +\\n        \\\"|(^date-?y$)\\\" +\\n        // Rules are from Chromium source codes\\n        \\\"|(add)?year\\\" +\\n        \\\"|jahr\\\" + // de-DE\\n        // \\\"|fecha\\\" + // es\\n        // \\\"|scadenza\\\" + // it-IT\\n        // \\\"|有効期限\\\" + // ja-JP\\n        // \\\"|validade\\\" + // pt-BR, pt-PT\\n        // \\\"|Срок действия карты\\\" + // ru\\n        \\\"|年|有效期\\\", // zh-CN\\n\\n      \\\"cc-type\\\":\\n        // Firefox-specific rules\\n        \\\"type\\\" +\\n        // de-DE\\n        \\\"|Kartenmarke\\\" +\\n        // Rules from Bitwarden\\n        \\\"|(^cc-?type$)\\\" +\\n        \\\"|(^card-?type$)\\\" +\\n        \\\"|(^card-?brand$)\\\" +\\n        \\\"|(^cc-?brand$)\\\" +\\n        \\\"|(^cb-?type$)\\\",\\n        // Rules are from Chromium source codes\\n    },\\n  ],\\n\\n  _getRule(name) {\\n    let rules = [];\\n    this.RULE_SETS.forEach(set => {\\n      if (set[name]) {\\n        rules.push(`(${set[name]})`.normalize(\\\"NFKC\\\"));\\n      }\\n    });\\n\\n    const value = new RegExp(rules.join(\\\"|\\\"), \\\"iu\\\");\\n    Object.defineProperty(this.RULES, name, { get: undefined });\\n    Object.defineProperty(this.RULES, name, { value });\\n    return value;\\n  },\\n\\n  init() {\\n    Object.keys(this.RULES).forEach(field =>\\n      Object.defineProperty(this.RULES, field, {\\n        get() {\\n          return FathomHeuristicsRegExp._getRule(field);\\n        },\\n      })\\n    );\\n  },\\n};\\n\\nFathomHeuristicsRegExp.init();\\n\\nconst MMRegExp = /^mm$|\\\\(mm\\\\)/i;\\nconst YYorYYYYRegExp = /^(yy|yyyy)$|\\\\(yy\\\\)|\\\\(yyyy\\\\)/i;\\nconst monthRegExp = /month/i;\\nconst yearRegExp = /year/i;\\nconst MMYYRegExp = /mm\\\\s*(\\\\/|\\\\\\\\)\\\\s*yy/i;\\nconst VisaCheckoutRegExp = /visa(-|\\\\s)checkout/i;\\nconst CREDIT_CARD_NETWORK_REGEXP = new RegExp(\\n  CreditCard.getSupportedNetworks()\\n    .concat(Object.keys(NETWORK_NAMES))\\n    .join(\\\"|\\\"),\\n  \\\"gui\\\"\\n  );\\nconst TwoDigitYearRegExp = /(?:exp.*date[^y\\\\\\\\n\\\\\\\\r]*|mm\\\\\\\\s*[-/]?\\\\\\\\s*)yy(?:[^y]|$)/i;\\nconst FourDigitYearRegExp = /(?:exp.*date[^y\\\\\\\\n\\\\\\\\r]*|mm\\\\\\\\s*[-/]?\\\\\\\\s*)yyyy(?:[^y]|$)/i;\\nconst dwfrmRegExp = /^dwfrm/i;\\nconst bmlRegExp = /bml/i;\\nconst templatedValue = /^\\\\{\\\\{.*\\\\}\\\\}$/;\\nconst firstRegExp = /first/i;\\nconst lastRegExp = /last/i;\\nconst giftRegExp = /gift/i;\\nconst subscriptionRegExp = /subscription/i;\\n\\nfunction autocompleteStringMatches(element, ccString) {\\n  const info = getAutocompleteInfo(element);\\n  return info.fieldName === ccString;\\n}\\n\\nfunction getFillableFormElements(element) {\\n  const formLike = FormLikeFactory.createFromField(element);\\n  return Array.from(formLike.elements).filter(el =>\\n    FormAutofillUtils.isCreditCardOrAddressFieldType(el)\\n  );\\n}\\n\\nfunction nextFillableFormField(element) {\\n  const fillableFormElements = getFillableFormElements(element);\\n  const elementIndex = fillableFormElements.indexOf(element);\\n  return fillableFormElements[elementIndex + 1];\\n}\\n\\nfunction previousFillableFormField(element) {\\n  const fillableFormElements = getFillableFormElements(element);\\n  const elementIndex = fillableFormElements.indexOf(element);\\n  return fillableFormElements[elementIndex - 1];\\n}\\n\\nfunction nextFieldPredicateIsTrue(element, predicate) {\\n  const nextField = nextFillableFormField(element);\\n  return !!nextField && predicate(nextField);\\n}\\n\\nfunction previousFieldPredicateIsTrue(element, predicate) {\\n  const previousField = previousFillableFormField(element);\\n  return !!previousField && predicate(previousField);\\n}\\n\\nfunction nextFieldMatchesExpYearAutocomplete(fnode) {\\n  return nextFieldPredicateIsTrue(fnode.element, nextField =>\\n    autocompleteStringMatches(nextField, \\\"cc-exp-year\\\")\\n  );\\n}\\n\\nfunction previousFieldMatchesExpMonthAutocomplete(fnode) {\\n  return previousFieldPredicateIsTrue(fnode.element, previousField =>\\n    autocompleteStringMatches(previousField, \\\"cc-exp-month\\\")\\n  );\\n}\\n\\n//////////////////////////////////////////////\\n// Attribute Regular Expression Rules\\nfunction idOrNameMatchRegExp(element, regExp) {\\n  for (const str of [element.id, element.name]) {\\n    if (regExp.test(str)) {\\n      return true;\\n    }\\n  }\\n  return false;\\n}\\n\\nfunction getElementLabels(element) {\\n  return {\\n    *[Symbol.iterator]() {\\n      const labels = LabelUtils.findLabelElements(element);\\n      for (let label of labels) {\\n        yield* LabelUtils.extractLabelStrings(label);\\n      }\\n    },\\n  };\\n}\\n\\nfunction labelsMatchRegExp(element, regExp) {\\n  const elemStrings = getElementLabels(element);\\n  for (const str of elemStrings) {\\n    if (regExp.test(str)) {\\n      return true;\\n    }\\n  }\\n\\n  const parentElement = element.parentElement;\\n  // Bug 1634819: element.parentElement is null if element.parentNode is a ShadowRoot\\n  if (!parentElement) {\\n    return false;\\n  }\\n  // Check if the input is in a <td>, and, if so, check the textContent of the containing <tr>\\n  if (parentElement.tagName === \\\"TD\\\" && parentElement.parentElement) {\\n    // TODO: How bad is the assumption that the <tr> won't be the parent of the <td>?\\n    return regExp.test(parentElement.parentElement.textContent);\\n  }\\n\\n  // Check if the input is in a <dd>, and, if so, check the textContent of the preceding <dt>\\n  if (\\n    parentElement.tagName === \\\"DD\\\" &&\\n    // previousElementSibling can be null\\n    parentElement.previousElementSibling\\n  ) {\\n    return regExp.test(parentElement.previousElementSibling.textContent);\\n  }\\n  return false;\\n}\\n\\nfunction closestLabelMatchesRegExp(element, regExp) {\\n  const previousElementSibling = element.previousElementSibling;\\n  if (\\n    previousElementSibling !== null &&\\n    previousElementSibling.tagName === \\\"LABEL\\\"\\n  ) {\\n    return regExp.test(previousElementSibling.textContent);\\n  }\\n\\n  const nextElementSibling = element.nextElementSibling;\\n  if (nextElementSibling !== null && nextElementSibling.tagName === \\\"LABEL\\\") {\\n    return regExp.test(nextElementSibling.textContent);\\n  }\\n\\n  return false;\\n}\\n\\nfunction ariaLabelMatchesRegExp(element, regExp) {\\n  const ariaLabel = element.getAttribute(\\\"aria-label\\\");\\n  return !!ariaLabel && regExp.test(ariaLabel);\\n}\\n\\nfunction placeholderMatchesRegExp(element, regExp) {\\n  const placeholder = element.getAttribute(\\\"placeholder\\\");\\n  return !!placeholder && regExp.test(placeholder);\\n}\\n\\nfunction nextFieldIdOrNameMatchRegExp(element, regExp) {\\n  return nextFieldPredicateIsTrue(element, nextField =>\\n    idOrNameMatchRegExp(nextField, regExp)\\n  );\\n}\\n\\nfunction nextFieldLabelsMatchRegExp(element, regExp) {\\n  return nextFieldPredicateIsTrue(element, nextField =>\\n    labelsMatchRegExp(nextField, regExp)\\n  );\\n}\\n\\nfunction nextFieldPlaceholderMatchesRegExp(element, regExp) {\\n  return nextFieldPredicateIsTrue(element, nextField =>\\n    placeholderMatchesRegExp(nextField, regExp)\\n  );\\n}\\n\\nfunction nextFieldAriaLabelMatchesRegExp(element, regExp) {\\n  return nextFieldPredicateIsTrue(element, nextField =>\\n    ariaLabelMatchesRegExp(nextField, regExp)\\n  );\\n}\\n\\nfunction previousFieldIdOrNameMatchRegExp(element, regExp) {\\n  return previousFieldPredicateIsTrue(element, previousField =>\\n    idOrNameMatchRegExp(previousField, regExp)\\n  );\\n}\\n\\nfunction previousFieldLabelsMatchRegExp(element, regExp) {\\n  return previousFieldPredicateIsTrue(element, previousField =>\\n    labelsMatchRegExp(previousField, regExp)\\n  );\\n}\\n\\nfunction previousFieldPlaceholderMatchesRegExp(element, regExp) {\\n  return previousFieldPredicateIsTrue(element, previousField =>\\n    placeholderMatchesRegExp(previousField, regExp)\\n  );\\n}\\n\\nfunction previousFieldAriaLabelMatchesRegExp(element, regExp) {\\n  return previousFieldPredicateIsTrue(element, previousField =>\\n    ariaLabelMatchesRegExp(previousField, regExp)\\n  );\\n}\\n//////////////////////////////////////////////\\n\\nfunction isSelectWithCreditCardOptions(fnode) {\\n  // Check every select for options that match credit card network names in\\n  // value or label.\\n  const element = fnode.element;\\n  if (element.tagName === \\\"SELECT\\\") {\\n    for (let option of element.querySelectorAll(\\\"option\\\")) {\\n      if (\\n        CreditCard.getNetworkFromName(option.value) ||\\n        CreditCard.getNetworkFromName(option.text)\\n      ) {\\n        return true;\\n      }\\n    }\\n  }\\n  return false;\\n}\\n\\n/**\\n * If any of the regular expressions match multiple times, we assume the tested\\n * string belongs to a radio button for payment type instead of card type.\\n *\\n * @param {Fnode} fnode\\n * @returns {boolean}\\n */\\nfunction isRadioWithCreditCardText(fnode) {\\n  const element = fnode.element;\\n  const inputType = element.type;\\n  if (!!inputType && inputType === \\\"radio\\\") {\\n    const valueMatches = element.value.match(CREDIT_CARD_NETWORK_REGEXP);\\n    if (valueMatches) {\\n      return valueMatches.length === 1;\\n    }\\n\\n    // Here we are checking that only one label matches only one entry in the regular expression.\\n    const labels = getElementLabels(element);\\n    let labelsMatched = 0;\\n    for (const label of labels) {\\n      const labelMatches = label.match(CREDIT_CARD_NETWORK_REGEXP);\\n      if (labelMatches) {\\n        if (labelMatches.length > 1) {\\n          return false;\\n        }\\n        labelsMatched++;\\n      }\\n    }\\n    if (labelsMatched > 0) {\\n      return labelsMatched === 1;\\n    }\\n\\n    const textContentMatches = element.textContent.match(\\n      CREDIT_CARD_NETWORK_REGEXP\\n    );\\n    if (textContentMatches) {\\n      return textContentMatches.length === 1;\\n    }\\n  }\\n  return false;\\n}\\n\\nfunction matchContiguousSubArray(array, subArray) {\\n  return array.some((elm, i) =>\\n    subArray.every((sElem, j) => sElem === array[i + j])\\n  );\\n}\\n\\nfunction isExpirationMonthLikely(element) {\\n  if (element.tagName !== \\\"SELECT\\\") {\\n    return false;\\n  }\\n\\n  const options = [...element.options];\\n  const desiredValues = Array(12)\\n    .fill(1)\\n    .map((v, i) => v + i);\\n\\n  // The number of month options shouldn't be less than 12 or larger than 13\\n  // including the default option.\\n  if (options.length < 12 || options.length > 13) {\\n    return false;\\n  }\\n\\n  return (\\n    matchContiguousSubArray(\\n      options.map(e => +e.value),\\n      desiredValues\\n    ) ||\\n    matchContiguousSubArray(\\n      options.map(e => +e.label),\\n      desiredValues\\n    )\\n  );\\n}\\n\\nfunction isExpirationYearLikely(element) {\\n  if (element.tagName !== \\\"SELECT\\\") {\\n    return false;\\n  }\\n\\n  const options = [...element.options];\\n  // A normal expiration year select should contain at least the last three years\\n  // in the list.\\n  const curYear = new Date().getFullYear();\\n  const desiredValues = Array(3)\\n    .fill(0)\\n    .map((v, i) => v + curYear + i);\\n\\n  return (\\n    matchContiguousSubArray(\\n      options.map(e => +e.value),\\n      desiredValues\\n    ) ||\\n    matchContiguousSubArray(\\n      options.map(e => +e.label),\\n      desiredValues\\n    )\\n  );\\n}\\n\\nfunction nextFieldIsExpirationYearLikely(fnode) {\\n  return nextFieldPredicateIsTrue(fnode.element, isExpirationYearLikely);\\n}\\n\\nfunction previousFieldIsExpirationMonthLikely(fnode) {\\n  return previousFieldPredicateIsTrue(fnode.element, isExpirationMonthLikely);\\n}\\n\\nfunction attrsMatchExpWith2Or4DigitYear(fnode, regExpMatchingFunction) {\\n  const element = fnode.element;\\n  return (\\n    regExpMatchingFunction(element, TwoDigitYearRegExp) ||\\n    regExpMatchingFunction(element, FourDigitYearRegExp)\\n  );\\n}\\n\\nfunction maxLengthIs(fnode, maxLengthValue) {\\n  return fnode.element.maxLength === maxLengthValue;\\n}\\n\\nfunction roleIsMenu(fnode) {\\n  const role = fnode.element.getAttribute(\\\"role\\\");\\n  return !!role && role === \\\"menu\\\";\\n}\\n\\nfunction idOrNameMatchDwfrmAndBml(fnode) {\\n  return (\\n    idOrNameMatchRegExp(fnode.element, dwfrmRegExp) &&\\n    idOrNameMatchRegExp(fnode.element, bmlRegExp)\\n  );\\n}\\n\\nfunction hasTemplatedValue(fnode) {\\n  const value = fnode.element.getAttribute(\\\"value\\\");\\n  return !!value && templatedValue.test(value);\\n}\\n\\nfunction inputTypeNotNumbery(fnode) {\\n  const inputType = fnode.element.type;\\n  if (inputType) {\\n    return ![\\\"text\\\", \\\"tel\\\", \\\"number\\\"].includes(inputType);\\n  }\\n  return false;\\n}\\n\\nfunction idOrNameMatchFirstAndLast(fnode) {\\n  return (\\n    idOrNameMatchRegExp(fnode.element, firstRegExp) &&\\n    idOrNameMatchRegExp(fnode.element, lastRegExp)\\n  );\\n}\\n\\n/**\\n * Compactly generate a series of rules that all take a single LHS type with no\\n * .when() clause and have only a score() call on the right- hand side.\\n *\\n * @param {Lhs} inType The incoming fnode type that all rules take\\n * @param {object} ruleMap A simple object used as a map with rule names\\n *   pointing to scoring callbacks\\n * @yields {Rule}\\n */\\nfunction* simpleScoringRules(inType, ruleMap) {\\n  for (const [name, scoringCallback] of Object.entries(ruleMap)) {\\n    yield rule(type(inType), score(scoringCallback), { name });\\n  }\\n}\\n\\nfunction makeRuleset(coeffs, biases) {\\n  return ruleset(\\n    [\\n      /**\\n       * Factor out the page scan just for a little more speed during training.\\n       * This selector is good for most fields. cardType is an exception: it\\n       * cannot be type=month.\\n       */\\n      rule(\\n        queriedOrClickedElements(\\n          \\\"input:not([type]), input[type=text], input[type=textbox], input[type=email], input[type=tel], input[type=number], input[type=month], select, button\\\"\\n        ),\\n        type(\\\"typicalCandidates\\\")\\n      ),\\n\\n      /**\\n       * number rules\\n       */\\n      rule(type(\\\"typicalCandidates\\\"), type(\\\"cc-number\\\")),\\n      ...simpleScoringRules(\\\"cc-number\\\", {\\n        idOrNameMatchNumberRegExp: fnode =>\\n          idOrNameMatchRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-number\\\"]\\n          ),\\n        labelsMatchNumberRegExp: fnode =>\\n          labelsMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\\\"cc-number\\\"]),\\n        closestLabelMatchesNumberRegExp: fnode =>\\n          closestLabelMatchesRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\\\"cc-number\\\"]),\\n        placeholderMatchesNumberRegExp: fnode =>\\n          placeholderMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-number\\\"]\\n          ),\\n        ariaLabelMatchesNumberRegExp: fnode =>\\n          ariaLabelMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-number\\\"]\\n          ),\\n        idOrNameMatchGift: fnode =>\\n          idOrNameMatchRegExp(fnode.element, giftRegExp),\\n        labelsMatchGift: fnode => labelsMatchRegExp(fnode.element, giftRegExp),\\n        placeholderMatchesGift: fnode =>\\n          placeholderMatchesRegExp(fnode.element, giftRegExp),\\n        ariaLabelMatchesGift: fnode =>\\n          ariaLabelMatchesRegExp(fnode.element, giftRegExp),\\n        idOrNameMatchSubscription: fnode =>\\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\\n        idOrNameMatchDwfrmAndBml,\\n        hasTemplatedValue,\\n        inputTypeNotNumbery,\\n      }),\\n      rule(type(\\\"cc-number\\\"), out(\\\"cc-number\\\")),\\n\\n      /**\\n       * name rules\\n       */\\n      rule(type(\\\"typicalCandidates\\\"), type(\\\"cc-name\\\")),\\n      ...simpleScoringRules(\\\"cc-name\\\", {\\n        idOrNameMatchNameRegExp: fnode =>\\n          idOrNameMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\\\"cc-name\\\"]),\\n        labelsMatchNameRegExp: fnode =>\\n          labelsMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\\\"cc-name\\\"]),\\n        closestLabelMatchesNameRegExp: fnode =>\\n          closestLabelMatchesRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\\\"cc-name\\\"]),\\n        placeholderMatchesNameRegExp: fnode =>\\n          placeholderMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-name\\\"]\\n          ),\\n        ariaLabelMatchesNameRegExp: fnode =>\\n          ariaLabelMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-name\\\"]\\n          ),\\n        idOrNameMatchFirst: fnode =>\\n          idOrNameMatchRegExp(fnode.element, firstRegExp),\\n        labelsMatchFirst: fnode =>\\n          labelsMatchRegExp(fnode.element, firstRegExp),\\n        placeholderMatchesFirst: fnode =>\\n          placeholderMatchesRegExp(fnode.element, firstRegExp),\\n        ariaLabelMatchesFirst: fnode =>\\n          ariaLabelMatchesRegExp(fnode.element, firstRegExp),\\n        idOrNameMatchLast: fnode =>\\n          idOrNameMatchRegExp(fnode.element, lastRegExp),\\n        labelsMatchLast: fnode => labelsMatchRegExp(fnode.element, lastRegExp),\\n        placeholderMatchesLast: fnode =>\\n          placeholderMatchesRegExp(fnode.element, lastRegExp),\\n        ariaLabelMatchesLast: fnode =>\\n          ariaLabelMatchesRegExp(fnode.element, lastRegExp),\\n        idOrNameMatchSubscription: fnode =>\\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\\n        idOrNameMatchFirstAndLast,\\n        idOrNameMatchDwfrmAndBml,\\n        hasTemplatedValue,\\n      }),\\n      rule(type(\\\"cc-name\\\"), out(\\\"cc-name\\\")),\\n\\n      /**\\n       * cardType rules\\n       */\\n      rule(\\n        queriedOrClickedElements(\\n          \\\"input:not([type]), input[type=text], input[type=textbox], input[type=email], input[type=tel], input[type=number], input[type=radio], select, button\\\"\\n        ),\\n        type(\\\"cc-type\\\")\\n      ),\\n      ...simpleScoringRules(\\\"cc-type\\\", {\\n        idOrNameMatchTypeRegExp: fnode =>\\n          idOrNameMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\\\"cc-type\\\"]),\\n        labelsMatchTypeRegExp: fnode =>\\n          labelsMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\\\"cc-type\\\"]),\\n        closestLabelMatchesTypeRegExp: fnode =>\\n          closestLabelMatchesRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\\\"cc-type\\\"]),\\n        idOrNameMatchVisaCheckout: fnode =>\\n          idOrNameMatchRegExp(fnode.element, VisaCheckoutRegExp),\\n        ariaLabelMatchesVisaCheckout: fnode =>\\n          ariaLabelMatchesRegExp(fnode.element, VisaCheckoutRegExp),\\n        isSelectWithCreditCardOptions,\\n        isRadioWithCreditCardText,\\n        idOrNameMatchSubscription: fnode =>\\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\\n        idOrNameMatchDwfrmAndBml,\\n        hasTemplatedValue,\\n      }),\\n      rule(type(\\\"cc-type\\\"), out(\\\"cc-type\\\")),\\n\\n      /**\\n       * expiration rules\\n       */\\n      rule(type(\\\"typicalCandidates\\\"), type(\\\"cc-exp\\\")),\\n      ...simpleScoringRules(\\\"cc-exp\\\", {\\n        labelsMatchExpRegExp: fnode =>\\n          labelsMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\\\"cc-exp\\\"]),\\n        closestLabelMatchesExpRegExp: fnode =>\\n          closestLabelMatchesRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\\\"cc-exp\\\"]),\\n        placeholderMatchesExpRegExp: fnode =>\\n          placeholderMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp\\\"]\\n          ),\\n        labelsMatchExpWith2Or4DigitYear: fnode =>\\n          attrsMatchExpWith2Or4DigitYear(fnode, labelsMatchRegExp),\\n        placeholderMatchesExpWith2Or4DigitYear: fnode =>\\n          attrsMatchExpWith2Or4DigitYear(fnode, placeholderMatchesRegExp),\\n        labelsMatchMMYY: fnode => labelsMatchRegExp(fnode.element, MMYYRegExp),\\n        placeholderMatchesMMYY: fnode =>\\n          placeholderMatchesRegExp(fnode.element, MMYYRegExp),\\n        maxLengthIs7: fnode => maxLengthIs(fnode, 7),\\n        idOrNameMatchSubscription: fnode =>\\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\\n        idOrNameMatchDwfrmAndBml,\\n        hasTemplatedValue,\\n        isExpirationMonthLikely: fnode =>\\n          isExpirationMonthLikely(fnode.element),\\n        isExpirationYearLikely: fnode => isExpirationYearLikely(fnode.element),\\n        idOrNameMatchMonth: fnode =>\\n          idOrNameMatchRegExp(fnode.element, monthRegExp),\\n        idOrNameMatchYear: fnode =>\\n          idOrNameMatchRegExp(fnode.element, yearRegExp),\\n        idOrNameMatchExpMonthRegExp: fnode =>\\n          idOrNameMatchRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-month\\\"]\\n          ),\\n        idOrNameMatchExpYearRegExp: fnode =>\\n          idOrNameMatchRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-year\\\"]\\n          ),\\n        idOrNameMatchValidation: fnode =>\\n          idOrNameMatchRegExp(fnode.element, /validate|validation/i),\\n      }),\\n      rule(type(\\\"cc-exp\\\"), out(\\\"cc-exp\\\")),\\n\\n      /**\\n       * expirationMonth rules\\n       */\\n      rule(type(\\\"typicalCandidates\\\"), type(\\\"cc-exp-month\\\")),\\n      ...simpleScoringRules(\\\"cc-exp-month\\\", {\\n        idOrNameMatchExpMonthRegExp: fnode =>\\n          idOrNameMatchRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-month\\\"]\\n          ),\\n        labelsMatchExpMonthRegExp: fnode =>\\n          labelsMatchRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-month\\\"]\\n          ),\\n        closestLabelMatchesExpMonthRegExp: fnode =>\\n          closestLabelMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-month\\\"]\\n          ),\\n        placeholderMatchesExpMonthRegExp: fnode =>\\n          placeholderMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-month\\\"]\\n          ),\\n        ariaLabelMatchesExpMonthRegExp: fnode =>\\n          ariaLabelMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-month\\\"]\\n          ),\\n        idOrNameMatchMonth: fnode =>\\n          idOrNameMatchRegExp(fnode.element, monthRegExp),\\n        labelsMatchMonth: fnode =>\\n          labelsMatchRegExp(fnode.element, monthRegExp),\\n        placeholderMatchesMonth: fnode =>\\n          placeholderMatchesRegExp(fnode.element, monthRegExp),\\n        ariaLabelMatchesMonth: fnode =>\\n          ariaLabelMatchesRegExp(fnode.element, monthRegExp),\\n        nextFieldIdOrNameMatchExpYearRegExp: fnode =>\\n          nextFieldIdOrNameMatchRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-year\\\"]\\n          ),\\n        nextFieldLabelsMatchExpYearRegExp: fnode =>\\n          nextFieldLabelsMatchRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-year\\\"]\\n          ),\\n        nextFieldPlaceholderMatchExpYearRegExp: fnode =>\\n          nextFieldPlaceholderMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-year\\\"]\\n          ),\\n        nextFieldAriaLabelMatchExpYearRegExp: fnode =>\\n          nextFieldAriaLabelMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-year\\\"]\\n          ),\\n        nextFieldIdOrNameMatchYear: fnode =>\\n          nextFieldIdOrNameMatchRegExp(fnode.element, yearRegExp),\\n        nextFieldLabelsMatchYear: fnode =>\\n          nextFieldLabelsMatchRegExp(fnode.element, yearRegExp),\\n        nextFieldPlaceholderMatchesYear: fnode =>\\n          nextFieldPlaceholderMatchesRegExp(fnode.element, yearRegExp),\\n        nextFieldAriaLabelMatchesYear: fnode =>\\n          nextFieldAriaLabelMatchesRegExp(fnode.element, yearRegExp),\\n        nextFieldMatchesExpYearAutocomplete,\\n        isExpirationMonthLikely: fnode =>\\n          isExpirationMonthLikely(fnode.element),\\n        nextFieldIsExpirationYearLikely,\\n        maxLengthIs2: fnode => maxLengthIs(fnode, 2),\\n        placeholderMatchesMM: fnode =>\\n          placeholderMatchesRegExp(fnode.element, MMRegExp),\\n        roleIsMenu,\\n        idOrNameMatchSubscription: fnode =>\\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\\n        idOrNameMatchDwfrmAndBml,\\n        hasTemplatedValue,\\n      }),\\n      rule(type(\\\"cc-exp-month\\\"), out(\\\"cc-exp-month\\\")),\\n\\n      /**\\n       * expirationYear rules\\n       */\\n      rule(type(\\\"typicalCandidates\\\"), type(\\\"cc-exp-year\\\")),\\n      ...simpleScoringRules(\\\"cc-exp-year\\\", {\\n        idOrNameMatchExpYearRegExp: fnode =>\\n          idOrNameMatchRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-year\\\"]\\n          ),\\n        labelsMatchExpYearRegExp: fnode =>\\n          labelsMatchRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-year\\\"]\\n          ),\\n        closestLabelMatchesExpYearRegExp: fnode =>\\n          closestLabelMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-year\\\"]\\n          ),\\n        placeholderMatchesExpYearRegExp: fnode =>\\n          placeholderMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-year\\\"]\\n          ),\\n        ariaLabelMatchesExpYearRegExp: fnode =>\\n          ariaLabelMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-year\\\"]\\n          ),\\n        idOrNameMatchYear: fnode =>\\n          idOrNameMatchRegExp(fnode.element, yearRegExp),\\n        labelsMatchYear: fnode => labelsMatchRegExp(fnode.element, yearRegExp),\\n        placeholderMatchesYear: fnode =>\\n          placeholderMatchesRegExp(fnode.element, yearRegExp),\\n        ariaLabelMatchesYear: fnode =>\\n          ariaLabelMatchesRegExp(fnode.element, yearRegExp),\\n        previousFieldIdOrNameMatchExpMonthRegExp: fnode =>\\n          previousFieldIdOrNameMatchRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-month\\\"]\\n          ),\\n        previousFieldLabelsMatchExpMonthRegExp: fnode =>\\n          previousFieldLabelsMatchRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-month\\\"]\\n          ),\\n        previousFieldPlaceholderMatchExpMonthRegExp: fnode =>\\n          previousFieldPlaceholderMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-month\\\"]\\n          ),\\n        previousFieldAriaLabelMatchExpMonthRegExp: fnode =>\\n          previousFieldAriaLabelMatchesRegExp(\\n            fnode.element,\\n            FathomHeuristicsRegExp.RULES[\\\"cc-exp-month\\\"]\\n          ),\\n        previousFieldIdOrNameMatchMonth: fnode =>\\n          previousFieldIdOrNameMatchRegExp(fnode.element, monthRegExp),\\n        previousFieldLabelsMatchMonth: fnode =>\\n          previousFieldLabelsMatchRegExp(fnode.element, monthRegExp),\\n        previousFieldPlaceholderMatchesMonth: fnode =>\\n          previousFieldPlaceholderMatchesRegExp(fnode.element, monthRegExp),\\n        previousFieldAriaLabelMatchesMonth: fnode =>\\n          previousFieldAriaLabelMatchesRegExp(fnode.element, monthRegExp),\\n        previousFieldMatchesExpMonthAutocomplete,\\n        isExpirationYearLikely: fnode => isExpirationYearLikely(fnode.element),\\n        previousFieldIsExpirationMonthLikely,\\n        placeholderMatchesYYOrYYYY: fnode =>\\n          placeholderMatchesRegExp(fnode.element, YYorYYYYRegExp),\\n        roleIsMenu,\\n        idOrNameMatchSubscription: fnode =>\\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\\n        idOrNameMatchDwfrmAndBml,\\n        hasTemplatedValue,\\n      }),\\n      rule(type(\\\"cc-exp-year\\\"), out(\\\"cc-exp-year\\\")),\\n    ],\\n    coeffs,\\n    biases\\n  );\\n}\\n\\nconst coefficients = {\\n  \\\"cc-number\\\": [\\n    [\\\"idOrNameMatchNumberRegExp\\\", 7.679469585418701],\\n    [\\\"labelsMatchNumberRegExp\\\", 5.122580051422119],\\n    [\\\"closestLabelMatchesNumberRegExp\\\", 2.1256935596466064],\\n    [\\\"placeholderMatchesNumberRegExp\\\", 9.471800804138184],\\n    [\\\"ariaLabelMatchesNumberRegExp\\\", 6.067715644836426],\\n    [\\\"idOrNameMatchGift\\\", -22.946273803710938],\\n    [\\\"labelsMatchGift\\\", -7.852959632873535],\\n    [\\\"placeholderMatchesGift\\\", -2.355496406555176],\\n    [\\\"ariaLabelMatchesGift\\\", -2.940307855606079],\\n    [\\\"idOrNameMatchSubscription\\\", 0.11255314946174622],\\n    [\\\"idOrNameMatchDwfrmAndBml\\\", -0.0006645023822784424],\\n    [\\\"hasTemplatedValue\\\", -0.11370040476322174],\\n    [\\\"inputTypeNotNumbery\\\", -3.750155210494995]\\n  ],\\n  \\\"cc-name\\\": [\\n    [\\\"idOrNameMatchNameRegExp\\\", 7.496212959289551],\\n    [\\\"labelsMatchNameRegExp\\\", 6.081472873687744],\\n    [\\\"closestLabelMatchesNameRegExp\\\", 2.600574254989624],\\n    [\\\"placeholderMatchesNameRegExp\\\", 5.750874042510986],\\n    [\\\"ariaLabelMatchesNameRegExp\\\", 5.162227153778076],\\n    [\\\"idOrNameMatchFirst\\\", -6.742659091949463],\\n    [\\\"labelsMatchFirst\\\", -0.5234538912773132],\\n    [\\\"placeholderMatchesFirst\\\", -3.4615235328674316],\\n    [\\\"ariaLabelMatchesFirst\\\", -1.3145145177841187],\\n    [\\\"idOrNameMatchLast\\\", -12.561869621276855],\\n    [\\\"labelsMatchLast\\\", -0.27417105436325073],\\n    [\\\"placeholderMatchesLast\\\", -1.434966802597046],\\n    [\\\"ariaLabelMatchesLast\\\", -2.9319725036621094],\\n    [\\\"idOrNameMatchFirstAndLast\\\", 24.123435974121094],\\n    [\\\"idOrNameMatchSubscription\\\", 0.08349418640136719],\\n    [\\\"idOrNameMatchDwfrmAndBml\\\", 0.01882520318031311],\\n    [\\\"hasTemplatedValue\\\", 0.182317852973938]\\n  ],\\n  \\\"cc-type\\\": [\\n    [\\\"idOrNameMatchTypeRegExp\\\", 2.0581533908843994],\\n    [\\\"labelsMatchTypeRegExp\\\", 1.0784518718719482],\\n    [\\\"closestLabelMatchesTypeRegExp\\\", 0.6995877623558044],\\n    [\\\"idOrNameMatchVisaCheckout\\\", -3.320356845855713],\\n    [\\\"ariaLabelMatchesVisaCheckout\\\", -3.4196767807006836],\\n    [\\\"isSelectWithCreditCardOptions\\\", 10.337477684020996],\\n    [\\\"isRadioWithCreditCardText\\\", 4.530318737030029],\\n    [\\\"idOrNameMatchSubscription\\\", -3.7206356525421143],\\n    [\\\"idOrNameMatchDwfrmAndBml\\\", -0.08782318234443665],\\n    [\\\"hasTemplatedValue\\\", 0.1772511601448059]\\n  ],\\n  \\\"cc-exp\\\": [\\n    [\\\"labelsMatchExpRegExp\\\", 7.588159561157227],\\n    [\\\"closestLabelMatchesExpRegExp\\\", 1.41484534740448],\\n    [\\\"placeholderMatchesExpRegExp\\\", 8.759064674377441],\\n    [\\\"labelsMatchExpWith2Or4DigitYear\\\", -3.876218795776367],\\n    [\\\"placeholderMatchesExpWith2Or4DigitYear\\\", 2.8364884853363037],\\n    [\\\"labelsMatchMMYY\\\", 8.836017608642578],\\n    [\\\"placeholderMatchesMMYY\\\", -0.5231751799583435],\\n    [\\\"maxLengthIs7\\\", 1.3565447330474854],\\n    [\\\"idOrNameMatchSubscription\\\", 0.1779913753271103],\\n    [\\\"idOrNameMatchDwfrmAndBml\\\", 0.21037884056568146],\\n    [\\\"hasTemplatedValue\\\", 0.14900512993335724],\\n    [\\\"isExpirationMonthLikely\\\", -3.223409652709961],\\n    [\\\"isExpirationYearLikely\\\", -2.536919593811035],\\n    [\\\"idOrNameMatchMonth\\\", -3.6893014907836914],\\n    [\\\"idOrNameMatchYear\\\", -3.108184337615967],\\n    [\\\"idOrNameMatchExpMonthRegExp\\\", -2.264357089996338],\\n    [\\\"idOrNameMatchExpYearRegExp\\\", -2.7957723140716553],\\n    [\\\"idOrNameMatchValidation\\\", -2.29402756690979]\\n  ],\\n  \\\"cc-exp-month\\\": [\\n    [\\\"idOrNameMatchExpMonthRegExp\\\", 0.2787344455718994],\\n    [\\\"labelsMatchExpMonthRegExp\\\", 1.298413634300232],\\n    [\\\"closestLabelMatchesExpMonthRegExp\\\", -11.206244468688965],\\n    [\\\"placeholderMatchesExpMonthRegExp\\\", 1.2605619430541992],\\n    [\\\"ariaLabelMatchesExpMonthRegExp\\\", 1.1330018043518066],\\n    [\\\"idOrNameMatchMonth\\\", 6.1464314460754395],\\n    [\\\"labelsMatchMonth\\\", 0.7051732540130615],\\n    [\\\"placeholderMatchesMonth\\\", 0.7463492751121521],\\n    [\\\"ariaLabelMatchesMonth\\\", 1.8244760036468506],\\n    [\\\"nextFieldIdOrNameMatchExpYearRegExp\\\", 0.06347066164016724],\\n    [\\\"nextFieldLabelsMatchExpYearRegExp\\\", -0.1692247837781906],\\n    [\\\"nextFieldPlaceholderMatchExpYearRegExp\\\", 1.0434566736221313],\\n    [\\\"nextFieldAriaLabelMatchExpYearRegExp\\\", 1.751156210899353],\\n    [\\\"nextFieldIdOrNameMatchYear\\\", -0.532447338104248],\\n    [\\\"nextFieldLabelsMatchYear\\\", 1.3248541355133057],\\n    [\\\"nextFieldPlaceholderMatchesYear\\\", 0.604235827922821],\\n    [\\\"nextFieldAriaLabelMatchesYear\\\", 1.5364223718643188],\\n    [\\\"nextFieldMatchesExpYearAutocomplete\\\", 6.285938262939453],\\n    [\\\"isExpirationMonthLikely\\\", 13.117807388305664],\\n    [\\\"nextFieldIsExpirationYearLikely\\\", 7.182341575622559],\\n    [\\\"maxLengthIs2\\\", 4.477289199829102],\\n    [\\\"placeholderMatchesMM\\\", 14.403288841247559],\\n    [\\\"roleIsMenu\\\", 5.770959854125977],\\n    [\\\"idOrNameMatchSubscription\\\", -0.043085768818855286],\\n    [\\\"idOrNameMatchDwfrmAndBml\\\", 0.02823038399219513],\\n    [\\\"hasTemplatedValue\\\", 0.07234494388103485]\\n  ],\\n  \\\"cc-exp-year\\\": [\\n    [\\\"idOrNameMatchExpYearRegExp\\\", 5.426016807556152],\\n    [\\\"labelsMatchExpYearRegExp\\\", 1.3240209817886353],\\n    [\\\"closestLabelMatchesExpYearRegExp\\\", -8.702284812927246],\\n    [\\\"placeholderMatchesExpYearRegExp\\\", 0.9059725999832153],\\n    [\\\"ariaLabelMatchesExpYearRegExp\\\", 0.5550334453582764],\\n    [\\\"idOrNameMatchYear\\\", 5.362994194030762],\\n    [\\\"labelsMatchYear\\\", 2.7185044288635254],\\n    [\\\"placeholderMatchesYear\\\", 0.7883157134056091],\\n    [\\\"ariaLabelMatchesYear\\\", 0.311492383480072],\\n    [\\\"previousFieldIdOrNameMatchExpMonthRegExp\\\", 1.8155208826065063],\\n    [\\\"previousFieldLabelsMatchExpMonthRegExp\\\", -0.46133187413215637],\\n    [\\\"previousFieldPlaceholderMatchExpMonthRegExp\\\", 1.0374903678894043],\\n    [\\\"previousFieldAriaLabelMatchExpMonthRegExp\\\", -0.5901495814323425],\\n    [\\\"previousFieldIdOrNameMatchMonth\\\", -5.960310935974121],\\n    [\\\"previousFieldLabelsMatchMonth\\\", 0.6495584845542908],\\n    [\\\"previousFieldPlaceholderMatchesMonth\\\", 0.7198042273521423],\\n    [\\\"previousFieldAriaLabelMatchesMonth\\\", 3.4590985774993896],\\n    [\\\"previousFieldMatchesExpMonthAutocomplete\\\", 2.986003875732422],\\n    [\\\"isExpirationYearLikely\\\", 4.021566390991211],\\n    [\\\"previousFieldIsExpirationMonthLikely\\\", 9.298635482788086],\\n    [\\\"placeholderMatchesYYOrYYYY\\\", 10.457176208496094],\\n    [\\\"roleIsMenu\\\", 1.1051956415176392],\\n    [\\\"idOrNameMatchSubscription\\\", 0.000688597559928894],\\n    [\\\"idOrNameMatchDwfrmAndBml\\\", 0.15687309205532074],\\n    [\\\"hasTemplatedValue\\\", -0.19141331315040588]\\n  ],\\n};\\n\\nconst biases = [\\n  [\\\"cc-number\\\", -4.948795795440674],\\n  [\\\"cc-name\\\", -5.3578081130981445],\\n  [\\\"cc-type\\\", -5.979659557342529],\\n  [\\\"cc-exp\\\", -5.849575996398926],\\n  [\\\"cc-exp-month\\\", -8.844199180603027],\\n  [\\\"cc-exp-year\\\", -6.499860763549805],\\n];\\n\\n/**\\n * END OF CODE PASTED FROM TRAINING REPOSITORY\\n */\\n\\n/**\\n * MORE CODE UNIQUE TO PRODUCTION--NOT IN THE TRAINING REPOSITORY:\\n */\\n// Currently there is a bug when a ruleset has multple types (ex, cc-name, cc-number)\\n// and those types also has the same rules (ex. rule `hasTemplatedValue` is used in\\n// all the tyoes). When the above case exists, the coefficient of the rule will be\\n// overwritten, which means, we can't have different coefficient for the same rule on\\n// different types. To workaround this issue, we create a new ruleset for each type.\\nexport var CreditCardRulesets = {\\n  init() {\\n    XPCOMUtils.defineLazyPreferenceGetter(\\n      this,\\n      \\\"supportedTypes\\\",\\n      \\\"extensions.formautofill.creditCards.heuristics.fathom.types\\\",\\n      null,\\n      null,\\n      val => val.split(\\\",\\\")\\n    );\\n\\n    for (const type of this.types) {\\n      if (type) {\\n        this[type] = makeRuleset([...coefficients[type]], biases);\\n      }\\n    }\\n  },\\n\\n  get types() {\\n    return this.supportedTypes;\\n  },\\n};\\n\\nCreditCardRulesets.init();\\n\\nexport default CreditCardRulesets;\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/EmptyModule.sys.mjs":
/*!****************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/EmptyModule.sys.mjs ***!
  \****************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"// This function will create a proxy for each undefined property\\n// This is useful when the accessed property name is unkonwn beforehand\\nconst undefinedProxy = () =>\\n  new Proxy(() => {}, {\\n    get() {\\n      return undefinedProxy();\\n    },\\n  });\\nexport default undefinedProxy();\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/EmptyModule.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs ***!
  \*****************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nconst lazy = {};\\nChromeUtils.defineESModuleGetters(lazy, {\\n  FormAutofill: \\\"resource://autofill/FormAutofill.sys.mjs\\\",\\n  FormAutofillUtils: \\\"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\\\",\\n  MLAutofill: \\\"resource://autofill/MLAutofill.sys.mjs\\\",\\n});\\n\\n/**\\n * Represents the detailed information about a form field, including\\n * the inferred field name, the approach used for inferring, and additional metadata.\\n */\\nexport class FieldDetail {\\n  // Reference to the elemenet\\n  elementWeakRef = null;\\n\\n  // The identifier generated via ContentDOMReference for the associated DOM element\\n  // of this field\\n  elementId = null;\\n\\n  // The identifier generated via ContentDOMReference for the root element of\\n  // this field\\n  rootElementId = null;\\n\\n  // If the element is an iframe, it is the id of the BrowsingContext of the iframe,\\n  // Otherwise, it is the id of the BrowsingContext the element is in\\n  browsingContextId = null;\\n\\n  // string with `${element.id}/{element.name}`. This is only used for debugging.\\n  identifier = \\\"\\\";\\n\\n  // tag name attribute of the element\\n  localName = null;\\n\\n  // The inferred field name for this element.\\n  fieldName = null;\\n\\n  // The approach we use to infer the information for this element\\n  // The possible values are \\\"autocomplete\\\", \\\"fathom\\\", and \\\"regex-heuristic\\\"\\n  reason = null;\\n\\n  /*\\n   * The \\\"section\\\", \\\"addressType\\\", and \\\"contactType\\\" values are\\n   * used to identify the exact field when the serializable data is received\\n   * from the backend.  There cannot be multiple fields which have\\n   * the same exact combination of these values.\\n   */\\n\\n  // Which section the field belongs to. The value comes from autocomplete attribute.\\n  // See https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill-detail-tokens for more details\\n  section = \\\"\\\";\\n  addressType = \\\"\\\";\\n  contactType = \\\"\\\";\\n  credentialType = \\\"\\\";\\n\\n  // When a field is split into N fields, we use part to record which field it is\\n  // For example, a credit card number field is split into 4 fields, the value of\\n  // \\\"part\\\" for the first cc-number field is 1, for the last one is 4.\\n  // If the field is not split, the value is null\\n  part = null;\\n\\n  // Confidence value when the field name is inferred by \\\"fathom\\\"\\n  confidence = null;\\n\\n  constructor(element) {\\n    this.elementWeakRef = new WeakRef(element);\\n  }\\n\\n  get element() {\\n    return this.elementWeakRef.deref();\\n  }\\n\\n  /**\\n   * Convert FieldDetail class to an object that is suitable for\\n   * sending over IPC. Avoid using this in other case.\\n   */\\n  toVanillaObject() {\\n    const json = { ...this };\\n    delete json.elementWeakRef;\\n    return json;\\n  }\\n\\n  static fromVanillaObject(obj) {\\n    const element = lazy.FormAutofillUtils.getElementByIdentifier(\\n      obj.elementId\\n    );\\n    return element ? Object.assign(new FieldDetail(element), obj) : null;\\n  }\\n\\n  static create(\\n    element,\\n    form,\\n    fieldName = null,\\n    {\\n      autocompleteInfo = null,\\n      fathomLabel = null,\\n      fathomConfidence = null,\\n      isVisible = true,\\n      mlHeaderInput = null,\\n      mlButtonInput = null,\\n    } = {}\\n  ) {\\n    const fieldDetail = new FieldDetail(element);\\n\\n    fieldDetail.elementId =\\n      lazy.FormAutofillUtils.getElementIdentifier(element);\\n    fieldDetail.rootElementId = lazy.FormAutofillUtils.getElementIdentifier(\\n      form.rootElement\\n    );\\n    fieldDetail.identifier = `${element.id}/${element.name}`;\\n    fieldDetail.localName = element.localName;\\n\\n    if (Array.isArray(fieldName)) {\\n      fieldDetail.fieldName = fieldName[0] ?? \\\"\\\";\\n      fieldDetail.alternativeFieldName = fieldName[1] ?? \\\"\\\";\\n    } else {\\n      fieldDetail.fieldName = fieldName;\\n    }\\n\\n    if (!fieldDetail.fieldName) {\\n      fieldDetail.reason = \\\"unknown\\\";\\n    } else if (autocompleteInfo) {\\n      fieldDetail.reason = \\\"autocomplete\\\";\\n      fieldDetail.section = autocompleteInfo.section;\\n      fieldDetail.addressType = autocompleteInfo.addressType;\\n      fieldDetail.contactType = autocompleteInfo.contactType;\\n      fieldDetail.credentialType = autocompleteInfo.credentialType;\\n      fieldDetail.sectionName =\\n        autocompleteInfo.section || autocompleteInfo.addressType;\\n    } else if (fathomConfidence) {\\n      fieldDetail.reason = \\\"fathom\\\";\\n      fieldDetail.confidence = fathomConfidence;\\n\\n      // TODO: This should be removed once we support reference field info across iframe.\\n      // Temporarily add an addtional \\\"the field is the only visible input\\\" constraint\\n      // when determining whether a form has only a high-confidence cc-* field a valid\\n      // credit card section. We can remove this restriction once we are confident\\n      // about only using fathom.\\n      fieldDetail.isOnlyVisibleFieldWithHighConfidence = false;\\n      if (\\n        fieldDetail.confidence >\\n        lazy.FormAutofillUtils.ccFathomHighConfidenceThreshold\\n      ) {\\n        const root = element.form || element.ownerDocument;\\n        const inputs = root.querySelectorAll(\\\"input:not([type=hidden])\\\");\\n        if (inputs.length == 1 && inputs[0] == element) {\\n          fieldDetail.isOnlyVisibleFieldWithHighConfidence = true;\\n        }\\n      }\\n    } else {\\n      fieldDetail.reason = \\\"regex-heuristic\\\";\\n    }\\n\\n    try {\\n      fieldDetail.browsingContextId =\\n        element.localName == \\\"iframe\\\"\\n          ? element.browsingContext.id\\n          : BrowsingContext.getFromWindow(element.ownerGlobal).id;\\n    } catch {\\n      /* unit test doesn't have ownerGlobal */\\n    }\\n\\n    fieldDetail.isVisible = isVisible;\\n\\n    // Info required by heuristics\\n    fieldDetail.maxLength = element.maxLength;\\n\\n    if (\\n      lazy.FormAutofill.isMLExperimentEnabled &&\\n      [\\\"input\\\", \\\"select\\\"].includes(element.localName)\\n    ) {\\n      fieldDetail.mlinput = lazy.MLAutofill.getMLMarkup(fieldDetail.element);\\n      fieldDetail.mlHeaderInput = mlHeaderInput;\\n      fieldDetail.mlButtonInput = mlButtonInput;\\n      fieldDetail.fathomLabel = fathomLabel;\\n      fieldDetail.fathomConfidence = fathomConfidence;\\n    }\\n\\n    return fieldDetail;\\n  }\\n}\\n\\n/**\\n * A scanner for traversing all elements in a form. It also provides a\\n * cursor (parsingIndex) to indicate which element is waiting for parsing.\\n *\\n * The scanner retrives the field detail by calling heuristics handlers\\n * `inferFieldInfo` function.\\n */\\nexport class FieldScanner {\\n  #parsingIndex = 0;\\n\\n  #fieldDetails = [];\\n\\n  /**\\n   * Create a FieldScanner based on form elements with the existing\\n   * fieldDetails.\\n   *\\n   * @param {Array<FieldDetails>} fieldDetails\\n   *        An array of fieldDetail object to be scanned.\\n   */\\n  constructor(fieldDetails) {\\n    this.#fieldDetails = fieldDetails;\\n  }\\n\\n  /**\\n   * This cursor means the index of the element which is waiting for parsing.\\n   *\\n   * @returns {number}\\n   *          The index of the element which is waiting for parsing.\\n   */\\n  get parsingIndex() {\\n    return this.#parsingIndex;\\n  }\\n\\n  get parsingFinished() {\\n    return this.parsingIndex >= this.#fieldDetails.length;\\n  }\\n\\n  /**\\n   * Move the parsingIndex to the next elements. Any elements behind this index\\n   * means the parsing tasks are finished.\\n   *\\n   * @param {number} index\\n   *        The latest index of elements waiting for parsing.\\n   */\\n  set parsingIndex(index) {\\n    if (index > this.#fieldDetails.length) {\\n      throw new Error(\\\"The parsing index is out of range.\\\");\\n    }\\n    this.#parsingIndex = index;\\n  }\\n\\n  /**\\n   * Retrieve the field detail by the index. If the field detail is not ready,\\n   * the elements will be traversed until matching the index.\\n   *\\n   * @param {number} index\\n   *        The index of the element that you want to retrieve.\\n   * @returns {object}\\n   *          The field detail at the specific index.\\n   */\\n  getFieldDetailByIndex(index) {\\n    if (index >= this.#fieldDetails.length) {\\n      return null;\\n    }\\n\\n    return this.#fieldDetails[index];\\n  }\\n\\n  /**\\n   * When a field detail should be changed its fieldName after parsing, use\\n   * this function to update the fieldName which is at a specific index.\\n   *\\n   * @param {number} index\\n   *        The index indicates a field detail to be updated.\\n   * @param {string} fieldName\\n   *        The new name of the field\\n   * @param {boolean} [ignoreAutocomplete=false]\\n   *        Whether to change the field name when the field name is determined by\\n   *        autocomplete attribute\\n   */\\n  updateFieldName(index, fieldName, ignoreAutocomplete = false) {\\n    if (index >= this.#fieldDetails.length) {\\n      throw new Error(\\\"Try to update the non-existing field detail.\\\");\\n    }\\n\\n    const fieldDetail = this.#fieldDetails[index];\\n    if (fieldDetail.fieldName == fieldName) {\\n      return;\\n    }\\n\\n    if (!ignoreAutocomplete && fieldDetail.reason == \\\"autocomplete\\\") {\\n      return;\\n    }\\n\\n    fieldDetail.fieldName = fieldName;\\n    fieldDetail.reason = \\\"update-heuristic\\\";\\n  }\\n\\n  elementExisting(index) {\\n    return index < this.#fieldDetails.length;\\n  }\\n}\\n\\nexport default FieldScanner;\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs ***!
  \*********************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nimport { FormAutofill } from \\\"resource://autofill/FormAutofill.sys.mjs\\\";\\n\\nFormAutofill.defineLogGetter = (_scope, _logPrefix) => ({\\n  // TODO: Bug 1828405. Explore how logging should be handled.\\n  // Maybe it makes more sense to do it on swift side and have JS just send messages.\\n  info: () => {},\\n  error: () => {},\\n  warn: () => {},\\n  debug: () => {},\\n});\\n\\nexport { FormAutofill };\\nexport default FormAutofill;\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs ***!
  \*****************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nimport { XPCOMUtils } from \\\"resource://gre/modules/XPCOMUtils.sys.mjs\\\";\\nimport { Region } from \\\"resource://gre/modules/Region.sys.mjs\\\";\\nimport { AddressMetaDataLoader } from \\\"resource://gre/modules/shared/AddressMetaDataLoader.sys.mjs\\\";\\n\\nconst AUTOFILL_ADDRESSES_AVAILABLE_PREF =\\n  \\\"extensions.formautofill.addresses.supported\\\";\\n// This pref should be refactored after the migration of the old bool pref\\nconst AUTOFILL_CREDITCARDS_AVAILABLE_PREF =\\n  \\\"extensions.formautofill.creditCards.supported\\\";\\nconst BROWSER_SEARCH_REGION_PREF = \\\"browser.search.region\\\";\\nconst CREDITCARDS_AUTOFILL_SUPPORTED_COUNTRIES_PREF =\\n  \\\"extensions.formautofill.creditCards.supportedCountries\\\";\\nconst ENABLED_AUTOFILL_ADDRESSES_PREF =\\n  \\\"extensions.formautofill.addresses.enabled\\\";\\nconst ENABLED_AUTOFILL_ADDRESSES_CAPTURE_PREF =\\n  \\\"extensions.formautofill.addresses.capture.enabled\\\";\\nconst ENABLED_AUTOFILL_ADDRESSES_CAPTURE_REQUIRED_FIELDS_PREF =\\n  \\\"extensions.formautofill.addresses.capture.requiredFields\\\";\\nconst ENABLED_AUTOFILL_ADDRESSES_SUPPORTED_COUNTRIES_PREF =\\n  \\\"extensions.formautofill.addresses.supportedCountries\\\";\\nconst ENABLED_AUTOFILL_CREDITCARDS_PREF =\\n  \\\"extensions.formautofill.creditCards.enabled\\\";\\nconst AUTOFILL_CREDITCARDS_REAUTH_PREF =\\n  \\\"extensions.formautofill.creditCards.reauth.optout\\\";\\nconst AUTOFILL_CREDITCARDS_HIDE_UI_PREF =\\n  \\\"extensions.formautofill.creditCards.hideui\\\";\\nconst FORM_AUTOFILL_SUPPORT_RTL_PREF = \\\"extensions.formautofill.supportRTL\\\";\\nconst AUTOFILL_CREDITCARDS_AUTOCOMPLETE_OFF_PREF =\\n  \\\"extensions.formautofill.creditCards.ignoreAutocompleteOff\\\";\\nconst AUTOFILL_ADDRESSES_AUTOCOMPLETE_OFF_PREF =\\n  \\\"extensions.formautofill.addresses.ignoreAutocompleteOff\\\";\\nconst ENABLED_AUTOFILL_CAPTURE_ON_FORM_REMOVAL_PREF =\\n  \\\"extensions.formautofill.heuristics.captureOnFormRemoval\\\";\\nconst ENABLED_AUTOFILL_CAPTURE_ON_PAGE_NAVIGATION_PREF =\\n  \\\"extensions.formautofill.heuristics.captureOnPageNavigation\\\";\\nconst ENABLED_AUTOFILL_SAME_ORIGIN_WITH_TOP =\\n  \\\"extensions.formautofill.heuristics.autofillSameOriginWithTop\\\";\\nconst ENABLED_AUTOFILL_DETECT_DYNAMIC_FORM_CHANGES_PREF =\\n  \\\"extensions.formautofill.heuristics.detectDynamicFormChanges\\\";\\nconst AUTOFILL_FILL_ON_DYNAMIC_FORM_CHANGES_TIMEOUT_PREF =\\n  \\\"extensions.formautofill.heuristics.fillOnDynamicFormChanges.timeout\\\";\\nconst AUTOFILL_FILL_ON_DYNAMIC_FORM_CHANGES_PREF =\\n  \\\"extensions.formautofill.heuristics.fillOnDynamicFormChanges\\\";\\n\\nexport const FormAutofill = {\\n  ENABLED_AUTOFILL_ADDRESSES_PREF,\\n  ENABLED_AUTOFILL_ADDRESSES_CAPTURE_PREF,\\n  ENABLED_AUTOFILL_CAPTURE_ON_FORM_REMOVAL_PREF,\\n  ENABLED_AUTOFILL_CAPTURE_ON_PAGE_NAVIGATION_PREF,\\n  ENABLED_AUTOFILL_SAME_ORIGIN_WITH_TOP,\\n  ENABLED_AUTOFILL_CREDITCARDS_PREF,\\n  ENABLED_AUTOFILL_DETECT_DYNAMIC_FORM_CHANGES_PREF,\\n  AUTOFILL_CREDITCARDS_REAUTH_PREF,\\n  AUTOFILL_CREDITCARDS_AUTOCOMPLETE_OFF_PREF,\\n  AUTOFILL_ADDRESSES_AUTOCOMPLETE_OFF_PREF,\\n  AUTOFILL_FILL_ON_DYNAMIC_FORM_CHANGES_PREF,\\n  AUTOFILL_FILL_ON_DYNAMIC_FORM_CHANGES_TIMEOUT_PREF,\\n\\n  _region: null,\\n\\n  get DEFAULT_REGION() {\\n    return this._region || Region.home || \\\"US\\\";\\n  },\\n\\n  set DEFAULT_REGION(region) {\\n    this._region = region;\\n  },\\n\\n  /**\\n   * Determines if an autofill feature should be enabled based on the \\\"available\\\"\\n   * and \\\"supportedCountries\\\" parameters.\\n   *\\n   * @param {string} available Available can be one of the following: \\\"on\\\", \\\"detect\\\", \\\"off\\\".\\n   * \\\"on\\\" forces the particular Form Autofill feature on, while \\\"detect\\\" utilizes the supported countries\\n   * to see if the feature should be available.\\n   * @param {string[]} supportedCountries\\n   * @returns {boolean} `true` if autofill feature is supported in the current browser search region\\n   */\\n  _isSupportedRegion(available, supportedCountries) {\\n    if (available == \\\"on\\\") {\\n      return true;\\n    } else if (available == \\\"detect\\\") {\\n      if (!FormAutofill.supportRTL && Services.locale.isAppLocaleRTL) {\\n        return false;\\n      }\\n\\n      return supportedCountries.includes(FormAutofill.browserSearchRegion);\\n    }\\n    return false;\\n  },\\n\\n  /**\\n   * Return true if address autofill is available for a specific country.\\n   */\\n  isAutofillAddressesAvailableInCountry(country) {\\n    if (FormAutofill._isAutofillAddressesAvailableInExperiment) {\\n      return true;\\n    }\\n\\n    let available = FormAutofill._isAutofillAddressesAvailable;\\n    if (country && available == \\\"detect\\\") {\\n      return FormAutofill._addressAutofillSupportedCountries.includes(\\n        country.toUpperCase()\\n      );\\n    }\\n    return available == \\\"on\\\";\\n  },\\n  get isAutofillEnabled() {\\n    return this.isAutofillAddressesEnabled || this.isAutofillCreditCardsEnabled;\\n  },\\n  /**\\n   * Determines if the credit card autofill feature is available to use in the browser.\\n   * If the feature is not available, then there are no user facing ways to enable it.\\n   *\\n   * @returns {boolean} `true` if credit card autofill is available\\n   */\\n  get isAutofillCreditCardsAvailable() {\\n    return this._isSupportedRegion(\\n      FormAutofill._isAutofillCreditCardsAvailable,\\n      FormAutofill._creditCardAutofillSupportedCountries\\n    );\\n  },\\n  /**\\n   * Determines if the address autofill feature is available to use in the browser.\\n   * If the feature is not available, then there are no user facing ways to enable it.\\n   * Two conditions must be met for the autofill feature to be considered available:\\n   *   1. Address autofill support is confirmed when:\\n   *      - `extensions.formautofill.addresses.supported` is set to `on`.\\n   *      - The user is located in a region supported by the feature\\n   *        (`extensions.formautofill.creditCards.supportedCountries`).\\n   *   2. Address autofill is enabled through a Nimbus experiment:\\n   *      - The experiment pref `extensions.formautofill.addresses.experiments.enabled` is set to true.\\n   *\\n   * @returns {boolean} `true` if address autofill is available\\n   */\\n  get isAutofillAddressesAvailable() {\\n    const isUserInSupportedRegion = this._isSupportedRegion(\\n      FormAutofill._isAutofillAddressesAvailable,\\n      FormAutofill._addressAutofillSupportedCountries\\n    );\\n    return (\\n      isUserInSupportedRegion ||\\n      FormAutofill._isAutofillAddressesAvailableInExperiment\\n    );\\n  },\\n  /**\\n   * Determines if the user has enabled or disabled credit card autofill.\\n   *\\n   * @returns {boolean} `true` if credit card autofill is enabled\\n   */\\n  get isAutofillCreditCardsEnabled() {\\n    return (\\n      this.isAutofillCreditCardsAvailable &&\\n      FormAutofill._isAutofillCreditCardsEnabled\\n    );\\n  },\\n  /**\\n   * Determines if credit card autofill is locked by policy.\\n   *\\n   * @returns {boolean} `true` if credit card autofill is locked\\n   */\\n  get isAutofillCreditCardsLocked() {\\n    return Services.prefs.prefIsLocked(ENABLED_AUTOFILL_CREDITCARDS_PREF);\\n  },\\n  /**\\n   * Determines if the user has enabled or disabled address autofill.\\n   *\\n   * @returns {boolean} `true` if address autofill is enabled\\n   */\\n  get isAutofillAddressesEnabled() {\\n    return (\\n      this.isAutofillAddressesAvailable &&\\n      FormAutofill._isAutofillAddressesEnabled\\n    );\\n  },\\n  /**\\n   * Determines if address autofill is locked by policy.\\n   *\\n   * @returns {boolean} `true` if address autofill is locked\\n   */\\n  get isAutofillAddressesLocked() {\\n    return Services.prefs.prefIsLocked(ENABLED_AUTOFILL_ADDRESSES_PREF);\\n  },\\n\\n  defineLogGetter(scope, logPrefix) {\\n    // A logging helper for debug logging to avoid creating Console objects\\n    // or triggering expensive JS -> C++ calls when debug logging is not\\n    // enabled.\\n    //\\n    // Console objects, even natively-implemented ones, can consume a lot of\\n    // memory, and since this code may run in every content process, that\\n    // memory can add up quickly. And, even when debug-level messages are\\n    // being ignored, console.debug() calls can be expensive.\\n    //\\n    // This helper avoids both of those problems by never touching the\\n    // console object unless debug logging is enabled.\\n    scope.debug = function debug() {\\n      if (FormAutofill.logLevel.toLowerCase() == \\\"debug\\\") {\\n        this.log.debug(...arguments);\\n      }\\n    };\\n\\n    let { ConsoleAPI } = ChromeUtils.importESModule(\\n      \\\"resource://gre/modules/Console.sys.mjs\\\"\\n    );\\n    return new ConsoleAPI({\\n      maxLogLevelPref: \\\"extensions.formautofill.loglevel\\\",\\n      prefix: logPrefix,\\n    });\\n  },\\n\\n  get isMLExperimentEnabled() {\\n    return FormAutofill._isMLEnabled && FormAutofill._isMLExperimentEnabled;\\n  },\\n};\\n\\n// TODO: Bug 1747284. Use Region.home instead of reading \\\"browser.serach.region\\\"\\n// by default. However, Region.home doesn't observe preference change at this point,\\n// we should also fix that issue.\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"browserSearchRegion\\\",\\n  BROWSER_SEARCH_REGION_PREF,\\n  FormAutofill.DEFAULT_REGION\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"logLevel\\\",\\n  \\\"extensions.formautofill.loglevel\\\",\\n  \\\"Warn\\\"\\n);\\n\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"_isAutofillAddressesAvailable\\\",\\n  AUTOFILL_ADDRESSES_AVAILABLE_PREF\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"_isAutofillAddressesEnabled\\\",\\n  ENABLED_AUTOFILL_ADDRESSES_PREF\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"isAutofillAddressesCaptureEnabled\\\",\\n  ENABLED_AUTOFILL_ADDRESSES_CAPTURE_PREF\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"_isAutofillCreditCardsAvailable\\\",\\n  AUTOFILL_CREDITCARDS_AVAILABLE_PREF\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"_isAutofillCreditCardsEnabled\\\",\\n  ENABLED_AUTOFILL_CREDITCARDS_PREF\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"isAutofillCreditCardsHideUI\\\",\\n  AUTOFILL_CREDITCARDS_HIDE_UI_PREF\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"_addressAutofillSupportedCountries\\\",\\n  ENABLED_AUTOFILL_ADDRESSES_SUPPORTED_COUNTRIES_PREF,\\n  null,\\n  val => val.split(\\\",\\\")\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"_creditCardAutofillSupportedCountries\\\",\\n  CREDITCARDS_AUTOFILL_SUPPORTED_COUNTRIES_PREF,\\n  null,\\n  null,\\n  val => val.split(\\\",\\\")\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"supportRTL\\\",\\n  FORM_AUTOFILL_SUPPORT_RTL_PREF\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"creditCardsAutocompleteOff\\\",\\n  AUTOFILL_CREDITCARDS_AUTOCOMPLETE_OFF_PREF\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"addressesAutocompleteOff\\\",\\n  AUTOFILL_ADDRESSES_AUTOCOMPLETE_OFF_PREF\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"captureOnFormRemoval\\\",\\n  ENABLED_AUTOFILL_CAPTURE_ON_FORM_REMOVAL_PREF\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"captureOnPageNavigation\\\",\\n  ENABLED_AUTOFILL_CAPTURE_ON_PAGE_NAVIGATION_PREF\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"addressCaptureRequiredFields\\\",\\n  ENABLED_AUTOFILL_ADDRESSES_CAPTURE_REQUIRED_FIELDS_PREF,\\n  null,\\n  null,\\n  val => val?.split(\\\",\\\").filter(v => !!v)\\n);\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"autofillSameOriginWithTop\\\",\\n  ENABLED_AUTOFILL_SAME_ORIGIN_WITH_TOP\\n);\\n\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"_isAutofillAddressesAvailableInExperiment\\\",\\n  \\\"extensions.formautofill.addresses.experiments.enabled\\\"\\n);\\n\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"_isMLEnabled\\\",\\n  \\\"browser.ml.enable\\\",\\n  false\\n);\\n\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"_isMLExperimentEnabled\\\",\\n  \\\"extensions.formautofill.ml.experiment.enabled\\\",\\n  false\\n);\\n\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"MLModelRevision\\\",\\n  \\\"extensions.formautofill.ml.experiment.modelRevision\\\",\\n  null\\n);\\n\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"detectDynamicFormChanges\\\",\\n  \\\"extensions.formautofill.heuristics.detectDynamicFormChanges\\\",\\n  false\\n);\\n\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"fillOnDynamicFormChanges\\\",\\n  \\\"extensions.formautofill.heuristics.fillOnDynamicFormChanges\\\",\\n  false\\n);\\n\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofill,\\n  \\\"fillOnDynamicFormChangeTimeout\\\",\\n  \\\"extensions.formautofill.heuristics.fillOnDynamicFormChanges.timeout\\\",\\n  0\\n);\\n\\nChromeUtils.defineLazyGetter(FormAutofill, \\\"countries\\\", () =>\\n  AddressMetaDataLoader.getCountries()\\n);\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs ***!
  \**************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n/* eslint-disable no-undef,mozilla/balanced-listeners */\\nimport { AddressRecord } from \\\"resource://gre/modules/shared/AddressRecord.sys.mjs\\\";\\nimport { FormAutofillHandler } from \\\"resource://gre/modules/shared/FormAutofillHandler.sys.mjs\\\";\\nimport { FormAutofillHeuristics } from \\\"resource://gre/modules/shared/FormAutofillHeuristics.sys.mjs\\\";\\nimport { FormAutofillUtils } from \\\"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\\\";\\nimport { FormStateManager } from \\\"resource://gre/modules/shared/FormStateManager.sys.mjs\\\";\\nimport { CreditCardRecord } from \\\"resource://gre/modules/shared/CreditCardRecord.sys.mjs\\\";\\nimport {\\n  FormAutofillAddressSection,\\n  FormAutofillCreditCardSection,\\n  FormAutofillSection,\\n} from \\\"resource://gre/modules/shared/FormAutofillSection.sys.mjs\\\";\\n\\nexport class FormAutofillChild {\\n  /**\\n   * Creates an instance of FormAutofillChild.\\n   *\\n   * @param {object} callbacks - An object containing callback functions.\\n   * @param {object} callbacks.address - Callbacks related to addresses.\\n   * @param {Function} callbacks.address.autofill - Function called to autofill address fields.\\n   * @param {Function} callbacks.address.submit - Function called on address form submission.\\n   * @param {object} callbacks.creditCard - Callbacks related to credit cards.\\n   * @param {Function} callbacks.creditCard.autofill - Function called to autofill credit card fields.\\n   * @param {Function} callbacks.creditCard.submit - Function called on credit card form submission.\\n   */\\n  constructor(callbacks) {\\n    this.onFocusIn = this.onFocusIn.bind(this);\\n    this.onSubmit = this.onSubmit.bind(this);\\n\\n    this.callbacks = callbacks;\\n\\n    this.fieldDetailsManager = new FormStateManager(fieldDetail =>\\n      // Collect field_modified telemetry\\n      this.activeSection?.onFilledModified(fieldDetail.elementId)\\n    );\\n\\n    try {\\n      document.addEventListener(\\\"focusin\\\", this.onFocusIn);\\n      document.addEventListener(\\\"submit\\\", this.onSubmit);\\n    } catch {\\n      // We don't have `document` when running in xpcshell-test\\n    }\\n  }\\n\\n  transformToFieldNamesWithValues(details) {\\n    return details?.reduce(\\n      (acc, field) => ({\\n        ...acc,\\n        [field.fieldName]: field.element.value,\\n      }),\\n      {}\\n    );\\n  }\\n\\n  identifyFieldsWhenFocused(element) {\\n    if (this.#focusedElement == element) {\\n      return;\\n    }\\n    this.#focusedElement = element;\\n\\n    if (!FormAutofillUtils.isCreditCardOrAddressFieldType(element)) {\\n      return;\\n    }\\n\\n    // Find the autofill handler for this form and identify all the fields.\\n    const handler = this.fieldDetailsManager.getOrCreateFormHandler(element);\\n\\n    if (!handler.hasIdentifiedFields() || handler.updateFormIfNeeded(element)) {\\n      // If we found newly identified fields, run section classification heuristic\\n      const detectedFields = FormAutofillHandler.collectFormFieldDetails(\\n        handler.form\\n      );\\n\\n      FormAutofillHeuristics.parseAndUpdateFieldNamesParent(detectedFields);\\n      handler.setIdentifiedFieldDetails(detectedFields);\\n\\n      this.#sections = FormAutofillSection.classifySections(\\n        handler.fieldDetails\\n      );\\n\\n      // For telemetry\\n      this.#sections.forEach(section => section.onDetected());\\n    }\\n  }\\n\\n  #focusedElement = null;\\n\\n  // This is a cache contains the classified section for the active form.\\n  #sections = null;\\n\\n  get activeSection() {\\n    const elementId = this.activeFieldDetail?.elementId;\\n    return this.#sections?.find(section =>\\n      section.getFieldDetailByElementId(elementId)\\n    );\\n  }\\n\\n  // active field detail only exists if we identified its field name\\n  get activeFieldDetail() {\\n    return this.activeHandler?.getFieldDetailByElement(this.#focusedElement);\\n  }\\n\\n  get activeHandler() {\\n    return this.fieldDetailsManager.getFormHandler(this.#focusedElement);\\n  }\\n\\n  onFocusIn(evt) {\\n    const element = evt.target;\\n\\n    if (element.shouldIgnoreAutofill) {\\n      return;\\n    }\\n\\n    this.identifyFieldsWhenFocused(element);\\n\\n    // Only ping swift if current field is either a cc or address field\\n    if (!this.activeFieldDetail) {\\n      return;\\n    }\\n\\n    // Since iOS doesn't support cross frame autofill,\\n    // we should only call the autofill callback if the section is valid.\\n    // TODO(issam): This will change when we have cross frame fill support.\\n    if (!this.activeSection?.isValidSection()) {\\n      return;\\n    }\\n\\n    const fieldNamesWithValues = this.transformToFieldNamesWithValues(\\n      this.activeSection.fieldDetails\\n    );\\n\\n    if (FormAutofillUtils.isAddressField(this.activeFieldDetail.fieldName)) {\\n      this.callbacks.address.autofill(fieldNamesWithValues);\\n    } else if (\\n      FormAutofillUtils.isCreditCardField(this.activeFieldDetail.fieldName)\\n    ) {\\n      // Normalize record format so we always get a consistent\\n      // credit card record format: {cc-number, cc-name, cc-exp-month, cc-exp-year}\\n      CreditCardRecord.normalizeFields(fieldNamesWithValues);\\n      this.callbacks.creditCard.autofill(fieldNamesWithValues);\\n    }\\n  }\\n\\n  onSubmit(_event) {\\n    if (!this.activeHandler) {\\n      return;\\n    }\\n\\n    // Get filled value for the form\\n    const formFilledData = this.activeHandler.collectFormFilledData();\\n\\n    // Should reference `_onFormSubmit` in `FormAutofillParent.sys.mjs`\\n    const creditCard = [];\\n\\n    for (const section of this.#sections) {\\n      const secRecord = section.createRecord(formFilledData);\\n      if (!secRecord) {\\n        continue;\\n      }\\n\\n      if (section instanceof FormAutofillAddressSection) {\\n        // TODO(FXSP-133 Phase 3): Support address capture\\n        // this.callbacks.address.submit();\\n        continue;\\n      } else if (section instanceof FormAutofillCreditCardSection) {\\n        creditCard.push(secRecord);\\n      } else {\\n        throw new Error(\\\"Unknown section type\\\");\\n      }\\n\\n      section.onSubmitted(formFilledData);\\n    }\\n\\n    if (creditCard.length) {\\n      // Normalize record format so we always get a consistent\\n      // credit card record format: {cc-number, cc-name, cc-exp-month, cc-exp-year}\\n      const creditCardRecords = creditCard.map(entry => {\\n        CreditCardRecord.normalizeFields(entry.record);\\n        return entry.record;\\n      });\\n      this.callbacks.creditCard.submit(creditCardRecords);\\n    }\\n  }\\n\\n  fillFormFields(payload) {\\n    // In iOS, we have access only to valid fields (https://github.com/mozilla/application-services/blob/9054db4bb5031881550ceab3448665ef6499a706/components/autofill/src/autofill.udl#L59-L76) for an address;\\n    // all additional data must be computed. On Desktop, computed fields are handled in FormAutofillStorageBase.sys.mjs at the time of saving. Ideally, we should centralize\\n    // all transformations, computations, and normalization processes within AddressRecord.sys.mjs to maintain a unified implementation across both platforms.\\n    // This will be addressed in FXCM-810, aiming to simplify our data representation for both credit cards and addresses.\\n\\n    if (FormAutofillUtils.isAddressField(this.activeFieldDetail?.fieldName)) {\\n      AddressRecord.computeFields(payload);\\n    }\\n\\n    this.activeHandler.fillFields(\\n      FormAutofillUtils.getElementIdentifier(this.#focusedElement),\\n      this.activeSection.fieldDetails.map(f => f.elementId),\\n      payload\\n    );\\n\\n    // For telemetry\\n    const formFilledData = this.activeHandler.collectFormFilledData();\\n    this.activeSection.onFilled(formFilledData);\\n  }\\n}\\n\\nexport default FormAutofillChild;\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs ***!
  \***********************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nexport class FormAutofillExtras {\\n\\n  isFocusable(element) {\\n    let style = window.getComputedStyle(element);\\n    return !(element.type === 'hidden' || element.offsetParent === null || style.visibility === 'hidden' || style.display === 'none' || style.opacity === '0' || element.hasAttribute('hidden'));\\n  }\\n\\n  focusNextInputField() {\\n    let inputFields = [...document.getElementsByTagName('input')];\\n    inputFields = inputFields.filter(this.isFocusable);\\n    const activeElement = document.activeElement;\\n    const currentIndex = inputFields.indexOf(activeElement);\\n    const inputFieldCount = inputFields.length - 1;\\n\\n    if (currentIndex < inputFieldCount) {\\n      const nextField = inputFields[currentIndex + 1];\\n      nextField.focus();\\n    }\\n  }\\n\\n  focusPreviousInputField() {\\n    let inputFields = [...document.getElementsByTagName('input')];\\n    inputFields = inputFields.filter(this.isFocusable);\\n    const activeElement = document.activeElement;\\n    const currentIndex = inputFields.indexOf(activeElement);\\n\\n    if (currentIndex > 0) {\\n      const previousField = inputFields[currentIndex - 1];\\n      previousField.focus();\\n    }\\n  }\\n}\\n\\nexport default FormAutofillExtras;\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs ***!
  \************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nimport { FormAutofill } from \\\"resource://autofill/FormAutofill.sys.mjs\\\";\\nimport { FormAutofillUtils } from \\\"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\\\";\\n\\nconst lazy = {};\\nChromeUtils.defineESModuleGetters(lazy, {\\n  AddressParser: \\\"resource://gre/modules/shared/AddressParser.sys.mjs\\\",\\n  AutofillFormFactory:\\n    \\\"resource://gre/modules/shared/AutofillFormFactory.sys.mjs\\\",\\n  CreditCard: \\\"resource://gre/modules/CreditCard.sys.mjs\\\",\\n  FieldDetail: \\\"resource://gre/modules/shared/FieldScanner.sys.mjs\\\",\\n  FormAutofillHeuristics:\\n    \\\"resource://gre/modules/shared/FormAutofillHeuristics.sys.mjs\\\",\\n  FormAutofillNameUtils:\\n    \\\"resource://gre/modules/shared/FormAutofillNameUtils.sys.mjs\\\",\\n  LabelUtils: \\\"resource://gre/modules/shared/LabelUtils.sys.mjs\\\",\\n});\\n\\nconst { FIELD_STATES } = FormAutofillUtils;\\n\\nexport const FORM_CHANGE_REASON = {\\n  NODES_ADDED: \\\"nodes-added\\\",\\n  NODES_REMOVED: \\\"nodes-removed\\\",\\n  ELEMENT_INVISIBLE: \\\"visible-element-became-invisible\\\",\\n  ELEMENT_VISIBLE: \\\"invisible-element-became-visible\\\",\\n};\\n\\n/**\\n * Handles profile autofill for a DOM Form element.\\n */\\nexport class FormAutofillHandler {\\n  // The window to which this form belongs\\n  window = null;\\n\\n  // DOM Form element to which this object is attached\\n  form = null;\\n\\n  // Keeps track of filled state for all identified elements\\n  #filledStateByElement = new WeakMap();\\n\\n  // An object that caches the current selected option, keyed by element.\\n  #matchingSelectOption = null;\\n\\n  /**\\n   * Array of collected data about relevant form fields.  Each item is an object\\n   * storing the identifying details of the field and a reference to the\\n   * originally associated element from the form.\\n   *\\n   * The \\\"section\\\", \\\"addressType\\\", \\\"contactType\\\", and \\\"fieldName\\\" values are\\n   * used to identify the exact field when the serializable data is received\\n   * from the backend.  There cannot be multiple fields which have\\n   * the same exact combination of these values.\\n   *\\n   * A direct reference to the associated element cannot be sent to the user\\n   * interface because processing may be done in the parent process.\\n   */\\n  #fieldDetails = null;\\n\\n  /**\\n   * Flags if the MutationObserver (this.#formMutationObserver) that is observing\\n   * node additions/removals for the root element has been set up\\n   */\\n  #isObservingFormMutations = false;\\n\\n  #formMutationObserver = null;\\n\\n  #visibilityStateObserverByElement = new WeakMap();\\n\\n  /**\\n   *\\n   * fillOnFormChangeData.isWithinDynamicFormChangeThreshold:\\n   *              Flags if a \\\"form-change\\\" event is received within the timeout threshold\\n   *              (see lazy.FormAutofill.fillOnDynamicFormChangeTimeout), that we set\\n   *              in order to consider newly detected fields for filling.\\n   * fillOnFormChangeData.previouslyUsedProfile\\n   *              The previously used profile from the latest autocompletion.\\n   * fillOnFormChangeData.previouslyFocusedId\\n   *              The previously focused element id from the latest autocompletion\\n   *\\n   * This is used for any following form changes and is cleared after a time threshold\\n   * set by lazy.FormAutofill.fillOnDynamicFormChangeTimeout.\\n   */\\n  #fillOnFormChangeData = new Map();\\n\\n  /**\\n   * Flag to indicate whethere there is an ongoing autofilling/clearing process.\\n   */\\n  #isAutofillInProgress = false;\\n\\n  /**\\n   * Initialize the form from `FormLike` object to handle the section or form\\n   * operations.\\n   *\\n   * @param {FormLike} form Form that need to be auto filled\\n   * @param {Function} onFilledModifiedCallback Function that can be invoked\\n   *                   when we want to suggest autofill on a form.\\n   */\\n  constructor(form, onFilledModifiedCallback = () => {}) {\\n    this._updateForm(form);\\n\\n    this.window = this.form.rootElement.ownerGlobal;\\n\\n    this.onFilledModifiedCallback = onFilledModifiedCallback;\\n\\n    // The identifier generated via ContentDOMReference for the root element.\\n    this.rootElementId = FormAutofillUtils.getElementIdentifier(\\n      form.rootElement\\n    );\\n\\n    ChromeUtils.defineLazyGetter(this, \\\"log\\\", () =>\\n      FormAutofill.defineLogGetter(this, \\\"FormAutofillHandler\\\")\\n    );\\n  }\\n\\n  get fillOnFormChangeData() {\\n    return this.#fillOnFormChangeData;\\n  }\\n\\n  clearFillOnFormChangeData() {\\n    this.#fillOnFormChangeData = new Map();\\n    this.#fillOnFormChangeData.isWithinDynamicFormChangeThreshold = false;\\n  }\\n\\n  /**\\n   * Retrieves the 'fieldDetails' property, ensuring it has been initialized by\\n   * `setIdentifiedFieldDetails`. Throws an error if accessed before initialization.\\n   *\\n   * This is because 'fieldDetail'' contains information that need to be computed\\n   * in the parent side first.\\n   *\\n   * @throws {Error} If `setIdentifiedFieldDetails` has not been called.\\n   * @returns {Array<FieldDetail>}\\n   *          The list of autofillable field details for this form.\\n   */\\n  get fieldDetails() {\\n    if (!this.#fieldDetails) {\\n      throw new Error(\\n        `Should only use 'fieldDetails' after 'setIdentifiedFieldDetails' is called`\\n      );\\n    }\\n    return this.#fieldDetails;\\n  }\\n\\n  /**\\n   * Sets the list of 'FieldDetail' objects for autofillable fields within the form.\\n   *\\n   * @param {Array<FieldDetail>} fieldDetails\\n   *        An array of field details that has been computed on the parent side.\\n   *        This method should be called before accessing `fieldDetails`.\\n   */\\n  setIdentifiedFieldDetails(fieldDetails) {\\n    this.#fieldDetails = fieldDetails;\\n  }\\n\\n  /**\\n   * Determines whether 'setIdentifiedFieldDetails' has been called and the\\n   * `fieldDetails` have been initialized.\\n   *\\n   * @returns {boolean}\\n   *          True if 'fieldDetails' has been initialized; otherwise, False.\\n   */\\n  hasIdentifiedFields() {\\n    return !!this.#fieldDetails;\\n  }\\n\\n  get isAutofillInProgress() {\\n    return this.#isAutofillInProgress;\\n  }\\n\\n  handleEvent(event) {\\n    switch (event.type) {\\n      case \\\"input\\\": {\\n        if (!event.isTrusted || this.isAutofillInProgress) {\\n          return;\\n        }\\n\\n        // This uses the #filledStateByElement map instead of\\n        // autofillState as the state has already been cleared by the time\\n        // the input event fires.\\n        const fieldDetail = this.getFieldDetailByElement(event.target);\\n        const previousState = this.getFilledStateByElement(event.target);\\n        const newState = FIELD_STATES.NORMAL;\\n\\n        if (previousState != newState) {\\n          this.changeFieldState(fieldDetail, newState);\\n        }\\n\\n        this.onFilledModifiedCallback?.(fieldDetail, previousState, newState);\\n      }\\n    }\\n  }\\n\\n  getFieldDetailByName(fieldName) {\\n    return this.fieldDetails.find(detail => detail.fieldName == fieldName);\\n  }\\n\\n  getFieldDetailByElement(element) {\\n    return this.fieldDetails.find(detail => detail.element == element);\\n  }\\n\\n  getFieldDetailByElementId(elementId) {\\n    return this.fieldDetails.find(detail => detail.elementId == elementId);\\n  }\\n\\n  /**\\n   * Only use this API within handleEvent\\n   */\\n  getFilledStateByElement(element) {\\n    return this.#filledStateByElement.get(element);\\n  }\\n\\n  isVisiblityStateObserverSetUpByElement(element) {\\n    return this.#visibilityStateObserverByElement.has(element);\\n  }\\n\\n  setVisibilityStateObserverByElement(element, observer) {\\n    this.#visibilityStateObserverByElement.set(element, observer);\\n  }\\n\\n  clearVisibilityStateObserverByElement(element) {\\n    if (this.isVisiblityStateObserverSetUpByElement(element)) {\\n      const observer = this.#visibilityStateObserverByElement.get(element);\\n      observer.disconnect();\\n      this.#visibilityStateObserverByElement.delete(element);\\n    }\\n  }\\n\\n  /**\\n   * Check the form is necessary to be updated. This function should be able to\\n   * detect any changes including all control elements in the form.\\n   *\\n   * @param {HTMLElement} element The element supposed to be in the form.\\n   * @returns {boolean} FormAutofillHandler.form is updated or not.\\n   */\\n  updateFormIfNeeded(element) {\\n    // When the following condition happens, FormAutofillHandler.form should be\\n    // updated:\\n    // * The count of form controls is changed.\\n    // * When the element can not be found in the current form.\\n    //\\n    // However, we should improve the function to detect the element changes.\\n    // e.g. a tel field is changed from type=\\\"hidden\\\" to type=\\\"tel\\\".\\n\\n    let _formLike;\\n    const getFormLike = () => {\\n      if (!_formLike) {\\n        _formLike = lazy.AutofillFormFactory.createFromField(element);\\n      }\\n      return _formLike;\\n    };\\n\\n    const currentForm = getFormLike();\\n    if (currentForm.elements.length != this.form.elements.length) {\\n      this.log.debug(\\\"The count of form elements is changed.\\\");\\n      this._updateForm(getFormLike());\\n      return true;\\n    }\\n\\n    if (!this.form.elements.includes(element)) {\\n      this.log.debug(\\\"The element can not be found in the current form.\\\");\\n      this._updateForm(getFormLike());\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  /**\\n   * Update the form with a new FormLike, and the related fields should be\\n   * updated or clear to ensure the data consistency.\\n   *\\n   * @param {FormLike} form a new FormLike to replace the original one.\\n   */\\n  _updateForm(form) {\\n    this.form = form;\\n\\n    this.#fieldDetails = null;\\n  }\\n\\n  /**\\n   * Collect <input>, <select>, and <iframe> elements from the specified form\\n   * and return the correspond 'FieldDetail' objects.\\n   *\\n   * @param {formLike} formLike\\n   *        The form that we collect information from.\\n   * @param {boolean} includeIframe\\n   *        True to add <iframe> to the returned FieldDetails array.\\n   * @param {boolean} ignoreInvisibleInput\\n   *        True to NOT run heuristics on invisible <input> fields.\\n   *\\n   * @returns {Array<FieldDeail>}\\n   *        An array containing eligible fields for autofill, also\\n   *        including iframe.\\n   */\\n  static collectFormFieldDetails(\\n    formLike,\\n    includeIframe,\\n    ignoreInvisibleInput = true\\n  ) {\\n    const fieldDetails =\\n      lazy.FormAutofillHeuristics.getFormInfo(formLike, ignoreInvisibleInput) ??\\n      [];\\n\\n    // 'FormLike' only contains <input> & <select>, so in order to include <iframe>\\n    // in the list of 'FieldDetails', we need to search for <iframe> in the form.\\n    if (!includeIframe) {\\n      return fieldDetails;\\n    }\\n\\n    // Insert <iframe> elements into the fieldDetails array, maintaining the element order.\\n    const elements = formLike.rootElement.querySelectorAll(\\\"iframe\\\");\\n\\n    let startIndex = 0;\\n\\n    // eslint-disable-next-line no-labels\\n    outer: for (const element of elements) {\\n      if (FormAutofillUtils.isFieldVisible(element)) {\\n        const iframeFd = lazy.FieldDetail.create(element, formLike, \\\"iframe\\\");\\n\\n        for (let index = startIndex; index < fieldDetails.length; index++) {\\n          let position = element.compareDocumentPosition(\\n            fieldDetails[index]?.element\\n          );\\n          if (\\n            position &\\n            (Node.DOCUMENT_POSITION_FOLLOWING |\\n              Node.DOCUMENT_POSITION_CONTAINED_BY)\\n          ) {\\n            fieldDetails.splice(index, 0, iframeFd);\\n            startIndex = index; // start from this index for later iframes\\n            // eslint-disable-next-line no-labels\\n            continue outer;\\n          }\\n        }\\n\\n        fieldDetails.push(iframeFd);\\n      }\\n    }\\n\\n    return fieldDetails;\\n  }\\n\\n  /**\\n   * Resetting the state element's fieldDetail after it was removed from the form\\n   * Todo: We'll need to update this.filledResult in FormAutofillParent (Bug 1948077).\\n   *\\n   * @param {HTMLElement} element that was removed\\n   */\\n  resetFieldStateWhenRemoved(element) {\\n    if (this.getFilledStateByElement(element) != FIELD_STATES.AUTO_FILLED) {\\n      return;\\n    }\\n    const fieldDetail = this.getFieldDetailByElement(element);\\n    this.#filledStateByElement.delete(fieldDetail);\\n  }\\n\\n  /**\\n   * Change the state of a field to correspond with different presentations.\\n   *\\n   * @param {object} fieldDetail\\n   *        A fieldDetail of which its element is about to update the state.\\n   * @param {string} state\\n   *        The state to apply.\\n   */\\n  changeFieldState(fieldDetail, state) {\\n    const element = fieldDetail.element;\\n    if (!element) {\\n      this.log.warn(\\n        fieldDetail.fieldName,\\n        \\\"is unreachable while changing state\\\"\\n      );\\n      return;\\n    }\\n\\n    if (!Object.values(FIELD_STATES).includes(state)) {\\n      this.log.warn(\\n        fieldDetail.fieldName,\\n        \\\"is trying to change to an invalid state\\\"\\n      );\\n      return;\\n    }\\n\\n    element.autofillState = state;\\n    this.#filledStateByElement.set(element, state);\\n\\n    if (state == FIELD_STATES.AUTO_FILLED) {\\n      element.addEventListener(\\\"input\\\", this, { mozSystemGroup: true });\\n    }\\n  }\\n\\n  /**\\n   * Populates result to the preview layers with given profile.\\n   *\\n   * @param {Array} elementIds\\n   * @param {object} profile\\n   *        A profile to be previewed with\\n   */\\n  previewFields(elementIds, profile) {\\n    this.getAdaptedProfiles([profile]);\\n\\n    for (const fieldDetail of this.fieldDetails) {\\n      const element = fieldDetail.element;\\n\\n      // Skip the field if it is null or readonly or disabled\\n      if (\\n        !elementIds.includes(fieldDetail.elementId) ||\\n        !FormAutofillUtils.isFieldAutofillable(element)\\n      ) {\\n        continue;\\n      }\\n\\n      let value = this.getFilledValueFromProfile(fieldDetail, profile);\\n      if (!value) {\\n        this.changeFieldState(fieldDetail, FIELD_STATES.NORMAL);\\n        continue;\\n      }\\n\\n      if (FormAutofillUtils.isTextControl(element)) {\\n        if (element.value && element.value != element.defaultValue) {\\n          // Skip the field if the user has already entered text and that text\\n          // is not the site prefilled value.\\n          continue;\\n        }\\n      } else if (HTMLSelectElement.isInstance(element)) {\\n        // Unlike text input, select element is always previewed even if\\n        // the option is already selected.\\n        const option = this.matchSelectOptions(fieldDetail, profile);\\n        value = option?.text ?? \\\"\\\";\\n      } else {\\n        continue;\\n      }\\n\\n      element.previewValue = value?.toString().replaceAll(\\\"*\\\", \\\"•\\\");\\n      this.changeFieldState(fieldDetail, FIELD_STATES.PREVIEW);\\n    }\\n  }\\n\\n  /**\\n   * Processes form fields that can be autofilled, and populates them with the\\n   * profile provided by backend.\\n   *\\n   * @param {string} focusedId\\n   *        The id of the element that triggers autofilling.\\n   * @param {Array} elementIds\\n   *        An array of IDs for the elements that should be autofilled.\\n   * @param {object} profile\\n   *        The data profile containing the values to be autofilled into the form fields.\\n   */\\n  fillFields(focusedId, elementIds, profile) {\\n    this.#isAutofillInProgress = true;\\n    this.getAdaptedProfiles([profile]);\\n\\n    for (const fieldDetail of this.fieldDetails) {\\n      const { element, elementId } = fieldDetail;\\n\\n      if (\\n        !elementIds.includes(elementId) ||\\n        !FormAutofillUtils.isFieldAutofillable(element)\\n      ) {\\n        continue;\\n      }\\n\\n      element.previewValue = \\\"\\\";\\n\\n      if (FormAutofillUtils.isTextControl(element)) {\\n        // Bug 1687679: Since profile appears to be presentation ready data, we need to utilize the \\\"x-formatted\\\" field\\n        // that is generated when presentation ready data doesn't fit into the autofilling element.\\n        // For example, autofilling expiration month into an input element will not work as expected if\\n        // the month is less than 10, since the input is expected a zero-padded string.\\n        // See Bug 1722941 for follow up.\\n        const value = this.getFilledValueFromProfile(fieldDetail, profile);\\n        if (!value) {\\n          continue;\\n        }\\n\\n        // For the focused input element, it will be filled with a valid value\\n        // anyway.\\n        // For the others, the fields should be only filled when their values are empty\\n        // or their values are equal to the site prefill value\\n        // or are the result of an earlier auto-fill.\\n        if (\\n          elementId == focusedId ||\\n          !element.value ||\\n          element.value == element.defaultValue ||\\n          element.autofillState == FIELD_STATES.AUTO_FILLED\\n        ) {\\n          FormAutofillHandler.fillFieldValue(element, value);\\n          this.changeFieldState(fieldDetail, FIELD_STATES.AUTO_FILLED);\\n        }\\n      } else if (HTMLSelectElement.isInstance(element)) {\\n        const option = this.matchSelectOptions(fieldDetail, profile);\\n        if (!option) {\\n          continue;\\n        }\\n\\n        // Do not change value or dispatch events if the option is already selected.\\n        // Use case for multiple select is not considered here.\\n        if (!option.selected) {\\n          option.selected = true;\\n          FormAutofillHandler.fillFieldValue(element, option.value);\\n        }\\n        // Autofill highlight appears regardless if value is changed or not\\n        this.changeFieldState(fieldDetail, FIELD_STATES.AUTO_FILLED);\\n      } else {\\n        continue;\\n      }\\n    }\\n\\n    this.focusPreviouslyFocusedElement(focusedId);\\n    this.#isAutofillInProgress = false;\\n\\n    this.registerFormChangeHandler();\\n  }\\n\\n  registerFormChangeHandler() {\\n    if (this.onChangeHandler) {\\n      return;\\n    }\\n\\n    this.log.debug(\\\"register change handler for filled form:\\\", this.form);\\n\\n    this.onChangeHandler = e => {\\n      if (!e.isTrusted) {\\n        return;\\n      }\\n      if (e.type == \\\"reset\\\") {\\n        for (const fieldDetail of this.fieldDetails) {\\n          const element = fieldDetail.element;\\n          element.removeEventListener(\\\"input\\\", this, { mozSystemGroup: true });\\n          this.changeFieldState(fieldDetail, FIELD_STATES.NORMAL);\\n        }\\n      }\\n\\n      // Unregister listeners once no field is in AUTO_FILLED state.\\n      if (\\n        this.fieldDetails.every(\\n          detail => detail.element.autofillState != FIELD_STATES.AUTO_FILLED\\n        )\\n      ) {\\n        this.form.rootElement.removeEventListener(\\n          \\\"input\\\",\\n          this.onChangeHandler,\\n          {\\n            mozSystemGroup: true,\\n          }\\n        );\\n        this.form.rootElement.removeEventListener(\\n          \\\"reset\\\",\\n          this.onChangeHandler,\\n          {\\n            mozSystemGroup: true,\\n          }\\n        );\\n        this.onChangeHandler = null;\\n      }\\n    };\\n\\n    // Handle the highlight style resetting caused by user's correction afterward.\\n    this.form.rootElement.addEventListener(\\\"input\\\", this.onChangeHandler, {\\n      mozSystemGroup: true,\\n    });\\n    this.form.rootElement.addEventListener(\\\"reset\\\", this.onChangeHandler, {\\n      mozSystemGroup: true,\\n    });\\n  }\\n\\n  /**\\n   * Listens for dynamic form changes by setting up two observer types:\\n   *      1. IntersectionObserver(s) that observe(s) intersections between\\n   *         (in-)visibile elements and an intersection target (the form/document of interest).\\n   *         (see this.setUpElementVisibilityObserver)\\n   *      2. MutationsObserver that observes child node additions and removals\\n   *         in the form/document of interest (see this.setUpNodesObserver)\\n   * If a form change is observed, a \\\"form-changed\\\" event gets dispatched transfering\\n   * the changed fields and the reason for the form change (see FORM_CHANGE_REASON).\\n   */\\n  setUpDynamicFormChangeObserver() {\\n    if (!FormAutofill.detectDynamicFormChanges) {\\n      return;\\n    }\\n\\n    this.setUpElementVisibilityObserver();\\n    this.setUpFormNodesMutationObserver();\\n  }\\n\\n  /**\\n   * Iterates through handler.form.elements and sets up an IntersectionObserver for each (in-)visible\\n   * address/cc input element that is not observed yet (see handler.#visibilityStateObserverByElement).\\n   * The observer notifies of intersections between the (in-)visible element and the intersection target (handler.form).\\n   * This is the case if e.g. a visible element becomes invisible or an invisible element becomes visible.\\n   * If a visibility state change is observed, a \\\"form-changes\\\" event is dispatched.\\n   */\\n  setUpElementVisibilityObserver() {\\n    const VISIBILITY_STATE = {\\n      VISIBLE: true,\\n      INVISIBLE: false,\\n    };\\n\\n    // Setting up an observer for an element's changing visibility state\\n    const setUpIntersectionObserver = (element, visibilityState) => {\\n      const visibilityStateObserver = new this.window.IntersectionObserver(\\n        (entries, observer) => {\\n          entries.forEach(entry => {\\n            if (entry.isIntersecting != visibilityState) {\\n              return;\\n            }\\n            if (\\n              entry.target.checkVisibility({\\n                checkOpacity: true,\\n                checkVisibilityCSS: true,\\n              }) != visibilityState\\n            ) {\\n              // The observer notified that the element reached the intersection threshold\\n              // (meaning the element's visibility state changed to either visible or invisible.\\n              // But checkVisibility doesn't confirm that.\\n              // For these mismatches we disconnect the observer to avoid an infinite loop.\\n              observer.disconnect();\\n              return;\\n            }\\n            const changes = {};\\n            const reason =\\n              visibilityState == VISIBILITY_STATE.VISIBLE\\n                ? FORM_CHANGE_REASON.ELEMENT_VISIBLE\\n                : FORM_CHANGE_REASON.ELEMENT_INVISIBLE;\\n            changes[reason] = [entry.target];\\n\\n            const formChangedEvent = new CustomEvent(\\\"form-changed\\\", {\\n              detail: {\\n                form: this.form.rootElement,\\n                changes,\\n              },\\n              bubbles: true,\\n            });\\n            this.form.ownerDocument.dispatchEvent(formChangedEvent);\\n\\n            this.clearVisibilityStateObserverByElement(element);\\n            observer.disconnect();\\n          });\\n        },\\n        {\\n          root: this.form.rootElement,\\n          // intersection reatio between 0.0 (invisible element) and 1.0 (visible element)\\n          threshold: visibilityState === VISIBILITY_STATE.INVISIBLE ? 0 : 1,\\n        }\\n      );\\n      visibilityStateObserver.observe(element);\\n      this.setVisibilityStateObserverByElement(\\n        element,\\n        visibilityStateObserver\\n      );\\n    };\\n\\n    for (let element of this.form.elements) {\\n      if (!FormAutofillUtils.isCreditCardOrAddressFieldType(element)) {\\n        continue;\\n      }\\n      if (this.isVisiblityStateObserverSetUpByElement(element)) {\\n        continue;\\n      }\\n      if (FormAutofillUtils.isFieldVisible(element)) {\\n        // Setting up an observer that notifies when the visible element becomes invisible\\n        setUpIntersectionObserver(element, VISIBILITY_STATE.INVISIBLE);\\n      } else {\\n        // Setting up an observer that notifies when the invisible element becomes visible\\n        setUpIntersectionObserver(element, VISIBILITY_STATE.VISIBLE);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Sets up a MutationObserver for the form or document (if form-less) of interest\\n   * in order to be notified about child nodes additions or removals.\\n   * If any of the added/removed nodes (including the nodes in the node's subtree)\\n   * are of an address of cc type, a \\\"form-changed\\\" event is dispatched.\\n   */\\n  setUpFormNodesMutationObserver() {\\n    if (this.#isObservingFormMutations) {\\n      return;\\n    }\\n\\n    const mutationObserver = new this.window.MutationObserver(\\n      (mutations, _) => {\\n        const collectMutatedNodes = mutations => {\\n          let removedNodes = [];\\n          let addedNodes = [];\\n          mutations.forEach(mutation => {\\n            if (mutation.type == \\\"childList\\\") {\\n              if (mutation.addedNodes.length) {\\n                addedNodes.push(...mutation.addedNodes);\\n              } else if (mutation.removedNodes.length) {\\n                removedNodes.push(...mutation.removedNodes);\\n              }\\n            }\\n          });\\n          return [addedNodes, removedNodes];\\n        };\\n\\n        const collectAllSubtreeElements = node => {\\n          if (!node.childNodes.length) {\\n            return node;\\n          }\\n          return Array.from(node.childNodes).flatMap(childNode =>\\n            collectAllSubtreeElements(childNode)\\n          );\\n        };\\n\\n        const getCCAndAddressElements = nodes => {\\n          return nodes\\n            .flatMap(node => collectAllSubtreeElements(node))\\n            .filter(element =>\\n              FormAutofillUtils.isCreditCardOrAddressFieldType(element)\\n            );\\n        };\\n\\n        let [addedNodes, removedNodes] = collectMutatedNodes(mutations);\\n        let relevantAddedElements = getCCAndAddressElements(addedNodes);\\n        // We only care about removed elements that might change the\\n        // currently detected fieldDetails\\n        let relevantRemovedElements = getCCAndAddressElements(\\n          removedNodes\\n        ).filter(\\n          element =>\\n            this.#fieldDetails && !!this.getFieldDetailByElement(element)\\n        );\\n\\n        if (!relevantRemovedElements.length && !relevantAddedElements.length) {\\n          return;\\n        }\\n\\n        let changes = {};\\n        if (relevantRemovedElements.length) {\\n          changes[FORM_CHANGE_REASON.NODES_REMOVED] = relevantRemovedElements;\\n        }\\n        if (relevantAddedElements.length) {\\n          changes[FORM_CHANGE_REASON.NODES_ADDED] = relevantAddedElements;\\n        }\\n\\n        const formChangedEvent = new CustomEvent(\\\"form-changed\\\", {\\n          detail: {\\n            form: this.form.rootElement,\\n            changes,\\n          },\\n          bubbles: true,\\n        });\\n        this.form.ownerDocument.dispatchEvent(formChangedEvent);\\n      }\\n    );\\n    const config = { childList: true, subtree: true };\\n    this.#formMutationObserver = mutationObserver;\\n    this.#formMutationObserver.observe(this.form.rootElement, config);\\n    this.#isObservingFormMutations = true;\\n  }\\n\\n  /**\\n   * After the form was submitted, disconnect all IntersectionObserver that\\n   * are still observing form's elements and disconnect the MutationsOberver\\n   * that is observing the form.\\n   */\\n  clearFormChangeObservers() {\\n    if (!this.#isObservingFormMutations) {\\n      return;\\n    }\\n    // Disconnect intersection observers\\n    for (let element of this.form.elements) {\\n      this.clearVisibilityStateObserverByElement(element);\\n    }\\n    // Disconnect mutation observer\\n    this.#formMutationObserver.disconnect();\\n    this.#isObservingFormMutations = false;\\n  }\\n\\n  computeFillingValue(fieldDetail) {\\n    const element = fieldDetail.element;\\n    if (!element) {\\n      return null;\\n    }\\n\\n    let value = element.value.trim();\\n    switch (fieldDetail.fieldName) {\\n      case \\\"address-level1\\\":\\n        if (HTMLSelectElement.isInstance(element)) {\\n          // Don't save the record when the option value is empty *OR* there\\n          // are multiple options being selected. The empty option is usually\\n          // assumed to be default along with a meaningless text to users.\\n          if (!value || element.selectedOptions.length != 1) {\\n            // Keep the property and preserve more information for address updating\\n            value = \\\"\\\";\\n          } else {\\n            const text = element.selectedOptions[0].text.trim();\\n            value =\\n              FormAutofillUtils.getAbbreviatedSubregionName([value, text]) ||\\n              text;\\n          }\\n        }\\n        break;\\n      case \\\"country\\\":\\n        // This is a temporary fix. Ideally we should have either case-insensitive comparison of country codes\\n        // or handle this elsewhere see Bug 1889234 for more context.\\n        value = value.toUpperCase();\\n        break;\\n      case \\\"cc-type\\\":\\n        if (\\n          HTMLSelectElement.isInstance(element) &&\\n          !lazy.CreditCard.isValidNetwork(value)\\n        ) {\\n          // Don't save the record when the option value is empty *OR* there\\n          // are multiple options being selected. The empty option is usually\\n          // assumed to be default along with a meaningless text to users.\\n          if (value && element.selectedOptions.length == 1) {\\n            const selectedOption = element.selectedOptions[0];\\n            const networkType =\\n              lazy.CreditCard.getNetworkFromName(selectedOption.text) ??\\n              lazy.CreditCard.getNetworkFromName(selectedOption.value);\\n            if (networkType) {\\n              value = networkType;\\n            }\\n          }\\n        }\\n        break;\\n    }\\n\\n    return value;\\n  }\\n\\n  /*\\n   * Apply both address and credit card related transformers.\\n   *\\n   * @param {Object} profile\\n   *        A profile for adjusting credit card related value.\\n   * @override\\n   */\\n  applyTransformers(profile) {\\n    this.addressTransformer(profile);\\n    this.telTransformer(profile);\\n    this.creditCardExpiryDateTransformer(profile);\\n    this.creditCardExpMonthAndYearTransformer(profile);\\n    this.creditCardNameTransformer(profile);\\n    this.adaptFieldMaxLength(profile);\\n  }\\n\\n  getAdaptedProfiles(originalProfiles) {\\n    for (let profile of originalProfiles) {\\n      this.applyTransformers(profile);\\n    }\\n    return originalProfiles;\\n  }\\n\\n  /**\\n   * Match the select option for a field if we autofill with the given profile.\\n   * This function caches the matching result in the `#matchingSelectionOption`\\n   * variable.\\n   *\\n   * @param {FieldDetail} fieldDetail\\n   *        The field information of the matching element.\\n   * @param {object} profile\\n   *        The profile used for autofill.\\n   *\\n   * @returns {Option}\\n   *        The matched option, or undefined if no matching option is found.\\n   */\\n  matchSelectOptions(fieldDetail, profile) {\\n    if (!this.#matchingSelectOption) {\\n      this.#matchingSelectOption = new WeakMap();\\n    }\\n\\n    const { element, fieldName } = fieldDetail;\\n    if (!HTMLSelectElement.isInstance(element)) {\\n      return undefined;\\n    }\\n\\n    const cache = this.#matchingSelectOption.get(element) || {};\\n    const value = profile[fieldName];\\n\\n    let option = cache[value]?.deref();\\n    if (!option) {\\n      option = FormAutofillUtils.findSelectOption(element, profile, fieldName);\\n\\n      if (option) {\\n        cache[value] = new WeakRef(option);\\n        this.#matchingSelectOption.set(element, cache);\\n      } else if (cache[value]) {\\n        delete cache[value];\\n        this.#matchingSelectOption.set(element, cache);\\n      }\\n    }\\n\\n    return option;\\n  }\\n\\n  adaptFieldMaxLength(profile) {\\n    for (let key in profile) {\\n      let detail = this.getFieldDetailByName(key);\\n      if (!detail || detail.part) {\\n        continue;\\n      }\\n\\n      let element = detail.element;\\n      if (!element) {\\n        continue;\\n      }\\n\\n      let maxLength = element.maxLength;\\n      if (\\n        maxLength === undefined ||\\n        maxLength < 0 ||\\n        profile[key].toString().length <= maxLength\\n      ) {\\n        continue;\\n      }\\n\\n      if (maxLength) {\\n        switch (typeof profile[key]) {\\n          case \\\"string\\\":\\n            // If this is an expiration field and our previous\\n            // adaptations haven't resulted in a string that is\\n            // short enough to satisfy the field length, and the\\n            // field is constrained to a length of 4 or 5, then we\\n            // assume it is intended to hold an expiration of the\\n            // form \\\"MMYY\\\" or \\\"MM/YY\\\".\\n            if (key == \\\"cc-exp\\\" && (maxLength == 4 || maxLength == 5)) {\\n              const month2Digits = (\\n                \\\"0\\\" + profile[\\\"cc-exp-month\\\"].toString()\\n              ).slice(-2);\\n              const year2Digits = profile[\\\"cc-exp-year\\\"].toString().slice(-2);\\n              const separator = maxLength == 5 ? \\\"/\\\" : \\\"\\\";\\n              profile[key] = `${month2Digits}${separator}${year2Digits}`;\\n            } else if (key == \\\"cc-number\\\") {\\n              // We want to show the last four digits of credit card so that\\n              // the masked credit card previews correctly and appears correctly\\n              // in the autocomplete menu\\n              profile[key] = profile[key].substr(\\n                profile[key].length - maxLength\\n              );\\n            } else {\\n              profile[key] = profile[key].substr(0, maxLength);\\n            }\\n            break;\\n          case \\\"number\\\":\\n            // There's no way to truncate a number smaller than a\\n            // single digit.\\n            if (maxLength < 1) {\\n              maxLength = 1;\\n            }\\n            // The only numbers we store are expiration month/year,\\n            // and if they truncate, we want the final digits, not\\n            // the initial ones.\\n            profile[key] = profile[key] % Math.pow(10, maxLength);\\n            break;\\n          default:\\n        }\\n      } else {\\n        delete profile[key];\\n        delete profile[`${key}-formatted`];\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Handles credit card expiry date transformation when\\n   * the expiry date exists in a cc-exp field.\\n   *\\n   * @param {object} profile\\n   */\\n  creditCardExpiryDateTransformer(profile) {\\n    if (!profile[\\\"cc-exp\\\"]) {\\n      return;\\n    }\\n\\n    const element = this.getFieldDetailByName(\\\"cc-exp\\\")?.element;\\n    if (!element) {\\n      return;\\n    }\\n\\n    function updateExpiry(_string, _month, _year) {\\n      // Bug 1687681: This is a short term fix to other locales having\\n      // different characters to represent year.\\n      // - FR locales may use \\\"A\\\" to represent year.\\n      // - DE locales may use \\\"J\\\" to represent year.\\n      // - PL locales may use \\\"R\\\" to represent year.\\n      // This approach will not scale well and should be investigated in a follow up bug.\\n      const monthChars = \\\"m\\\";\\n      const yearChars = \\\"yy|aa|jj|rr\\\";\\n      const expiryDateFormatRegex = (firstChars, secondChars) =>\\n        new RegExp(\\n          \\\"(?:\\\\\\\\b|^)((?:[\\\" +\\n            firstChars +\\n            \\\"]{2}){1,2})\\\\\\\\s*([\\\\\\\\-/])\\\\\\\\s*((?:[\\\" +\\n            secondChars +\\n            \\\"]{2}){1,2})(?:\\\\\\\\b|$)\\\",\\n          \\\"i\\\"\\n        );\\n\\n      // If the month first check finds a result, where placeholder is \\\"mm - yyyy\\\",\\n      // the result will be structured as such: [\\\"mm - yyyy\\\", \\\"mm\\\", \\\"-\\\", \\\"yyyy\\\"]\\n      let result = expiryDateFormatRegex(monthChars, yearChars).exec(_string);\\n      if (result) {\\n        return (\\n          _month.padStart(result[1].length, \\\"0\\\") +\\n          result[2] +\\n          _year.substr(-1 * result[3].length)\\n        );\\n      }\\n\\n      // If the year first check finds a result, where placeholder is \\\"yyyy mm\\\",\\n      // the result will be structured as such: [\\\"yyyy mm\\\", \\\"yyyy\\\", \\\" \\\", \\\"mm\\\"]\\n      result = expiryDateFormatRegex(yearChars, monthChars).exec(_string);\\n      if (result) {\\n        return (\\n          _year.substr(-1 * result[1].length) +\\n          result[2] +\\n          _month.padStart(result[3].length, \\\"0\\\")\\n        );\\n      }\\n      return null;\\n    }\\n\\n    let newExpiryString = null;\\n    const month = profile[\\\"cc-exp-month\\\"].toString();\\n    const year = profile[\\\"cc-exp-year\\\"].toString();\\n    if (element.localName == \\\"input\\\") {\\n      // Use the placeholder or label to determine the expiry string format.\\n      const possibleExpiryStrings = [];\\n      if (element.placeholder) {\\n        possibleExpiryStrings.push(element.placeholder);\\n      }\\n      const labels = lazy.LabelUtils.findLabelElements(element);\\n      if (labels) {\\n        // Not consider multiple lable for now.\\n        possibleExpiryStrings.push(element.labels[0]?.textContent);\\n      }\\n      if (element.previousElementSibling?.localName == \\\"label\\\") {\\n        possibleExpiryStrings.push(element.previousElementSibling.textContent);\\n      }\\n\\n      possibleExpiryStrings.some(string => {\\n        newExpiryString = updateExpiry(string, month, year);\\n        return !!newExpiryString;\\n      });\\n    }\\n\\n    // Bug 1688576: Change YYYY-MM to MM/YYYY since MM/YYYY is the\\n    // preferred presentation format for credit card expiry dates.\\n    profile[\\\"cc-exp\\\"] = newExpiryString ?? `${month.padStart(2, \\\"0\\\")}/${year}`;\\n  }\\n\\n  /**\\n   * Handles credit card expiry date transformation when the expiry date exists in\\n   * the separate cc-exp-month and cc-exp-year fields\\n   *\\n   * @param {object} profile\\n   */\\n  creditCardExpMonthAndYearTransformer(profile) {\\n    const getInputElementByField = (field, self) => {\\n      if (!field) {\\n        return null;\\n      }\\n      const detail = self.getFieldDetailByName(field);\\n      if (!detail) {\\n        return null;\\n      }\\n      const element = detail.element;\\n      return element.localName === \\\"input\\\" ? element : null;\\n    };\\n    const month = getInputElementByField(\\\"cc-exp-month\\\", this);\\n    if (month) {\\n      // Transform the expiry month to MM since this is a common format needed for filling.\\n      profile[\\\"cc-exp-month-formatted\\\"] = profile[\\\"cc-exp-month\\\"]\\n        ?.toString()\\n        .padStart(2, \\\"0\\\");\\n    }\\n    const year = getInputElementByField(\\\"cc-exp-year\\\", this);\\n    // If the expiration year element is an input,\\n    // then we examine any placeholder to see if we should format the expiration year\\n    // as a zero padded string in order to autofill correctly.\\n    if (year) {\\n      const placeholder = year.placeholder;\\n\\n      // Checks for 'YY'|'AA'|'JJ'|'RR' placeholder and converts the year to a two digit string using the last two digits.\\n      const result = /\\\\b(yy|aa|jj|rr)\\\\b/i.test(placeholder);\\n      if (result) {\\n        profile[\\\"cc-exp-year-formatted\\\"] = profile[\\\"cc-exp-year\\\"]\\n          ?.toString()\\n          .substring(2);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Handles credit card name transformation when the name exists in\\n   * the separate cc-given-name, cc-middle-name, and cc-family name fields\\n   *\\n   * @param {object} profile\\n   */\\n  creditCardNameTransformer(profile) {\\n    const name = profile[\\\"cc-name\\\"];\\n    if (!name) {\\n      return;\\n    }\\n\\n    const given = this.getFieldDetailByName(\\\"cc-given-name\\\");\\n    const middle = this.getFieldDetailByName(\\\"cc-middle-name\\\");\\n    const family = this.getFieldDetailByName(\\\"cc-family-name\\\");\\n    if (given || middle || family) {\\n      const nameParts = lazy.FormAutofillNameUtils.splitName(name);\\n      if (given && nameParts.given) {\\n        profile[\\\"cc-given-name\\\"] = nameParts.given;\\n      }\\n      if (middle && nameParts.middle) {\\n        profile[\\\"cc-middle-name\\\"] = nameParts.middle;\\n      }\\n      if (family && nameParts.family) {\\n        profile[\\\"cc-family-name\\\"] = nameParts.family;\\n      }\\n    }\\n  }\\n\\n  addressTransformer(profile) {\\n    if (profile[\\\"street-address\\\"]) {\\n      // \\\"-moz-street-address-one-line\\\" is used by the labels in\\n      // ProfileAutoCompleteResult.\\n      profile[\\\"-moz-street-address-one-line\\\"] =\\n        FormAutofillUtils.toOneLineAddress(profile[\\\"street-address\\\"]);\\n      let streetAddressDetail = this.getFieldDetailByName(\\\"street-address\\\");\\n      if (\\n        streetAddressDetail &&\\n        FormAutofillUtils.isTextControl(streetAddressDetail.element)\\n      ) {\\n        profile[\\\"street-address\\\"] = profile[\\\"-moz-street-address-one-line\\\"];\\n      }\\n\\n      let waitForConcat = [];\\n      for (let f of [\\\"address-line3\\\", \\\"address-line2\\\", \\\"address-line1\\\"]) {\\n        waitForConcat.unshift(profile[f]);\\n        if (this.getFieldDetailByName(f)) {\\n          if (waitForConcat.length > 1) {\\n            profile[f] = FormAutofillUtils.toOneLineAddress(waitForConcat);\\n          }\\n          waitForConcat = [];\\n        }\\n      }\\n    }\\n\\n    // If a house number field exists, split the address up into house number\\n    // and street name.\\n    if (this.getFieldDetailByName(\\\"address-housenumber\\\")) {\\n      let address = lazy.AddressParser.parseStreetAddress(\\n        profile[\\\"street-address\\\"]\\n      );\\n      if (address) {\\n        profile[\\\"address-housenumber\\\"] = address.street_number;\\n        let field = this.getFieldDetailByName(\\\"address-line1\\\")\\n          ? \\\"address-line1\\\"\\n          : \\\"street-address\\\";\\n        profile[field] = address.street_name;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Replace tel with tel-national if tel violates the input element's\\n   * restriction.\\n   *\\n   * @param {object} profile\\n   *        A profile to be converted.\\n   */\\n  telTransformer(profile) {\\n    if (!profile.tel || !profile[\\\"tel-national\\\"]) {\\n      return;\\n    }\\n\\n    let detail = this.getFieldDetailByName(\\\"tel\\\");\\n    if (!detail) {\\n      return;\\n    }\\n\\n    let element = detail.element;\\n    let _pattern;\\n    let testPattern = str => {\\n      if (!_pattern) {\\n        // The pattern has to match the entire value.\\n        _pattern = new RegExp(\\\"^(?:\\\" + element.pattern + \\\")$\\\", \\\"u\\\");\\n      }\\n      return _pattern.test(str);\\n    };\\n    if (element.pattern) {\\n      if (testPattern(profile.tel)) {\\n        return;\\n      }\\n    } else if (element.maxLength) {\\n      if (\\n        detail.reason == \\\"autocomplete\\\" &&\\n        profile.tel.length <= element.maxLength\\n      ) {\\n        return;\\n      }\\n    }\\n\\n    if (detail.reason != \\\"autocomplete\\\") {\\n      // Since we only target people living in US and using en-US websites in\\n      // MVP, it makes more sense to fill `tel-national` instead of `tel`\\n      // if the field is identified by heuristics and no other clues to\\n      // determine which one is better.\\n      // TODO: [Bug 1407545] This should be improved once more countries are\\n      // supported.\\n      profile.tel = profile[\\\"tel-national\\\"];\\n    } else if (element.pattern) {\\n      if (testPattern(profile[\\\"tel-national\\\"])) {\\n        profile.tel = profile[\\\"tel-national\\\"];\\n      }\\n    } else if (element.maxLength) {\\n      if (profile[\\\"tel-national\\\"].length <= element.maxLength) {\\n        profile.tel = profile[\\\"tel-national\\\"];\\n      }\\n    }\\n  }\\n\\n  /**\\n   *\\n   * @param {object} fieldDetail A fieldDetail of the related element.\\n   * @param {object} profile The profile to fill.\\n   * @returns {string} The value to fill for the given field.\\n   */\\n  getFilledValueFromProfile(fieldDetail, profile) {\\n    let value =\\n      profile[`${fieldDetail.fieldName}-formatted`] ||\\n      profile[fieldDetail.fieldName];\\n\\n    if (fieldDetail.fieldName == \\\"cc-number\\\" && fieldDetail.part != null) {\\n      const part = fieldDetail.part;\\n      return value.slice((part - 1) * 4, part * 4);\\n    }\\n    return value;\\n  }\\n  /**\\n   * Fills the provided element with the specified value.\\n   *\\n   * @param {HTMLElement} element - The form field element to be filled.\\n   * @param {string} value - The value to be filled into the form field.\\n   */\\n  static fillFieldValue(element, value) {\\n    if (FormAutofillUtils.focusOnAutofill) {\\n      element.focus({ preventScroll: true });\\n    }\\n    if (FormAutofillUtils.isTextControl(element)) {\\n      element.setUserInput(value);\\n    } else if (HTMLSelectElement.isInstance(element)) {\\n      // Set the value of the select element so that web event handlers can react accordingly\\n      element.value = value;\\n      element.dispatchEvent(\\n        new element.ownerGlobal.Event(\\\"input\\\", { bubbles: true })\\n      );\\n      element.dispatchEvent(\\n        new element.ownerGlobal.Event(\\\"change\\\", { bubbles: true })\\n      );\\n    }\\n  }\\n\\n  clearPreviewedFields(elementIds) {\\n    for (const elementId of elementIds) {\\n      const fieldDetail = this.getFieldDetailByElementId(elementId);\\n      const element = fieldDetail?.element;\\n      if (!element) {\\n        this.log.warn(fieldDetail.fieldName, \\\"is unreachable\\\");\\n        continue;\\n      }\\n\\n      element.previewValue = \\\"\\\";\\n      if (element.autofillState == FIELD_STATES.AUTO_FILLED) {\\n        continue;\\n      }\\n      this.changeFieldState(fieldDetail, FIELD_STATES.NORMAL);\\n    }\\n  }\\n\\n  clearFilledFields(focusedId, elementIds) {\\n    this.#isAutofillInProgress = true;\\n    const fieldDetails = elementIds.map(id =>\\n      this.getFieldDetailByElementId(id)\\n    );\\n    for (const fieldDetail of fieldDetails) {\\n      const element = fieldDetail?.element;\\n      if (!element) {\\n        this.log.warn(fieldDetail?.fieldName, \\\"is unreachable\\\");\\n        continue;\\n      }\\n\\n      if (element.autofillState == FIELD_STATES.AUTO_FILLED) {\\n        let value = \\\"\\\";\\n        if (HTMLSelectElement.isInstance(element)) {\\n          if (!element.options.length) {\\n            continue;\\n          }\\n          // Resets a <select> element to its selected option or the first\\n          // option if there is none selected.\\n          const selected = [...element.options].find(option =>\\n            option.hasAttribute(\\\"selected\\\")\\n          );\\n          value = selected ? selected.value : element.options[0].value;\\n        }\\n        FormAutofillHandler.fillFieldValue(element, value);\\n        this.changeFieldState(fieldDetail, FIELD_STATES.NORMAL);\\n      }\\n    }\\n\\n    this.focusPreviouslyFocusedElement(focusedId);\\n    this.#isAutofillInProgress = false;\\n  }\\n\\n  focusPreviouslyFocusedElement(focusedId) {\\n    let focusedElement = FormAutofillUtils.getElementByIdentifier(focusedId);\\n    if (FormAutofillUtils.focusOnAutofill && focusedElement) {\\n      focusedElement.focus({ preventScroll: true });\\n    }\\n  }\\n\\n  /**\\n   * Return the record that is keyed by element id and value is the normalized value\\n   * done by computeFillingValue\\n   *\\n   * @returns {object} An object keyed by element id, and the value is\\n   *                   an object that includes the following properties:\\n   * filledState: The autofill state of the element\\n   * filledvalue: The value of the element\\n   */\\n  collectFormFilledData() {\\n    const filledData = new Map();\\n\\n    for (const fieldDetail of this.fieldDetails) {\\n      const element = fieldDetail.element;\\n      filledData.set(fieldDetail.elementId, {\\n        filledState: element.autofillState,\\n        filledValue: this.computeFillingValue(fieldDetail),\\n      });\\n    }\\n    return filledData;\\n  }\\n\\n  isFieldAutofillable(fieldDetail, profile) {\\n    if (FormAutofillUtils.isTextControl(fieldDetail.element)) {\\n      return !!profile[fieldDetail.fieldName];\\n    }\\n    return !!this.matchSelectOptions(fieldDetail, profile);\\n  }\\n}\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs ***!
  \***************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nimport { FormAutofill } from \\\"resource://autofill/FormAutofill.sys.mjs\\\";\\nimport { HeuristicsRegExp } from \\\"resource://gre/modules/shared/HeuristicsRegExp.sys.mjs\\\";\\n\\nconst lazy = {};\\nChromeUtils.defineESModuleGetters(lazy, {\\n  CreditCard: \\\"resource://gre/modules/CreditCard.sys.mjs\\\",\\n  CreditCardRulesets: \\\"resource://gre/modules/shared/CreditCardRuleset.sys.mjs\\\",\\n  FieldDetail: \\\"resource://gre/modules/shared/FieldScanner.sys.mjs\\\",\\n  FieldScanner: \\\"resource://gre/modules/shared/FieldScanner.sys.mjs\\\",\\n  FormAutofillUtils: \\\"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\\\",\\n  LabelUtils: \\\"resource://gre/modules/shared/LabelUtils.sys.mjs\\\",\\n  MLAutofill: \\\"resource://autofill/MLAutofill.sys.mjs\\\",\\n});\\n\\n/**\\n * To help us classify sections that can appear only N times in a row.\\n * For example, the only time multiple cc-number fields are valid is when\\n * there are four of these fields in a row.\\n * Otherwise, multiple cc-number fields should be in separate sections.\\n */\\nconst MULTI_N_FIELD_NAMES = {\\n  \\\"cc-number\\\": 4,\\n};\\n\\nconst CC_TYPE = 1;\\nconst ADDR_TYPE = 2;\\n\\n/**\\n * Returns the autocomplete information of fields according to heuristics.\\n */\\nexport const FormAutofillHeuristics = {\\n  RULES: HeuristicsRegExp.getRules(),\\n  LABEL_RULES: HeuristicsRegExp.getLabelRules(),\\n\\n  CREDIT_CARD_FIELDNAMES: [],\\n  ADDRESS_FIELDNAMES: [],\\n  /**\\n   * Try to find a contiguous sub-array within an array.\\n   *\\n   * @param {Array} array\\n   * @param {Array} subArray\\n   *\\n   * @returns {boolean}\\n   *          Return whether subArray was found within the array or not.\\n   */\\n  _matchContiguousSubArray(array, subArray) {\\n    return array.some((elm, i) =>\\n      subArray.every((sElem, j) => sElem == array[i + j])\\n    );\\n  },\\n\\n  /**\\n   * Try to find the field that is look like a month select.\\n   *\\n   * @param {DOMElement} element\\n   * @returns {boolean}\\n   *          Return true if we observe the trait of month select in\\n   *          the current element.\\n   */\\n  _isExpirationMonthLikely(element) {\\n    if (!HTMLSelectElement.isInstance(element)) {\\n      return false;\\n    }\\n\\n    const options = [...element.options];\\n    const desiredValues = Array(12)\\n      .fill(1)\\n      .map((v, i) => v + i);\\n\\n    // The number of month options shouldn't be less than 12 or larger than 13\\n    // including the default option.\\n    if (options.length < 12 || options.length > 13) {\\n      return false;\\n    }\\n\\n    return (\\n      this._matchContiguousSubArray(\\n        options.map(e => +e.value),\\n        desiredValues\\n      ) ||\\n      this._matchContiguousSubArray(\\n        options.map(e => +e.label),\\n        desiredValues\\n      )\\n    );\\n  },\\n\\n  /**\\n   * Try to find the field that is look like a year select.\\n   *\\n   * @param {DOMElement} element\\n   * @returns {boolean}\\n   *          Return true if we observe the trait of year select in\\n   *          the current element.\\n   */\\n  _isExpirationYearLikely(element) {\\n    if (!HTMLSelectElement.isInstance(element)) {\\n      return false;\\n    }\\n\\n    const options = [...element.options];\\n    // A normal expiration year select should contain at least the last three years\\n    // in the list.\\n    const curYear = new Date().getFullYear();\\n    const desiredValues = Array(3)\\n      .fill(0)\\n      .map((v, i) => v + curYear + i);\\n\\n    return (\\n      this._matchContiguousSubArray(\\n        options.map(e => +e.value),\\n        desiredValues\\n      ) ||\\n      this._matchContiguousSubArray(\\n        options.map(e => +e.label),\\n        desiredValues\\n      )\\n    );\\n  },\\n\\n  /**\\n   * This function handles the case when two adjacent fields are incorrectly\\n   * identified with the same field name. Currently, only given-name and\\n   * family-name are handled as possible errors.\\n   *\\n   * @param {FieldScanner} scanner\\n   *        The current parsing status for all elements\\n   * @returns {boolean}\\n   *        Return true if any field is recognized and updated, otherwise false.\\n   */\\n  _parseNameFieldsContent(scanner, fieldDetail) {\\n    const TARGET_FIELDS = [\\\"given-name\\\", \\\"family-name\\\"];\\n    if (!TARGET_FIELDS.includes(fieldDetail.fieldName)) {\\n      return false;\\n    }\\n\\n    let idx = scanner.parsingIndex;\\n    const detailBefore = scanner.getFieldDetailByIndex(idx - 1);\\n    if (fieldDetail.fieldName == detailBefore?.fieldName) {\\n      let otherFieldName =\\n        fieldDetail.fieldName == TARGET_FIELDS[0]\\n          ? TARGET_FIELDS[1]\\n          : TARGET_FIELDS[0];\\n\\n      // If the second field matches both field names, or both fields match\\n      // both field names, then we change the second field, since the author\\n      // was more likely to miscopy the second field from the first. However,\\n      // if the earlier field only matches, then we change the first field.\\n      if (\\n        this._findMatchedFieldNames(fieldDetail.element, [otherFieldName])\\n          .length\\n      ) {\\n        scanner.updateFieldName(idx, otherFieldName);\\n      } else if (\\n        this._findMatchedFieldNames(detailBefore.element, [otherFieldName])\\n          .length\\n      ) {\\n        scanner.updateFieldName(idx - 1, otherFieldName);\\n      }\\n\\n      scanner.parsingIndex++;\\n      return true;\\n    }\\n\\n    return false;\\n  },\\n\\n  /**\\n   * In some languages such French (nom) and German (Name), name can mean either family name or\\n   * full name in a form, depending on the context. We want to be sure that if \\\"name\\\" is\\n   * detected in the context of \\\"family-name\\\" or \\\"given-name\\\", it is updated accordingly.\\n   *\\n   * Look for \\\"given-name\\\", \\\"family-name\\\", and \\\"name\\\" fields. If any two of those fields are detected\\n   * and one of them is \\\"name\\\", then replace \\\"name\\\" with \\\"family-name\\\" if \\\"name\\\" is accompanied by\\n   * \\\"given-name\\\" or vise-versa.\\n   *\\n   * @param {FieldScanner} scanner\\n   *        The current parsing status for all elements\\n   * @returns {boolean}\\n   *        Return true if any field is recognized and updated, otherwise false.\\n   */\\n  _parseNameFields(scanner, fieldDetail) {\\n    const TARGET_FIELDS = [\\\"name\\\", \\\"given-name\\\", \\\"family-name\\\"];\\n\\n    if (!TARGET_FIELDS.includes(fieldDetail.fieldName)) {\\n      return false;\\n    }\\n\\n    const fields = [];\\n    let nameIndex = -1;\\n\\n    for (let idx = scanner.parsingIndex; ; idx++) {\\n      const detail = scanner.getFieldDetailByIndex(idx);\\n      if (!TARGET_FIELDS.includes(detail?.fieldName)) {\\n        break;\\n      }\\n      if (detail.fieldName === \\\"name\\\") {\\n        nameIndex = idx;\\n      }\\n      fields.push(detail);\\n    }\\n\\n    if (nameIndex != -1 && fields.length == 2) {\\n      //if name is detected and the other of the two fields detected is 'given-name'\\n      //then update name to 'name' to 'family-name'\\n      if (\\n        fields[0].fieldName == \\\"given-name\\\" ||\\n        fields[1].fieldName == \\\"given-name\\\"\\n      ) {\\n        scanner.updateFieldName(nameIndex, \\\"family-name\\\");\\n        //if name is detected and the other of the two fields detected is 'family-name'\\n        //then update name to 'name' to 'given-name'\\n      } else if (\\n        fields[0].fieldName == \\\"family-name\\\" ||\\n        fields[1].fieldName == \\\"family-name\\\"\\n      ) {\\n        scanner.updateFieldName(nameIndex, \\\"given-name\\\");\\n      } else {\\n        return false;\\n      }\\n\\n      scanner.parsingIndex += fields.length;\\n      return true;\\n    }\\n\\n    return false;\\n  },\\n\\n  /**\\n   * Try to match the telephone related fields to the grammar\\n   * list to see if there is any valid telephone set and correct their\\n   * field names.\\n   *\\n   * @param {FieldScanner} scanner\\n   *        The current parsing status for all elements\\n   * @returns {boolean}\\n   *          Return true if there is any field can be recognized in the parser,\\n   *          otherwise false.\\n   */\\n  _parsePhoneFields(scanner, _fieldDetail) {\\n    let matchingResult;\\n    const GRAMMARS = this.PHONE_FIELD_GRAMMARS;\\n\\n    function isGrammarSeparator(index) {\\n      return !GRAMMARS[index][0];\\n    }\\n\\n    const savedIndex = scanner.parsingIndex;\\n    for (let ruleFrom = 0; ruleFrom < GRAMMARS.length; ) {\\n      const detailStart = scanner.parsingIndex;\\n      let ruleTo = ruleFrom;\\n      for (let count = 0; ruleTo < GRAMMARS.length; ruleTo++, count++) {\\n        // Bail out when reaching the end of the current set of grammars\\n        // or there are no more elements to parse\\n        if (\\n          isGrammarSeparator(ruleTo) ||\\n          !scanner.elementExisting(detailStart + count)\\n        ) {\\n          break;\\n        }\\n\\n        const [category, , length] = GRAMMARS[ruleTo];\\n        const detail = scanner.getFieldDetailByIndex(detailStart + count);\\n\\n        // If the field is not what this grammar rule is interested in, skip processing.\\n        if (\\n          !detail ||\\n          detail.fieldName != category ||\\n          detail.reason == \\\"autocomplete\\\"\\n        ) {\\n          break;\\n        }\\n\\n        const element = detail.element;\\n        if (length && (!element.maxLength || length < element.maxLength)) {\\n          break;\\n        }\\n      }\\n\\n      // if we reach the grammar separator, that means all the previous rules are matched.\\n      // Set the matchingResult so we update field names accordingly.\\n      if (isGrammarSeparator(ruleTo)) {\\n        matchingResult = { ruleFrom, ruleTo };\\n        break;\\n      }\\n\\n      // Fast forward to the next rule set.\\n      for (; ruleFrom < GRAMMARS.length; ) {\\n        if (isGrammarSeparator(ruleFrom++)) {\\n          break;\\n        }\\n      }\\n    }\\n\\n    if (matchingResult) {\\n      const { ruleFrom, ruleTo } = matchingResult;\\n      for (let i = ruleFrom; i < ruleTo; i++) {\\n        scanner.updateFieldName(scanner.parsingIndex, GRAMMARS[i][1]);\\n        scanner.parsingIndex++;\\n      }\\n    }\\n\\n    // If the previous parsed field is a \\\"tel\\\" field, run heuristic to see\\n    // if the current field is a \\\"tel-extension\\\" field\\n    const field = scanner.getFieldDetailByIndex(scanner.parsingIndex);\\n    if (field && field.reason != \\\"autocomplete\\\") {\\n      const prev = scanner.getFieldDetailByIndex(scanner.parsingIndex - 1);\\n      if (\\n        prev &&\\n        lazy.FormAutofillUtils.getCategoryFromFieldName(prev.fieldName) == \\\"tel\\\"\\n      ) {\\n        const regExpTelExtension = new RegExp(\\n          \\\"\\\\\\\\bext|ext\\\\\\\\b|extension|ramal\\\", // pt-BR, pt-PT\\n          \\\"iug\\\"\\n        );\\n        if (this._matchRegexp(field.element, regExpTelExtension)) {\\n          scanner.updateFieldName(scanner.parsingIndex, \\\"tel-extension\\\");\\n          scanner.parsingIndex++;\\n        }\\n      }\\n    }\\n    return savedIndex != scanner.parsingIndex;\\n  },\\n\\n  /**\\n   * If this is a house number field and there is no address-line1 or\\n   * street-address field, change the house number field to address-line1.\\n   *\\n   * @param {FieldScanner} scanner\\n   *        The current parsing status for all elements\\n   * @returns {boolean}\\n   *          Return true if there is any field can be recognized in the parser,\\n   *          otherwise false.\\n   */\\n  _parseHouseNumberFields(scanner, fieldDetail) {\\n    if (fieldDetail?.fieldName == \\\"address-housenumber\\\") {\\n      const savedIndex = scanner.parsingIndex;\\n      for (let idx = 0; !scanner.parsingFinished; idx++) {\\n        const detail = scanner.getFieldDetailByIndex(idx);\\n        if (!detail) {\\n          break;\\n        }\\n\\n        if ([\\\"address-line1\\\", \\\"street-address\\\"].includes(detail?.fieldName)) {\\n          return false;\\n        }\\n      }\\n\\n      // Return false so additional address handling still gets performed.\\n      scanner.updateFieldName(savedIndex, \\\"street-address\\\");\\n    }\\n\\n    return false;\\n  },\\n\\n  /**\\n   * Try to find the correct address-line[1-3] sequence and correct their field\\n   * names.\\n   *\\n   * @param {FieldScanner} scanner\\n   *        The current parsing status for all elements\\n   * @returns {boolean}\\n   *          Return true if there is any field can be recognized in the parser,\\n   *          otherwise false.\\n   */\\n  _parseStreetAddressFields(scanner, _fieldDetail) {\\n    const INTERESTED_FIELDS = [\\n      \\\"street-address\\\",\\n      \\\"address-line1\\\",\\n      \\\"address-line2\\\",\\n      \\\"address-line3\\\",\\n    ];\\n\\n    // Store the index of fields that are recognized as 'address-housenumber'\\n    let houseNumberFields = [];\\n\\n    // We need to build a list of the address fields. A list of the indicies\\n    // is also needed as the fields with a given name can change positions\\n    // during the update.\\n    const fields = [];\\n    const fieldIndicies = [];\\n    for (let idx = scanner.parsingIndex; !scanner.parsingFinished; idx++) {\\n      const detail = scanner.getFieldDetailByIndex(idx);\\n\\n      // Skip over any house number fields. There should only be zero or one,\\n      // but we'll skip over them all anyway.\\n      if (\\n        [detail?.fieldName, detail?.alternativeFieldName].includes(\\n          \\\"address-housenumber\\\"\\n        )\\n      ) {\\n        houseNumberFields.push(idx);\\n        continue;\\n      }\\n\\n      if (!INTERESTED_FIELDS.includes(detail?.fieldName)) {\\n        break;\\n      }\\n      fields.push(detail);\\n      fieldIndicies.push(idx);\\n    }\\n\\n    if (!fields.length) {\\n      return false;\\n    }\\n\\n    switch (fields.length) {\\n      case 1:\\n        if (\\n          fields[0].reason != \\\"autocomplete\\\" &&\\n          [\\\"address-line2\\\", \\\"address-line3\\\"].includes(fields[0].fieldName)\\n        ) {\\n          // If an earlier address field was already found, ignore any\\n          // address-related fields from the OTHER_ADDRESS_FIELDS\\n          // list since those can appear in-between the address-level1\\n          // and additional address info fields. If no address field\\n          // exists, update the field to be address-line1.\\n          const OTHER_ADDRESS_FIELDS = [\\n            \\\"address-level1\\\",\\n            \\\"address-level2\\\",\\n            \\\"address-level3\\\",\\n            \\\"postal-code\\\",\\n            \\\"organization\\\",\\n          ];\\n          let canUpdate = true;\\n\\n          for (let idx = scanner.parsingIndex - 1; idx >= 0; idx--) {\\n            const detail = scanner.getFieldDetailByIndex(idx);\\n            if (\\n              detail?.fieldName == \\\"street-address\\\" ||\\n              detail?.fieldName == \\\"address-line1\\\" ||\\n              detail?.fieldName == \\\"address-housenumber\\\"\\n            ) {\\n              canUpdate = false;\\n              break;\\n            }\\n\\n            if (!OTHER_ADDRESS_FIELDS.includes(detail?.fieldName)) {\\n              break;\\n            }\\n          }\\n\\n          if (canUpdate) {\\n            scanner.updateFieldName(fieldIndicies[0], \\\"address-line1\\\");\\n          }\\n        }\\n        break;\\n      case 2:\\n        if (fields[0].reason == \\\"autocomplete\\\") {\\n          if (\\n            fields[0].fieldName == \\\"street-address\\\" &&\\n            (fields[1].fieldName == \\\"address-line2\\\" ||\\n              fields[1].reason != \\\"autocomplete\\\")\\n          ) {\\n            scanner.updateFieldName(fieldIndicies[0], \\\"address-line1\\\", true);\\n          }\\n        } else {\\n          scanner.updateFieldName(fieldIndicies[0], \\\"address-line1\\\");\\n        }\\n        scanner.updateFieldName(fieldIndicies[1], \\\"address-line2\\\");\\n        break;\\n      case 3:\\n      default:\\n        scanner.updateFieldName(fieldIndicies[0], \\\"address-line1\\\");\\n        scanner.updateFieldName(fieldIndicies[1], \\\"address-line2\\\");\\n        scanner.updateFieldName(fieldIndicies[2], \\\"address-line3\\\");\\n        break;\\n    }\\n\\n    // 'address-housenumber' might be recognized alongside another field type\\n    // (see `alternativeFieldName`). In this case, we should update the field\\n    // name before advancing the parsing index.\\n    for (const idx of houseNumberFields) {\\n      scanner.updateFieldName(idx, \\\"address-housenumber\\\");\\n    }\\n    scanner.parsingIndex += fields.length + houseNumberFields.length;\\n    return true;\\n  },\\n\\n  _parseAddressFields(scanner, fieldDetail) {\\n    const INTERESTED_FIELDS = [\\\"address-level1\\\", \\\"address-level2\\\"];\\n\\n    if (!INTERESTED_FIELDS.includes(fieldDetail.fieldName)) {\\n      return false;\\n    }\\n\\n    const fields = [];\\n    for (let idx = scanner.parsingIndex; !scanner.parsingFinished; idx++) {\\n      const detail = scanner.getFieldDetailByIndex(idx);\\n      if (!INTERESTED_FIELDS.includes(detail?.fieldName)) {\\n        break;\\n      }\\n      fields.push(detail);\\n    }\\n\\n    if (!fields.length) {\\n      return false;\\n    }\\n\\n    // State & City(address-level2)\\n    if (fields.length == 1) {\\n      if (fields[0].fieldName == \\\"address-level2\\\") {\\n        const prev = scanner.getFieldDetailByIndex(scanner.parsingIndex - 1);\\n        if (prev && !prev.fieldName && prev.localName == \\\"select\\\") {\\n          scanner.updateFieldName(scanner.parsingIndex - 1, \\\"address-level1\\\");\\n          scanner.parsingIndex += 1;\\n          return true;\\n        }\\n        const next = scanner.getFieldDetailByIndex(scanner.parsingIndex + 1);\\n        if (next && !next.fieldName && next.localName == \\\"select\\\") {\\n          scanner.updateFieldName(scanner.parsingIndex + 1, \\\"address-level1\\\");\\n          scanner.parsingIndex += 2;\\n          return true;\\n        }\\n      }\\n    }\\n\\n    scanner.parsingIndex += fields.length;\\n    return true;\\n  },\\n\\n  /**\\n   * Try to look for expiration date fields and revise the field names if needed.\\n   *\\n   * @param {FieldScanner} scanner\\n   *        The current parsing status for all elements\\n   * @returns {boolean}\\n   *          Return true if there is any field can be recognized in the parser,\\n   *          otherwise false.\\n   */\\n  _parseCreditCardExpiryFields(scanner, fieldDetail) {\\n    const INTERESTED_FIELDS = [\\\"cc-exp\\\", \\\"cc-exp-month\\\", \\\"cc-exp-year\\\"];\\n\\n    if (!INTERESTED_FIELDS.includes(fieldDetail.fieldName)) {\\n      return false;\\n    }\\n\\n    const fields = [];\\n    for (let idx = scanner.parsingIndex; ; idx++) {\\n      const detail = scanner.getFieldDetailByIndex(idx);\\n      if (!INTERESTED_FIELDS.includes(detail?.fieldName)) {\\n        break;\\n      }\\n      fields.push(detail);\\n    }\\n\\n    // Don't process the fields if expiration month and expiration year are already\\n    // matched by regex in correct order.\\n    if (\\n      (fields.length == 1 && fields[0].fieldName == \\\"cc-exp\\\") ||\\n      (fields.length == 2 &&\\n        fields[0].fieldName == \\\"cc-exp-month\\\" &&\\n        fields[1].fieldName == \\\"cc-exp-year\\\")\\n    ) {\\n      scanner.parsingIndex += fields.length;\\n      return true;\\n    }\\n\\n    const prevCCFields = new Set();\\n    for (let idx = scanner.parsingIndex - 1; ; idx--) {\\n      const detail = scanner.getFieldDetailByIndex(idx);\\n      if (\\n        lazy.FormAutofillUtils.getCategoryFromFieldName(detail?.fieldName) !=\\n        \\\"creditCard\\\"\\n      ) {\\n        break;\\n      }\\n      prevCCFields.add(detail.fieldName);\\n    }\\n    // We update the \\\"cc-exp-*\\\" fields to correct \\\"cc-ex-*\\\" fields order when\\n    // the following conditions are met:\\n    // 1. The previous elements are identified as credit card fields and\\n    //    cc-number is in it\\n    // 2. There is no \\\"cc-exp-*\\\" fields in the previous credit card elements\\n    if (\\n      [\\\"cc-number\\\", \\\"cc-name\\\"].some(f => prevCCFields.has(f)) &&\\n      ![\\\"cc-exp\\\", \\\"cc-exp-month\\\", \\\"cc-exp-year\\\"].some(f => prevCCFields.has(f))\\n    ) {\\n      if (fields.length == 1) {\\n        scanner.updateFieldName(scanner.parsingIndex, \\\"cc-exp\\\");\\n      } else if (fields.length == 2) {\\n        scanner.updateFieldName(scanner.parsingIndex, \\\"cc-exp-month\\\");\\n        scanner.updateFieldName(scanner.parsingIndex + 1, \\\"cc-exp-year\\\");\\n      }\\n      scanner.parsingIndex += fields.length;\\n      return true;\\n    }\\n\\n    // Set field name to null as it failed to match any patterns.\\n    for (let idx = 0; idx < fields.length; idx++) {\\n      scanner.updateFieldName(scanner.parsingIndex + idx, null);\\n    }\\n    return false;\\n  },\\n\\n  _parseCreditCardNumberFields(scanner, fieldDetail) {\\n    const INTERESTED_FIELDS = [\\\"cc-number\\\"];\\n\\n    if (!INTERESTED_FIELDS.includes(fieldDetail.fieldName)) {\\n      return false;\\n    }\\n\\n    const fieldDetails = [];\\n    for (let idx = scanner.parsingIndex; ; idx++) {\\n      const detail = scanner.getFieldDetailByIndex(idx);\\n      if (!INTERESTED_FIELDS.includes(detail?.fieldName)) {\\n        break;\\n      }\\n      fieldDetails.push(detail);\\n    }\\n\\n    // This rule only applies when all the fields are visible\\n    if (fieldDetails.some(field => !field.isVisible)) {\\n      scanner.parsingIndex += fieldDetails.length;\\n      return true;\\n    }\\n\\n    // This is the heuristic to handle special cases where we can have multiple\\n    // fields in one section, but only if the field has appeared N times in a row.\\n    // For example, websites can use 4 consecutive 4-digit `cc-number` fields\\n    // instead of one 16-digit `cc-number` field.\\n    const N = MULTI_N_FIELD_NAMES[\\\"cc-number\\\"];\\n    if (fieldDetails.length == N) {\\n      fieldDetails.forEach((fd, index) => {\\n        // part starts with 1\\n        fd.part = index + 1;\\n      });\\n      scanner.parsingIndex += fieldDetails.length;\\n      return true;\\n    }\\n\\n    return false;\\n  },\\n  /**\\n   * Look for cc-*-name fields when *-name field is present\\n   *\\n   * @param {FieldScanner} scanner\\n   *        The current parsing status for all elements\\n   * @returns {boolean}\\n   *          Return true if there is any field can be recognized in the parser,\\n   *          otherwise false.\\n   */\\n  _parseCreditCardNameFields(scanner, fieldDetail) {\\n    const INTERESTED_FIELDS = [\\n      \\\"name\\\",\\n      \\\"given-name\\\",\\n      \\\"additional-name\\\",\\n      \\\"family-name\\\",\\n    ];\\n\\n    if (!INTERESTED_FIELDS.includes(fieldDetail.fieldName)) {\\n      return false;\\n    }\\n\\n    const fields = [];\\n    for (let idx = scanner.parsingIndex; ; idx++) {\\n      const detail = scanner.getFieldDetailByIndex(idx);\\n      if (!INTERESTED_FIELDS.includes(detail?.fieldName)) {\\n        break;\\n      }\\n      fields.push(detail);\\n    }\\n\\n    const prevCCFields = new Set();\\n    for (let idx = scanner.parsingIndex - 1; ; idx--) {\\n      const detail = scanner.getFieldDetailByIndex(idx);\\n      if (\\n        lazy.FormAutofillUtils.getCategoryFromFieldName(detail?.fieldName) !=\\n        \\\"creditCard\\\"\\n      ) {\\n        break;\\n      }\\n      prevCCFields.add(detail.fieldName);\\n    }\\n\\n    const subsequentCCFields = new Set();\\n\\n    for (let idx = scanner.parsingIndex + fields.length; ; idx++) {\\n      const detail = scanner.getFieldDetailByIndex(idx);\\n      if (\\n        // For updates we only check subsequent fields that are not of type address or do not have an\\n        // alternative field name that is of type address, to avoid falsely updating address\\n        // form name fields to cc-*-name.\\n        lazy.FormAutofillUtils.getCategoryFromFieldName(detail?.fieldName) !=\\n          \\\"creditCard\\\" ||\\n        (detail?.alternativeFieldName !== undefined &&\\n          lazy.FormAutofillUtils.getCategoryFromFieldName(\\n            detail?.alternativeFieldName\\n          ) != \\\"creditCard\\\")\\n      ) {\\n        break;\\n      }\\n      subsequentCCFields.add(detail.fieldName);\\n    }\\n\\n    const isLastField =\\n      scanner.getFieldDetailByIndex(scanner.parsingIndex + 1) === null;\\n\\n    // We update the \\\"name\\\" fields to \\\"cc-name\\\" fields when the following\\n    // conditions are met:\\n    // 1. The preceding fields are identified as credit card fields and\\n    //    contain the \\\"cc-number\\\" field.\\n    // 2. No \\\"cc-name-*\\\" field is found among the preceding credit card fields.\\n    // 3. The \\\"cc-csc\\\" field is either not present among the preceding credit card fields,\\n    //    or the current field is the last field in the form. This condition is in place\\n    //    because \\\"cc-csc\\\" is often the last field in a credit card form, and we want to\\n    //    avoid mistakenly updating fields in subsequent address forms.\\n    if (\\n      ([\\\"cc-number\\\"].some(f => prevCCFields.has(f)) &&\\n        ![\\\"cc-name\\\", \\\"cc-given-name\\\", \\\"cc-family-name\\\"].some(f =>\\n          prevCCFields.has(f)\\n        ) &&\\n        (isLastField || !prevCCFields.has(\\\"cc-csc\\\"))) || // 4. Or we update when current name field is followed by\\n      //    creditcard form fields that contain cc-number\\n      //    and no cc-*-name field is detected\\n      ([\\\"cc-number\\\"].some(f => subsequentCCFields.has(f)) &&\\n        ![\\\"cc-name\\\", \\\"cc-given-name\\\", \\\"cc-family-name\\\"].some(f =>\\n          subsequentCCFields.has(f)\\n        ))\\n    ) {\\n      // If there is only one field, assume the name field a `cc-name` field\\n      if (fields.length == 1) {\\n        scanner.updateFieldName(scanner.parsingIndex, `cc-name`);\\n        scanner.parsingIndex += 1;\\n      } else {\\n        // update *-name to cc-*-name\\n        for (const field of fields) {\\n          scanner.updateFieldName(\\n            scanner.parsingIndex,\\n            `cc-${field.fieldName}`\\n          );\\n          scanner.parsingIndex += 1;\\n        }\\n      }\\n      return true;\\n    }\\n\\n    return false;\\n  },\\n\\n  /**\\n   * If the given field is of a different type than the previous\\n   * field, use the alternate field name instead.\\n   */\\n  _checkForAlternateField(scanner, fieldDetail) {\\n    if (fieldDetail.alternativeFieldName) {\\n      const previousField = scanner.getFieldDetailByIndex(\\n        scanner.parsingIndex - 1\\n      );\\n      if (previousField) {\\n        const preIsCC = lazy.FormAutofillUtils.isCreditCardField(\\n          previousField.fieldName\\n        );\\n        const curIsCC = lazy.FormAutofillUtils.isCreditCardField(\\n          fieldDetail.fieldName\\n        );\\n\\n        // If the current type is different from the previous element's type, use\\n        // the alternative fieldname instead.\\n        if (preIsCC != curIsCC) {\\n          fieldDetail.fieldName = fieldDetail.alternativeFieldName;\\n          fieldDetail.reason = \\\"update-heuristic-alternate\\\";\\n        }\\n      }\\n    }\\n  },\\n\\n  /**\\n   * This function should provide all field details of a form which are placed\\n   * in the belonging section. The details contain the autocomplete info\\n   * (e.g. fieldName, section, etc).\\n   *\\n   * @param {formLike} formLike\\n   *        the elements in this form to be predicted the field info.\\n   * @param {boolean} ignoreInvisibleInput\\n   *        True to NOT run heuristics on invisible <input> fields.\\n   * @returns {Array<FormSection>}\\n   *        all sections within its field details in the form.\\n   */\\n  getFormInfo(formLike, ignoreInvisibleInput) {\\n    const elements = Array.from(formLike.elements).filter(element =>\\n      lazy.FormAutofillUtils.isCreditCardOrAddressFieldType(element)\\n    );\\n\\n    let closestHeaders;\\n    let closestButtons;\\n    if (FormAutofill.isMLExperimentEnabled && elements.length) {\\n      closestHeaders = lazy.MLAutofill.closestHeaderAbove(elements);\\n      closestButtons = lazy.MLAutofill.closestButtonBelow(elements);\\n    }\\n\\n    const fieldDetails = [];\\n    for (let idx = 0; idx < elements.length; idx++) {\\n      const element = elements[idx];\\n      // Ignore invisible <input>, we still keep invisible <select> since\\n      // some websites implements their custom dropdown and use invisible <select>\\n      // to store the value.\\n      const isVisible = lazy.FormAutofillUtils.isFieldVisible(element);\\n      if (\\n        !HTMLSelectElement.isInstance(element) &&\\n        !isVisible &&\\n        ignoreInvisibleInput &&\\n        // Include invisible but previously autocompleted inputs in order\\n        // keep track of them. This way they will also be cleared on a form clearing action.\\n        element.autofillState != lazy.FormAutofillUtils.FIELD_STATES.AUTO_FILLED\\n      ) {\\n        continue;\\n      }\\n\\n      const [fieldName, inferInfo] = this.inferFieldInfo(element, elements);\\n\\n      // For cases where the heuristic has determined the field name without\\n      // running Fathom, still run Fathom so we can compare the results between\\n      // Fathom and the ML model. Note that this is only enabled when the ML experiment\\n      // is enabled.\\n      if (\\n        FormAutofill.isMLExperimentEnabled &&\\n        inferInfo.fathomConfidence == undefined\\n      ) {\\n        let fields = this._getPossibleFieldNames(element);\\n        fields = fields.filter(r => lazy.CreditCardRulesets.types.includes(r));\\n        const [label, score] = this.getFathomField(element, fields, elements);\\n        inferInfo.fathomLabel = label;\\n        inferInfo.fathomConfidence = score;\\n      }\\n\\n      fieldDetails.push(\\n        lazy.FieldDetail.create(element, formLike, fieldName, {\\n          autocompleteInfo: inferInfo.autocompleteInfo,\\n          fathomLabel: inferInfo.fathomLabel,\\n          fathomConfidence: inferInfo.fathomConfidence,\\n          isVisible,\\n          mlHeaderInput: closestHeaders?.[idx] ?? null,\\n          mlButtonInput: closestButtons?.[idx] ?? null,\\n        })\\n      );\\n    }\\n\\n    this.parseAndUpdateFieldNamesContent(fieldDetails);\\n\\n    lazy.LabelUtils.clearLabelMap();\\n\\n    return fieldDetails;\\n  },\\n\\n  /**\\n   * Similar to `parseAndUpdateFieldNamesParent`. The difference is that\\n   * the parsing heuristics used in this function are based on information\\n   * not currently passed to the parent process. For example,\\n   * text strings from associated labels.\\n   *\\n   * Note that the heuristics run in this function will not be able\\n   * to reference field information across frames.\\n   *\\n   * @param {Array<FieldDetail>} fieldDetails\\n   *        An array of the identified fields.\\n   */\\n  parseAndUpdateFieldNamesContent(fieldDetails) {\\n    const scanner = new lazy.FieldScanner(fieldDetails);\\n\\n    while (!scanner.parsingFinished) {\\n      const savedIndex = scanner.parsingIndex;\\n\\n      // First, we get the inferred field info\\n      const fieldDetail = scanner.getFieldDetailByIndex(scanner.parsingIndex);\\n\\n      if (\\n        this._parseNameFieldsContent(scanner, fieldDetail) ||\\n        this._parsePhoneFields(scanner, fieldDetail)\\n      ) {\\n        continue;\\n      }\\n\\n      if (savedIndex == scanner.parsingIndex) {\\n        scanner.parsingIndex++;\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Iterates through the field details and updates the field names\\n   * based on surrounding field information, using various parsing functions.\\n   *\\n   * @param {Array<FieldDetail>} fieldDetails\\n   *        An array of the identified fields.\\n   */\\n  parseAndUpdateFieldNamesParent(fieldDetails) {\\n    const scanner = new lazy.FieldScanner(fieldDetails);\\n\\n    while (!scanner.parsingFinished) {\\n      const savedIndex = scanner.parsingIndex;\\n\\n      const fieldDetail = scanner.getFieldDetailByIndex(scanner.parsingIndex);\\n\\n      this._checkForAlternateField(scanner, fieldDetail);\\n\\n      // Attempt to parse the field using different parsers.\\n      if (\\n        this._parseNameFields(scanner, fieldDetail) ||\\n        this._parseHouseNumberFields(scanner, fieldDetail) ||\\n        this._parseStreetAddressFields(scanner, fieldDetail) ||\\n        this._parseAddressFields(scanner, fieldDetail) ||\\n        this._parseCreditCardExpiryFields(scanner, fieldDetail) ||\\n        this._parseCreditCardNameFields(scanner, fieldDetail) ||\\n        this._parseCreditCardNumberFields(scanner, fieldDetail)\\n      ) {\\n        continue;\\n      }\\n\\n      // Move the parsing cursor forward if no parser was applied.\\n      if (savedIndex == scanner.parsingIndex) {\\n        scanner.parsingIndex++;\\n      }\\n    }\\n  },\\n\\n  _getPossibleFieldNames(element) {\\n    let fieldNames = [];\\n    const isAutoCompleteOff =\\n      element.autocomplete == \\\"off\\\" || element.form?.autocomplete == \\\"off\\\";\\n    if (!isAutoCompleteOff || FormAutofill.creditCardsAutocompleteOff) {\\n      fieldNames.push(...this.CREDIT_CARD_FIELDNAMES);\\n    }\\n    if (!isAutoCompleteOff || FormAutofill.addressesAutocompleteOff) {\\n      fieldNames.push(...this.ADDRESS_FIELDNAMES);\\n    }\\n\\n    if (HTMLInputElement.isInstance(element) && element.type == \\\"search\\\") {\\n      const FIELDNAMES_FOR_SEARCH_TYPE = [\\n        \\\"address-level1\\\",\\n        \\\"address-level2\\\",\\n        \\\"address-line1\\\",\\n        \\\"address-line2\\\",\\n        \\\"address-line3\\\",\\n        \\\"street-address\\\",\\n        \\\"postal-code\\\",\\n      ];\\n      fieldNames = fieldNames.filter(name =>\\n        FIELDNAMES_FOR_SEARCH_TYPE.includes(name)\\n      );\\n    } else if (HTMLSelectElement.isInstance(element)) {\\n      const FIELDNAMES_FOR_SELECT_ELEMENT = [\\n        \\\"address-level1\\\",\\n        \\\"address-level2\\\",\\n        \\\"country\\\",\\n        \\\"cc-exp-month\\\",\\n        \\\"cc-exp-year\\\",\\n        \\\"cc-exp\\\",\\n        \\\"cc-type\\\",\\n        \\\"tel-country-code\\\",\\n      ];\\n      fieldNames = fieldNames.filter(name =>\\n        FIELDNAMES_FOR_SELECT_ELEMENT.includes(name)\\n      );\\n    } else if (HTMLTextAreaElement.isInstance(element)) {\\n      const FIELDNAMES_FOR_TEXT_AREA_ELEMENT = [\\\"street-address\\\"];\\n      fieldNames = fieldNames.filter(name =>\\n        FIELDNAMES_FOR_TEXT_AREA_ELEMENT.includes(name)\\n      );\\n    }\\n\\n    return fieldNames;\\n  },\\n\\n  /**\\n   * Get inferred information about an input element using autocomplete info, fathom and regex-based heuristics.\\n   *\\n   * @param {HTMLElement} element - The input element to infer information about.\\n   * @param {Array<HTMLElement>} elements - See `getFathomField` for details\\n   * @returns {Array} - An array containing:\\n   *                    [0]the inferred field name\\n   *                    [1]information collected during the inference process. The possible values includes:\\n   *                       'autocompleteInfo', 'fathomLabel', and 'fathomConfidence'.\\n   */\\n  inferFieldInfo(element, elements = []) {\\n    const inferredInfo = {};\\n    const autocompleteInfo = element.getAutocompleteInfo();\\n\\n    // An input[autocomplete=\\\"on\\\"] will not be early return here since it stll\\n    // needs to find the field name.\\n    if (\\n      autocompleteInfo?.fieldName &&\\n      ![\\\"on\\\", \\\"off\\\"].includes(autocompleteInfo.fieldName)\\n    ) {\\n      inferredInfo.autocompleteInfo = autocompleteInfo;\\n      return [autocompleteInfo.fieldName, inferredInfo];\\n    }\\n\\n    const fields = this._getPossibleFieldNames(element);\\n\\n    // \\\"email\\\" type of input is accurate for heuristics to determine its Email\\n    // field or not. However, \\\"tel\\\" type is used for ZIP code for some web site\\n    // (e.g. HomeDepot, BestBuy), so \\\"tel\\\" type should be not used for \\\"tel\\\"\\n    // prediction.\\n    if (element.type == \\\"email\\\" && fields.includes(\\\"email\\\")) {\\n      return [\\\"email\\\", inferredInfo];\\n    }\\n\\n    if (lazy.FormAutofillUtils.isFathomCreditCardsEnabled()) {\\n      // We don't care fields that are not supported by fathom\\n      const fathomFields = fields.filter(r =>\\n        lazy.CreditCardRulesets.types.includes(r)\\n      );\\n      const [matchedFieldName, confidence] = this.getFathomField(\\n        element,\\n        fathomFields,\\n        elements\\n      );\\n      if (confidence != null) {\\n        inferredInfo.fathomLabel = matchedFieldName;\\n        inferredInfo.fathomConfidence = confidence;\\n      }\\n      // At this point, use fathom's recommendation if it has one\\n      if (matchedFieldName) {\\n        return [matchedFieldName, inferredInfo];\\n      }\\n\\n      // Continue to run regex-based heuristics even when fathom doesn't recognize\\n      // the field. Since the regex-based heuristic has good search coverage but\\n      // has a worse precision. We use it in conjunction with fathom to maximize\\n      // our search coverage. For example, when a <input> is not considered cc-name\\n      // by fathom but is considered cc-name by regex-based heuristic, if the form\\n      // also contains a cc-number identified by fathom, we will treat the form as a\\n      // valid cc form; hence both cc-number & cc-name are identified.\\n    }\\n\\n    // Check every select for options that\\n    // match credit card network names in value or label.\\n    if (HTMLSelectElement.isInstance(element)) {\\n      if (this._isExpirationMonthLikely(element)) {\\n        return [\\\"cc-exp-month\\\", inferredInfo];\\n      } else if (this._isExpirationYearLikely(element)) {\\n        return [\\\"cc-exp-year\\\", inferredInfo];\\n      }\\n\\n      const options = Array.from(element.querySelectorAll(\\\"option\\\"));\\n      if (\\n        options.find(\\n          option =>\\n            lazy.CreditCard.getNetworkFromName(option.value) ||\\n            lazy.CreditCard.getNetworkFromName(option.text)\\n        )\\n      ) {\\n        return [\\\"cc-type\\\", inferredInfo];\\n      }\\n\\n      // At least two options match the country name, otherwise some state name might\\n      // also match a country name, ex, Georgia. We check the last two\\n      // options rather than the first, as selects often start with a non-country display option.\\n      const countryDisplayNames = Array.from(FormAutofill.countries.values());\\n      if (\\n        options.length >= 2 &&\\n        options\\n          .slice(-2)\\n          .every(\\n            option =>\\n              countryDisplayNames.includes(option.value) ||\\n              countryDisplayNames.includes(option.text)\\n          )\\n      ) {\\n        return [\\\"country\\\", inferredInfo];\\n      }\\n    }\\n\\n    // Find a matched field name using regexp-based heuristics\\n    const matchedFieldNames = this._findMatchedFieldNames(element, fields);\\n\\n    return [matchedFieldNames, inferredInfo];\\n  },\\n\\n  /**\\n   * Using Fathom, say what kind of CC field an element is most likely to be.\\n   * This function deoesn't only run fathom on the passed elements. It also\\n   * runs fathom for all elements in the FieldScanner for optimization purpose.\\n   *\\n   * @param {HTMLElement} element\\n   * @param {Array} fields\\n   * @param {Array<HTMLElement>} elements - All other eligible elements in the same form. This is mainly used as an\\n   *                                        optimization approach to run fathom model on all eligible elements\\n   *                                        once instead of one by one\\n   * @returns {Array} A tuple of [field name, probability] describing the\\n   *   highest-confidence classification\\n   */\\n  getFathomField(element, fields, elements = []) {\\n    if (!fields.length) {\\n      return [null, null];\\n    }\\n\\n    if (!this._fathomConfidences?.get(element)) {\\n      this._fathomConfidences = new Map();\\n\\n      // This should not throw unless we run into an OOM situation, at which\\n      // point we have worse problems and this failing is not a big deal.\\n      elements = elements.includes(element) ? elements : [element];\\n      const confidences = this.getFormAutofillConfidences(elements);\\n\\n      for (let i = 0; i < elements.length; i++) {\\n        this._fathomConfidences.set(elements[i], confidences[i]);\\n      }\\n    }\\n\\n    const elementConfidences = this._fathomConfidences.get(element);\\n    if (!elementConfidences) {\\n      return [null, null];\\n    }\\n\\n    let highestField = null;\\n    let highestConfidence = lazy.FormAutofillUtils.ccFathomConfidenceThreshold; // Start with a threshold of 0.5\\n    for (let [key, value] of Object.entries(elementConfidences)) {\\n      if (!fields.includes(key)) {\\n        // ignore field that we don't care\\n        continue;\\n      }\\n\\n      if (value > highestConfidence) {\\n        highestConfidence = value;\\n        highestField = key;\\n      }\\n    }\\n\\n    if (!highestField) {\\n      return [null, null];\\n    }\\n\\n    // Used by test ONLY! This ensure testcases always get the same confidence\\n    if (lazy.FormAutofillUtils.ccFathomTestConfidence > 0) {\\n      highestConfidence = lazy.FormAutofillUtils.ccFathomTestConfidence;\\n    }\\n\\n    return [highestField, highestConfidence];\\n  },\\n\\n  /**\\n   * @param {Array} elements Array of elements that we want to get result from fathom cc rules\\n   * @returns {object} Fathom confidence keyed by field-type.\\n   */\\n  getFormAutofillConfidences(elements) {\\n    if (\\n      lazy.FormAutofillUtils.ccHeuristicsMode ==\\n      lazy.FormAutofillUtils.CC_FATHOM_NATIVE\\n    ) {\\n      const confidences = ChromeUtils.getFormAutofillConfidences(elements);\\n      return confidences.map(c => {\\n        let result = {};\\n        for (let [fieldName, confidence] of Object.entries(c)) {\\n          let type =\\n            lazy.FormAutofillUtils.formAutofillConfidencesKeyToCCFieldType(\\n              fieldName\\n            );\\n          result[type] = confidence;\\n        }\\n        return result;\\n      });\\n    }\\n\\n    return elements.map(element => {\\n      /**\\n       * Return how confident our ML model is that `element` is a field of the\\n       * given type.\\n       *\\n       * @param {string} fieldName The Fathom type to check against. This is\\n       *   conveniently the same as the autocomplete attribute value that means\\n       *   the same thing.\\n       * @returns {number} Confidence in range [0, 1]\\n       */\\n      function confidence(fieldName) {\\n        const ruleset = lazy.CreditCardRulesets[fieldName];\\n        const fnodes = ruleset.against(element).get(fieldName);\\n\\n        // fnodes is either 0 or 1 item long, since we ran the ruleset\\n        // against a single element:\\n        return fnodes.length ? fnodes[0].scoreFor(fieldName) : 0;\\n      }\\n\\n      // Bang the element against the ruleset for every type of field:\\n      const confidences = {};\\n      lazy.CreditCardRulesets.types.map(fieldName => {\\n        confidences[fieldName] = confidence(fieldName);\\n      });\\n\\n      return confidences;\\n    });\\n  },\\n\\n  /**\\n   * @typedef ElementStrings\\n   * @type {object}\\n   * @yields {string} id - element id.\\n   * @yields {string} name - element name.\\n   * @yields {Array<string>} labels - extracted labels.\\n   */\\n\\n  /**\\n   * Extract all the signature strings of an element.\\n   *\\n   * @param {HTMLElement} element\\n   * @returns {Array<string>}\\n   */\\n  _getElementStrings(element) {\\n    return [element.id, element.name, element.placeholder?.trim()];\\n  },\\n\\n  /**\\n   * Extract all the label strings associated with an element.\\n   *\\n   * @param {HTMLElement} element\\n   * @returns {ElementStrings}\\n   */\\n  _getElementLabelStrings(element) {\\n    return {\\n      *[Symbol.iterator]() {\\n        const labels = lazy.LabelUtils.findLabelElements(element);\\n        for (let label of labels) {\\n          yield* lazy.LabelUtils.extractLabelStrings(label);\\n        }\\n\\n        const ariaLabels = element.getAttribute(\\\"aria-label\\\");\\n        if (ariaLabels) {\\n          yield* [ariaLabels];\\n        }\\n      },\\n    };\\n  },\\n\\n  // In order to support webkit we need to avoid usage of negative lookbehind due to low support\\n  // First safari version with support is 16.4 (Release Date: 27th March 2023)\\n  // https://caniuse.com/js-regexp-lookbehind\\n  // We can mimic the behaviour of negative lookbehinds by using a named capture group\\n  // (?<!not)word -> (?<neg>notword)|word\\n  // TODO: Bug 1829583\\n  testRegex(regex, string) {\\n    const matches = string?.matchAll(regex);\\n    if (!matches) {\\n      return false;\\n    }\\n\\n    const excludeNegativeCaptureGroups = [];\\n\\n    for (const match of matches) {\\n      excludeNegativeCaptureGroups.push(\\n        ...match.filter(m => m !== match?.groups?.neg).filter(Boolean)\\n      );\\n    }\\n    return excludeNegativeCaptureGroups?.length > 0;\\n  },\\n\\n  /**\\n   * Find matching field names from a given list of field names\\n   * that matches an HTML element.\\n   *\\n   * The function first tries to match the element against a set of\\n   * pre-defined regular expression rules. If no match is found, it\\n   * then checks for label-specific rules, if they exist.\\n   *\\n   * The return value can contain a maximum of two field names, the\\n   * first item the first match found, and the second an alternate field\\n   * name always of a different type, where the two type are credit card\\n   * and address.\\n   *\\n   * Note: For label rules, the keyword is often more general\\n   * (e.g., \\\"^\\\\\\\\W*address\\\"), hence they are only searched within labels\\n   * to reduce the occurrence of false positives.\\n   *\\n   * @param {HTMLElement} element The element to match.\\n   * @param {Array<string>} fieldNames An array of field names to compare against.\\n   * @returns {Array} An array of the matching field names.\\n   */\\n  _findMatchedFieldNames(element, fieldNames) {\\n    if (!fieldNames.length) {\\n      return [];\\n    }\\n\\n    // The first element is the field name, and the second element is the type.\\n    let fields = fieldNames.map(name => [\\n      name,\\n      lazy.FormAutofillUtils.isCreditCardField(name) ? CC_TYPE : ADDR_TYPE,\\n    ]);\\n\\n    let foundType;\\n    let attribute = true;\\n    let matchedFieldNames = [];\\n\\n    // Check RULES first, and only check LABEL_RULES if no match is found.\\n    for (let rules of [this.RULES, this.LABEL_RULES]) {\\n      // Attempt to match the element against the default set of rules.\\n      if (\\n        fields.find(field => {\\n          const [fieldName, type] = field;\\n\\n          // The same type has been found already, so skip.\\n          if (foundType == type) {\\n            return false;\\n          }\\n\\n          if (!this._matchRegexp(element, rules[fieldName], { attribute })) {\\n            return false;\\n          }\\n\\n          foundType = type;\\n          matchedFieldNames.push(fieldName);\\n\\n          return matchedFieldNames.length == 2;\\n        })\\n      ) {\\n        break;\\n      }\\n\\n      // Don't match attributes for label rules.\\n      attribute = false;\\n    }\\n\\n    return matchedFieldNames;\\n  },\\n\\n  /**\\n   * Determine whether the regexp can match any of element strings.\\n   *\\n   * @param {HTMLElement} element The HTML element to match.\\n   * @param {RegExp} regexp       The regular expression to match against.\\n   * @param {object} [options]    Optional parameters for matching.\\n   * @param {boolean} [options.attribute=true]\\n   *                              Whether to match against the element's attributes.\\n   * @param {boolean} [options.label=true]\\n   *                              Whether to match against the element's labels.\\n   * @returns {boolean} True if a match is found, otherwise false.\\n   */\\n  _matchRegexp(element, regexp, { attribute = true, label = true } = {}) {\\n    if (!regexp) {\\n      return false;\\n    }\\n\\n    if (attribute) {\\n      const elemStrings = this._getElementStrings(element);\\n      if (elemStrings.find(s => this.testRegex(regexp, s?.toLowerCase()))) {\\n        return true;\\n      }\\n    }\\n\\n    if (label) {\\n      const elementLabelStrings = this._getElementLabelStrings(element);\\n      for (const s of elementLabelStrings) {\\n        if (this.testRegex(regexp, s?.toLowerCase())) {\\n          return true;\\n        }\\n      }\\n    }\\n\\n    return false;\\n  },\\n\\n  /**\\n   * Phone field grammars - first matched grammar will be parsed. Grammars are\\n   * separated by { REGEX_SEPARATOR, FIELD_NONE, 0 }. Suffix and extension are\\n   * parsed separately unless they are necessary parts of the match.\\n   * The following notation is used to describe the patterns:\\n   * <cc> - country code field.\\n   * <ac> - area code field.\\n   * <phone> - phone or prefix.\\n   * <suffix> - suffix.\\n   * <ext> - extension.\\n   * :N means field is limited to N characters, otherwise it is unlimited.\\n   * (pattern <field>)? means pattern is optional and matched separately.\\n   *\\n   * This grammar list from Chromium will be enabled partially once we need to\\n   * support more cases of Telephone fields.\\n   */\\n  PHONE_FIELD_GRAMMARS: [\\n    // Country code: <cc> Area Code: <ac> Phone: <phone> (- <suffix>\\n\\n    // (Ext: <ext>)?)?\\n    // {REGEX_COUNTRY, FIELD_COUNTRY_CODE, 0},\\n    // {REGEX_AREA, FIELD_AREA_CODE, 0},\\n    // {REGEX_PHONE, FIELD_PHONE, 0},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n\\n    // \\\\( <ac> \\\\) <phone>:3 <suffix>:4 (Ext: <ext>)?\\n    // {REGEX_AREA_NOTEXT, FIELD_AREA_CODE, 3},\\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 3},\\n    // {REGEX_PHONE, FIELD_SUFFIX, 4},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n\\n    // Phone: <cc> <ac>:3 - <phone>:3 - <suffix>:4 (Ext: <ext>)?\\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\\n    // {REGEX_PHONE, FIELD_AREA_CODE, 3},\\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 3},\\n    // {REGEX_SUFFIX_SEPARATOR, FIELD_SUFFIX, 4},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n\\n    // Phone: <cc>:3 <ac>:3 <phone>:3 <suffix>:4 (Ext: <ext>)?\\n    [\\\"tel\\\", \\\"tel-country-code\\\", 3],\\n    [\\\"tel\\\", \\\"tel-area-code\\\", 3],\\n    [\\\"tel\\\", \\\"tel-local-prefix\\\", 3],\\n    [\\\"tel\\\", \\\"tel-local-suffix\\\", 4],\\n    [null, null, 0],\\n\\n    // Area Code: <ac> Phone: <phone> (- <suffix> (Ext: <ext>)?)?\\n    // {REGEX_AREA, FIELD_AREA_CODE, 0},\\n    // {REGEX_PHONE, FIELD_PHONE, 0},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n\\n    // Phone: <ac> <phone>:3 <suffix>:4 (Ext: <ext>)?\\n    // {REGEX_PHONE, FIELD_AREA_CODE, 0},\\n    // {REGEX_PHONE, FIELD_PHONE, 3},\\n    // {REGEX_PHONE, FIELD_SUFFIX, 4},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n\\n    // Phone: <cc> \\\\( <ac> \\\\) <phone> (- <suffix> (Ext: <ext>)?)?\\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\\n    // {REGEX_AREA_NOTEXT, FIELD_AREA_CODE, 0},\\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 0},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n\\n    // Phone: \\\\( <ac> \\\\) <phone> (- <suffix> (Ext: <ext>)?)?\\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\\n    // {REGEX_AREA_NOTEXT, FIELD_AREA_CODE, 0},\\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 0},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n\\n    // Phone: <cc> - <ac> - <phone> - <suffix> (Ext: <ext>)?\\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\\n    // {REGEX_PREFIX_SEPARATOR, FIELD_AREA_CODE, 0},\\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 0},\\n    // {REGEX_SUFFIX_SEPARATOR, FIELD_SUFFIX, 0},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n\\n    // Area code: <ac>:3 Prefix: <prefix>:3 Suffix: <suffix>:4 (Ext: <ext>)?\\n    // {REGEX_AREA, FIELD_AREA_CODE, 3},\\n    // {REGEX_PREFIX, FIELD_PHONE, 3},\\n    // {REGEX_SUFFIX, FIELD_SUFFIX, 4},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n\\n    // Phone: <ac> Prefix: <phone> Suffix: <suffix> (Ext: <ext>)?\\n    // {REGEX_PHONE, FIELD_AREA_CODE, 0},\\n    // {REGEX_PREFIX, FIELD_PHONE, 0},\\n    // {REGEX_SUFFIX, FIELD_SUFFIX, 0},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n\\n    // Phone: <ac> - <phone>:3 - <suffix>:4 (Ext: <ext>)?\\n    [\\\"tel\\\", \\\"tel-area-code\\\", 0],\\n    [\\\"tel\\\", \\\"tel-local-prefix\\\", 3],\\n    [\\\"tel\\\", \\\"tel-local-suffix\\\", 4],\\n    [null, null, 0],\\n\\n    // Phone: <cc> - <ac> - <phone> (Ext: <ext>)?\\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\\n    // {REGEX_PREFIX_SEPARATOR, FIELD_AREA_CODE, 0},\\n    // {REGEX_SUFFIX_SEPARATOR, FIELD_PHONE, 0},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n\\n    // Phone: <ac> - <phone> (Ext: <ext>)?\\n    // {REGEX_AREA, FIELD_AREA_CODE, 0},\\n    // {REGEX_PHONE, FIELD_PHONE, 0},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n\\n    // Phone: <cc>:3 - <phone>:10 (Ext: <ext>)?\\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 3},\\n    // {REGEX_PHONE, FIELD_PHONE, 10},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n\\n    // Ext: <ext>\\n    // {REGEX_EXTENSION, FIELD_EXTENSION, 0},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n\\n    // Phone: <phone> (Ext: <ext>)?\\n    // {REGEX_PHONE, FIELD_PHONE, 0},\\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\\n  ],\\n};\\n\\nChromeUtils.defineLazyGetter(\\n  FormAutofillHeuristics,\\n  \\\"CREDIT_CARD_FIELDNAMES\\\",\\n  () =>\\n    Object.keys(FormAutofillHeuristics.RULES).filter(name =>\\n      lazy.FormAutofillUtils.isCreditCardField(name)\\n    )\\n);\\n\\nChromeUtils.defineLazyGetter(FormAutofillHeuristics, \\\"ADDRESS_FIELDNAMES\\\", () =>\\n  Object.keys(FormAutofillHeuristics.RULES).filter(name =>\\n    lazy.FormAutofillUtils.isAddressField(name)\\n  )\\n);\\n\\nexport default FormAutofillHeuristics;\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs ***!
  \**************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n// FormAutofillNameUtils is initially translated from\\n// https://cs.chromium.org/chromium/src/components/autofill/core/browser/autofill_data_util.cc?rcl=b861deff77abecff11ae6a9f6946e9cc844b9817\\nexport var FormAutofillNameUtils = {\\n  NAME_PREFIXES: [\\n    \\\"1lt\\\",\\n    \\\"1st\\\",\\n    \\\"2lt\\\",\\n    \\\"2nd\\\",\\n    \\\"3rd\\\",\\n    \\\"admiral\\\",\\n    \\\"capt\\\",\\n    \\\"captain\\\",\\n    \\\"col\\\",\\n    \\\"cpt\\\",\\n    \\\"dr\\\",\\n    \\\"gen\\\",\\n    \\\"general\\\",\\n    \\\"lcdr\\\",\\n    \\\"lt\\\",\\n    \\\"ltc\\\",\\n    \\\"ltg\\\",\\n    \\\"ltjg\\\",\\n    \\\"maj\\\",\\n    \\\"major\\\",\\n    \\\"mg\\\",\\n    \\\"mr\\\",\\n    \\\"mrs\\\",\\n    \\\"ms\\\",\\n    \\\"pastor\\\",\\n    \\\"prof\\\",\\n    \\\"rep\\\",\\n    \\\"reverend\\\",\\n    \\\"rev\\\",\\n    \\\"sen\\\",\\n    \\\"st\\\",\\n  ],\\n\\n  NAME_SUFFIXES: [\\n    \\\"b.a\\\",\\n    \\\"ba\\\",\\n    \\\"d.d.s\\\",\\n    \\\"dds\\\",\\n    \\\"i\\\",\\n    \\\"ii\\\",\\n    \\\"iii\\\",\\n    \\\"iv\\\",\\n    \\\"ix\\\",\\n    \\\"jr\\\",\\n    \\\"m.a\\\",\\n    \\\"m.d\\\",\\n    \\\"ma\\\",\\n    \\\"md\\\",\\n    \\\"ms\\\",\\n    \\\"ph.d\\\",\\n    \\\"phd\\\",\\n    \\\"sr\\\",\\n    \\\"v\\\",\\n    \\\"vi\\\",\\n    \\\"vii\\\",\\n    \\\"viii\\\",\\n    \\\"x\\\",\\n  ],\\n\\n  FAMILY_NAME_PREFIXES: [\\n    \\\"d'\\\",\\n    \\\"de\\\",\\n    \\\"del\\\",\\n    \\\"der\\\",\\n    \\\"di\\\",\\n    \\\"la\\\",\\n    \\\"le\\\",\\n    \\\"mc\\\",\\n    \\\"san\\\",\\n    \\\"st\\\",\\n    \\\"ter\\\",\\n    \\\"van\\\",\\n    \\\"von\\\",\\n  ],\\n\\n  // The common and non-ambiguous CJK surnames (last names) that have more than\\n  // one character.\\n  COMMON_CJK_MULTI_CHAR_SURNAMES: [\\n    // Korean, taken from the list of surnames:\\n    // https://ko.wikipedia.org/wiki/%ED%95%9C%EA%B5%AD%EC%9D%98_%EC%84%B1%EC%94%A8_%EB%AA%A9%EB%A1%9D\\n    \\\"남궁\\\",\\n    \\\"사공\\\",\\n    \\\"서문\\\",\\n    \\\"선우\\\",\\n    \\\"제갈\\\",\\n    \\\"황보\\\",\\n    \\\"독고\\\",\\n    \\\"망절\\\",\\n\\n    // Chinese, taken from the top 10 Chinese 2-character surnames:\\n    // https://zh.wikipedia.org/wiki/%E8%A4%87%E5%A7%93#.E5.B8.B8.E8.A6.8B.E7.9A.84.E8.A4.87.E5.A7.93\\n    // Simplified Chinese (mostly mainland China)\\n    \\\"欧阳\\\",\\n    \\\"令狐\\\",\\n    \\\"皇甫\\\",\\n    \\\"上官\\\",\\n    \\\"司徒\\\",\\n    \\\"诸葛\\\",\\n    \\\"司马\\\",\\n    \\\"宇文\\\",\\n    \\\"呼延\\\",\\n    \\\"端木\\\",\\n    // Traditional Chinese (mostly Taiwan)\\n    \\\"張簡\\\",\\n    \\\"歐陽\\\",\\n    \\\"諸葛\\\",\\n    \\\"申屠\\\",\\n    \\\"尉遲\\\",\\n    \\\"司馬\\\",\\n    \\\"軒轅\\\",\\n    \\\"夏侯\\\",\\n  ],\\n\\n  // All Korean surnames that have more than one character, even the\\n  // rare/ambiguous ones.\\n  KOREAN_MULTI_CHAR_SURNAMES: [\\n    \\\"강전\\\",\\n    \\\"남궁\\\",\\n    \\\"독고\\\",\\n    \\\"동방\\\",\\n    \\\"망절\\\",\\n    \\\"사공\\\",\\n    \\\"서문\\\",\\n    \\\"선우\\\",\\n    \\\"소봉\\\",\\n    \\\"어금\\\",\\n    \\\"장곡\\\",\\n    \\\"제갈\\\",\\n    \\\"황목\\\",\\n    \\\"황보\\\",\\n  ],\\n\\n  // The whitespace definition based on\\n  // https://cs.chromium.org/chromium/src/base/strings/string_util_constants.cc?l=9&rcl=b861deff77abecff11ae6a9f6946e9cc844b9817\\n  WHITESPACE: [\\n    \\\"\\\\u0009\\\", // CHARACTER TABULATION\\n    \\\"\\\\u000A\\\", // LINE FEED (LF)\\n    \\\"\\\\u000B\\\", // LINE TABULATION\\n    \\\"\\\\u000C\\\", // FORM FEED (FF)\\n    \\\"\\\\u000D\\\", // CARRIAGE RETURN (CR)\\n    \\\"\\\\u0020\\\", // SPACE\\n    \\\"\\\\u0085\\\", // NEXT LINE (NEL)\\n    \\\"\\\\u00A0\\\", // NO-BREAK SPACE\\n    \\\"\\\\u1680\\\", // OGHAM SPACE MARK\\n    \\\"\\\\u2000\\\", // EN QUAD\\n    \\\"\\\\u2001\\\", // EM QUAD\\n    \\\"\\\\u2002\\\", // EN SPACE\\n    \\\"\\\\u2003\\\", // EM SPACE\\n    \\\"\\\\u2004\\\", // THREE-PER-EM SPACE\\n    \\\"\\\\u2005\\\", // FOUR-PER-EM SPACE\\n    \\\"\\\\u2006\\\", // SIX-PER-EM SPACE\\n    \\\"\\\\u2007\\\", // FIGURE SPACE\\n    \\\"\\\\u2008\\\", // PUNCTUATION SPACE\\n    \\\"\\\\u2009\\\", // THIN SPACE\\n    \\\"\\\\u200A\\\", // HAIR SPACE\\n    \\\"\\\\u2028\\\", // LINE SEPARATOR\\n    \\\"\\\\u2029\\\", // PARAGRAPH SEPARATOR\\n    \\\"\\\\u202F\\\", // NARROW NO-BREAK SPACE\\n    \\\"\\\\u205F\\\", // MEDIUM MATHEMATICAL SPACE\\n    \\\"\\\\u3000\\\", // IDEOGRAPHIC SPACE\\n  ],\\n\\n  // The middle dot is used as a separator for foreign names in Japanese.\\n  MIDDLE_DOT: [\\n    \\\"\\\\u30FB\\\", // KATAKANA MIDDLE DOT\\n    \\\"\\\\u00B7\\\", // A (common?) typo for \\\"KATAKANA MIDDLE DOT\\\"\\n  ],\\n\\n  // The Unicode range is based on Wiki:\\n  // https://en.wikipedia.org/wiki/CJK_Unified_Ideographs\\n  // https://en.wikipedia.org/wiki/Hangul\\n  // https://en.wikipedia.org/wiki/Japanese_writing_system\\n  CJK_RANGE: [\\n    \\\"\\\\u1100-\\\\u11FF\\\", // Hangul Jamo\\n    \\\"\\\\u3040-\\\\u309F\\\", // Hiragana\\n    \\\"\\\\u30A0-\\\\u30FF\\\", // Katakana\\n    \\\"\\\\u3105-\\\\u312C\\\", // Bopomofo\\n    \\\"\\\\u3130-\\\\u318F\\\", // Hangul Compatibility Jamo\\n    \\\"\\\\u31F0-\\\\u31FF\\\", // Katakana Phonetic Extensions\\n    \\\"\\\\u3200-\\\\u32FF\\\", // Enclosed CJK Letters and Months\\n    \\\"\\\\u3400-\\\\u4DBF\\\", // CJK unified ideographs Extension A\\n    \\\"\\\\u4E00-\\\\u9FFF\\\", // CJK Unified Ideographs\\n    \\\"\\\\uA960-\\\\uA97F\\\", // Hangul Jamo Extended-A\\n    \\\"\\\\uAC00-\\\\uD7AF\\\", // Hangul Syllables\\n    \\\"\\\\uD7B0-\\\\uD7FF\\\", // Hangul Jamo Extended-B\\n    \\\"\\\\uFF00-\\\\uFFEF\\\", // Halfwidth and Fullwidth Forms\\n  ],\\n\\n  HANGUL_RANGE: [\\n    \\\"\\\\u1100-\\\\u11FF\\\", // Hangul Jamo\\n    \\\"\\\\u3130-\\\\u318F\\\", // Hangul Compatibility Jamo\\n    \\\"\\\\uA960-\\\\uA97F\\\", // Hangul Jamo Extended-A\\n    \\\"\\\\uAC00-\\\\uD7AF\\\", // Hangul Syllables\\n    \\\"\\\\uD7B0-\\\\uD7FF\\\", // Hangul Jamo Extended-B\\n  ],\\n\\n  _dataLoaded: false,\\n\\n  // Returns true if |set| contains |token|, modulo a final period.\\n  _containsString(set, token) {\\n    let target = token.replace(/\\\\.$/, \\\"\\\").toLowerCase();\\n    return set.includes(target);\\n  },\\n\\n  // Removes common name prefixes from |name_tokens|.\\n  _stripPrefixes(nameTokens) {\\n    for (let i in nameTokens) {\\n      if (!this._containsString(this.NAME_PREFIXES, nameTokens[i])) {\\n        return nameTokens.slice(i);\\n      }\\n    }\\n    return [];\\n  },\\n\\n  // Removes common name suffixes from |name_tokens|.\\n  _stripSuffixes(nameTokens) {\\n    for (let i = nameTokens.length - 1; i >= 0; i--) {\\n      if (!this._containsString(this.NAME_SUFFIXES, nameTokens[i])) {\\n        return nameTokens.slice(0, i + 1);\\n      }\\n    }\\n    return [];\\n  },\\n\\n  _isCJKName(name) {\\n    // The name is considered to be a CJK name if it is only CJK characters,\\n    // spaces, and \\\"middle dot\\\" separators, with at least one CJK character, and\\n    // no more than 2 words.\\n    //\\n    // Chinese and Japanese names are usually spelled out using the Han\\n    // characters (logographs), which constitute the \\\"CJK Unified Ideographs\\\"\\n    // block in Unicode, also referred to as Unihan. Korean names are usually\\n    // spelled out in the Korean alphabet (Hangul), although they do have a Han\\n    // equivalent as well.\\n\\n    if (!name) {\\n      return false;\\n    }\\n\\n    let previousWasCJK = false;\\n    let wordCount = 0;\\n\\n    for (let c of name) {\\n      let isMiddleDot = this.MIDDLE_DOT.includes(c);\\n      let isCJK = !isMiddleDot && this.reCJK.test(c);\\n      if (!isCJK && !isMiddleDot && !this.WHITESPACE.includes(c)) {\\n        return false;\\n      }\\n      if (isCJK && !previousWasCJK) {\\n        wordCount++;\\n      }\\n      previousWasCJK = isCJK;\\n    }\\n\\n    return wordCount > 0 && wordCount < 3;\\n  },\\n\\n  // Tries to split a Chinese, Japanese, or Korean name into its given name &\\n  // surname parts. If splitting did not work for whatever reason, returns null.\\n  _splitCJKName(nameTokens) {\\n    // The convention for CJK languages is to put the surname (last name) first,\\n    // and the given name (first name) second. In a continuous text, there is\\n    // normally no space between the two parts of the name. When entering their\\n    // name into a field, though, some people add a space to disambiguate. CJK\\n    // names (almost) never have a middle name.\\n\\n    let reHangulName = new RegExp(\\n      \\\"^[\\\" + this.HANGUL_RANGE.join(\\\"\\\") + this.WHITESPACE.join(\\\"\\\") + \\\"]+$\\\",\\n      \\\"u\\\"\\n    );\\n    let nameParts = {\\n      given: \\\"\\\",\\n      middle: \\\"\\\",\\n      family: \\\"\\\",\\n    };\\n\\n    if (nameTokens.length == 1) {\\n      // There is no space between the surname and given name. Try to infer\\n      // where to separate between the two. Most Chinese and Korean surnames\\n      // have only one character, but there are a few that have 2. If the name\\n      // does not start with a surname from a known list, default to one\\n      // character.\\n      let name = nameTokens[0];\\n      let isKorean = reHangulName.test(name);\\n      let surnameLength = 0;\\n\\n      // 4-character Korean names are more likely to be 2/2 than 1/3, so use\\n      // the full list of Korean 2-char surnames. (instead of only the common\\n      // ones)\\n      let multiCharSurnames =\\n        isKorean && name.length > 3\\n          ? this.KOREAN_MULTI_CHAR_SURNAMES\\n          : this.COMMON_CJK_MULTI_CHAR_SURNAMES;\\n\\n      // Default to 1 character if the surname is not in the list.\\n      surnameLength = multiCharSurnames.some(surname =>\\n        name.startsWith(surname)\\n      )\\n        ? 2\\n        : 1;\\n\\n      nameParts.family = name.substr(0, surnameLength);\\n      nameParts.given = name.substr(surnameLength);\\n    } else if (nameTokens.length == 2) {\\n      // The user entered a space between the two name parts. This makes our job\\n      // easier. Family name first, given name second.\\n      nameParts.family = nameTokens[0];\\n      nameParts.given = nameTokens[1];\\n    } else {\\n      return null;\\n    }\\n\\n    return nameParts;\\n  },\\n\\n  init() {\\n    if (this._dataLoaded) {\\n      return;\\n    }\\n    this._dataLoaded = true;\\n\\n    this.reCJK = new RegExp(\\\"[\\\" + this.CJK_RANGE.join(\\\"\\\") + \\\"]\\\", \\\"u\\\");\\n  },\\n\\n  splitName(name) {\\n    let nameParts = {\\n      given: \\\"\\\",\\n      middle: \\\"\\\",\\n      family: \\\"\\\",\\n    };\\n\\n    if (!name) {\\n      return nameParts;\\n    }\\n\\n    let nameTokens = name.trim().split(/[ ,\\\\u3000\\\\u30FB\\\\u00B7]+/);\\n    nameTokens = this._stripPrefixes(nameTokens);\\n\\n    if (this._isCJKName(name)) {\\n      let parts = this._splitCJKName(nameTokens);\\n      if (parts) {\\n        return parts;\\n      }\\n    }\\n\\n    // Don't assume \\\"Ma\\\" is a suffix in John Ma.\\n    if (nameTokens.length > 2) {\\n      nameTokens = this._stripSuffixes(nameTokens);\\n    }\\n\\n    if (!nameTokens.length) {\\n      // Bad things have happened; just assume the whole thing is a given name.\\n      nameParts.given = name;\\n      return nameParts;\\n    }\\n\\n    // Only one token, assume given name.\\n    if (nameTokens.length == 1) {\\n      nameParts.given = nameTokens[0];\\n      return nameParts;\\n    }\\n\\n    // 2 or more tokens. Grab the family, which is the last word plus any\\n    // recognizable family prefixes.\\n    let familyTokens = [nameTokens.pop()];\\n    while (nameTokens.length) {\\n      let lastToken = nameTokens[nameTokens.length - 1];\\n      if (!this._containsString(this.FAMILY_NAME_PREFIXES, lastToken)) {\\n        break;\\n      }\\n      familyTokens.unshift(lastToken);\\n      nameTokens.pop();\\n    }\\n    nameParts.family = familyTokens.join(\\\" \\\");\\n\\n    // Take the last remaining token as the middle name (if there are at least 2\\n    // tokens).\\n    if (nameTokens.length >= 2) {\\n      nameParts.middle = nameTokens.pop();\\n    }\\n\\n    // Remainder is given name.\\n    nameParts.given = nameTokens.join(\\\" \\\");\\n\\n    return nameParts;\\n  },\\n\\n  joinNameParts({ given, middle, family }) {\\n    if (this._isCJKName(given) && this._isCJKName(family) && !middle) {\\n      return family + given;\\n    }\\n    return [given, middle, family]\\n      .filter(part => part && part.length)\\n      .join(\\\" \\\");\\n  },\\n};\\n\\nFormAutofillNameUtils.init();\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs ***!
  \****************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nimport { FormAutofillSection } from \\\"resource://autofill/FormAutofillSection.sys.mjs\\\";\\n\\n// Since we are listening on focus events to ping swift,\\n// focusing inputs before filling will cause an infinite loop\\nFormAutofillSection.SHOULD_FOCUS_ON_AUTOFILL = false;\\n\\nexport { FormAutofillSection };\\nexport * from \\\"resource://autofill/FormAutofillSection.sys.mjs\\\";\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs ***!
  \************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nconst lazy = {};\\nChromeUtils.defineESModuleGetters(lazy, {\\n  AutofillTelemetry: \\\"resource://gre/modules/shared/AutofillTelemetry.sys.mjs\\\",\\n  FormAutofillUtils: \\\"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\\\",\\n  FormAutofill: \\\"resource://autofill/FormAutofill.sys.mjs\\\",\\n  OSKeyStore: \\\"resource://gre/modules/OSKeyStore.sys.mjs\\\",\\n});\\n\\nclass FormSection {\\n  static ADDRESS = \\\"address\\\";\\n  static CREDIT_CARD = \\\"creditCard\\\";\\n\\n  #fieldDetails = [];\\n\\n  #name = \\\"\\\";\\n\\n  constructor(fieldDetails) {\\n    if (!fieldDetails.length) {\\n      throw new TypeError(\\\"A section should contain at least one field\\\");\\n    }\\n\\n    fieldDetails.forEach(field => this.addField(field));\\n\\n    for (const fieldDetail of fieldDetails) {\\n      if (lazy.FormAutofillUtils.isAddressField(fieldDetail.fieldName)) {\\n        this.type = FormSection.ADDRESS;\\n        break;\\n      } else if (\\n        lazy.FormAutofillUtils.isCreditCardField(fieldDetail.fieldName)\\n      ) {\\n        this.type = FormSection.CREDIT_CARD;\\n        break;\\n      }\\n    }\\n\\n    this.type ||= FormSection.ADDRESS;\\n  }\\n\\n  get fieldDetails() {\\n    return this.#fieldDetails;\\n  }\\n\\n  get name() {\\n    return this.#name;\\n  }\\n\\n  addField(fieldDetail) {\\n    this.#name ||= fieldDetail.sectionName;\\n    this.#fieldDetails.push(fieldDetail);\\n  }\\n}\\n\\nexport class FormAutofillSection {\\n  /**\\n   * Record information for fields that are in this section\\n   */\\n  #fieldDetails = [];\\n\\n  constructor(fieldDetails) {\\n    this.#fieldDetails = fieldDetails;\\n\\n    ChromeUtils.defineLazyGetter(this, \\\"log\\\", () =>\\n      lazy.FormAutofill.defineLogGetter(this, \\\"FormAutofillSection\\\")\\n    );\\n\\n    // Identifier used to correlate events relating to the same form\\n    this.flowId = Services.uuid.generateUUID().toString();\\n    this.log.debug(\\n      \\\"Creating new credit card section with flowId =\\\",\\n      this.flowId\\n    );\\n  }\\n\\n  get fieldDetails() {\\n    return this.#fieldDetails;\\n  }\\n\\n  get allFieldNames() {\\n    return this.fieldDetails.map(field => field.fieldName);\\n  }\\n\\n  /*\\n   * Examine the section is a valid section or not based on its fieldDetails or\\n   * other information. This method must be overrided.\\n   *\\n   * @returns {boolean} True for a valid section, otherwise false\\n   *\\n   */\\n  isValidSection() {\\n    throw new TypeError(\\\"isValidSection method must be overrided\\\");\\n  }\\n\\n  /*\\n   * Examine the section is an enabled section type or not based on its\\n   * preferences. This method must be overrided.\\n   *\\n   * @returns {boolean} True for an enabled section type, otherwise false\\n   *\\n   */\\n  isEnabled() {\\n    throw new TypeError(\\\"isEnabled method must be overrided\\\");\\n  }\\n\\n  /*\\n   * Examine the section is createable for storing the profile. This method\\n   * must be overrided.\\n   *\\n   * @param {Object} _record The record for examining createable\\n   * @returns {boolean} True for the record is createable, otherwise false\\n   *\\n   */\\n  isRecordCreatable(_record) {\\n    throw new TypeError(\\\"isRecordCreatable method must be overridden\\\");\\n  }\\n\\n  /**\\n   * Override this method if the profile is needed to be customized for\\n   * previewing values.\\n   *\\n   * @param {object} _profile\\n   *        A profile for pre-processing before previewing values.\\n   * @returns {boolean} Whether the profile should be previewed.\\n   */\\n  preparePreviewProfile(_profile) {\\n    return true;\\n  }\\n\\n  /**\\n   * Override this method if the profile is needed to be customized for filling\\n   * values.\\n   *\\n   * @param {object} _profile\\n   *        A profile for pre-processing before filling values.\\n   * @returns {boolean} Whether the profile should be filled.\\n   */\\n  async prepareFillingProfile(_profile) {\\n    return true;\\n  }\\n\\n  /**\\n   * The result is an array contains the sections with its belonging field details.\\n   *\\n   * @param   {Array<FieldDetails>} fieldDetails field detail array to be classified\\n   * @param   {object} options\\n   * @param   {boolean} [options.ignoreInvalidSection = false]\\n   *          True to keep invalid section in the return array. Only used by tests now\\n   * @param   {boolean} [options.ignoreUnknownField = true]\\n   *          False to keep unknown field in a section. Only used by developer tools now\\n   * @returns {Array<FormSection>} The array with the sections.\\n   */\\n  static classifySections(\\n    fieldDetails,\\n    { ignoreInvalidSection = false, ignoreUnknownField = true } = {}\\n  ) {\\n    const addressFields = [];\\n    const creditCardFields = [];\\n\\n    // 'current' refers to the last list where an field was added to.\\n    // It helps determine the appropriate list for unknown fields, defaulting to the address\\n    // field list for simplicity\\n    let current = addressFields;\\n    for (const fieldDetail of fieldDetails) {\\n      if (lazy.FormAutofillUtils.isAddressField(fieldDetail.fieldName)) {\\n        current = addressFields;\\n      } else if (\\n        lazy.FormAutofillUtils.isCreditCardField(fieldDetail.fieldName)\\n      ) {\\n        current = creditCardFields;\\n      } else if (ignoreUnknownField) {\\n        continue;\\n      }\\n      current.push(fieldDetail);\\n    }\\n\\n    const addressSections = FormAutofillSection.groupFields(addressFields);\\n    const creditCardSections =\\n      FormAutofillSection.groupFields(creditCardFields);\\n\\n    const sections = [...addressSections, ...creditCardSections].sort(\\n      (a, b) =>\\n        fieldDetails.indexOf(a.fieldDetails[0]) -\\n        fieldDetails.indexOf(b.fieldDetails[0])\\n    );\\n\\n    const autofillableSections = [];\\n    for (const section of sections) {\\n      if (!section.fieldDetails.length) {\\n        continue;\\n      }\\n\\n      const autofillableSection =\\n        section.type == FormSection.ADDRESS\\n          ? new FormAutofillAddressSection(section.fieldDetails)\\n          : new FormAutofillCreditCardSection(section.fieldDetails);\\n\\n      if (ignoreInvalidSection && !autofillableSection.isValidSection()) {\\n        continue;\\n      }\\n\\n      autofillableSections.push(autofillableSection);\\n    }\\n    return autofillableSections;\\n  }\\n\\n  /**\\n   * Groups fields into sections based on:\\n   * 1. Their `sectionName` attribute.\\n   * 2. Whether the section already contains a field with the same `fieldName`,\\n   *    If so, a new section is created.\\n   *\\n   * @param {Array} fieldDetails An array of field detail objects.\\n   * @returns {Array} An array of FormSection objects.\\n   */\\n  static groupFields(fieldDetails) {\\n    let sections = [];\\n    for (let i = 0; i < fieldDetails.length; i++) {\\n      const cur = fieldDetails[i];\\n      const [currentSection] = sections.slice(-1);\\n\\n      // The section this field might be placed into.\\n      let candidateSection = null;\\n\\n      // Use name group from autocomplete attribute (ex, section-xxx) to look for the section\\n      // we might place this field into.\\n      // If the field doesn't have a section name, the candidate section is the previous section.\\n      if (!currentSection || !cur.sectionName) {\\n        candidateSection = currentSection;\\n      } else if (cur.sectionName) {\\n        // If the field has a section name, the candidate section is the nearest section that\\n        // either shares the same name or lacks a name.\\n        for (let idx = sections.length - 1; idx >= 0; idx--) {\\n          if (!sections[idx].name || sections[idx].name == cur.sectionName) {\\n            candidateSection = sections[idx];\\n            break;\\n          }\\n        }\\n      }\\n\\n      if (candidateSection) {\\n        // The field will still be placed in a new section if it is a duplicate of\\n        // an existing field, unless it is a duplicate of the previous field. This\\n        // allows for fields that might commonly appear twice such as a verification\\n        // email field, an invisible field that appears next to the user-visible field,\\n        // and simple cases where a page error where a field name is reused twice.\\n        let dupIndex = candidateSection.fieldDetails.findIndex(\\n          f => f.fieldName == cur.fieldName && f.isVisible && cur.isVisible\\n        );\\n        let isDuplicate = dupIndex != -1;\\n\\n        if (isDuplicate) {\\n          const [last] = candidateSection.fieldDetails.slice(-1);\\n          if (last.fieldName == cur.fieldName) {\\n            isDuplicate = false;\\n          } else if (\\n            lazy.FormAutofillUtils.getCategoryFromFieldName(cur.fieldName) ==\\n            \\\"name\\\"\\n          ) {\\n            // If the duplicate field is in the \\\"name\\\" category (e.g., family-name, given-name),\\n            // we check whether all fields starting from the first duplicate also belong to the\\n            // name category. If they do, we don't consider the field a duplicate, since name\\n            // fields often appear in groups like family-name + given-name.\\n            isDuplicate = !candidateSection.fieldDetails\\n              .slice(dupIndex)\\n              .every(\\n                f =>\\n                  lazy.FormAutofillUtils.getCategoryFromFieldName(\\n                    f.fieldName\\n                  ) === \\\"name\\\"\\n              );\\n          }\\n        }\\n\\n        if (!isDuplicate) {\\n          candidateSection.addField(cur);\\n          continue;\\n        }\\n      }\\n\\n      // Create a new section\\n      sections.push(new FormSection([cur]));\\n    }\\n\\n    return sections;\\n  }\\n\\n  /**\\n   * Return the record that is converted from the element's value.\\n   * The `valueByElementId` is passed by the child process.\\n   *\\n   * @returns {object} object keyed by field name, and values are field values.\\n   */\\n  createRecord(formFilledData) {\\n    if (!this.fieldDetails.length) {\\n      return {};\\n    }\\n\\n    const data = {\\n      flowId: this.flowId,\\n      record: {},\\n    };\\n\\n    for (const detail of this.fieldDetails) {\\n      // Do not save security code.\\n      if (detail.fieldName == \\\"cc-csc\\\") {\\n        continue;\\n      }\\n      const { filledValue } = formFilledData.get(detail.elementId) ?? {};\\n\\n      if (\\n        !filledValue ||\\n        filledValue.length > lazy.FormAutofillUtils.MAX_FIELD_VALUE_LENGTH\\n      ) {\\n        // Keep the property and preserve more information for updating\\n        data.record[detail.fieldName] = \\\"\\\";\\n      } else if (detail.part > 1) {\\n        // If there are multiple parts for the same field, concatenate the values.\\n        // This is now used in cases where the credit card number field\\n        // is split into multiple fields.\\n        data.record[detail.fieldName] += filledValue;\\n      } else {\\n        data.record[detail.fieldName] = filledValue;\\n      }\\n    }\\n\\n    if (!this.isRecordCreatable(data.record)) {\\n      return null;\\n    }\\n\\n    return data;\\n  }\\n\\n  /**\\n   * Heuristics to determine which fields to autofill when a section contains\\n   * multiple fields of the same type.\\n   */\\n  getAutofillFields() {\\n    return this.fieldDetails.filter(fieldDetail => {\\n      // We don't save security code, but if somehow the profile has securty code,\\n      // make sure we don't autofill it.\\n      if (fieldDetail.fieldName == \\\"cc-csc\\\") {\\n        return false;\\n      }\\n\\n      // When both visible and invisible elements exist, we only autofill the\\n      // visible element.\\n      if (!fieldDetail.isVisible) {\\n        return !this.fieldDetails.some(\\n          field => field.fieldName == fieldDetail.fieldName && field.isVisible\\n        );\\n      }\\n      return true;\\n    });\\n  }\\n\\n  /*\\n   * For telemetry\\n   */\\n  onDetected() {\\n    if (!this.isValidSection()) {\\n      return;\\n    }\\n\\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\\n      \\\"detected\\\",\\n      this.flowId,\\n      this.fieldDetails\\n    );\\n  }\\n\\n  onPopupOpened(elementId) {\\n    const fieldDetail = this.getFieldDetailByElementId(elementId);\\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\\n      \\\"popup_shown\\\",\\n      this.flowId,\\n      [fieldDetail]\\n    );\\n  }\\n\\n  onFilled(filledResult) {\\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\\n      \\\"filled\\\",\\n      this.flowId,\\n      this.fieldDetails,\\n      filledResult\\n    );\\n  }\\n\\n  onFilledOnFieldsUpdate(filledResult) {\\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\\n      \\\"filled_on_fields_update\\\",\\n      this.flowId,\\n      this.fieldDetails,\\n      filledResult\\n    );\\n  }\\n\\n  onFilledModified(elementId) {\\n    const fieldDetail = this.getFieldDetailByElementId(elementId);\\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\\n      \\\"filled_modified\\\",\\n      this.flowId,\\n      [fieldDetail]\\n    );\\n  }\\n\\n  onSubmitted(formFilledData) {\\n    this.submitted = true;\\n\\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\\n      \\\"submitted\\\",\\n      this.flowId,\\n      this.fieldDetails,\\n      formFilledData\\n    );\\n  }\\n\\n  onCleared(elementId) {\\n    const fieldDetail = this.getFieldDetailByElementId(elementId);\\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\\\"cleared\\\", this.flowId, [\\n      fieldDetail,\\n    ]);\\n  }\\n\\n  /**\\n   * Utility functions\\n   */\\n  getFieldDetailByElementId(elementId) {\\n    return this.fieldDetails.find(detail => detail.elementId == elementId);\\n  }\\n\\n  /**\\n   * Groups an array of field details by their browsing context IDs.\\n   *\\n   * @param {Array} fieldDetails\\n   *        Array of fieldDetails object\\n   *\\n   * @returns {object}\\n   *        An object keyed by BrowsingContext Id, value is an array that\\n   *        contains all fieldDetails with the same BrowsingContext id.\\n   */\\n  static groupFieldDetailsByBrowsingContext(fieldDetails) {\\n    const detailsByBC = {};\\n    for (const fieldDetail of fieldDetails) {\\n      const bcid = fieldDetail.browsingContextId;\\n      if (detailsByBC[bcid]) {\\n        detailsByBC[bcid].push(fieldDetail);\\n      } else {\\n        detailsByBC[bcid] = [fieldDetail];\\n      }\\n    }\\n    return detailsByBC;\\n  }\\n}\\n\\nexport class FormAutofillAddressSection extends FormAutofillSection {\\n  isValidSection() {\\n    const fields = new Set(this.fieldDetails.map(f => f.fieldName));\\n    return fields.size >= lazy.FormAutofillUtils.AUTOFILL_FIELDS_THRESHOLD;\\n  }\\n\\n  isEnabled() {\\n    return lazy.FormAutofill.isAutofillAddressesEnabled;\\n  }\\n\\n  isRecordCreatable(record) {\\n    const country = lazy.FormAutofillUtils.identifyCountryCode(\\n      record.country || record[\\\"country-name\\\"]\\n    );\\n    if (\\n      country &&\\n      !lazy.FormAutofill.isAutofillAddressesAvailableInCountry(country)\\n    ) {\\n      // We don't want to save data in the wrong fields due to not having proper\\n      // heuristic regexes in countries we don't yet support.\\n      this.log.warn(\\n        \\\"isRecordCreatable: Country not supported:\\\",\\n        record.country\\n      );\\n      return false;\\n    }\\n\\n    // Multiple name or tel fields are treat as 1 field while countng whether\\n    // the number of fields exceed the valid address secton threshold\\n    const categories = Object.entries(record)\\n      .filter(e => !!e[1])\\n      .map(e => lazy.FormAutofillUtils.getCategoryFromFieldName(e[0]));\\n\\n    return (\\n      categories.reduce(\\n        (acc, category) =>\\n          [\\\"name\\\", \\\"tel\\\"].includes(category) && acc.includes(category)\\n            ? acc\\n            : [...acc, category],\\n        []\\n      ).length >= lazy.FormAutofillUtils.AUTOFILL_FIELDS_THRESHOLD\\n    );\\n  }\\n}\\n\\nexport class FormAutofillCreditCardSection extends FormAutofillSection {\\n  /**\\n   * Determine whether a set of cc fields identified by our heuristics form a\\n   * valid credit card section.\\n   * There are 4 different cases when a field is considered a credit card field\\n   * 1. Identified by autocomplete attribute. ex <input autocomplete=\\\"cc-number\\\">\\n   * 2. Identified by fathom and fathom is pretty confident (when confidence\\n   *    value is higher than `highConfidenceThreshold`)\\n   * 3. Identified by fathom. Confidence value is between `fathom.confidenceThreshold`\\n   *    and `fathom.highConfidenceThreshold`\\n   * 4. Identified by regex-based heurstic. There is no confidence value in thise case.\\n   *\\n   * A form is considered a valid credit card form when one of the following condition\\n   * is met:\\n   * A. One of the cc field is identified by autocomplete (case 1)\\n   * B. One of the cc field is identified by fathom (case 2 or 3), and there is also\\n   *    another cc field found by any of our heuristic (case 2, 3, or 4)\\n   * C. Only one cc field is found in the section, but fathom is very confident (Case 2).\\n   *    Currently we add an extra restriction to this rule to decrease the false-positive\\n   *    rate. See comments below for details.\\n   *\\n   * @returns {boolean} True for a valid section, otherwise false\\n   */\\n  isValidSection() {\\n    let ccNumberDetail = null;\\n    let ccNameDetail = null;\\n    let ccExpiryDetail = null;\\n\\n    for (let detail of this.fieldDetails) {\\n      switch (detail.fieldName) {\\n        case \\\"cc-number\\\":\\n          ccNumberDetail = detail;\\n          break;\\n        case \\\"cc-name\\\":\\n        case \\\"cc-given-name\\\":\\n        case \\\"cc-additional-name\\\":\\n        case \\\"cc-family-name\\\":\\n          ccNameDetail = detail;\\n          break;\\n        case \\\"cc-exp\\\":\\n        case \\\"cc-exp-month\\\":\\n        case \\\"cc-exp-year\\\":\\n          ccExpiryDetail = detail;\\n          break;\\n      }\\n    }\\n\\n    // Condition A. Always trust autocomplete attribute. A section is considered a valid\\n    // cc section as long as a field has autocomplete=cc-number, cc-name or cc-exp*\\n    if (\\n      ccNumberDetail?.reason == \\\"autocomplete\\\" ||\\n      ccNameDetail?.reason == \\\"autocomplete\\\" ||\\n      ccExpiryDetail?.reason == \\\"autocomplete\\\"\\n    ) {\\n      return true;\\n    }\\n\\n    // Condition B. One of the field is identified by fathom, if this section also\\n    // contains another cc field found by our heuristic (Case 2, 3, or 4), we consider\\n    // this section a valid credit card seciton\\n    if (ccNumberDetail?.reason == \\\"fathom\\\") {\\n      if (ccNameDetail || ccExpiryDetail) {\\n        return true;\\n      }\\n    } else if (ccNameDetail?.reason == \\\"fathom\\\") {\\n      if (ccNumberDetail || ccExpiryDetail) {\\n        return true;\\n      }\\n    }\\n\\n    // Condition C.\\n    if (\\n      ccNumberDetail?.isOnlyVisibleFieldWithHighConfidence ||\\n      ccNameDetail?.isOnlyVisibleFieldWithHighConfidence\\n    ) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  isEnabled() {\\n    return lazy.FormAutofill.isAutofillCreditCardsEnabled;\\n  }\\n\\n  isRecordCreatable(record) {\\n    return (\\n      record[\\\"cc-number\\\"] &&\\n      lazy.FormAutofillUtils.isCCNumber(record[\\\"cc-number\\\"])\\n    );\\n  }\\n\\n  /**\\n   * Customize for previewing profile\\n   *\\n   * @param {object} profile\\n   *        A profile for pre-processing before previewing values.\\n   * @returns {boolean} Whether the profile should be filled.\\n   * @override\\n   */\\n  preparePreviewProfile(profile) {\\n    if (!profile) {\\n      return true;\\n    }\\n\\n    // Always show the decrypted credit card number when Master Password is\\n    // disabled.\\n    if (profile[\\\"cc-number-decrypted\\\"]) {\\n      profile[\\\"cc-number\\\"] = profile[\\\"cc-number-decrypted\\\"];\\n    } else if (!profile[\\\"cc-number\\\"].startsWith(\\\"****\\\")) {\\n      // Show the previewed credit card as \\\"**** 4444\\\" which is\\n      // needed when a credit card number field has a maxlength of four.\\n      profile[\\\"cc-number\\\"] = \\\"****\\\" + profile[\\\"cc-number\\\"];\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * Customize for filling profile\\n   *\\n   * @param {object} profile\\n   *        A profile for pre-processing before filling values.\\n   * @returns {boolean} Whether the profile should be filled.\\n   * @override\\n   */\\n  async prepareFillingProfile(profile) {\\n    // Prompt the OS login dialog to get the decrypted credit card number.\\n    if (profile[\\\"cc-number-encrypted\\\"]) {\\n      const promptMessage = lazy.FormAutofillUtils.reauthOSPromptMessage(\\n        \\\"autofill-use-payment-method-os-prompt-macos\\\",\\n        \\\"autofill-use-payment-method-os-prompt-windows\\\",\\n        \\\"autofill-use-payment-method-os-prompt-other\\\"\\n      );\\n      let decrypted;\\n      let result;\\n      try {\\n        decrypted = await this.getDecryptedString(\\n          profile[\\\"cc-number-encrypted\\\"],\\n          promptMessage\\n        );\\n        result = decrypted ? \\\"success\\\" : \\\"fail_user_canceled\\\";\\n      } catch (ex) {\\n        result = \\\"fail_error\\\";\\n        throw ex;\\n      } finally {\\n        Glean.formautofill.promptShownOsReauth.record({\\n          trigger: \\\"autofill\\\",\\n          result,\\n        });\\n      }\\n      if (!decrypted) {\\n        // Early return if the decrypted is empty or undefined\\n        return false;\\n      }\\n      profile[\\\"cc-number\\\"] = decrypted;\\n    }\\n    return true;\\n  }\\n\\n  async getDecryptedString(cipherText, reauth) {\\n    if (\\n      !lazy.FormAutofillUtils.getOSAuthEnabled(\\n        lazy.FormAutofill.AUTOFILL_CREDITCARDS_REAUTH_PREF\\n      )\\n    ) {\\n      this.log.debug(\\\"Reauth is disabled\\\");\\n      reauth = false;\\n    }\\n    let string;\\n    let errorResult = 0;\\n    try {\\n      string = await lazy.OSKeyStore.decrypt(cipherText, reauth);\\n    } catch (e) {\\n      errorResult = e.result;\\n      if (e.result != Cr.NS_ERROR_ABORT) {\\n        throw e;\\n      }\\n      this.log.warn(\\\"User canceled encryption login\\\");\\n    } finally {\\n      Glean.creditcard.osKeystoreDecrypt.record({\\n        isDecryptSuccess: errorResult === 0,\\n        errorResult,\\n        trigger: \\\"autofill\\\",\\n      });\\n    }\\n    return string;\\n  }\\n}\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs ***!
  \**********************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nimport { FormAutofill } from \\\"resource://autofill/FormAutofill.sys.mjs\\\";\\nimport { XPCOMUtils } from \\\"resource://gre/modules/XPCOMUtils.sys.mjs\\\";\\nimport { AppConstants } from \\\"resource://gre/modules/AppConstants.sys.mjs\\\";\\n\\nconst lazy = {};\\nChromeUtils.defineESModuleGetters(lazy, {\\n  ContentDOMReference: \\\"resource://gre/modules/ContentDOMReference.sys.mjs\\\",\\n  CreditCard: \\\"resource://gre/modules/CreditCard.sys.mjs\\\",\\n  FormAutofillNameUtils:\\n    \\\"resource://gre/modules/shared/FormAutofillNameUtils.sys.mjs\\\",\\n  OSKeyStore: \\\"resource://gre/modules/OSKeyStore.sys.mjs\\\",\\n  AddressMetaDataLoader:\\n    \\\"resource://gre/modules/shared/AddressMetaDataLoader.sys.mjs\\\",\\n});\\n\\nChromeUtils.defineLazyGetter(\\n  lazy,\\n  \\\"l10n\\\",\\n  () =>\\n    new Localization(\\n      [\\\"toolkit/formautofill/formAutofill.ftl\\\", \\\"branding/brand.ftl\\\"],\\n      true\\n    )\\n);\\n\\nXPCOMUtils.defineLazyServiceGetter(\\n  lazy,\\n  \\\"Crypto\\\",\\n  \\\"@mozilla.org/login-manager/crypto/SDR;1\\\",\\n  \\\"nsILoginManagerCrypto\\\"\\n);\\n\\nexport let FormAutofillUtils;\\n\\nconst ADDRESSES_COLLECTION_NAME = \\\"addresses\\\";\\nconst CREDITCARDS_COLLECTION_NAME = \\\"creditCards\\\";\\nconst AUTOFILL_CREDITCARDS_REAUTH_PREF =\\n  FormAutofill.AUTOFILL_CREDITCARDS_REAUTH_PREF;\\nconst MANAGE_ADDRESSES_L10N_IDS = [\\n  \\\"autofill-add-address-title\\\",\\n  \\\"autofill-manage-addresses-title\\\",\\n];\\nconst EDIT_ADDRESS_L10N_IDS = [\\n  \\\"autofill-address-name\\\",\\n  \\\"autofill-address-organization\\\",\\n  \\\"autofill-address-street\\\",\\n  \\\"autofill-address-state\\\",\\n  \\\"autofill-address-province\\\",\\n  \\\"autofill-address-city\\\",\\n  \\\"autofill-address-country\\\",\\n  \\\"autofill-address-zip\\\",\\n  \\\"autofill-address-postal-code\\\",\\n  \\\"autofill-address-email\\\",\\n  \\\"autofill-address-tel\\\",\\n  \\\"autofill-edit-address-title\\\",\\n  \\\"autofill-address-neighborhood\\\",\\n  \\\"autofill-address-village-township\\\",\\n  \\\"autofill-address-island\\\",\\n  \\\"autofill-address-townland\\\",\\n  \\\"autofill-address-district\\\",\\n  \\\"autofill-address-county\\\",\\n  \\\"autofill-address-post-town\\\",\\n  \\\"autofill-address-suburb\\\",\\n  \\\"autofill-address-parish\\\",\\n  \\\"autofill-address-prefecture\\\",\\n  \\\"autofill-address-area\\\",\\n  \\\"autofill-address-do-si\\\",\\n  \\\"autofill-address-department\\\",\\n  \\\"autofill-address-emirate\\\",\\n  \\\"autofill-address-oblast\\\",\\n  \\\"autofill-address-pin\\\",\\n  \\\"autofill-address-eircode\\\",\\n  \\\"autofill-address-country-only\\\",\\n  \\\"autofill-cancel-button\\\",\\n  \\\"autofill-save-button\\\",\\n];\\nconst MANAGE_CREDITCARDS_L10N_IDS = [\\n  \\\"autofill-add-card-title\\\",\\n  \\\"autofill-manage-payment-methods-title\\\",\\n];\\nconst EDIT_CREDITCARD_L10N_IDS = [\\n  \\\"autofill-card-number\\\",\\n  \\\"autofill-card-name-on-card\\\",\\n  \\\"autofill-card-expires-month\\\",\\n  \\\"autofill-card-expires-year\\\",\\n  \\\"autofill-card-network\\\",\\n];\\nconst FIELD_STATES = {\\n  NORMAL: \\\"\\\",\\n  AUTO_FILLED: \\\"autofill\\\",\\n  PREVIEW: \\\"preview\\\",\\n};\\nconst FORM_SUBMISSION_REASON = {\\n  FORM_SUBMIT_EVENT: \\\"form-submit-event\\\",\\n  FORM_REMOVAL_AFTER_FETCH: \\\"form-removal-after-fetch\\\",\\n  IFRAME_PAGEHIDE: \\\"iframe-pagehide\\\",\\n  PAGE_NAVIGATION: \\\"page-navigation\\\",\\n};\\n\\nconst ELIGIBLE_ELEMENT_TYPES = [\\\"input\\\", \\\"select\\\", \\\"textarea\\\"];\\nconst ELIGIBLE_INPUT_TYPES = [\\n  \\\"text\\\",\\n  \\\"email\\\",\\n  \\\"tel\\\",\\n  \\\"number\\\",\\n  \\\"month\\\",\\n  \\\"search\\\",\\n];\\n\\n// The maximum length of data to be saved in a single field for preventing DoS\\n// attacks that fill the user's hard drive(s).\\nconst MAX_FIELD_VALUE_LENGTH = 200;\\n\\nFormAutofillUtils = {\\n  get AUTOFILL_FIELDS_THRESHOLD() {\\n    return 3;\\n  },\\n\\n  ADDRESSES_COLLECTION_NAME,\\n  CREDITCARDS_COLLECTION_NAME,\\n  AUTOFILL_CREDITCARDS_REAUTH_PREF,\\n  MANAGE_ADDRESSES_L10N_IDS,\\n  EDIT_ADDRESS_L10N_IDS,\\n  MANAGE_CREDITCARDS_L10N_IDS,\\n  EDIT_CREDITCARD_L10N_IDS,\\n  MAX_FIELD_VALUE_LENGTH,\\n  FIELD_STATES,\\n  FORM_SUBMISSION_REASON,\\n  ELIGIBLE_ELEMENT_TYPES,\\n  ELIGIBLE_INPUT_TYPES,\\n\\n  _fieldNameInfo: {\\n    name: \\\"name\\\",\\n    \\\"given-name\\\": \\\"name\\\",\\n    \\\"additional-name\\\": \\\"name\\\",\\n    \\\"family-name\\\": \\\"name\\\",\\n    organization: \\\"organization\\\",\\n    \\\"street-address\\\": \\\"address\\\",\\n    \\\"address-line1\\\": \\\"address\\\",\\n    \\\"address-line2\\\": \\\"address\\\",\\n    \\\"address-line3\\\": \\\"address\\\",\\n    \\\"address-level1\\\": \\\"address\\\",\\n    \\\"address-level2\\\": \\\"address\\\",\\n    \\\"address-level3\\\": \\\"address\\\",\\n    // DE addresses are often split into street name and house number;\\n    // combined they form address-line1\\n    \\\"address-streetname\\\": \\\"address\\\",\\n    \\\"address-housenumber\\\": \\\"address\\\",\\n    \\\"postal-code\\\": \\\"address\\\",\\n    country: \\\"address\\\",\\n    \\\"country-name\\\": \\\"address\\\",\\n    tel: \\\"tel\\\",\\n    \\\"tel-country-code\\\": \\\"tel\\\",\\n    \\\"tel-national\\\": \\\"tel\\\",\\n    \\\"tel-area-code\\\": \\\"tel\\\",\\n    \\\"tel-local\\\": \\\"tel\\\",\\n    \\\"tel-local-prefix\\\": \\\"tel\\\",\\n    \\\"tel-local-suffix\\\": \\\"tel\\\",\\n    \\\"tel-extension\\\": \\\"tel\\\",\\n    email: \\\"email\\\",\\n    \\\"cc-name\\\": \\\"creditCard\\\",\\n    \\\"cc-given-name\\\": \\\"creditCard\\\",\\n    \\\"cc-additional-name\\\": \\\"creditCard\\\",\\n    \\\"cc-family-name\\\": \\\"creditCard\\\",\\n    \\\"cc-number\\\": \\\"creditCard\\\",\\n    \\\"cc-exp-month\\\": \\\"creditCard\\\",\\n    \\\"cc-exp-year\\\": \\\"creditCard\\\",\\n    \\\"cc-exp\\\": \\\"creditCard\\\",\\n    \\\"cc-type\\\": \\\"creditCard\\\",\\n    \\\"cc-csc\\\": \\\"creditCard\\\",\\n  },\\n\\n  _collators: {},\\n  _reAlternativeCountryNames: {},\\n\\n  isAddressField(fieldName) {\\n    return (\\n      !!this._fieldNameInfo[fieldName] && !this.isCreditCardField(fieldName)\\n    );\\n  },\\n\\n  isCreditCardField(fieldName) {\\n    return this._fieldNameInfo?.[fieldName] == \\\"creditCard\\\";\\n  },\\n\\n  isCCNumber(ccNumber) {\\n    return ccNumber && lazy.CreditCard.isValidNumber(ccNumber);\\n  },\\n\\n  isTextControl(element) {\\n    return (\\n      HTMLInputElement.isInstance(element) ||\\n      HTMLTextAreaElement.isInstance(element)\\n    );\\n  },\\n\\n  queryEligibleElements(element, includeIframe = false) {\\n    const types = includeIframe\\n      ? [...ELIGIBLE_ELEMENT_TYPES, \\\"iframe\\\"]\\n      : ELIGIBLE_ELEMENT_TYPES;\\n    return Array.from(element.querySelectorAll(types.join(\\\",\\\")));\\n  },\\n\\n  /**\\n   * Get the decrypted value for a string pref.\\n   *\\n   * @param {string} prefName -> The pref whose value is needed.\\n   * @param {string} safeDefaultValue -> Value to be returned incase the pref is not yet set.\\n   * @returns {string}\\n   */\\n  getSecurePref(prefName, safeDefaultValue) {\\n    if (Services.prefs.getBoolPref(\\\"security.nocertdb\\\", false)) {\\n      return false;\\n    }\\n    try {\\n      const encryptedValue = Services.prefs.getStringPref(prefName, \\\"\\\");\\n      return encryptedValue === \\\"\\\"\\n        ? safeDefaultValue\\n        : lazy.Crypto.decrypt(encryptedValue);\\n    } catch {\\n      return safeDefaultValue;\\n    }\\n  },\\n\\n  /**\\n   * Set the pref to the encrypted form of the value.\\n   *\\n   * @param {string} prefName -> The pref whose value is to be set.\\n   * @param {string} value -> The value to be set in its encrypted form.\\n   */\\n  setSecurePref(prefName, value) {\\n    if (Services.prefs.getBoolPref(\\\"security.nocertdb\\\", false)) {\\n      return;\\n    }\\n    if (value) {\\n      const encryptedValue = lazy.Crypto.encrypt(value);\\n      Services.prefs.setStringPref(prefName, encryptedValue);\\n    } else {\\n      Services.prefs.clearUserPref(prefName);\\n    }\\n  },\\n\\n  /**\\n   * Get whether the OSAuth is enabled or not.\\n   *\\n   * @param {string} prefName -> The name of the pref (creditcards or addresses)\\n   * @returns {boolean}\\n   */\\n  getOSAuthEnabled(prefName) {\\n    return (\\n      lazy.OSKeyStore.canReauth() &&\\n      this.getSecurePref(prefName, \\\"\\\") !== \\\"opt out\\\"\\n    );\\n  },\\n\\n  /**\\n   * Set whether the OSAuth is enabled or not.\\n   *\\n   * @param {string} prefName -> The pref to encrypt.\\n   * @param {boolean} enable -> Whether the pref is to be enabled.\\n   */\\n  setOSAuthEnabled(prefName, enable) {\\n    this.setSecurePref(prefName, enable ? null : \\\"opt out\\\");\\n  },\\n\\n  async verifyUserOSAuth(\\n    prefName,\\n    promptMessage,\\n    captionDialog = \\\"\\\",\\n    parentWindow = null,\\n    generateKeyIfNotAvailable = true\\n  ) {\\n    if (!this.getOSAuthEnabled(prefName)) {\\n      promptMessage = false;\\n    }\\n    try {\\n      return (\\n        await lazy.OSKeyStore.ensureLoggedIn(\\n          promptMessage,\\n          captionDialog,\\n          parentWindow,\\n          generateKeyIfNotAvailable\\n        )\\n      ).authenticated;\\n    } catch (ex) {\\n      // Since Win throws an exception whereas Mac resolves to false upon cancelling.\\n      if (ex.result !== Cr.NS_ERROR_FAILURE) {\\n        throw ex;\\n      }\\n    }\\n    return false;\\n  },\\n\\n  /**\\n   * Get the array of credit card network ids (\\\"types\\\") we expect and offer as valid choices\\n   *\\n   * @returns {Array}\\n   */\\n  getCreditCardNetworks() {\\n    return lazy.CreditCard.getSupportedNetworks();\\n  },\\n\\n  getCategoryFromFieldName(fieldName) {\\n    return this._fieldNameInfo[fieldName];\\n  },\\n\\n  getCategoriesFromFieldNames(fieldNames) {\\n    let categories = new Set();\\n    for (let fieldName of fieldNames) {\\n      let info = this.getCategoryFromFieldName(fieldName);\\n      if (info) {\\n        categories.add(info);\\n      }\\n    }\\n    return Array.from(categories);\\n  },\\n\\n  getCollectionNameFromFieldName(fieldName) {\\n    return this.isCreditCardField(fieldName)\\n      ? CREDITCARDS_COLLECTION_NAME\\n      : ADDRESSES_COLLECTION_NAME;\\n  },\\n\\n  getAddressSeparator() {\\n    // The separator should be based on the L10N address format, and using a\\n    // white space is a temporary solution.\\n    return \\\" \\\";\\n  },\\n\\n  /**\\n   * Get address display label. It should display information separated\\n   * by a comma.\\n   *\\n   * @param  {object} address\\n   * @returns {string}\\n   */\\n  getAddressLabel(address) {\\n    // TODO: Implement a smarter way for deciding what to display\\n    //       as option text. Possibly improve the algorithm in\\n    //       ProfileAutoCompleteResult.sys.mjs and reuse it here.\\n    let fieldOrder = [\\n      \\\"name\\\",\\n      \\\"-moz-street-address-one-line\\\", // Street address\\n      \\\"address-level3\\\", // Townland / Neighborhood / Village\\n      \\\"address-level2\\\", // City/Town\\n      \\\"organization\\\", // Company or organization name\\n      \\\"address-level1\\\", // Province/State (Standardized code if possible)\\n      \\\"country\\\", // Country name\\n      \\\"postal-code\\\", // Postal code\\n      \\\"tel\\\", // Phone number\\n      \\\"email\\\", // Email address\\n    ];\\n\\n    address = { ...address };\\n    let parts = [];\\n    if (address[\\\"street-address\\\"]) {\\n      address[\\\"-moz-street-address-one-line\\\"] = this.toOneLineAddress(\\n        address[\\\"street-address\\\"]\\n      );\\n    }\\n\\n    if (!(\\\"name\\\" in address)) {\\n      address.name = lazy.FormAutofillNameUtils.joinNameParts({\\n        given: address[\\\"given-name\\\"],\\n        middle: address[\\\"additional-name\\\"],\\n        family: address[\\\"family-name\\\"],\\n      });\\n    }\\n\\n    for (const fieldName of fieldOrder) {\\n      let string = address[fieldName];\\n      if (string) {\\n        parts.push(string);\\n      }\\n    }\\n    return parts.join(\\\", \\\");\\n  },\\n\\n  /**\\n   * Internal method to split an address to multiple parts per the provided delimiter,\\n   * removing blank parts.\\n   *\\n   * @param {string} address The address the split\\n   * @param {string} [delimiter] The separator that is used between lines in the address\\n   * @returns {string[]}\\n   */\\n  _toStreetAddressParts(address, delimiter = \\\"\\\\n\\\") {\\n    let array = typeof address == \\\"string\\\" ? address.split(delimiter) : address;\\n\\n    if (!Array.isArray(array)) {\\n      return [];\\n    }\\n    return array.map(s => (s ? s.trim() : \\\"\\\")).filter(s => s);\\n  },\\n\\n  /**\\n   * Converts a street address to a single line, removing linebreaks marked by the delimiter\\n   *\\n   * @param {string} address The address the convert\\n   * @param {string} [delimiter] The separator that is used between lines in the address\\n   * @returns {string}\\n   */\\n  toOneLineAddress(address, delimiter = \\\"\\\\n\\\") {\\n    let addressParts = this._toStreetAddressParts(address, delimiter);\\n    return addressParts.join(this.getAddressSeparator());\\n  },\\n\\n  /**\\n   * Returns false if an address is written <number> <street>\\n   * and true if an address is written <street> <number>. In the future, this\\n   * can be expanded to format an address\\n   */\\n  getAddressReversed(region) {\\n    return this.getCountryAddressData(region).address_reversed;\\n  },\\n\\n  /**\\n   * In-place concatenate tel-related components into a single \\\"tel\\\" field and\\n   * delete unnecessary fields.\\n   *\\n   * @param {object} address An address record.\\n   */\\n  compressTel(address) {\\n    let telCountryCode = address[\\\"tel-country-code\\\"] || \\\"\\\";\\n    let telAreaCode = address[\\\"tel-area-code\\\"] || \\\"\\\";\\n\\n    if (!address.tel) {\\n      if (address[\\\"tel-national\\\"]) {\\n        address.tel = telCountryCode + address[\\\"tel-national\\\"];\\n      } else if (address[\\\"tel-local\\\"]) {\\n        address.tel = telCountryCode + telAreaCode + address[\\\"tel-local\\\"];\\n      } else if (address[\\\"tel-local-prefix\\\"] && address[\\\"tel-local-suffix\\\"]) {\\n        address.tel =\\n          telCountryCode +\\n          telAreaCode +\\n          address[\\\"tel-local-prefix\\\"] +\\n          address[\\\"tel-local-suffix\\\"];\\n      }\\n    }\\n\\n    for (let field in address) {\\n      if (field != \\\"tel\\\" && this.getCategoryFromFieldName(field) == \\\"tel\\\") {\\n        delete address[field];\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Determines if an element can be autofilled or not.\\n   *\\n   * @param {HTMLElement} element\\n   * @returns {boolean} true if the element can be autofilled\\n   */\\n  isFieldAutofillable(element) {\\n    return element && !element.readOnly && !element.disabled;\\n  },\\n\\n  /**\\n   * Determines if an element is visually hidden or not.\\n   *\\n   * @param {HTMLElement} element\\n   * @param {boolean} visibilityCheck true to run visiblity check against\\n   *                  element.checkVisibility API. Otherwise, test by only checking\\n   *                  `hidden` and `display` attributes\\n   * @returns {boolean} true if the element is visible\\n   */\\n  isFieldVisible(element, visibilityCheck = true) {\\n    if (\\n      visibilityCheck &&\\n      element.checkVisibility &&\\n      !FormAutofillUtils.ignoreVisibilityCheck\\n    ) {\\n      if (\\n        !element.checkVisibility({\\n          checkOpacity: true,\\n          checkVisibilityCSS: true,\\n        })\\n      ) {\\n        return false;\\n      }\\n    } else if (element.hidden || element.style.display == \\\"none\\\") {\\n      return false;\\n    }\\n\\n    return element.getAttribute(\\\"aria-hidden\\\") != \\\"true\\\";\\n  },\\n\\n  /**\\n   * Determines if an element is eligible to be used by credit card or address autofill.\\n   *\\n   * @param {HTMLElement} element\\n   * @returns {boolean} true if element can be used by credit card or address autofill\\n   */\\n  isCreditCardOrAddressFieldType(element) {\\n    if (!element) {\\n      return false;\\n    }\\n\\n    if (HTMLInputElement.isInstance(element)) {\\n      // `element.type` can be recognized as `text`, if it's missing or invalid.\\n      return ELIGIBLE_INPUT_TYPES.includes(element.type);\\n    }\\n\\n    if (HTMLTextAreaElement.isInstance(element)) {\\n      return true;\\n    }\\n\\n    return HTMLSelectElement.isInstance(element);\\n  },\\n\\n  loadDataFromScript(url, sandbox = {}) {\\n    Services.scriptloader.loadSubScript(url, sandbox);\\n    return sandbox;\\n  },\\n\\n  /**\\n   * Get country address data and fallback to US if not found.\\n   * See AddressMetaDataLoader.#loadData for more details of addressData structure.\\n   *\\n   * @param {string} [country=FormAutofill.DEFAULT_REGION]\\n   *        The country code for requesting specific country's metadata. It'll be\\n   *        default region if parameter is not set.\\n   * @param {string} [level1=null]\\n   *        Return address level 1/level 2 metadata if parameter is set.\\n   * @returns {object|null}\\n   *          Return metadata of specific region with default locale and other supported\\n   *          locales. We need to return a default country metadata for layout format\\n   *          and collator, but for sub-region metadata we'll just return null if not found.\\n   */\\n  getCountryAddressRawData(\\n    country = FormAutofill.DEFAULT_REGION,\\n    level1 = null\\n  ) {\\n    let metadata = lazy.AddressMetaDataLoader.getData(country, level1);\\n    if (!metadata) {\\n      if (level1) {\\n        return null;\\n      }\\n      // Fallback to default region if we couldn't get data from given country.\\n      if (country != FormAutofill.DEFAULT_REGION) {\\n        metadata = lazy.AddressMetaDataLoader.getData(\\n          FormAutofill.DEFAULT_REGION\\n        );\\n      }\\n    }\\n\\n    // TODO: Now we fallback to US if we couldn't get data from default region,\\n    //       but it could be removed in bug 1423464 if it's not necessary.\\n    if (!metadata) {\\n      metadata = lazy.AddressMetaDataLoader.getData(\\\"US\\\");\\n    }\\n    return metadata;\\n  },\\n\\n  /**\\n   * Get country address data with default locale.\\n   *\\n   * @param {string} country\\n   * @param {string} level1\\n   * @returns {object|null} Return metadata of specific region with default locale.\\n   *          NOTE: The returned data may be for a default region if the\\n   *          specified one cannot be found. Callers who only want the specific\\n   *          region should check the returned country code.\\n   */\\n  getCountryAddressData(country, level1) {\\n    let metadata = this.getCountryAddressRawData(country, level1);\\n    return metadata && metadata.defaultLocale;\\n  },\\n\\n  /**\\n   * Get country address data with all locales.\\n   *\\n   * @param {string} country\\n   * @param {string} level1\\n   * @returns {Array<object> | null}\\n   *          Return metadata of specific region with all the locales.\\n   *          NOTE: The returned data may be for a default region if the\\n   *          specified one cannot be found. Callers who only want the specific\\n   *          region should check the returned country code.\\n   */\\n  getCountryAddressDataWithLocales(country, level1) {\\n    let metadata = this.getCountryAddressRawData(country, level1);\\n    return metadata && [metadata.defaultLocale, ...metadata.locales];\\n  },\\n\\n  /**\\n   * Get the collators based on the specified country.\\n   *\\n   * @param {string}  country The specified country.\\n   * @param {object}  [options = {}] a list of options for this method\\n   * @param {boolean} [options.ignorePunctuation = true] Whether punctuation should be ignored.\\n   * @param {string}  [options.sensitivity = 'base'] Which differences in the strings should lead to non-zero result values\\n   * @param {string}  [options.usage = 'search'] Whether the comparison is for sorting or for searching for matching strings\\n   * @returns {Array} An array containing several collator objects.\\n   */\\n  getSearchCollators(\\n    country,\\n    { ignorePunctuation = true, sensitivity = \\\"base\\\", usage = \\\"search\\\" } = {}\\n  ) {\\n    // TODO: Only one language should be used at a time per country. The locale\\n    //       of the page should be taken into account to do this properly.\\n    //       We are going to support more countries in bug 1370193 and this\\n    //       should be addressed when we start to implement that bug.\\n\\n    if (!this._collators[country]) {\\n      let dataset = this.getCountryAddressData(country);\\n      let languages = dataset.languages || [dataset.lang];\\n      let options = {\\n        ignorePunctuation,\\n        sensitivity,\\n        usage,\\n      };\\n      this._collators[country] = languages.map(\\n        lang => new Intl.Collator(lang, options)\\n      );\\n    }\\n    return this._collators[country];\\n  },\\n\\n  // Based on the list of fields abbreviations in\\n  // https://github.com/googlei18n/libaddressinput/wiki/AddressValidationMetadata\\n  FIELDS_LOOKUP: {\\n    N: \\\"name\\\",\\n    O: \\\"organization\\\",\\n    A: \\\"street-address\\\",\\n    S: \\\"address-level1\\\",\\n    C: \\\"address-level2\\\",\\n    D: \\\"address-level3\\\",\\n    Z: \\\"postal-code\\\",\\n    n: \\\"newLine\\\",\\n  },\\n\\n  /**\\n   * Parse a country address format string and outputs an array of fields.\\n   * Spaces, commas, and other literals are ignored in this implementation.\\n   * For example, format string \\\"%A%n%C, %S\\\" should return:\\n   * [\\n   *   {fieldId: \\\"street-address\\\", newLine: true},\\n   *   {fieldId: \\\"address-level2\\\"},\\n   *   {fieldId: \\\"address-level1\\\"},\\n   * ]\\n   *\\n   * @param   {string} fmt Country address format string\\n   * @returns {Array<object>} List of fields\\n   */\\n  parseAddressFormat(fmt) {\\n    if (!fmt) {\\n      throw new Error(\\\"fmt string is missing.\\\");\\n    }\\n\\n    return fmt.match(/%[^%]/g).reduce((parsed, part) => {\\n      // Take the first letter of each segment and try to identify it\\n      let fieldId = this.FIELDS_LOOKUP[part[1]];\\n      // Early return if cannot identify part.\\n      if (!fieldId) {\\n        return parsed;\\n      }\\n      // If a new line is detected, add an attribute to the previous field.\\n      if (fieldId == \\\"newLine\\\") {\\n        let size = parsed.length;\\n        if (size) {\\n          parsed[size - 1].newLine = true;\\n        }\\n        return parsed;\\n      }\\n      return parsed.concat({ fieldId });\\n    }, []);\\n  },\\n\\n  /**\\n   * Used to populate dropdowns in the UI (e.g. FormAutofill preferences).\\n   * Use findAddressSelectOption for matching a value to a region.\\n   *\\n   * @param {string[]} subKeys An array of regionCode strings\\n   * @param {string[]} subIsoids An array of ISO ID strings, if provided will be preferred over the key\\n   * @param {string[]} subNames An array of regionName strings\\n   * @param {string[]} subLnames An array of latinised regionName strings\\n   * @returns {Map?} Returns null if subKeys or subNames are not truthy.\\n   *                   Otherwise, a Map will be returned mapping keys -> names.\\n   */\\n  buildRegionMapIfAvailable(subKeys, subIsoids, subNames, subLnames) {\\n    // Not all regions have sub_keys. e.g. DE\\n    if (\\n      !subKeys ||\\n      !subKeys.length ||\\n      (!subNames && !subLnames) ||\\n      (subNames && subKeys.length != subNames.length) ||\\n      (subLnames && subKeys.length != subLnames.length)\\n    ) {\\n      return null;\\n    }\\n\\n    // Overwrite subKeys with subIsoids, when available\\n    if (subIsoids && subIsoids.length && subIsoids.length == subKeys.length) {\\n      for (let i = 0; i < subIsoids.length; i++) {\\n        if (subIsoids[i]) {\\n          subKeys[i] = subIsoids[i];\\n        }\\n      }\\n    }\\n\\n    // Apply sub_lnames if sub_names does not exist\\n    let names = subNames || subLnames;\\n    return new Map(subKeys.map((key, index) => [key, names[index]]));\\n  },\\n\\n  /**\\n   * Parse a require string and outputs an array of fields.\\n   * Spaces, commas, and other literals are ignored in this implementation.\\n   * For example, a require string \\\"ACS\\\" should return:\\n   * [\\\"street-address\\\", \\\"address-level2\\\", \\\"address-level1\\\"]\\n   *\\n   * @param   {string} requireString Country address require string\\n   * @returns {Array<string>} List of fields\\n   */\\n  parseRequireString(requireString) {\\n    if (!requireString) {\\n      throw new Error(\\\"requireString string is missing.\\\");\\n    }\\n\\n    return requireString.split(\\\"\\\").map(fieldId => this.FIELDS_LOOKUP[fieldId]);\\n  },\\n\\n  /**\\n   * Use address data and alternative country name list to identify a country code from a\\n   * specified country name.\\n   *\\n   * @param   {string} countryName A country name to be identified\\n   * @param   {string} [countrySpecified] A country code indicating that we only\\n   *                                      search its alternative names if specified.\\n   * @returns {string} The matching country code.\\n   */\\n  identifyCountryCode(countryName, countrySpecified) {\\n    if (!countryName) {\\n      return null;\\n    }\\n\\n    if (lazy.AddressMetaDataLoader.getData(countryName)) {\\n      return countryName;\\n    }\\n\\n    const countries = countrySpecified\\n      ? [countrySpecified]\\n      : [...FormAutofill.countries.keys()];\\n\\n    for (const country of countries) {\\n      let collators = this.getSearchCollators(country);\\n      let metadata = this.getCountryAddressData(country);\\n      if (country != metadata.key) {\\n        // We hit the fallback logic in getCountryAddressRawData so ignore it as\\n        // it's not related to `country` and use the name from l10n instead.\\n        metadata = {\\n          id: `data/${country}`,\\n          key: country,\\n          name: FormAutofill.countries.get(country),\\n        };\\n      }\\n      let alternativeCountryNames = metadata.alternative_names || [\\n        metadata.name,\\n      ];\\n      let reAlternativeCountryNames = this._reAlternativeCountryNames[country];\\n      if (!reAlternativeCountryNames) {\\n        reAlternativeCountryNames = this._reAlternativeCountryNames[country] =\\n          [];\\n      }\\n\\n      if (countryName.length == 3) {\\n        if (this.strCompare(metadata.alpha_3_code, countryName, collators)) {\\n          return country;\\n        }\\n      }\\n\\n      for (let i = 0; i < alternativeCountryNames.length; i++) {\\n        let name = alternativeCountryNames[i];\\n        let reName = reAlternativeCountryNames[i];\\n        if (!reName) {\\n          reName = reAlternativeCountryNames[i] = new RegExp(\\n            \\\"\\\\\\\\b\\\" + this.escapeRegExp(name) + \\\"\\\\\\\\b\\\",\\n            \\\"i\\\"\\n          );\\n        }\\n\\n        if (\\n          this.strCompare(name, countryName, collators) ||\\n          reName.test(countryName)\\n        ) {\\n          return country;\\n        }\\n      }\\n    }\\n\\n    return null;\\n  },\\n\\n  findSelectOption(selectEl, record, fieldName) {\\n    if (this.isAddressField(fieldName)) {\\n      return this.findAddressSelectOption(selectEl.options, record, fieldName);\\n    }\\n    if (this.isCreditCardField(fieldName)) {\\n      return this.findCreditCardSelectOption(selectEl, record, fieldName);\\n    }\\n    return null;\\n  },\\n\\n  /**\\n   * Try to find the abbreviation of the given sub-region name\\n   *\\n   * @param   {string[]} subregionValues A list of inferable sub-region values.\\n   * @param   {string} [country] A country name to be identified.\\n   * @returns {string} The matching sub-region abbreviation.\\n   */\\n  getAbbreviatedSubregionName(subregionValues, country) {\\n    let values = Array.isArray(subregionValues)\\n      ? subregionValues\\n      : [subregionValues];\\n\\n    let collators = this.getSearchCollators(country);\\n    for (let metadata of this.getCountryAddressDataWithLocales(country)) {\\n      let {\\n        sub_keys: subKeys,\\n        sub_names: subNames,\\n        sub_lnames: subLnames,\\n        sub_isoids: subIsoids,\\n      } = metadata;\\n      if (!subKeys) {\\n        // Not all regions have sub_keys. e.g. DE\\n        continue;\\n      }\\n      // Apply sub_lnames if sub_names does not exist\\n      subNames = subNames || subLnames;\\n\\n      let speculatedSubIndexes = [];\\n      for (const val of values) {\\n        let identifiedValue = this.identifyValue(\\n          subKeys,\\n          subNames,\\n          subIsoids,\\n          val,\\n          collators\\n        );\\n        if (identifiedValue) {\\n          return identifiedValue;\\n        }\\n\\n        // Predict the possible state by partial-matching if no exact match.\\n        [subKeys, subNames].forEach(sub => {\\n          speculatedSubIndexes.push(\\n            sub.findIndex(token => {\\n              let pattern = new RegExp(\\n                \\\"\\\\\\\\b\\\" + this.escapeRegExp(token) + \\\"\\\\\\\\b\\\"\\n              );\\n\\n              return pattern.test(val);\\n            })\\n          );\\n        });\\n      }\\n      let subKey = subKeys[speculatedSubIndexes.find(i => !!~i)];\\n      if (subKey) {\\n        return subKey;\\n      }\\n    }\\n    return null;\\n  },\\n\\n  /**\\n   * Find the option element from select element.\\n   * 1. Try to find the locale using the country from address.\\n   * 2. First pass try to find exact match.\\n   * 3. Second pass try to identify values from address value and options,\\n   *    and look for a match.\\n   *\\n   * @param   {Array<{text: string, value: string}>} options\\n   * @param   {object} address\\n   * @param   {string} fieldName\\n   * @returns {DOMElement}\\n   */\\n  findAddressSelectOption(options, address, fieldName) {\\n    if (options.length > 512) {\\n      // Allow enough space for all countries (roughly 300 distinct values) and all\\n      // timezones (roughly 400 distinct values), plus some extra wiggle room.\\n      return null;\\n    }\\n    let value = address[fieldName];\\n    if (!value) {\\n      return null;\\n    }\\n\\n    let collators = this.getSearchCollators(address.country);\\n\\n    for (const option of options) {\\n      if (\\n        this.strCompare(value, option.value, collators) ||\\n        this.strCompare(value, option.text, collators)\\n      ) {\\n        return option;\\n      }\\n    }\\n\\n    switch (fieldName) {\\n      case \\\"address-level1\\\": {\\n        let { country } = address;\\n        let identifiedValue = this.getAbbreviatedSubregionName(\\n          [value],\\n          country\\n        );\\n        // No point going any further if we cannot identify value from address level 1\\n        if (!identifiedValue) {\\n          return null;\\n        }\\n        for (let dataset of this.getCountryAddressDataWithLocales(country)) {\\n          let keys = dataset.sub_keys;\\n          if (!keys) {\\n            // Not all regions have sub_keys. e.g. DE\\n            continue;\\n          }\\n          // Apply sub_lnames if sub_names does not exist\\n          let names = dataset.sub_names || dataset.sub_lnames;\\n          let isoids = dataset.sub_isoids;\\n\\n          // Go through options one by one to find a match.\\n          // Also check if any option contain the address-level1 key.\\n          let pattern = new RegExp(\\n            \\\"\\\\\\\\b\\\" + this.escapeRegExp(identifiedValue) + \\\"\\\\\\\\b\\\",\\n            \\\"i\\\"\\n          );\\n          for (const option of options) {\\n            let optionValue = this.identifyValue(\\n              keys,\\n              names,\\n              isoids,\\n              option.value,\\n              collators\\n            );\\n            let optionText = this.identifyValue(\\n              keys,\\n              names,\\n              isoids,\\n              option.text,\\n              collators,\\n              true\\n            );\\n            if (\\n              identifiedValue === optionValue ||\\n              identifiedValue === optionText ||\\n              pattern.test(option.value)\\n            ) {\\n              return option;\\n            }\\n          }\\n        }\\n        break;\\n      }\\n      case \\\"country\\\": {\\n        if (this.getCountryAddressData(value)) {\\n          for (const option of options) {\\n            if (\\n              this.identifyCountryCode(option.text, value) ||\\n              this.identifyCountryCode(option.value, value)\\n            ) {\\n              return option;\\n            }\\n          }\\n        }\\n        break;\\n      }\\n    }\\n\\n    return null;\\n  },\\n\\n  /**\\n   * Find the option element from xul menu popups, as used in address capture\\n   * doorhanger.\\n   *\\n   * This is a proxy to `findAddressSelectOption`, which expects HTML select\\n   * DOM nodes and operates on options instead of xul menuitems.\\n   *\\n   * NOTE: This is a temporary solution until Bug 1886949 is landed. This\\n   * method will then be removed `findAddressSelectOption` will be used\\n   * directly.\\n   *\\n   * @param   {XULPopupElement} menupopup\\n   * @param   {object} address\\n   * @param   {string} fieldName\\n   * @returns {XULElement}\\n   */\\n  findAddressSelectOptionWithMenuPopup(menupopup, address, fieldName) {\\n    const options = Array.from(menupopup.childNodes).map(menuitem => ({\\n      text: menuitem.label,\\n      value: menuitem.value,\\n      menuitem,\\n    }));\\n\\n    return this.findAddressSelectOption(options, address, fieldName)?.menuitem;\\n  },\\n\\n  findCreditCardSelectOption(selectEl, creditCard, fieldName) {\\n    let oneDigitMonth = creditCard[\\\"cc-exp-month\\\"]\\n      ? creditCard[\\\"cc-exp-month\\\"].toString()\\n      : null;\\n    let twoDigitsMonth = oneDigitMonth ? oneDigitMonth.padStart(2, \\\"0\\\") : null;\\n    let fourDigitsYear = creditCard[\\\"cc-exp-year\\\"]\\n      ? creditCard[\\\"cc-exp-year\\\"].toString()\\n      : null;\\n    let twoDigitsYear = fourDigitsYear ? fourDigitsYear.substr(2, 2) : null;\\n    let options = Array.from(selectEl.options);\\n\\n    switch (fieldName) {\\n      case \\\"cc-exp-month\\\": {\\n        if (!oneDigitMonth) {\\n          return null;\\n        }\\n        for (let option of options) {\\n          if (\\n            [option.text, option.label, option.value].some(s => {\\n              let result = /[1-9]\\\\d*/.exec(s);\\n              return result && result[0] == oneDigitMonth;\\n            })\\n          ) {\\n            return option;\\n          }\\n        }\\n        break;\\n      }\\n      case \\\"cc-exp-year\\\": {\\n        if (!fourDigitsYear) {\\n          return null;\\n        }\\n        for (let option of options) {\\n          if (\\n            [option.text, option.label, option.value].some(\\n              s => s == twoDigitsYear || s == fourDigitsYear\\n            )\\n          ) {\\n            return option;\\n          }\\n        }\\n        break;\\n      }\\n      case \\\"cc-exp\\\": {\\n        if (!oneDigitMonth || !fourDigitsYear) {\\n          return null;\\n        }\\n        let patterns = [\\n          oneDigitMonth + \\\"/\\\" + twoDigitsYear, // 8/22\\n          oneDigitMonth + \\\"/\\\" + fourDigitsYear, // 8/2022\\n          twoDigitsMonth + \\\"/\\\" + twoDigitsYear, // 08/22\\n          twoDigitsMonth + \\\"/\\\" + fourDigitsYear, // 08/2022\\n          oneDigitMonth + \\\"-\\\" + twoDigitsYear, // 8-22\\n          oneDigitMonth + \\\"-\\\" + fourDigitsYear, // 8-2022\\n          twoDigitsMonth + \\\"-\\\" + twoDigitsYear, // 08-22\\n          twoDigitsMonth + \\\"-\\\" + fourDigitsYear, // 08-2022\\n          twoDigitsYear + \\\"-\\\" + twoDigitsMonth, // 22-08\\n          fourDigitsYear + \\\"-\\\" + twoDigitsMonth, // 2022-08\\n          fourDigitsYear + \\\"/\\\" + oneDigitMonth, // 2022/8\\n          twoDigitsMonth + twoDigitsYear, // 0822\\n          twoDigitsYear + twoDigitsMonth, // 2208\\n        ];\\n\\n        for (let option of options) {\\n          if (\\n            [option.text, option.label, option.value].some(str =>\\n              patterns.some(pattern => str.includes(pattern))\\n            )\\n          ) {\\n            return option;\\n          }\\n        }\\n        break;\\n      }\\n      case \\\"cc-type\\\": {\\n        let network = creditCard[\\\"cc-type\\\"] || \\\"\\\";\\n        for (let option of options) {\\n          if (\\n            [option.text, option.label, option.value].some(\\n              s => lazy.CreditCard.getNetworkFromName(s) == network\\n            )\\n          ) {\\n            return option;\\n          }\\n        }\\n        break;\\n      }\\n    }\\n\\n    return null;\\n  },\\n\\n  /**\\n   * Try to match value with keys and names, but always return the key.\\n   * If inexactMatch is true, then a substring match is performed, otherwise\\n   * the string must match exactly.\\n   *\\n   * @param   {Array<string>} keys\\n   * @param   {Array<string>} names\\n   * @param   {Array<string>} isoids\\n   * @param   {string} value\\n   * @param   {Array} collators\\n   * @param   {bool} inexactMatch\\n   * @returns {string}\\n   */\\n  identifyValue(keys, names, isoids, value, collators, inexactMatch = false) {\\n    if (!value) {\\n      return null;\\n    }\\n\\n    let resultKey = keys.find(key => this.strCompare(value, key, collators));\\n    if (resultKey) {\\n      return resultKey;\\n    }\\n\\n    let index = names.findIndex(name =>\\n      inexactMatch\\n        ? this.strInclude(value, name, collators)\\n        : this.strCompare(value, name, collators)\\n    );\\n    if (index === -1) {\\n      index = isoids.findIndex(isoid =>\\n        inexactMatch\\n          ? this.strInclude(value, isoid, collators)\\n          : this.strCompare(value, isoid, collators)\\n      );\\n    }\\n\\n    return index !== -1 ? keys[index] : null;\\n  },\\n\\n  /**\\n   * Compare if two strings are the same.\\n   *\\n   * @param   {string} a\\n   * @param   {string} b\\n   * @param   {Array} collators\\n   * @returns {boolean}\\n   */\\n  strCompare(a = \\\"\\\", b = \\\"\\\", collators) {\\n    return collators.some(collator => !collator.compare(a, b));\\n  },\\n\\n  /**\\n   * Determine whether one string(b) may be found within another string(a)\\n   *\\n   * @param   {string} a\\n   * @param   {string} b\\n   * @param   {Array} collators\\n   * @returns {boolean} True if the string is found\\n   */\\n  strInclude(a = \\\"\\\", b = \\\"\\\", collators) {\\n    const len = a.length - b.length;\\n    for (let i = 0; i <= len; i++) {\\n      if (this.strCompare(a.substring(i, i + b.length), b, collators)) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  },\\n\\n  /**\\n   * Escaping user input to be treated as a literal string within a regular\\n   * expression.\\n   *\\n   * @param   {string} string\\n   * @returns {string}\\n   */\\n  escapeRegExp(string) {\\n    return string.replace(/[.*+?^${}()|[\\\\]\\\\\\\\]/g, \\\"\\\\\\\\$&\\\");\\n  },\\n\\n  /**\\n   * Get formatting information of a given country\\n   *\\n   * @param   {string} country\\n   * @returns {object}\\n   *         {\\n   *           {string} addressLevel3L10nId\\n   *           {string} addressLevel2L10nId\\n   *           {string} addressLevel1L10nId\\n   *           {string} postalCodeL10nId\\n   *           {object} fieldsOrder\\n   *           {string} postalCodePattern\\n   *         }\\n   */\\n  getFormFormat(country) {\\n    let dataset = this.getCountryAddressData(country);\\n    // We hit a country fallback in `getCountryAddressRawData` but it's not relevant here.\\n    if (country != dataset.key) {\\n      // Use a sparse object so the below default values take effect.\\n      dataset = {\\n        /**\\n         * Even though data/ZZ only has address-level2, include the other levels\\n         * in case they are needed for unknown countries. Users can leave the\\n         * unnecessary fields blank which is better than forcing users to enter\\n         * the data in incorrect fields.\\n         */\\n        fmt: \\\"%N%n%O%n%A%n%C %S %Z\\\",\\n      };\\n    }\\n    return {\\n      // When particular values are missing for a country, the\\n      // data/ZZ value should be used instead:\\n      // https://chromium-i18n.appspot.com/ssl-aggregate-address/data/ZZ\\n      addressLevel3L10nId: this.getAddressFieldL10nId(\\n        dataset.sublocality_name_type || \\\"suburb\\\"\\n      ),\\n      addressLevel2L10nId: this.getAddressFieldL10nId(\\n        dataset.locality_name_type || \\\"city\\\"\\n      ),\\n      addressLevel1L10nId: this.getAddressFieldL10nId(\\n        dataset.state_name_type || \\\"province\\\"\\n      ),\\n      addressLevel1Options: this.buildRegionMapIfAvailable(\\n        dataset.sub_keys,\\n        dataset.sub_isoids,\\n        dataset.sub_names,\\n        dataset.sub_lnames\\n      ),\\n      countryRequiredFields: this.parseRequireString(dataset.require || \\\"AC\\\"),\\n      fieldsOrder: this.parseAddressFormat(dataset.fmt || \\\"%N%n%O%n%A%n%C\\\"),\\n      postalCodeL10nId: this.getAddressFieldL10nId(\\n        dataset.zip_name_type || \\\"postal-code\\\"\\n      ),\\n      postalCodePattern: dataset.zip,\\n    };\\n  },\\n  /**\\n   * Converts a Map to an array of objects with `value` and `text` properties ( option like).\\n   *\\n   * @param {Map} optionsMap\\n   * @returns {Array<{ value: string, text: string }>|null}\\n   */\\n  optionsMapToArray(optionsMap) {\\n    return optionsMap?.size\\n      ? [...optionsMap].map(([value, text]) => ({ value, text }))\\n      : null;\\n  },\\n\\n  /**\\n   * Get flattened form layout information of a given country\\n   * TODO(Bug 1891730): Remove getFormFormat and use this instead.\\n   *\\n   * @param {object} record - An object containing at least the 'country' property.\\n   * @returns {Array} Flattened array with the address fiels in order.\\n   */\\n  getFormLayout(record) {\\n    const formFormat = this.getFormFormat(record.country);\\n    let fieldsInOrder = formFormat.fieldsOrder;\\n\\n    // Add missing fields that are always present but not in the .fmt of addresses\\n    // TODO: extend libaddress later to support this if possible\\n    fieldsInOrder = [\\n      ...fieldsInOrder,\\n      {\\n        fieldId: \\\"country\\\",\\n        options: this.optionsMapToArray(FormAutofill.countries),\\n        required: true,\\n      },\\n      { fieldId: \\\"tel\\\", type: \\\"tel\\\" },\\n      { fieldId: \\\"email\\\", type: \\\"email\\\" },\\n    ];\\n\\n    const addressLevel1Options = this.optionsMapToArray(\\n      formFormat.addressLevel1Options\\n    );\\n\\n    const addressLevel1SelectedValue = addressLevel1Options\\n      ? this.findAddressSelectOption(\\n          addressLevel1Options,\\n          record,\\n          \\\"address-level1\\\"\\n        )?.value\\n      : record[\\\"address-level1\\\"];\\n\\n    for (const field of fieldsInOrder) {\\n      const flattenedObject = {\\n        fieldId: field.fieldId,\\n        newLine: field.newLine,\\n        l10nId: this.getAddressFieldL10nId(field.fieldId),\\n        required: formFormat.countryRequiredFields.includes(field.fieldId),\\n        value: record[field.fieldId] ?? \\\"\\\",\\n        ...(field.fieldId === \\\"street-address\\\" && {\\n          l10nId: \\\"autofill-address-street\\\",\\n          multiline: true,\\n        }),\\n        ...(field.fieldId === \\\"address-level1\\\" && {\\n          l10nId: formFormat.addressLevel1L10nId,\\n          options: addressLevel1Options,\\n          value: addressLevel1SelectedValue,\\n        }),\\n        ...(field.fieldId === \\\"address-level2\\\" && {\\n          l10nId: formFormat.addressLevel2L10nId,\\n        }),\\n        ...(field.fieldId === \\\"address-level3\\\" && {\\n          l10nId: formFormat.addressLevel3L10nId,\\n        }),\\n        ...(field.fieldId === \\\"postal-code\\\" && {\\n          pattern: formFormat.postalCodePattern,\\n          l10nId: formFormat.postalCodeL10nId,\\n        }),\\n      };\\n      Object.assign(field, flattenedObject);\\n    }\\n\\n    return fieldsInOrder;\\n  },\\n\\n  getAddressFieldL10nId(type) {\\n    return \\\"autofill-address-\\\" + type.replace(/_/g, \\\"-\\\");\\n  },\\n\\n  CC_FATHOM_NONE: 0,\\n  CC_FATHOM_JS: 1,\\n  CC_FATHOM_NATIVE: 2,\\n  isFathomCreditCardsEnabled() {\\n    return this.ccHeuristicsMode != this.CC_FATHOM_NONE;\\n  },\\n\\n  /**\\n   * Transform the key in FormAutofillConfidences (defined in ChromeUtils.webidl)\\n   * to fathom recognized field type.\\n   *\\n   * @param {string} key key from FormAutofillConfidences dictionary\\n   * @returns {string} fathom field type\\n   */\\n  formAutofillConfidencesKeyToCCFieldType(key) {\\n    const MAP = {\\n      ccNumber: \\\"cc-number\\\",\\n      ccName: \\\"cc-name\\\",\\n      ccType: \\\"cc-type\\\",\\n      ccExp: \\\"cc-exp\\\",\\n      ccExpMonth: \\\"cc-exp-month\\\",\\n      ccExpYear: \\\"cc-exp-year\\\",\\n    };\\n    return MAP[key];\\n  },\\n  /**\\n   * Generates the localized os dialog message that\\n   * prompts the user to reauthenticate\\n   *\\n   * @param {string} msgMac fluent message id for macos clients\\n   * @param {string} msgWin fluent message id for windows clients\\n   * @param {string} msgOther fluent message id for other clients\\n   * @param {string} msgLin (optional) fluent message id for linux clients\\n   * @returns {string} localized os prompt message\\n   */\\n  reauthOSPromptMessage(msgMac, msgWin, msgOther, msgLin = null) {\\n    const platform = AppConstants.platform;\\n    let messageID;\\n\\n    switch (platform) {\\n      case \\\"win\\\":\\n        messageID = msgWin;\\n        break;\\n      case \\\"macosx\\\":\\n        messageID = msgMac;\\n        break;\\n      case \\\"linux\\\":\\n        messageID = msgLin ?? msgOther;\\n        break;\\n      default:\\n        messageID = msgOther;\\n    }\\n    return lazy.l10n.formatValueSync(messageID);\\n  },\\n\\n  /**\\n   * Retrieves a unique identifier for a given DOM element.\\n   * Note that the identifier generated by ContentDOMReference is an object but\\n   * this API serializes it to string to make lookup easier.\\n   *\\n   * @param {Element} element The DOM element from which to generate an identifier.\\n   * @returns {string} A unique identifier for the element.\\n   */\\n  getElementIdentifier(element) {\\n    let id;\\n    try {\\n      id = JSON.stringify(lazy.ContentDOMReference.get(element));\\n    } catch {\\n      // This is needed because when running in xpc-shell test, we don't have\\n      const entry = Object.entries(this._elementByElementId).find(\\n        e => e[1] == element\\n      );\\n      if (entry) {\\n        id = entry[0];\\n      } else {\\n        id = Services.uuid.generateUUID().toString();\\n        this._elementByElementId[id] = element;\\n      }\\n    }\\n    return id;\\n  },\\n\\n  /**\\n   * Maps element identifiers to their corresponding DOM elements.\\n   * Only used when we can't get the identifier via ContentDOMReference,\\n   * for example, xpcshell test.\\n   */\\n  _elementByElementId: {},\\n\\n  /**\\n   * Retrieves the DOM element associated with the specific identifier.\\n   * The identifier should be generated with the `getElementIdentifier` API\\n   *\\n   * @param {string} elementId The identifier of the element.\\n   * @returns {Element} The DOM element associated with the given identifier.\\n   */\\n  getElementByIdentifier(elementId) {\\n    let element;\\n    try {\\n      element = lazy.ContentDOMReference.resolve(JSON.parse(elementId));\\n    } catch {\\n      element = this._elementByElementId[elementId];\\n    }\\n    return element;\\n  },\\n\\n  /**\\n   * This function is used to determine the frames that can also be autofilled\\n   * when users trigger autofill on the focusd frame.\\n   *\\n   * Currently we also autofill when for frames that\\n   * 1. is top-level.\\n   * 2. is same origin with the top-level.\\n   * 3. is same origin with the frame that triggers autofill.\\n   *\\n   * @param {BrowsingContext} browsingContext\\n   *        frame to be checked whether we can also autofill\\n   */\\n  isBCSameOriginWithTop(browsingContext) {\\n    return (\\n      browsingContext.top == browsingContext ||\\n      browsingContext.currentWindowGlobal.documentPrincipal.equals(\\n        browsingContext.top.currentWindowGlobal.documentPrincipal\\n      )\\n    );\\n  },\\n};\\n\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofillUtils,\\n  \\\"_reauthEnabledByUser\\\",\\n  \\\"extensions.formautofill.reauth.enabled\\\",\\n  false\\n);\\n\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofillUtils,\\n  \\\"ccHeuristicsMode\\\",\\n  \\\"extensions.formautofill.creditCards.heuristics.mode\\\",\\n  0\\n);\\n\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofillUtils,\\n  \\\"ccFathomConfidenceThreshold\\\",\\n  \\\"extensions.formautofill.creditCards.heuristics.fathom.confidenceThreshold\\\",\\n  null,\\n  null,\\n  pref => parseFloat(pref)\\n);\\n\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofillUtils,\\n  \\\"ccFathomHighConfidenceThreshold\\\",\\n  \\\"extensions.formautofill.creditCards.heuristics.fathom.highConfidenceThreshold\\\",\\n  null,\\n  null,\\n  pref => parseFloat(pref)\\n);\\n\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofillUtils,\\n  \\\"ccFathomTestConfidence\\\",\\n  \\\"extensions.formautofill.creditCards.heuristics.fathom.testConfidence\\\",\\n  null,\\n  null,\\n  pref => parseFloat(pref)\\n);\\n\\n// This is only used in iOS\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofillUtils,\\n  \\\"focusOnAutofill\\\",\\n  \\\"extensions.formautofill.focusOnAutofill\\\",\\n  true\\n);\\n\\n// This is only used for testing\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  FormAutofillUtils,\\n  \\\"ignoreVisibilityCheck\\\",\\n  \\\"extensions.formautofill.test.ignoreVisibilityCheck\\\",\\n  false\\n);\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs":
/*!********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs ***!
  \********************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n/**\\n * A factory to generate FormLike objects that represent a set of related fields\\n * which aren't necessarily marked up with a <form> element. FormLike's emulate\\n * the properties of an HTMLFormElement which are relevant to form tasks.\\n */\\nexport let FormLikeFactory = {\\n  _propsFromForm: [\\\"action\\\", \\\"autocomplete\\\", \\\"ownerDocument\\\"],\\n\\n  /**\\n   * Create a FormLike object from a <form>.\\n   *\\n   * @param {HTMLFormElement} aForm\\n   * @return {FormLike}\\n   * @throws Error if aForm isn't an HTMLFormElement\\n   */\\n  createFromForm(aForm) {\\n    if (!HTMLFormElement.isInstance(aForm)) {\\n      throw new Error(\\\"createFromForm: aForm must be a HTMLFormElement\\\");\\n    }\\n\\n    let formLike = {\\n      elements: this.gatherFormElements(aForm),\\n      rootElement: aForm,\\n    };\\n\\n    for (let prop of this._propsFromForm) {\\n      formLike[prop] = aForm[prop];\\n    }\\n\\n    this._addToJSONProperty(formLike);\\n\\n    return formLike;\\n  },\\n\\n  gatherFormElements(aForm) {\\n    // If there is no nested <form> element, just return the form's elements.\\n    if (!aForm.querySelector(\\\"form\\\")) {\\n      return [...aForm.elements];\\n    }\\n\\n    // Get all of the child input and select elements from the form. Nested\\n    // forms are normally removed during markup parsing, but could be created\\n    // if the document is modified later. Consider all of the elements that\\n    // are descendants of the form or within the form's .elements list to be\\n    // part of the form, except those with a form attribute set to a different\\n    // form. These are all added in document order.\\n    let childElements = [...aForm.querySelectorAll(\\\"input, select\\\")];\\n    childElements = childElements.filter(\\n      e => !e.getAttribute(\\\"form\\\") || e.form == aForm\\n    );\\n\\n    // Add the element into the child elements list in document order.\\n    let index = 0;\\n    for (const formElement of aForm.elements) {\\n      if (!childElements.includes(formElement)) {\\n        // Insert elements that appear before the <form> at the beginning and\\n        // other elements at the end.\\n        let position = aForm.compareDocumentPosition(formElement);\\n        if (position & Node.DOCUMENT_POSITION_PRECEDING) {\\n          childElements.splice(index++, 0, formElement);\\n          continue;\\n        } else {\\n          childElements.push(formElement);\\n        }\\n      }\\n    }\\n\\n    return childElements;\\n  },\\n\\n  /**\\n   * Create a FormLike object from an element that is the root of the document\\n   *\\n   * Currently all <input> not in a <form> are one LoginForm but this\\n   * shouldn't be relied upon as the heuristics may change to detect multiple\\n   * \\\"forms\\\" (e.g. registration and login) on one page with a <form>.\\n   *\\n   * @param {HTMLElement} aDocumentRoot\\n   * @param {Object} aOptions\\n   * @param {boolean} [aOptions.ignoreForm = false]\\n   *        True to always use owner document as the `form`\\n   * @return {formLike}\\n   * @throws Error if aDocumentRoot is null\\n   */\\n  createFromDocumentRoot(aDocumentRoot, aOptions = {}) {\\n    if (!aDocumentRoot) {\\n      throw new Error(\\\"createFromDocumentRoot: aDocumentRoot is null\\\");\\n    }\\n\\n    let formLike = {\\n      action: aDocumentRoot.baseURI,\\n      autocomplete: \\\"on\\\",\\n      ownerDocument: aDocumentRoot.ownerDocument,\\n      rootElement: aDocumentRoot,\\n    };\\n\\n    // FormLikes can be created when fields are inserted into the DOM. When\\n    // many, many fields are inserted one after the other, we create many\\n    // FormLikes, and computing the elements list becomes more and more\\n    // expensive. Making the elements list lazy means that it'll only\\n    // be computed when it's eventually needed (if ever).\\n    ChromeUtils.defineLazyGetter(formLike, \\\"elements\\\", function () {\\n      let elements = [];\\n      for (let el of aDocumentRoot.querySelectorAll(\\n        \\\"input, select, textarea\\\"\\n      )) {\\n        // Exclude elements inside the rootElement that are already in a <form> as\\n        // they will be handled by their own FormLike.\\n        if (!el.form || aOptions.ignoreForm) {\\n          elements.push(el);\\n        }\\n      }\\n\\n      return elements;\\n    });\\n\\n    this._addToJSONProperty(formLike);\\n    return formLike;\\n  },\\n\\n  /**\\n   * Create a FormLike object from an <input>/<select> in a document.\\n   *\\n   * If the field is in a <form>, construct the FormLike from the form.\\n   * Otherwise, create a FormLike with a rootElement (wrapper) according to\\n   * heuristics. Currently all <input>/<select> not in a <form> are one FormLike\\n   * but this shouldn't be relied upon as the heuristics may change to detect\\n   * multiple \\\"forms\\\" (e.g. registration and login) on one page with a <form>.\\n   *\\n   * Note that two FormLikes created from the same field won't return the same FormLike object.\\n   * Use the `rootElement` property on the FormLike as a key instead.\\n   *\\n   * @param {HTMLInputElement|HTMLSelectElement} aField\\n   *        an <input>, <select> or <iframe> field in a document\\n   * @param {Object} aOptions\\n   * @param {boolean} [aOptions.ignoreForm = false]\\n   *        True to always use owner document as the `form`\\n   * @return {FormLike}\\n   * @throws Error if aField isn't a password or username field in a document\\n   */\\n  createFromField(aField, aOptions = {}) {\\n    if (\\n      (!HTMLInputElement.isInstance(aField) &&\\n        !HTMLIFrameElement.isInstance(aField) &&\\n        !HTMLSelectElement.isInstance(aField) &&\\n        !HTMLTextAreaElement.isInstance(aField)) ||\\n      !aField.ownerDocument\\n    ) {\\n      throw new Error(\\\"createFromField requires a field in a document\\\");\\n    }\\n\\n    const rootElement = this.findRootForField(aField, aOptions);\\n    return HTMLFormElement.isInstance(rootElement)\\n      ? this.createFromForm(rootElement)\\n      : this.createFromDocumentRoot(rootElement, aOptions);\\n  },\\n\\n  /**\\n   * Find the closest <form> if any when aField is inside a ShadowRoot.\\n   *\\n   * @param {HTMLInputElement} aField - a password or username field in a document\\n   * @return {HTMLFormElement|null}\\n   */\\n  closestFormIgnoringShadowRoots(aField) {\\n    let form = aField.closest(\\\"form\\\");\\n    let current = aField;\\n    while (!form) {\\n      let shadowRoot = current.getRootNode();\\n      if (!ShadowRoot.isInstance(shadowRoot)) {\\n        break;\\n      }\\n      let host = shadowRoot.host;\\n      form = host.closest(\\\"form\\\");\\n      current = host;\\n    }\\n    return form;\\n  },\\n\\n  /**\\n   * Determine the Element that encapsulates the related fields. For example, if\\n   * a page contains a login form and a checkout form which are \\\"submitted\\\"\\n   * separately, and the username field is passed in, ideally this would return\\n   * an ancestor Element of the username and password fields which doesn't\\n   * include any of the checkout fields.\\n   *\\n   * @param {HTMLInputElement|HTMLSelectElement} aField\\n   *        a field in a document\\n   * @return {HTMLElement} - the root element surrounding related fields\\n   */\\n  findRootForField(aField, { ignoreForm = false } = {}) {\\n    if (!ignoreForm) {\\n      let form = aField.form || this.closestFormIgnoringShadowRoots(aField);\\n      if (form) {\\n        // If a <form> appears inside another form, use the outermost <form> element.\\n        let parent = form;\\n        while ((parent = parent.parentNode)) {\\n          if (HTMLFormElement.isInstance(parent)) {\\n            form = parent;\\n          }\\n        }\\n        return form;\\n      }\\n    }\\n\\n    return aField.ownerDocument.documentElement;\\n  },\\n\\n  /**\\n   * Add a `toJSON` property to a FormLike so logging which ends up going\\n   * through dump doesn't include usless garbage from DOM objects.\\n   */\\n  _addToJSONProperty(aFormLike) {\\n    function prettyElementOutput(aElement) {\\n      let idText = aElement.id ? \\\"#\\\" + aElement.id : \\\"\\\";\\n      let classText = \\\"\\\";\\n      for (let className of aElement.classList) {\\n        classText += \\\".\\\" + className;\\n      }\\n      return `<${aElement.nodeName + idText + classText}>`;\\n    }\\n\\n    Object.defineProperty(aFormLike, \\\"toJSON\\\", {\\n      value: () => {\\n        let cleansed = {};\\n        for (let key of Object.keys(aFormLike)) {\\n          let value = aFormLike[key];\\n          let cleansedValue = value;\\n\\n          switch (key) {\\n            case \\\"elements\\\": {\\n              cleansedValue = [];\\n              for (let element of value) {\\n                cleansedValue.push(prettyElementOutput(element));\\n              }\\n              break;\\n            }\\n\\n            case \\\"ownerDocument\\\": {\\n              cleansedValue = {\\n                location: {\\n                  href: value.location.href,\\n                },\\n              };\\n              break;\\n            }\\n\\n            case \\\"rootElement\\\": {\\n              cleansedValue = prettyElementOutput(value);\\n              break;\\n            }\\n          }\\n\\n          cleansed[key] = cleansedValue;\\n        }\\n        return cleansed;\\n      },\\n    });\\n  },\\n};\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs ***!
  \*********************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nconst lazy = {};\\nChromeUtils.defineESModuleGetters(lazy, {\\n  AutofillFormFactory:\\n    \\\"resource://gre/modules/shared/AutofillFormFactory.sys.mjs\\\",\\n  FormAutofillHandler:\\n    \\\"resource://gre/modules/shared/FormAutofillHandler.sys.mjs\\\",\\n  FormAutofillUtils: \\\"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\\\",\\n});\\n\\nexport class FormStateManager {\\n  #formHandlerByElement = new WeakMap();\\n  #formHandlerByRootElement = new WeakMap();\\n  #formHandlerByRootId = new Map();\\n\\n  constructor(onFilledModifiedCallback) {\\n    /**\\n     * @type {WeakMap} mapping FormLike root HTML elements to FormAutofillHandler objects.\\n     */\\n\\n    this.onFilledModifiedCallback = onFilledModifiedCallback;\\n  }\\n\\n  getWeakIdentifiedForms() {\\n    return ChromeUtils.nondeterministicGetWeakMapKeys(\\n      this.#formHandlerByRootElement\\n    );\\n  }\\n\\n  /**\\n   * Get the form handler for the specified input element.\\n   *\\n   * @param {HTMLElement} element\\n   *        Focused input which triggered profile searching\\n   * @returns {FormAutofillHandler | null}\\n   *        The form handler associated with the specified input element.\\n   */\\n  getFormHandler(element) {\\n    if (!element) {\\n      return null;\\n    }\\n\\n    let handler = this.#formHandlerByElement.get(element);\\n    if (handler) {\\n      return handler;\\n    }\\n\\n    const rootElement = lazy.AutofillFormFactory.findRootForField(element);\\n    return this.#formHandlerByRootElement.get(rootElement);\\n  }\\n\\n  /**\\n   * Get the form handler for the specified root element.\\n   *\\n   * @param {string} rootElementId\\n   *        the id of the root element\\n   * @returns {FormAutofillHandler | null}\\n   *        The form handler associated with the specified input element.\\n   */\\n  getFormHandlerByRootElementId(rootElementId) {\\n    return this.#formHandlerByRootId.get(rootElementId);\\n  }\\n\\n  /**\\n   * Get the form handler for the specified input element. If no handler exists\\n   * in the cache, this function creates a new one.\\n   *\\n   * @param {HTMLElement} element\\n   *        Focused input which triggered profile searching\\n   * @returns {FormAutofillHandler}\\n   *        The form handler associated with the specified input element.\\n   */\\n  getOrCreateFormHandler(element) {\\n    let handler = this.getFormHandler(element);\\n    if (!handler) {\\n      handler = new lazy.FormAutofillHandler(\\n        lazy.AutofillFormFactory.createFromField(element),\\n        this.onFilledModifiedCallback\\n      );\\n\\n      const root = handler.form.rootElement;\\n      const rootElementId = lazy.FormAutofillUtils.getElementIdentifier(root);\\n      this.#formHandlerByRootId.set(rootElementId, handler);\\n      this.#formHandlerByRootElement.set(root, handler);\\n    }\\n    return handler;\\n  }\\n\\n  removeFormHandlerByElementEntries(handler) {\\n    handler.form.elements.forEach(element =>\\n      this.#formHandlerByElement.delete(element)\\n    );\\n  }\\n\\n  addFormHandlerByElementEntries(handler) {\\n    handler.form.elements.forEach(element => {\\n      if (!this.#formHandlerByElement.has(element, handler)) {\\n        this.#formHandlerByElement.set(element, handler);\\n      }\\n    });\\n  }\\n}\\n\\nexport default FormStateManager;\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs ***!
  \************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nimport { IOSAppConstants } from \\\"resource://gre/modules/shared/Constants.ios.mjs\\\";\\nimport Overrides from \\\"resource://gre/modules/Overrides.ios.js\\\";\\n\\nconst EMPTY_MODULE_PATH = \\\"EmptyModule.sys.mjs\\\";\\n\\n/* eslint mozilla/use-isInstance: 0 */\\nHTMLSelectElement.isInstance = element => element instanceof HTMLSelectElement;\\nHTMLInputElement.isInstance = element => element instanceof HTMLInputElement;\\nHTMLTextAreaElement.isInstance = element =>\\n  element instanceof HTMLTextAreaElement;\\nHTMLIFrameElement.isInstance = element => element instanceof HTMLIFrameElement;\\nHTMLFormElement.isInstance = element => element instanceof HTMLFormElement;\\nShadowRoot.isInstance = element => element instanceof ShadowRoot;\\n\\nHTMLElement.prototype.ownerGlobal = window;\\n\\n// We cannot mock this in WebKit because we lack access to low-level APIs.\\n// For completeness, we simply return true when the input type is \\\"password\\\".\\n// NOTE: Since now we also include this file for password generator, it might be included multiple times\\n// which causes the defineProperty to throw. Allowing it to be overwritten for now is fine, since\\n// our code runs in a sandbox and only firefox code can overwrite it.\\nObject.defineProperty(HTMLInputElement.prototype, \\\"hasBeenTypePassword\\\", {\\n  get() {\\n    return this.type === \\\"password\\\";\\n  },\\n  configurable: true,\\n});\\n\\nObject.defineProperty(HTMLInputElement.prototype, \\\"nodePrincipal\\\", {\\n  get() {\\n    return { isNullPrincipal: false };\\n  },\\n  configurable: true,\\n});\\n\\nfunction setUserInput(value) {\\n  this.value = value;\\n\\n  // In React apps, setting .value may not always work reliably.\\n  // We dispatch change, input as a workaround.\\n  // There are other more \\\"robust\\\" solutions:\\n  // - Dispatching keyboard events and comparing the value after setting it\\n  //   (https://github.com/fmeum/browserpass-extension/blob/5efb1f9de6078b509904a83847d370c8e92fc097/src/inject.js#L412-L440)\\n  // - Using the native setter\\n  //   (https://github.com/facebook/react/issues/10135#issuecomment-401496776)\\n  // These are a bit more bloated. We can consider using these later if we encounter any further issues.\\n  [\\\"input\\\", \\\"change\\\"].forEach(eventName => {\\n    this.dispatchEvent(new Event(eventName, { bubbles: true }));\\n  });\\n\\n  this.dispatchEvent(new Event(\\\"blur\\\", { bubbles: true }));\\n}\\n\\nHTMLInputElement.prototype.setUserInput = setUserInput;\\nHTMLTextAreaElement.prototype.setUserInput = setUserInput;\\n\\n// Mimic the behavior of .getAutocompleteInfo()\\n// It should return an object with a fieldName property matching the autocomplete attribute\\n// only if it's a valid value from this list https://searchfox.org/mozilla-central/source/dom/base/AutocompleteFieldList.h#89-149\\n// Also found here: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete\\nHTMLElement.prototype.getAutocompleteInfo = function () {\\n  const autocomplete = this.getAttribute(\\\"autocomplete\\\");\\n\\n  return {\\n    fieldName: IOSAppConstants.validAutocompleteFields.includes(autocomplete)\\n      ? autocomplete\\n      : \\\"\\\",\\n  };\\n};\\n\\n// This function  helps us debug better when an error occurs because a certain mock is missing\\nconst withNotImplementedError = obj =>\\n  new Proxy(obj, {\\n    get(target, prop) {\\n      if (!Object.keys(target).includes(prop)) {\\n        throw new Error(\\n          `Not implemented: ${prop} doesn't exist in mocked object `\\n        );\\n      }\\n      return Reflect.get(...arguments);\\n    },\\n  });\\n\\n// This function will create a proxy for each undefined property\\n// This is useful when the accessed property name is unkonwn beforehand\\nconst undefinedProxy = () =>\\n  new Proxy(() => {}, {\\n    get() {\\n      return undefinedProxy();\\n    },\\n  });\\n\\n// Webpack needs to be able to statically analyze require statements in order to build the dependency graph\\n// In order to require modules dynamically at runtime, we use require.context() to create a dynamic require\\n// that is still able to be parsed by Webpack at compile time. The \\\"./\\\" and \\\".mjs\\\" tells webpack that files\\n// in the current directory ending with .mjs might be needed and should be added to the dependency graph.\\n// NOTE: This can't handle circular dependencies. A static import can be used in this case.\\n// https://webpack.js.org/guides/dependency-management/\\nconst internalModuleResolvers = {\\n  resolveModule(moduleURI) {\\n    // eslint-disable-next-line no-undef\\n    const moduleResolver = require.context(\\\"./\\\", false, /.mjs$/);\\n    // Desktop code uses uris for importing modules of the form resource://gre/modules/<module_path>\\n    // We only need the filename here\\n    const moduleName = moduleURI.split(\\\"/\\\").pop();\\n    const modulePath =\\n      \\\"./\\\" + (Overrides.ModuleOverrides[moduleName] ?? moduleName);\\n    return { module: moduleResolver(modulePath), path: modulePath };\\n  },\\n\\n  resolveModules(obj, modules) {\\n    for (const [exportName, moduleURI] of Object.entries(modules)) {\\n      const resolvedModule = this.resolveModule(moduleURI);\\n      obj[exportName] = resolvedModule.path.includes(EMPTY_MODULE_PATH)\\n        ? resolvedModule.module?.default\\n        : resolvedModule.module?.[exportName];\\n    }\\n  },\\n};\\n\\n// Define mock for XPCOMUtils\\nexport const XPCOMUtils = withNotImplementedError({\\n  defineLazyPreferenceGetter: (\\n    obj,\\n    prop,\\n    pref,\\n    defaultValue = null,\\n    onUpdate,\\n    transform = val => val\\n  ) => {\\n    const value = IOSAppConstants.prefs[pref] ?? defaultValue;\\n    // Explicitly check for undefined since null, false, \\\"\\\" and 0 are valid values\\n    if (value === undefined) {\\n      throw Error(\\n        `Pref ${pref} is not defined and no valid default value was provided.`\\n      );\\n    }\\n    obj[prop] = transform(value);\\n  },\\n  defineLazyServiceGetter() {\\n    // Don't do anything\\n    // We need this for OS Auth fixes for formautofill.\\n    // TODO(issam, Bug 1894967): Move os auth to separate module and remove this.\\n  },\\n});\\n\\n// eslint-disable-next-line no-shadow\\nexport const ChromeUtils = withNotImplementedError({\\n  defineLazyGetter: (obj, prop, getFn) => {\\n    const callback = prop === \\\"log\\\" ? genericLogger : getFn;\\n    obj[prop] = callback?.call(obj);\\n  },\\n  defineESModuleGetters(obj, modules) {\\n    internalModuleResolvers.resolveModules(obj, modules);\\n  },\\n  importESModule(moduleURI) {\\n    return internalModuleResolvers.resolveModule(moduleURI)?.module;\\n  },\\n});\\nwindow.ChromeUtils = ChromeUtils;\\n\\n// Define mock for Region.sys.mjs\\nexport const Region = withNotImplementedError({\\n  home: \\\"US\\\",\\n});\\n\\n// Define mock for OSKeyStore.sys.mjs\\nexport const OSKeyStore = withNotImplementedError({\\n  ensureLoggedIn: () => true,\\n});\\n\\n// Define mock for Services\\n// NOTE: Services is a global so we need to attach it to the window\\n// eslint-disable-next-line no-shadow\\nexport const Services = withNotImplementedError({\\n  locale: withNotImplementedError({ isAppLocaleRTL: false }),\\n  prefs: withNotImplementedError({ prefIsLocked: () => false }),\\n  strings: withNotImplementedError({\\n    createBundle: () =>\\n      withNotImplementedError({\\n        GetStringFromName: () => \\\"\\\",\\n        formatStringFromName: () => \\\"\\\",\\n      }),\\n  }),\\n  // TODO(FXCM-936): we should use crypto.randomUUID() instead of Services.uuid.generateUUID() in our codebase\\n  // Underneath crypto.randomUUID() uses the same implementation as generateUUID()\\n  // https://searchfox.org/mozilla-central/rev/d405168c4d3c0fb900a7354ae17bb34e939af996/dom/base/Crypto.cpp#96\\n  // The only limitation is that it's not available in insecure contexts, which should be fine for both iOS and Desktop\\n  // since we only autofill in secure contexts\\n  uuid: withNotImplementedError({ generateUUID: () => crypto.randomUUID() }),\\n});\\nwindow.Services = Services;\\n\\n// Define mock for Localization\\nwindow.Localization = function () {\\n  return { formatValueSync: () => \\\"\\\" };\\n};\\n\\n// TODO(issam, FXCM-935): In order to create create a universal mock for glean that\\n// dispatches telemetry messages to the iOS, we need to modify typedefs in swift. For now, we map the telemetry events\\n// to the expected shape. FXCM-935 will tackle cleaning this up.\\nwindow.Glean = {\\n  // While moving away from Legacy Telemetry to Glean, the automated script generated the additional categories\\n  // `creditcard` and `address`. After bug 1933961 all probes will have moved to category formautofillCreditcards and formautofillAddresses.\\n  formautofillCreditcards: undefinedProxy(),\\n  formautofill: undefinedProxy(),\\n  creditcard: undefinedProxy(),\\n  _mapGleanToLegacy: (eventName, { value, ...extra }) => {\\n    const eventMapping = {\\n      filledModifiedAddressForm: {\\n        method: \\\"filled_modified\\\",\\n        object: \\\"address_form\\\",\\n      },\\n      filledAddressForm: { method: \\\"filled\\\", object: \\\"address_form\\\" },\\n      detectedAddressForm: { method: \\\"detected\\\", object: \\\"address_form\\\" },\\n      filledModifiedAddressFormExt: {\\n        method: \\\"filled_modified\\\",\\n        object: \\\"address_form_ext\\\",\\n      },\\n      filledAddressFormExt: { method: \\\"filled\\\", object: \\\"address_form_ext\\\" },\\n      detectedAddressFormExt: {\\n        method: \\\"detected\\\",\\n        object: \\\"address_form_ext\\\",\\n      },\\n    };\\n    // eslint-disable-next-line no-undef\\n    webkit.messageHandlers.addressFormTelemetryMessageHandler.postMessage(\\n      JSON.stringify({\\n        type: \\\"event\\\",\\n        category: \\\"address\\\",\\n        ...eventMapping[eventName],\\n        value,\\n        extra,\\n      })\\n    );\\n  },\\n  address: new Proxy(\\n    {},\\n    {\\n      get(_target, prop) {\\n        return {\\n          record: extras => Glean._mapGleanToLegacy(prop, extras),\\n        };\\n      },\\n    }\\n  ),\\n  // Keeping unused category formautofillAddresses here, because Bug 1933961\\n  // will move probes from the glean category address to formautofillAddresses\\n  formautofillAddresses: undefinedProxy(),\\n};\\n\\nconst genericLogger = () =>\\n  withNotImplementedError({\\n    info: () => {},\\n    error: () => {},\\n    warn: () => {},\\n    debug: () => {},\\n  });\\n\\nexport { IOSAppConstants as AppConstants } from \\\"resource://gre/modules/shared/Constants.ios.mjs\\\";\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs ***!
  \*********************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* eslint-disable no-useless-concat */\\n/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n// prettier-ignore\\nexport const HeuristicsRegExp = {\\n  RULES: {\\n    email: undefined,\\n    tel: undefined,\\n    \\\"tel-country-code\\\" : undefined,\\n    \\\"address-housenumber\\\": undefined,\\n    \\\"street-address\\\": undefined,\\n    \\\"address-line1\\\": undefined,\\n    \\\"address-line2\\\": undefined,\\n    \\\"address-line3\\\": undefined,\\n    \\\"postal-code\\\": undefined,\\n    \\\"address-level3\\\": undefined,\\n    \\\"address-level2\\\": undefined,\\n    \\\"address-level1\\\": undefined,\\n    // Note: We place the `organization` field after the `address` fields, to\\n    // ensure that all address-related fields that might contain organization \\n    // info are matched as address fields first.\\n    organization: undefined,\\n    country: undefined,\\n    // Note: We place the `cc-name` field for Credit Card first, because\\n    // it is more specific than the `name` field below and we want to check\\n    // for it before we catch the more generic one.\\n    \\\"cc-name\\\": undefined,\\n    name: undefined,\\n    \\\"given-name\\\": undefined,\\n    \\\"additional-name\\\": undefined,\\n    \\\"family-name\\\": undefined,\\n    \\\"cc-csc\\\": undefined,\\n    \\\"cc-number\\\": undefined,\\n    \\\"cc-exp-month\\\": undefined,\\n    \\\"cc-exp-year\\\": undefined,\\n    \\\"cc-exp\\\": undefined,\\n    \\\"cc-type\\\": undefined,\\n  },\\n\\n  // regular expressions that only apply to label\\n  LABEL_RULES: {\\n    \\\"address-line1\\\": undefined,\\n    \\\"address-line2\\\": undefined,\\n  },\\n\\n  RULE_SETS: [\\n    //=========================================================================\\n    // Firefox-specific rules\\n    {\\n      \\\"address-line1\\\": \\\"addrline1|address_1|addl1\\\",\\n      \\\"address-line2\\\":\\n        \\\"addrline2|address_2|addl2\\\" +\\n        \\\"|landmark\\\", // common in IN\\n      \\\"address-line3\\\": \\\"addrline3|address_3|addl3\\\",\\n      \\\"address-level2\\\": \\\"città\\\", // it-IT\\n      \\\"address-housenumber\\\":\\n        \\\"house\\\\\\\\s*number|hausnummer|haus|house[a-z\\\\-]*n(r|o)\\\",\\n      \\\"address-level3\\\":\\n        \\\"(^address-?level-?3$)\\\" +\\n        \\\"|neighbou*rhood|barrio|bairro|colonia|suburb\\\", // en/es/pt/mx/au/nz\\n      \\\"postal-code\\\": \\\"^PLZ(\\\\\\\\b|\\\\\\\\*)\\\", // de-DE\\n      \\\"additional-name\\\": \\\"apellido.?materno|lastlastname\\\",\\n      \\\"cc-name\\\":\\n        \\\"accountholdername\\\" +\\n        \\\"|titulaire\\\", // fr-FR\\n      \\\"cc-number\\\":\\n        \\\"(cc|kk)nr\\\",    // de-DE\\n      \\\"cc-exp\\\":\\n        \\\"ważna.*do\\\" +        // pl-PL\\n        \\\"|data.*ważności\\\" +  // pl-PL\\n        \\\"|mm\\\\\\\\s*[\\\\\\\\-\\\\\\\\/]\\\\\\\\s*yy\\\" +  // en-US\\n        \\\"|mm\\\\\\\\s*[\\\\\\\\-\\\\\\\\/]\\\\\\\\s*aa\\\" +  // es-ES\\n        \\\"|mm\\\\\\\\s*[\\\\\\\\-\\\\\\\\/]\\\\\\\\s*jj\\\" +  // de-AT\\n        \\\"|vervaldatum\\\",            // nl-NL\\n      \\\"cc-exp-month\\\":\\n        \\\"month\\\" +\\n        \\\"|(cc|kk)month\\\" +    // de-DE\\n        \\\"|miesiąc\\\" +         // pl-PL\\n        \\\"|mes\\\" +             // es-ES\\n        \\\"|maand\\\",            // nl-NL\\n      \\\"cc-exp-year\\\":\\n        \\\"year\\\" +\\n        \\\"|(cc|kk)year\\\" +     // de-DE\\n        \\\"|rok\\\" +             // pl-PL\\n        \\\"|(anno|año)\\\" +      // es-ES\\n        \\\"|jaar\\\",             // nl-NL\\n      \\\"cc-type\\\":\\n        \\\"(cc|card).*(type)\\\" +\\n        \\\"|kartenmarke\\\" +     // de-DE\\n        \\\"|typ.*karty\\\",       // pl-PL\\n      \\\"cc-csc\\\":\\n        \\\"(\\\\\\\\bcvn\\\\\\\\b|\\\\\\\\bcvv\\\\\\\\b|\\\\\\\\bcvc\\\\\\\\b|\\\\\\\\bcsc\\\\\\\\b|\\\\\\\\bcvd\\\\\\\\b|\\\\\\\\bcid\\\\\\\\b|\\\\\\\\bccv\\\\\\\\b)\\\",\\n      \\\"tel-country-code\\\":\\n        \\\"phone.*country|country.*phone\\\" +\\n        \\\"tel.*country|country.*tel\\\",\\n    },\\n\\n    //=========================================================================\\n    // These are the rules used by Bitwarden [0], converted into RegExp form.\\n    // [0] https://github.com/bitwarden/browser/blob/c2b8802201fac5e292d55d5caf3f1f78088d823c/src/services/autofill.service.ts#L436\\n    {\\n      email: \\\"(^e-?mail$)|(^email-?address$)\\\",\\n\\n      tel:\\n        \\\"(^phone$)\\\" +\\n        \\\"|(^mobile$)\\\" +\\n        \\\"|(^mobile-?phone$)\\\" +\\n        \\\"|(^tel$)\\\" +\\n        \\\"|(^telephone$)\\\" +\\n        \\\"|(^phone-?number$)\\\",\\n\\n      organization:\\n        \\\"(^company$)\\\" +\\n        \\\"|(^company-?name$)\\\" +\\n        \\\"|(^organization$)\\\" +\\n        \\\"|(^organization-?name$)\\\",\\n\\n      \\\"street-address\\\":\\n        \\\"(^address$)\\\" +\\n        \\\"|(^street-?address$)\\\" +\\n        \\\"|(^addr$)\\\" +\\n        \\\"|(^street$)\\\" +\\n        \\\"|(^mailing-?addr(ess)?$)\\\" + // Modified to not grab lines, below\\n        \\\"|(^billing-?addr(ess)?$)\\\" + // Modified to not grab lines, below\\n        \\\"|(^mail-?addr(ess)?$)\\\" + // Modified to not grab lines, below\\n        \\\"|(^bill-?addr(ess)?$)\\\", // Modified to not grab lines, below\\n\\n      \\\"address-line1\\\":\\n        \\\"(^address-?1$)\\\" +\\n        \\\"|(^address-?line-?1$)\\\" +\\n        \\\"|(^addr-?1$)\\\" +\\n        \\\"|(^street-?1$)\\\",\\n\\n      \\\"address-line2\\\":\\n        \\\"(^address-?2$)\\\" +\\n        \\\"|(^address-?line-?2$)\\\" +\\n        \\\"|(^addr-?2$)\\\" +\\n        \\\"|(^street-?2$)\\\",\\n\\n      \\\"address-line3\\\":\\n        \\\"(^address-?3$)\\\" +\\n        \\\"|(^address-?line-?3$)\\\" +\\n        \\\"|(^addr-?3$)\\\" +\\n        \\\"|(^street-?3$)\\\",\\n\\n      \\\"address-level2\\\":\\n        \\\"(^city$)\\\" +\\n        \\\"|(^town$)\\\" +\\n        \\\"|(^address-?level-?2$)\\\" +\\n        \\\"|(^address-?city$)\\\" +\\n        \\\"|(^address-?town$)\\\",\\n\\n      \\\"address-level1\\\":\\n        \\\"(^state$)\\\" +\\n        \\\"|(^province$)\\\" +\\n        \\\"|(^provence$)\\\" +\\n        \\\"|(^address-?level-?1$)\\\" +\\n        \\\"|(^address-?state$)\\\" +\\n        \\\"|(^address-?province$)\\\",\\n\\n      \\\"postal-code\\\":\\n        \\\"(^postal$)\\\" +\\n        \\\"|(^zip$)\\\" +\\n        \\\"|(^zip2$)\\\" +\\n        \\\"|(^zip-?code$)\\\" +\\n        \\\"|(^postal-?code$)\\\" +\\n        \\\"|(^post-?code$)\\\" +\\n        \\\"|(^address-?zip$)\\\" +\\n        \\\"|(^address-?postal$)\\\" +\\n        \\\"|(^address-?code$)\\\" +\\n        \\\"|(^address-?postal-?code$)\\\" +\\n        \\\"|(^address-?zip-?code$)\\\",\\n\\n      country:\\n        \\\"(^country$)\\\" +\\n        \\\"|(^country-?code$)\\\" +\\n        \\\"|(^country-?name$)\\\" +\\n        \\\"|(^address-?country$)\\\" +\\n        \\\"|(^address-?country-?name$)\\\" +\\n        \\\"|(^address-?country-?code$)\\\",\\n\\n      name: \\\"(^name$)|full-?name|your-?name\\\",\\n\\n      \\\"given-name\\\":\\n        \\\"(^f-?name$)\\\" +\\n        \\\"|(^first-?name$)\\\" +\\n        \\\"|(^given-?name$)\\\" +\\n        \\\"|(^first-?n$)\\\",\\n\\n      \\\"additional-name\\\":\\n        \\\"(^m-?name$)\\\" +\\n        \\\"|(^middle-?name$)\\\" +\\n        \\\"|(^additional-?name$)\\\" +\\n        \\\"|(^middle-?initial$)\\\" +\\n        \\\"|(^middle-?n$)\\\" +\\n        \\\"|(^middle-?i$)\\\",\\n\\n      \\\"family-name\\\":\\n        \\\"(^l-?name$)\\\" +\\n        \\\"|(^last-?name$)\\\" +\\n        \\\"|(^s-?name$)\\\" +\\n        \\\"|(^surname$)\\\" +\\n        \\\"|(^family-?name$)\\\" +\\n        \\\"|(^family-?n$)\\\" +\\n        \\\"|(^last-?n$)\\\",\\n\\n      \\\"cc-name\\\":\\n        \\\"cc-?name\\\" +\\n        \\\"|card-?name\\\" +\\n        \\\"|cardholder-?name\\\" +\\n        \\\"|cardholder\\\",\\n        // \\\"|(^name$)\\\" + // Removed to avoid overwriting \\\"name\\\", above.\\n\\n      \\\"cc-number\\\":\\n        \\\"cc-?number\\\" +\\n        \\\"|cc-?num\\\" +\\n        \\\"|card-?number\\\" +\\n        \\\"|card-?num\\\" +\\n        \\\"|(^number$)\\\" +\\n        \\\"|(^cc$)\\\" +\\n        \\\"|cc-?no\\\" +\\n        \\\"|card-?no\\\" +\\n        \\\"|(^credit-?card$)\\\" +\\n        \\\"|numero-?carte\\\" +\\n        \\\"|(^carte$)\\\" +\\n        \\\"|(^carte-?credit$)\\\" +\\n        \\\"|num-?carte\\\" +\\n        \\\"|cb-?num\\\",\\n\\n      \\\"cc-exp\\\":\\n        \\\"(^cc-?exp$)\\\" +\\n        \\\"|(^card-?exp$)\\\" +\\n        \\\"|(^cc-?expiration$)\\\" +\\n        \\\"|(^card-?expiration$)\\\" +\\n        \\\"|(^cc-?ex$)\\\" +\\n        \\\"|(^card-?ex$)\\\" +\\n        \\\"|(^card-?expire$)\\\" +\\n        \\\"|(^card-?expiry$)\\\" +\\n        \\\"|(^validite$)\\\" +\\n        \\\"|(^expiration$)\\\" +\\n        \\\"|(^expiry$)\\\" +\\n        \\\"|mm-?yy\\\" +\\n        \\\"|mm-?yyyy\\\" +\\n        \\\"|yy-?mm\\\" +\\n        \\\"|yyyy-?mm\\\" +\\n        \\\"|expiration-?date\\\" +\\n        \\\"|payment-?card-?expiration\\\" +\\n        \\\"|(^payment-?cc-?date$)\\\",\\n\\n      \\\"cc-exp-month\\\":\\n        \\\"(^exp-?month$)\\\" +\\n        \\\"|(^cc-?exp-?month$)\\\" +\\n        \\\"|(^cc-?month$)\\\" +\\n        \\\"|(^card-?month$)\\\" +\\n        \\\"|(^cc-?mo$)\\\" +\\n        \\\"|(^card-?mo$)\\\" +\\n        \\\"|(^exp-?mo$)\\\" +\\n        \\\"|(^card-?exp-?mo$)\\\" +\\n        \\\"|(^cc-?exp-?mo$)\\\" +\\n        \\\"|(^card-?expiration-?month$)\\\" +\\n        \\\"|(^expiration-?month$)\\\" +\\n        \\\"|(^cc-?mm$)\\\" +\\n        \\\"|(^cc-?m$)\\\" +\\n        \\\"|(^card-?mm$)\\\" +\\n        \\\"|(^card-?m$)\\\" +\\n        \\\"|(^card-?exp-?mm$)\\\" +\\n        \\\"|(^cc-?exp-?mm$)\\\" +\\n        \\\"|(^exp-?mm$)\\\" +\\n        \\\"|(^exp-?m$)\\\" +\\n        \\\"|(^expire-?month$)\\\" +\\n        \\\"|(^expire-?mo$)\\\" +\\n        \\\"|(^expiry-?month$)\\\" +\\n        \\\"|(^expiry-?mo$)\\\" +\\n        \\\"|(^card-?expire-?month$)\\\" +\\n        \\\"|(^card-?expire-?mo$)\\\" +\\n        \\\"|(^card-?expiry-?month$)\\\" +\\n        \\\"|(^card-?expiry-?mo$)\\\" +\\n        \\\"|(^mois-?validite$)\\\" +\\n        \\\"|(^mois-?expiration$)\\\" +\\n        \\\"|(^m-?validite$)\\\" +\\n        \\\"|(^m-?expiration$)\\\" +\\n        \\\"|(^expiry-?date-?field-?month$)\\\" +\\n        \\\"|(^expiration-?date-?month$)\\\" +\\n        \\\"|(^expiration-?date-?mm$)\\\" +\\n        \\\"|(^exp-?mon$)\\\" +\\n        \\\"|(^validity-?mo$)\\\" +\\n        \\\"|(^exp-?date-?mo$)\\\" +\\n        \\\"|(^cb-?date-?mois$)\\\" +\\n        \\\"|(^date-?m$)\\\",\\n\\n      \\\"cc-exp-year\\\":\\n        \\\"(^exp-?year$)\\\" +\\n        \\\"|(^cc-?exp-?year$)\\\" +\\n        \\\"|(^cc-?year$)\\\" +\\n        \\\"|(^card-?year$)\\\" +\\n        \\\"|(^cc-?yr$)\\\" +\\n        \\\"|(^card-?yr$)\\\" +\\n        \\\"|(^exp-?yr$)\\\" +\\n        \\\"|(^card-?exp-?yr$)\\\" +\\n        \\\"|(^cc-?exp-?yr$)\\\" +\\n        \\\"|(^card-?expiration-?year$)\\\" +\\n        \\\"|(^expiration-?year$)\\\" +\\n        \\\"|(^cc-?yy$)\\\" +\\n        \\\"|(^cc-?y$)\\\" +\\n        \\\"|(^card-?yy$)\\\" +\\n        \\\"|(^card-?y$)\\\" +\\n        \\\"|(^card-?exp-?yy$)\\\" +\\n        \\\"|(^cc-?exp-?yy$)\\\" +\\n        \\\"|(^exp-?yy$)\\\" +\\n        \\\"|(^exp-?y$)\\\" +\\n        \\\"|(^cc-?yyyy$)\\\" +\\n        \\\"|(^card-?yyyy$)\\\" +\\n        \\\"|(^card-?exp-?yyyy$)\\\" +\\n        \\\"|(^cc-?exp-?yyyy$)\\\" +\\n        \\\"|(^expire-?year$)\\\" +\\n        \\\"|(^expire-?yr$)\\\" +\\n        \\\"|(^expiry-?year$)\\\" +\\n        \\\"|(^expiry-?yr$)\\\" +\\n        \\\"|(^card-?expire-?year$)\\\" +\\n        \\\"|(^card-?expire-?yr$)\\\" +\\n        \\\"|(^card-?expiry-?year$)\\\" +\\n        \\\"|(^card-?expiry-?yr$)\\\" +\\n        \\\"|(^an-?validite$)\\\" +\\n        \\\"|(^an-?expiration$)\\\" +\\n        \\\"|(^annee-?validite$)\\\" +\\n        \\\"|(^annee-?expiration$)\\\" +\\n        \\\"|(^expiry-?date-?field-?year$)\\\" +\\n        \\\"|(^expiration-?date-?year$)\\\" +\\n        \\\"|(^cb-?date-?ann$)\\\" +\\n        \\\"|(^expiration-?date-?yy$)\\\" +\\n        \\\"|(^expiration-?date-?yyyy$)\\\" +\\n        \\\"|(^validity-?year$)\\\" +\\n        \\\"|(^exp-?date-?year$)\\\" +\\n        \\\"|(^date-?y$)\\\",\\n\\n      \\\"cc-type\\\":\\n        \\\"(^cc-?type$)\\\" +\\n        \\\"|(^card-?type$)\\\" +\\n        \\\"|(^card-?brand$)\\\" +\\n        \\\"|(^cc-?brand$)\\\" +\\n        \\\"|(^cb-?type$)\\\",\\n    },\\n\\n    //=========================================================================\\n    // These rules are from Chromium source codes [1]. Most of them\\n    // converted to JS format have the same meaning with the original ones except\\n    // the first line of \\\"address-level1\\\".\\n    // [1] https://source.chromium.org/chromium/chromium/src/+/master:components/autofill/core/common/autofill_regex_constants.cc\\n    {\\n      // ==== Email ====\\n      email:\\n        \\\"e.?mail\\\" +\\n        \\\"|courriel\\\" + // fr\\n        \\\"|correo.*electr(o|ó)nico\\\" + // es-ES\\n        \\\"|メールアドレス\\\" + // ja-JP\\n        \\\"|Электронной.?Почты\\\" + // ru\\n        \\\"|邮件|邮箱\\\" + // zh-CN\\n        \\\"|電郵地址\\\" + // zh-TW\\n        \\\"|ഇ-മെയില്‍|ഇലക്ട്രോണിക്.?\\\" +\\n        \\\"മെയിൽ\\\" + // ml\\n        \\\"|ایمیل|پست.*الکترونیک\\\" + // fa\\n        \\\"|ईमेल|इलॅक्ट्रॉनिक.?मेल\\\" + // hi\\n        \\\"|(\\\\\\\\b|_)eposta(\\\\\\\\b|_)\\\" + // tr\\n        \\\"|(?:이메일|전자.?우편|[Ee]-?mail)(.?주소)?\\\", // ko-KR\\n\\n      // ==== Telephone ====\\n      tel:\\n        \\\"phone|mobile|contact.?number\\\" +\\n        \\\"|telefonnummer\\\" + // de-DE\\n        \\\"|telefono|teléfono\\\" + // es\\n        \\\"|telfixe\\\" + // fr-FR\\n        \\\"|電話\\\" + // ja-JP\\n        \\\"|telefone|telemovel\\\" + // pt-BR, pt-PT\\n        \\\"|телефон\\\" + // ru\\n        \\\"|मोबाइल\\\" + // hi for mobile\\n        \\\"|(\\\\\\\\b|_|\\\\\\\\*)telefon(\\\\\\\\b|_|\\\\\\\\*)\\\" + // tr\\n        \\\"|电话\\\" + // zh-CN\\n        \\\"|മൊബൈല്‍\\\" + // ml for mobile\\n        \\\"|(?:전화|핸드폰|휴대폰|휴대전화)(?:.?번호)?\\\", // ko-KR\\n\\n      // ==== Address Fields ====\\n      organization:\\n        \\\"company|business|organization|organisation\\\" +\\n        // In order to support webkit we convert all negative lookbehinds to a capture group\\n        // (?<!not)word -> (?<neg>notword)|word\\n        // TODO: Bug 1829583\\n        \\\"|(?<neg>confirma)\\\" +\\n        \\\"|firma|firmenname\\\" + // de-DE\\n        \\\"|empresa\\\" + // es\\n        \\\"|societe|société\\\" + // fr-FR\\n        \\\"|ragione.?sociale\\\" + // it-IT\\n        \\\"|会社\\\" + // ja-JP\\n        \\\"|название.?компании\\\" + // ru\\n        \\\"|单位|公司\\\" + // zh-CN\\n        \\\"|شرکت\\\" + // fa\\n        \\\"|회사|직장\\\", // ko-KR\\n\\n      \\\"street-address\\\": \\\"streetaddress|street-address\\\",\\n      \\\"address-line1\\\":\\n        \\\"^address$|address[_-]?line(one)?|address1|addr1|street\\\" +\\n        \\\"|(?:shipping|billing)address$\\\" +\\n        \\\"|strasse|straße\\\" + // de-DE\\n        \\\"|house.?name\\\" + // en-GB\\n        \\\"|direccion|dirección\\\" + // es\\n        \\\"|adresse\\\" + // fr-FR\\n        \\\"|indirizzo\\\" + // it-IT\\n        \\\"|^住所$|住所1\\\" + // ja-JP\\n        \\\"|morada\\\" + // pt-BR, pt-PT\\n        // In order to support webkit we convert all negative lookbehinds to a capture group\\n        // (?<!not)word -> (?<neg>notword)|word\\n        // TODO: Bug 1829583\\n        \\\"|(?<neg>identificação do endereço)\\\" +\\n        \\\"|(endereço)\\\" + // pt-BR, pt-PT\\n        \\\"|Адрес\\\" + // ru\\n        \\\"|地址\\\" + // zh-CN\\n        \\\"|(\\\\\\\\b|_)adres(?! (başlığı(nız)?|tarifi))(\\\\\\\\b|_)\\\" + // tr\\n        \\\"|^주소.?$|주소.?1\\\", // ko-KR\\n\\n      \\\"address-line2\\\":\\n        \\\"address[_-]?line(2|two)|address2|addr2|street|suite|unit(?!e)\\\" + // Firefox adds `(?!e)` to unit to skip `United State`\\n        \\\"|adresszusatz|ergänzende.?angaben\\\" + // de-DE\\n        \\\"|direccion2|colonia|adicional\\\" + // es\\n        \\\"|addresssuppl|complementnom|appartement\\\" + // fr-FR\\n        \\\"|indirizzo2\\\" + // it-IT\\n        \\\"|住所2\\\" + // ja-JP\\n        \\\"|complemento|addrcomplement\\\" + // pt-BR, pt-PT\\n        \\\"|Улица\\\" + // ru\\n        \\\"|地址2\\\" + // zh-CN\\n        \\\"|주소.?2\\\", // ko-KR\\n\\n      \\\"address-line3\\\":\\n        \\\"address[_-]?line(3|three)|address3|addr3|street|suite|unit(?!e)\\\" + // Firefox adds `(?!e)` to unit to skip `United State`\\n        \\\"|adresszusatz|ergänzende.?angaben\\\" + // de-DE\\n        \\\"|direccion3|colonia|adicional\\\" + // es\\n        \\\"|addresssuppl|complementnom|appartement\\\" + // fr-FR\\n        \\\"|indirizzo3\\\" + // it-IT\\n        \\\"|住所3\\\" + // ja-JP\\n        \\\"|complemento|addrcomplement\\\" + // pt-BR, pt-PT\\n        \\\"|Улица\\\" + // ru\\n        \\\"|地址3\\\" + // zh-CN\\n        \\\"|주소.?3\\\", // ko-KR\\n\\n      \\\"address-level2\\\":\\n        \\\"city|town\\\" +\\n        \\\"|\\\\\\\\bort\\\\\\\\b|stadt\\\" + // de-DE\\n        \\\"|suburb\\\" + // en-AU\\n        \\\"|ciudad|provincia|localidad|poblacion\\\" + // es\\n        \\\"|ville|commune\\\" + // fr-FR\\n        \\\"|localita\\\" + // it-IT\\n        \\\"|市区町村\\\" + // ja-JP\\n        \\\"|cidade\\\" + // pt-BR, pt-PT\\n        \\\"|Город\\\" + // ru\\n        \\\"|市\\\" + // zh-CN\\n        \\\"|分區\\\" + // zh-TW\\n        \\\"|شهر\\\" + // fa\\n        \\\"|शहर\\\" + // hi for city\\n        \\\"|ग्राम|गाँव\\\" + // hi for village\\n        \\\"|നഗരം|ഗ്രാമം\\\" + // ml for town|village\\n        \\\"|((\\\\\\\\b|_|\\\\\\\\*)([İii̇]l[cç]e(miz|niz)?)(\\\\\\\\b|_|\\\\\\\\*))\\\" + // tr\\n        \\\"|^시[^도·・]|시[·・]?군[·・]?구\\\", // ko-KR\\n\\n      \\\"address-level1\\\":\\n        // In order to support webkit we convert all negative lookbehinds to a capture group\\n        // (?<!not)word -> (?<neg>notword)|word\\n        // TODO: Bug 1829583\\n        \\\"(?<neg>united?.state|hist?.state|history?.state)\\\" +\\n        \\\"|state|county|region|province\\\" +\\n        \\\"|principality\\\" + // en-UK\\n        \\\"|都道府県\\\" + // ja-JP\\n        \\\"|estado|provincia\\\" + // pt-BR, pt-PT\\n        \\\"|область\\\" + // ru\\n        \\\"|省\\\" + // zh-CN\\n        \\\"|地區\\\" + // zh-TW\\n        \\\"|സംസ്ഥാനം\\\" + // ml\\n        \\\"|استان\\\" + // fa\\n        \\\"|राज्य\\\" + // hi\\n        \\\"|((\\\\\\\\b|_|\\\\\\\\*)(eyalet|[şs]ehir|[İii̇]l(imiz)?|kent)(\\\\\\\\b|_|\\\\\\\\*))\\\" + // tr\\n        \\\"|^시[·・]?도\\\", // ko-KR\\n\\n      \\\"postal-code\\\":\\n        \\\"zip|postal|post.*code|pcode\\\" +\\n        \\\"|pin.?code\\\" + // en-IN\\n        \\\"|postleitzahl\\\" + // de-DE\\n        \\\"|\\\\\\\\bcp\\\\\\\\b\\\" + // es\\n        \\\"|\\\\\\\\bcdp\\\\\\\\b\\\" + // fr-FR\\n        \\\"|\\\\\\\\bcap\\\\\\\\b\\\" + // it-IT\\n        \\\"|郵便番号\\\" + // ja-JP\\n        \\\"|codigo|codpos|\\\\\\\\bcep\\\\\\\\b\\\" + // pt-BR, pt-PT\\n        \\\"|Почтовый.?Индекс\\\" + // ru\\n        \\\"|पिन.?कोड\\\" + // hi\\n        \\\"|പിന്‍കോഡ്\\\" + // ml\\n        \\\"|邮政编码|邮编\\\" + // zh-CN\\n        \\\"|郵遞區號\\\" + // zh-TW\\n        \\\"|(\\\\\\\\b|_)posta kodu(\\\\\\\\b|_)\\\" + // tr\\n        \\\"|우편.?번호\\\", // ko-KR\\n\\n      country:\\n        \\\"country|countries\\\" +\\n        \\\"|país|pais\\\" + // es\\n        \\\"|(\\\\\\\\b|_)land(\\\\\\\\b|_)(?!.*(mark.*))\\\" + // de-DE landmark is a type in india.\\n        // In order to support webkit we convert all negative lookbehinds to a capture group\\n        // (?<!not)word -> (?<neg>notword)|word\\n        // TODO: Bug 1829583\\n        \\\"|(?<neg>入国|出国)\\\" +\\n        \\\"|国\\\" + // ja-JP\\n        \\\"|国家\\\" + // zh-CN\\n        \\\"|국가|나라\\\" + // ko-KR\\n        \\\"|(\\\\\\\\b|_)(ülke|ulce|ulke)(\\\\\\\\b|_)\\\" + // tr\\n        \\\"|کشور\\\", // fa\\n\\n      // ==== Name Fields ====\\n      \\\"cc-name\\\":\\n        \\\"card.?(?:holder|owner)|name.*(\\\\\\\\b)?on(\\\\\\\\b)?.*card\\\" +\\n        \\\"|^(credit[-\\\\\\\\s]?card|card).*name|cc.?full.?name\\\" +\\n        \\\"|karteninhaber\\\" + // de-DE\\n        \\\"|nombre.*tarjeta\\\" + // es\\n        \\\"|nom.*carte\\\" + // fr-FR\\n        \\\"|nome.*cart\\\" + // it-IT\\n        \\\"|名前\\\" + // ja-JP\\n        \\\"|Имя.*карты\\\" + // ru\\n        \\\"|信用卡开户名|开户名|持卡人姓名\\\" + // zh-CN\\n        \\\"|持卡人姓名\\\", // zh-TW\\n\\n      name:\\n        \\\"^name|full.?name|your.?name|customer.?name|bill.?name|ship.?name\\\" +\\n        \\\"|name.*first.*last|firstandlastname\\\" +\\n        \\\"|nombre.*y.*apellidos\\\" + // es\\n        \\\"|^nom(?!bre)\\\" + // fr-FR\\n        \\\"|お名前|氏名\\\" + // ja-JP\\n        \\\"|^nome\\\" + // pt-BR, pt-PT\\n        \\\"|نام.*نام.*خانوادگی\\\" + // fa\\n        \\\"|姓名\\\" + // zh-CN\\n        \\\"|(\\\\\\\\b|_|\\\\\\\\*)ad[ı]? soyad[ı]?(\\\\\\\\b|_|\\\\\\\\*)\\\" + // tr\\n        \\\"|성명\\\", // ko-KR\\n\\n      \\\"given-name\\\":\\n        \\\"first.*name|initials|fname|first$|given.*name\\\" +\\n        \\\"|vorname\\\" + // de-DE\\n        \\\"|nombre\\\" + // es\\n        \\\"|forename|prénom|prenom\\\" + // fr-FR\\n        \\\"|名\\\" + // ja-JP\\n        \\\"|nome\\\" + // pt-BR, pt-PT\\n        \\\"|Имя\\\" + // ru\\n        \\\"|نام\\\" + // fa\\n        \\\"|이름\\\" + // ko-KR\\n        \\\"|പേര്\\\" + // ml\\n        \\\"|(\\\\\\\\b|_|\\\\\\\\*)(isim|ad|ad(i|ı|iniz|ınız)?)(\\\\\\\\b|_|\\\\\\\\*)\\\" + // tr\\n        \\\"|नाम\\\", // hi\\n\\n      \\\"additional-name\\\":\\n        \\\"middle.*name|mname|middle$|middle.*initial|m\\\\\\\\.i\\\\\\\\.|mi$|\\\\\\\\bmi\\\\\\\\b\\\",\\n\\n      \\\"family-name\\\":\\n        \\\"last.*name|lname|surname|last$|secondname|family.*name\\\" +\\n        \\\"|nachname\\\" + // de-DE\\n        \\\"|apellidos?\\\" + // es\\n        \\\"|famille|^nom(?!bre)\\\" + // fr-FR\\n        \\\"|cognome\\\" + // it-IT\\n        \\\"|姓\\\" + // ja-JP\\n        \\\"|apelidos|surename|sobrenome\\\" + // pt-BR, pt-PT\\n        \\\"|Фамилия\\\" + // ru\\n        \\\"|نام.*خانوادگی\\\" + // fa\\n        \\\"|उपनाम\\\" + // hi\\n        \\\"|മറുപേര്\\\" + // ml\\n        \\\"|(\\\\\\\\b|_|\\\\\\\\*)(soyisim|soyad(i|ı|iniz|ınız)?)(\\\\\\\\b|_|\\\\\\\\*)\\\" + // tr\\n        \\\"|\\\\\\\\b성(?:[^명]|\\\\\\\\b)\\\", // ko-KR\\n\\n      // ==== Credit Card Fields ====\\n      // Note: `cc-name` expression has been moved up, above `name`, in\\n      // order to handle specialization through ordering.\\n      \\\"cc-number\\\":\\n        \\\"(add)?(?:card|cc|acct).?(?:number|#|no|num|field(?!s)|pan)\\\" +\\n        // In order to support webkit we convert all negative lookbehinds to a capture group\\n        // (?<!not)word -> (?<neg>notword)|word\\n        // TODO: Bug 1829583\\n        \\\"|(?<neg>telefonnummer|hausnummer|personnummer|fødselsnummer)\\\" + // de-DE, sv-SE, no\\n        \\\"|nummer\\\" +\\n        \\\"|カード番号\\\" + // ja-JP\\n        \\\"|Номер.*карты\\\" + // ru\\n        \\\"|信用卡号|信用卡号码\\\" + // zh-CN\\n        \\\"|信用卡卡號\\\" + // zh-TW\\n        \\\"|카드\\\" + // ko-KR\\n        // es/pt/fr\\n        \\\"|(numero|número|numéro)(?!.*(document|fono|phone|réservation))\\\",\\n\\n      \\\"cc-exp-month\\\":\\n        \\\"expir|exp.*mo|exp.*date|ccmonth|cardmonth|addmonth\\\" +\\n        \\\"|gueltig|gültig|monat\\\" + // de-DE\\n        \\\"|fecha\\\" + // es\\n        \\\"|date.*exp\\\" + // fr-FR\\n        \\\"|scadenza\\\" + // it-IT\\n        \\\"|有効期限\\\" + // ja-JP\\n        \\\"|validade\\\" + // pt-BR, pt-PT\\n        \\\"|Срок действия карты\\\" + // ru\\n        \\\"|月\\\", // zh-CN\\n\\n      \\\"cc-exp-year\\\":\\n        \\\"exp|^/|(add)?year\\\" +\\n        \\\"|ablaufdatum|gueltig|gültig|jahr\\\" + // de-DE\\n        \\\"|fecha\\\" + // es\\n        \\\"|scadenza\\\" + // it-IT\\n        \\\"|有効期限\\\" + // ja-JP\\n        \\\"|validade\\\" + // pt-BR, pt-PT\\n        \\\"|Срок действия карты\\\" + // ru\\n        \\\"|年|有效期\\\", // zh-CN\\n\\n      \\\"cc-exp\\\":\\n        \\\"expir|exp.*date|^expfield$\\\" +\\n        \\\"|gueltig|gültig\\\" + // de-DE\\n        \\\"|fecha\\\" + // es\\n        \\\"|date.*exp\\\" + // fr-FR\\n        \\\"|scadenza\\\" + // it-IT\\n        \\\"|有効期限\\\" + // ja-JP\\n        \\\"|validade\\\" + // pt-BR, pt-PT\\n        \\\"|Срок действия карты\\\", // ru\\n\\n      \\\"cc-csc\\\":\\n        \\\"verification|card.?identification|security.?code|card.?code\\\" +\\n        \\\"|security.?value\\\" +\\n        \\\"|security.?number|card.?pin|c-v-v\\\" +\\n        // We omit this regexp in favor of being less generic.\\n        // See \\\"Firefox-specific\\\" rules for cc-csc\\n        // \\\"|(cvn|cvv|cvc|csc|cvd|cid|ccv)(field)?\\\" +\\n        \\\"|\\\\\\\\bcid\\\\\\\\b\\\",\\n    },\\n  ],\\n\\n  LABEL_RULE_SETS: [\\n    {\\n      \\\"address-line1\\\":\\n        \\\"(^\\\\\\\\W*address)\\\" +\\n        \\\"|(address\\\\\\\\W*$)\\\" +\\n        \\\"|(?:shipping|billing|mailing|pick.?up|drop.?off|delivery|sender|postal|\\\" +\\n        \\\"recipient|home|work|office|school|business|mail)[\\\\\\\\s\\\\\\\\-]+address\\\" +\\n        \\\"|address\\\\\\\\s+(of|for|to|from)\\\" +\\n        \\\"|adresse\\\" +                         // fr-FR\\n        \\\"|indirizzo\\\" +                       // it-IT\\n        \\\"|住所\\\" +                            // ja-JP\\n        \\\"|地址\\\" +                            // zh-CN\\n        \\\"|(\\\\\\\\b|_)adres(?! tarifi)(\\\\\\\\b|_)\\\" +  // tr\\n        \\\"|주소\\\" +                            // ko-KR\\n        \\\"|^alamat\\\" +                         // id\\n        // Should contain street and any other address component, in any order\\n        \\\"|street.*(house|building|apartment|floor)\\\" +  // en\\n        \\\"|(house|building|apartment|floor).*street\\\" +\\n        \\\"|(sokak|cadde).*(apartman|bina|daire|mahalle)\\\" +  // tr\\n        \\\"|(apartman|bina|daire|mahalle).*(sokak|cadde)\\\" +\\n        \\\"|улиц.*(дом|корпус|квартир|этаж)|(дом|корпус|квартир|этаж).*улиц\\\",  // ru\\n    },\\n    {\\n      \\\"address-line2\\\":\\n        \\\"address|line\\\" +\\n        \\\"|house|building|apartment|floor\\\" +    // de-DE\\n        \\\"|adresse\\\" +      // fr-FR\\n        \\\"|indirizzo\\\" +    // it-IT\\n        \\\"|地址\\\" +         // zh-CN\\n        \\\"|주소\\\",          // ko-KR\\n    },\\n  ],\\n\\n  _getRules(rules, rulesets) {\\n    function computeRule(name) {\\n      let regexps = [];\\n      rulesets.forEach(set => {\\n        if (set[name]) {\\n          // Add the rule.\\n          // We make the regex lower case so that we can match it against the\\n          // lower-cased field name and get a rough equivalent of a case-insensitive\\n          // match. This avoids a performance cliff with the \\\"iu\\\" flag on regular\\n          // expressions.\\n          regexps.push(`(${set[name].toLowerCase()})`.normalize(\\\"NFKC\\\"));\\n        }\\n      });\\n\\n      const value = new RegExp(regexps.join(\\\"|\\\"), \\\"gu\\\");\\n\\n      Object.defineProperty(rules, name, { get: undefined });\\n      Object.defineProperty(rules, name, { value });\\n      return value;\\n    }\\n\\n    Object.keys(rules).forEach(field =>\\n      Object.defineProperty(rules, field, {\\n        get() {\\n          return computeRule(field);\\n        },\\n      })\\n    );\\n\\n    return rules;\\n  },\\n\\n  getLabelRules() {\\n    return this._getRules(this.LABEL_RULES, this.LABEL_RULE_SETS);\\n  },\\n\\n  getRules() {\\n    return this._getRules(this.RULES, this.RULE_SETS);\\n  },\\n};\\n\\nexport default HeuristicsRegExp;\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs ***!
  \***************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nconst lazy = {};\\nChromeUtils.defineESModuleGetters(lazy, {\\n  FormAutofillUtils: \\\"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\\\",\\n});\\n\\n/**\\n * This is a utility object to work with HTML labels in web pages,\\n * including finding label elements and label text extraction.\\n */\\nexport const LabelUtils = {\\n  // The tag name list is from Chromium except for \\\"STYLE\\\":\\n  // eslint-disable-next-line max-len\\n  // https://cs.chromium.org/chromium/src/components/autofill/content/renderer/form_autofill_util.cc?l=216&rcl=d33a171b7c308a64dc3372fac3da2179c63b419e\\n  EXCLUDED_TAGS: [\\\"SCRIPT\\\", \\\"NOSCRIPT\\\", \\\"OPTION\\\", \\\"STYLE\\\"],\\n\\n  // A map object, whose keys are the id's of form fields and each value is an\\n  // array consisting of label elements correponding to the id. This map only\\n  // contains those labels with an id that matches a form element.\\n  // @type {Map<string, array>}\\n  _mappedLabels: null,\\n\\n  // An array consisting of label elements whose correponding form field doesn't\\n  // have an id attribute.\\n  // @type {Array<[HTMLLabelElement, HTMLElement]>}\\n  _unmappedLabelControls: null,\\n\\n  // A weak map consisting of label element and extracted strings pairs.\\n  // @type {WeakMap<HTMLLabelElement, array>}\\n  _labelStrings: null,\\n\\n  /**\\n   * Extract all strings of an element's children to an array.\\n   * \\\"element.textContent\\\" is a string which is merged of all children nodes,\\n   * and this function provides an array of the strings contains in an element.\\n   *\\n   * @param  {object} element\\n   *         A DOM element to be extracted.\\n   * @returns {Array}\\n   *          All strings in an element.\\n   */\\n  extractLabelStrings(element) {\\n    if (this._labelStrings.has(element)) {\\n      return this._labelStrings.get(element);\\n    }\\n    let strings = [];\\n    let _extractLabelStrings = el => {\\n      if (this.EXCLUDED_TAGS.includes(el.tagName)) {\\n        return;\\n      }\\n\\n      if (el.nodeType == el.TEXT_NODE || !el.childNodes.length) {\\n        let trimmedText = el.textContent.trim();\\n        if (trimmedText) {\\n          strings.push(trimmedText);\\n        }\\n        return;\\n      }\\n\\n      for (let node of el.childNodes) {\\n        let nodeType = node.nodeType;\\n        if (nodeType != node.ELEMENT_NODE && nodeType != node.TEXT_NODE) {\\n          continue;\\n        }\\n        _extractLabelStrings(node);\\n      }\\n    };\\n    _extractLabelStrings(element);\\n    this._labelStrings.set(element, strings);\\n    return strings;\\n  },\\n\\n  /**\\n   * From a starting label element, find a nearby input or select element\\n   * by traversing the nodes in document order, but don't search past another\\n   * related element or outside the form.\\n   */\\n  findAdjacentControl(labelElement, potentialLabels) {\\n    // First, look for an form element after the label.\\n    let foundElementAfter = this.findNextFormControl(\\n      labelElement,\\n      false,\\n      potentialLabels\\n    );\\n\\n    // If the control has the same parent as the label, return it.\\n    if (foundElementAfter?.parentNode == labelElement.parentNode) {\\n      return foundElementAfter;\\n    }\\n\\n    // Otherwise, look for a form control with the same parent backwards\\n    // in the document.\\n    let foundElementBefore = this.findNextFormControl(\\n      labelElement,\\n      true,\\n      potentialLabels\\n    );\\n    if (foundElementBefore?.parentNode == labelElement.parentNode) {\\n      return foundElementBefore;\\n    }\\n\\n    // If there is no form control with the same parent forward or backward,\\n    // return the form control nearest forward, if any, even though it doesn't\\n    // have the same parent.\\n    return foundElementAfter;\\n  },\\n\\n  /**\\n   * Find the next form control in the document tree after a starting label that\\n   * could correspond to the label. If the form control is in potentialLabels, then\\n   * it has already been possibly matched to another label so should be ignored.\\n   *\\n   *   @param {HTMLLabelElement} element\\n   *          starting <label> element\\n   *   @param {boolean} reverse\\n   *          true to search backwards or false to search forwards\\n   *   @param {Map} potentialLabels\\n   *           map of form controls that have already potentially matched\\n   */\\n  findNextFormControl(element, reverse, potentialLabels) {\\n    // Ignore elements and stop searching for elements that are already potentially\\n    // labelled or are form elements that cannot be autofilled.\\n    while ((element = this.nextElementInOrder(element, reverse))) {\\n      if (potentialLabels.has(element)) {\\n        break;\\n      } else if (\\n        lazy.FormAutofillUtils.isCreditCardOrAddressFieldType(element)\\n      ) {\\n        return element;\\n      } else if (\\n        [\\n          \\\"button\\\",\\n          \\\"input\\\",\\n          \\\"label\\\",\\n          \\\"meter\\\",\\n          \\\"output\\\",\\n          \\\"progress\\\",\\n          \\\"select\\\",\\n          \\\"textarea\\\",\\n        ].includes(element.localName)\\n      ) {\\n        break;\\n      }\\n    }\\n\\n    return null;\\n  },\\n\\n  nextElementInOrder(element, reverse) {\\n    let result = reverse ? element.lastElementChild : element.firstElementChild;\\n    if (result) {\\n      return result;\\n    }\\n\\n    while (element) {\\n      result = reverse\\n        ? element.previousElementSibling\\n        : element.nextElementSibling;\\n      if (result) {\\n        return result;\\n      }\\n\\n      element = element.parentNode;\\n      if (\\n        !element ||\\n        element.localName == \\\"form\\\" ||\\n        element.localName == \\\"fieldset\\\"\\n      ) {\\n        break;\\n      }\\n    }\\n\\n    return null;\\n  },\\n\\n  generateLabelMap(doc) {\\n    this._mappedLabels = new Map();\\n    this._unmappedLabelControls = [];\\n    this._labelStrings = new WeakMap();\\n\\n    // A map of potential label -> control for labels that don't have an id or\\n    // control associated with them. Labels that have ids or associated controls\\n    // will be placed in _mappedLabels.\\n    let potentialLabels = new Map();\\n\\n    for (let label of doc.querySelectorAll(\\\"label\\\")) {\\n      let id = label.htmlFor;\\n      let control;\\n      if (!id) {\\n        control = label.control;\\n        if (!control) {\\n          // If the label has no control, look for the next input or select\\n          // element in the document and add that to the potentialLabels list.\\n          control = this.findAdjacentControl(label, potentialLabels);\\n          if (control) {\\n            potentialLabels.set(control, label);\\n          } else {\\n            continue;\\n          }\\n        }\\n        id = control.id;\\n      }\\n      if (id) {\\n        let labels = this._mappedLabels.get(id);\\n        if (labels) {\\n          labels.push(label);\\n        } else {\\n          this._mappedLabels.set(id, [label]);\\n        }\\n      } else {\\n        // control must be non-empty here\\n        this._unmappedLabelControls.push({ label, control });\\n      }\\n    }\\n\\n    // Now check the potentialLabels list. If any of the labels match form controls\\n    // that are not bound to a label, add them. This allows a label to match a form\\n    // control that is nearby even when it has no for attribute or doesn't match an id.\\n    if (potentialLabels.size) {\\n      for (let label of potentialLabels) {\\n        if (\\n          !this._unmappedLabelControls.some(e => e.control == label[0]) &&\\n          (!label[1].id || !this._mappedLabels.has(label[1].id))\\n        ) {\\n          this._unmappedLabelControls.push({\\n            label: label[1],\\n            control: label[0],\\n          });\\n        }\\n      }\\n    }\\n  },\\n\\n  clearLabelMap() {\\n    this._mappedLabels = null;\\n    this._unmappedLabelControls = null;\\n    this._labelStrings = null;\\n  },\\n\\n  findLabelElements(element) {\\n    if (!this._mappedLabels) {\\n      this.generateLabelMap(element.ownerDocument);\\n    }\\n\\n    let id = element.id;\\n    if (!id) {\\n      return this._unmappedLabelControls\\n        .filter(lc => lc.control == element)\\n        .map(lc => lc.label);\\n    }\\n    return this._mappedLabels.get(id) || [];\\n  },\\n};\\n\\nexport default LabelUtils;\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginFormFactory.sys.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginFormFactory.sys.mjs ***!
  \*********************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n/**\\n * A factory to generate LoginForm objects that represent a set of login fields\\n * which aren't necessarily marked up with a <form> element.\\n */\\n\\nconst lazy = {};\\n\\nChromeUtils.defineESModuleGetters(lazy, {\\n  FormLikeFactory: \\\"resource://gre/modules/FormLikeFactory.sys.mjs\\\",\\n  LoginHelper: \\\"resource://gre/modules/LoginHelper.sys.mjs\\\",\\n  Logic: \\\"resource://gre/modules/LoginManager.shared.sys.mjs\\\",\\n});\\n\\nChromeUtils.defineLazyGetter(lazy, \\\"log\\\", () => {\\n  return lazy.LoginHelper.createLogger(\\\"LoginFormFactory\\\");\\n});\\n\\nexport const LoginFormFactory = {\\n  /**\\n   * WeakMap of the root element of a LoginForm to the LoginForm representing its fields.\\n   *\\n   * This is used to be able to lookup an existing LoginForm for a given root element since multiple\\n   * calls to LoginFormFactory.createFrom* won't give the exact same object. When batching fills we don't always\\n   * want to use the most recent list of elements for a LoginForm since we may end up doing multiple\\n   * fills for the same set of elements when a field gets added between arming and running the\\n   * DeferredTask.\\n   *\\n   * @type {WeakMap}\\n   */\\n  _loginFormsByRootElement: new WeakMap(),\\n\\n  /**\\n   * Maps all DOM content documents in this content process, including those in\\n   * frames, to a WeakSet of LoginForm.rootElement for the document.\\n   */\\n  _loginFormRootElementsByDocument: new WeakMap(),\\n\\n  /**\\n   * Create a LoginForm object from a <form>.\\n   *\\n   * @param {HTMLFormElement} aForm\\n   * @return {LoginForm}\\n   * @throws Error if aForm isn't an HTMLFormElement\\n   */\\n  createFromForm(aForm) {\\n    let formLike = lazy.FormLikeFactory.createFromForm(aForm);\\n    formLike.action = lazy.Logic.getFormActionOrigin(aForm);\\n\\n    this._addLoginFormToRootElementsSet(formLike);\\n\\n    return formLike;\\n  },\\n\\n  /**\\n   * Create a LoginForm object from an elememt that is the root of the document\\n   *\\n   * Currently all <input> not in a <form> are one LoginForm but this\\n   * shouldn't be relied upon as the heuristics may change to detect multiple\\n   * \\\"forms\\\" (e.g. registration and login) on one page with a <form>.\\n   *\\n   * @param {HTMLElement} aDocumentRoot\\n   * @return {LoginForm}\\n   * @throws Error if aDocumentRoot is null\\n   */\\n  createFromDocumentRoot(aDocumentRoot) {\\n    const formLike = lazy.FormLikeFactory.createFromDocumentRoot(aDocumentRoot);\\n    formLike.action = lazy.Logic.getLoginOrigin(aDocumentRoot.baseURI);\\n\\n    lazy.log.debug(\\n      \\\"Created non-form LoginForm for rootElement:\\\",\\n      aDocumentRoot\\n    );\\n\\n    this._addLoginFormToRootElementsSet(formLike);\\n\\n    return formLike;\\n  },\\n\\n  /**\\n   * Create a LoginForm object from a password or username field.\\n   *\\n   * If the field is in a <form>, construct the LoginForm from the form.\\n   * Otherwise, create a LoginForm with a rootElement (wrapper) according to\\n   * heuristics. Currently all <input> not in a <form> are one LoginForm but this\\n   * shouldn't be relied upon as the heuristics may change to detect multiple\\n   * \\\"forms\\\" (e.g. registration and login) on one page with a <form>.\\n   *\\n   * Note that two LoginForms created from the same field won't return the same LoginForm object.\\n   * Use the `rootElement` property on the LoginForm as a key instead.\\n   *\\n   * @param {HTMLInputElement} aField - a password or username field in a document\\n   * @return {LoginForm}\\n   * @throws Error if aField isn't a password or username field in a document\\n   */\\n  createFromField(aField) {\\n    if (\\n      !HTMLInputElement.isInstance(aField) ||\\n      (!aField.hasBeenTypePassword &&\\n        !lazy.Logic.isUsernameFieldType(aField)) ||\\n      !aField.ownerDocument\\n    ) {\\n      throw new Error(\\n        \\\"createFromField requires a password or username field in a document\\\"\\n      );\\n    }\\n\\n    let form =\\n      aField.form ||\\n      lazy.FormLikeFactory.closestFormIgnoringShadowRoots(aField);\\n    if (form) {\\n      return this.createFromForm(form);\\n    } else if (aField.hasAttribute(\\\"form\\\")) {\\n      lazy.log.debug(\\n        \\\"createFromField: field has form attribute but no form: \\\",\\n        aField.getAttribute(\\\"form\\\")\\n      );\\n    }\\n\\n    let formLike = lazy.FormLikeFactory.createFromField(aField);\\n    formLike.action = lazy.Logic.getLoginOrigin(aField.ownerDocument.baseURI);\\n    lazy.log.debug(\\n      \\\"Created non-form LoginForm for rootElement:\\\",\\n      aField.ownerDocument.documentElement\\n    );\\n\\n    this._addLoginFormToRootElementsSet(formLike);\\n    return formLike;\\n  },\\n\\n  getRootElementsWeakSetForDocument(aDocument) {\\n    let rootElementsSet = this._loginFormRootElementsByDocument.get(aDocument);\\n    if (!rootElementsSet) {\\n      rootElementsSet = new WeakSet();\\n      this._loginFormRootElementsByDocument.set(aDocument, rootElementsSet);\\n    }\\n    return rootElementsSet;\\n  },\\n\\n  getForRootElement(aRootElement) {\\n    return this._loginFormsByRootElement.get(aRootElement);\\n  },\\n\\n  setForRootElement(aRootElement, aLoginForm) {\\n    return this._loginFormsByRootElement.set(aRootElement, aLoginForm);\\n  },\\n\\n  _addLoginFormToRootElementsSet(formLike) {\\n    let rootElementsSet = this.getRootElementsWeakSetForDocument(\\n      formLike.ownerDocument\\n    );\\n    rootElementsSet.add(formLike.rootElement);\\n    lazy.log.debug(\\n      \\\"adding\\\",\\n      formLike.rootElement,\\n      \\\"to root elements for\\\",\\n      formLike.ownerDocument\\n    );\\n\\n    this._loginFormsByRootElement.set(formLike.rootElement, formLike);\\n  },\\n};\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/LoginFormFactory.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginFormState.sys.mjs":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginFormState.sys.mjs ***!
  \*******************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"import { Logic } from \\\"resource://gre/modules/LoginManager.shared.sys.mjs\\\";\\n\\nconst lazy = {};\\n\\nChromeUtils.defineESModuleGetters(lazy, {\\n  FormLikeFactory: \\\"resource://gre/modules/FormLikeFactory.sys.mjs\\\",\\n  LoginFormFactory: \\\"resource://gre/modules/shared/LoginFormFactory.sys.mjs\\\",\\n  LoginHelper: \\\"resource://gre/modules/LoginHelper.sys.mjs\\\",\\n  LoginRecipesContent: \\\"resource://gre/modules/LoginRecipes.sys.mjs\\\",\\n});\\n\\nexport const AUTOFILL_STATE = \\\"autofill\\\";\\n\\n// Events on pages with Shadow DOM could return the shadow host element\\n// (aEvent.target) rather than the actual username or password field\\n// (aEvent.composedTarget).\\n// Only allow input elements (can be extended later) to avoid false negatives.\\nexport class WeakFieldSet extends WeakSet {\\n  add(value) {\\n    if (!HTMLInputElement.isInstance(value)) {\\n      throw new Error(\\\"Non-field type added to a WeakFieldSet\\\");\\n    }\\n    super.add(value);\\n  }\\n}\\n\\n/**\\n * Logic of Capture and Filling.\\n *\\n * This class will be shared with Firefox iOS and should have no references to\\n * Gecko internals. See Bug 1774208.\\n */\\nexport class LoginFormState {\\n  /**\\n   * Keeps track of filled fields and values.\\n   */\\n  fillsByRootElement = new WeakMap();\\n  /**\\n   * Keeps track of fields we've filled with generated passwords\\n   */\\n  generatedPasswordFields = new WeakFieldSet();\\n  /**\\n   * Keeps track of logins that were last submitted.\\n   */\\n  lastSubmittedValuesByRootElement = new WeakMap();\\n  fieldModificationsByRootElement = new WeakMap();\\n  /**\\n   * Anything entered into an <input> that we think might be a username\\n   */\\n  possibleUsernames = new Set();\\n  /**\\n   * Anything entered into an <input> that we think might be a password\\n   */\\n  possiblePasswords = new Set();\\n\\n  /**\\n   * Keeps track of the formLike of nodes (form or formless password field)\\n   * that we are watching when they are removed from DOM.\\n   */\\n  formLikeByObservedNode = new WeakMap();\\n\\n  /**\\n   * Keeps track of all formless password fields that have been\\n   * updated by the user.\\n   */\\n  formlessModifiedPasswordFields = new WeakFieldSet();\\n\\n  /**\\n   * Caches the results of the username heuristics\\n   */\\n  #cachedIsInferredUsernameField = new WeakMap();\\n  #cachedIsInferredEmailField = new WeakMap();\\n  #cachedIsInferredLoginForm = new WeakMap();\\n\\n  /**\\n   * Records the mock username field when its associated form is submitted.\\n   */\\n  mockUsernameOnlyField = null;\\n\\n  /**\\n   * Records the number of possible username event received for this document.\\n   */\\n  numFormHasPossibleUsernameEvent = 0;\\n\\n  captureLoginTimeStamp = 0;\\n\\n  // Scenarios detected on this page\\n  #scenariosByRoot = new WeakMap();\\n\\n  constructor(logger = () => {}, observer = () => {}) {\\n    LoginFormState.logger = logger;\\n    this.observer = observer;\\n  }\\n\\n  getScenario(inputElement) {\\n    const formLikeRoot = lazy.FormLikeFactory.findRootForField(inputElement);\\n    return this.#scenariosByRoot.get(formLikeRoot);\\n  }\\n\\n  setScenario(formLikeRoot, scenario) {\\n    this.#scenariosByRoot.set(formLikeRoot, scenario);\\n  }\\n\\n  storeUserInput(field) {\\n    if (field.value && lazy.LoginHelper.captureInputChanges) {\\n      if (Logic.isPasswordFieldType(field)) {\\n        this.possiblePasswords.add(field.value);\\n      } else if (Logic.isUsernameFieldType(field)) {\\n        this.possibleUsernames.add(field.value);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Returns true if the input field is considered an email field by\\n   * 'LoginHelper.isInferredEmailField'.\\n   *\\n   * @param {Element} element the field to check.\\n   * @returns {boolean} True if the element is likely an email field\\n   */\\n  isProbablyAnEmailField(inputElement) {\\n    if (!inputElement) {\\n      return false;\\n    }\\n\\n    let result = this.#cachedIsInferredEmailField.get(inputElement);\\n    if (result === undefined) {\\n      result = Logic.isInferredEmailField(inputElement);\\n      this.#cachedIsInferredEmailField.set(inputElement, result);\\n    }\\n\\n    return result;\\n  }\\n\\n  /**\\n   * Returns true if the input field is considered a username field by\\n   * 'LoginHelper.isInferredUsernameField'. The main purpose of this method\\n   * is to cache the result because _getFormFields has many call sites and we\\n   * want to avoid applying the heuristic every time.\\n   *\\n   * @param {Element} element the field to check.\\n   * @returns {boolean} True if the element is likely a username field\\n   */\\n  isProbablyAUsernameField(inputElement) {\\n    let result = this.#cachedIsInferredUsernameField.get(inputElement);\\n    if (result === undefined) {\\n      result = Logic.isInferredUsernameField(inputElement);\\n      this.#cachedIsInferredUsernameField.set(inputElement, result);\\n    }\\n\\n    return result;\\n  }\\n\\n  /**\\n   * Returns true if the form is considered a username login form if\\n   * 1. The input element looks like a username field or the form looks\\n   *    like a login form\\n   * 2. The input field doesn't match keywords that indicate the username\\n   *    is not used for login (ex, search) or the login form is not use\\n   *    a username to sign-in (ex, authentication code)\\n   *\\n   * @param {Element} element the form to check.\\n   * @returns {boolean} True if the element is likely a login form\\n   */\\n  #isProbablyAUsernameLoginForm(formElement, inputElement) {\\n    let result = this.#cachedIsInferredLoginForm.get(formElement);\\n    if (result === undefined) {\\n      // We should revisit these rules after we collect more positive or negative\\n      // cases for username-only forms. Right now, if-else-based rules are good\\n      // enough to cover the sites we know, but if we find out defining \\\"weight\\\" for each\\n      // rule is necessary to improve the heuristic, we should consider switching\\n      // this with Fathom.\\n\\n      result = false;\\n      // Check whether the input field looks like a username field or the\\n      // form looks like a sign-in or sign-up form.\\n      if (\\n        this.isProbablyAUsernameField(inputElement) ||\\n        Logic.isInferredLoginForm(formElement)\\n      ) {\\n        // This is where we collect hints that indicate this is not a username\\n        // login form.\\n        if (!Logic.isInferredNonUsernameField(inputElement)) {\\n          result = true;\\n        }\\n      }\\n      this.#cachedIsInferredLoginForm.set(formElement, result);\\n    }\\n\\n    return result;\\n  }\\n\\n  /**\\n   * Given a field, determine whether that field was last filled as a username\\n   * field AND whether the username is still filled in with the username AND\\n   * whether the associated password field has the matching password.\\n   *\\n   * @note This could possibly be unified with getFieldContext but they have\\n   * slightly different use cases. getFieldContext looks up recipes whereas this\\n   * method doesn't need to since it's only returning a boolean based upon the\\n   * recipes used for the last fill (in _fillForm).\\n   *\\n   * @param {HTMLInputElement} aUsernameField element contained in a LoginForm\\n   *                                          cached in LoginFormFactory.\\n   * @returns {Boolean} whether the username and password fields still have the\\n   *                    last-filled values, if previously filled.\\n   */\\n  #isLoginAlreadyFilled(aUsernameField) {\\n    let formLikeRoot = lazy.FormLikeFactory.findRootForField(aUsernameField);\\n    // Look for the existing LoginForm.\\n    let existingLoginForm =\\n      lazy.LoginFormFactory.getForRootElement(formLikeRoot);\\n    if (!existingLoginForm) {\\n      throw new Error(\\n        \\\"#isLoginAlreadyFilled called with a username field with \\\" +\\n          \\\"no rootElement LoginForm\\\"\\n      );\\n    }\\n\\n    let { login: filledLogin } =\\n      this.fillsByRootElement.get(formLikeRoot) || {};\\n    if (!filledLogin) {\\n      return false;\\n    }\\n\\n    // Unpack the weak references.\\n    let autoFilledUsernameField = filledLogin.usernameField?.get();\\n    let autoFilledPasswordField = filledLogin.passwordField?.get();\\n\\n    // Check username and password values match what was filled.\\n    if (\\n      !autoFilledUsernameField ||\\n      autoFilledUsernameField != aUsernameField ||\\n      autoFilledUsernameField.value != filledLogin.username ||\\n      (autoFilledPasswordField &&\\n        autoFilledPasswordField.value != filledLogin.password)\\n    ) {\\n      return false;\\n    }\\n\\n    return true;\\n  }\\n\\n  _togglePasswordFieldMasking(passwordField, unmask) {\\n    let { editor } = passwordField;\\n\\n    if (passwordField.type != \\\"password\\\") {\\n      // The type may have been changed by the website.\\n      LoginFormState.logger(\\\"Field isn't type=password.\\\");\\n      return;\\n    }\\n\\n    if (!unmask && !editor) {\\n      // It hasn't been created yet but the default is to be masked anyways.\\n      return;\\n    }\\n\\n    if (unmask) {\\n      editor.unmask(0);\\n      return;\\n    }\\n\\n    if (editor.autoMaskingEnabled) {\\n      return;\\n    }\\n    editor.mask();\\n  }\\n\\n  /**\\n   * Track a form field as has having been filled with a generated password. This adds explicit\\n   * focus & blur handling to unmask & mask the value, and enables special handling of edits to\\n   * generated password values (see the observer's input event handler.)\\n   *\\n   * @param {HTMLInputElement} passwordField\\n   */\\n  _treatAsGeneratedPasswordField(passwordField) {\\n    this.generatedPasswordFields.add(passwordField);\\n\\n    // blur/focus: listen for focus changes to we can mask/unmask generated passwords\\n    for (let eventType of [\\\"blur\\\", \\\"focus\\\"]) {\\n      passwordField.addEventListener(eventType, this.observer, {\\n        capture: true,\\n        mozSystemGroup: true,\\n      });\\n    }\\n    if (passwordField.ownerDocument.activeElement == passwordField) {\\n      // Unmask the password field\\n      this._togglePasswordFieldMasking(passwordField, true);\\n    }\\n  }\\n\\n  _formHasModifiedFields(form) {\\n    const doc = form.rootElement.ownerDocument;\\n    let userHasInteracted;\\n    const testOnlyUserHasInteracted =\\n      lazy.LoginHelper.testOnlyUserHasInteractedWithDocument;\\n    if (Cu.isInAutomation && testOnlyUserHasInteracted !== null) {\\n      userHasInteracted = testOnlyUserHasInteracted;\\n    } else {\\n      userHasInteracted =\\n        !lazy.LoginHelper.userInputRequiredToCapture ||\\n        this.captureLoginTimeStamp != doc.lastUserGestureTimeStamp;\\n    }\\n\\n    LoginFormState.logger(\\n      `_formHasModifiedFields: userHasInteracted: ${userHasInteracted}.`\\n    );\\n\\n    // Skip if user didn't interact with the page since last call or ever\\n    if (!userHasInteracted) {\\n      return false;\\n    }\\n\\n    // check for user inputs to the form fields\\n    let fieldsModified = this.fieldModificationsByRootElement.get(\\n      form.rootElement\\n    );\\n    // also consider a form modified if there's a difference between fields' .value and .defaultValue\\n    if (!fieldsModified) {\\n      fieldsModified = Array.from(form.elements).some(\\n        field =>\\n          field.defaultValue !== undefined && field.value !== field.defaultValue\\n      );\\n    }\\n    return fieldsModified;\\n  }\\n\\n  _stopTreatingAsGeneratedPasswordField(passwordField) {\\n    this.generatedPasswordFields.delete(passwordField);\\n\\n    // Remove all the event listeners added in _passwordEditedOrGenerated\\n    for (let eventType of [\\\"blur\\\", \\\"focus\\\"]) {\\n      passwordField.removeEventListener(eventType, this.observer, {\\n        capture: true,\\n        mozSystemGroup: true,\\n      });\\n    }\\n\\n    // Mask the password field\\n    this._togglePasswordFieldMasking(passwordField, false);\\n  }\\n\\n  onFocus(field, focusedField, onUsernameFocus) {\\n    if (field.hasBeenTypePassword && this.generatedPasswordFields.has(field)) {\\n      // Used to unmask fields with filled generated passwords when focused.\\n      this._togglePasswordFieldMasking(field, true);\\n      return;\\n    }\\n\\n    if (this.#isLoginAlreadyFilled(focusedField)) {\\n      LoginFormState.logger(\\\"Login already filled.\\\");\\n      return;\\n    }\\n\\n    // Only used for username fields.\\n    onUsernameFocus(focusedField);\\n  }\\n\\n  /** Remove login field highlight when its value is cleared or overwritten.\\n   */\\n  static #removeFillFieldHighlight(event) {\\n    event.target.autofillState = \\\"\\\";\\n  }\\n\\n  /**\\n   * Highlight login fields on autocomplete or autofill on page load.\\n   * @param {Node} element that needs highlighting.\\n   */\\n  static _highlightFilledField(element) {\\n    element.autofillState = AUTOFILL_STATE;\\n    // Remove highlighting when the field is changed.\\n    element.addEventListener(\\n      \\\"input\\\",\\n      LoginFormState.#removeFillFieldHighlight,\\n      {\\n        mozSystemGroup: true,\\n        once: true,\\n      }\\n    );\\n  }\\n\\n  /**\\n   * Returns the username field of the passed form if the form is a\\n   * username-only form.\\n   * A form is considered a username-only form only if it meets all the\\n   * following conditions:\\n   * 1. Does not have any password field,\\n   * 2. Only contains one input field whose type is username compatible.\\n   * 3. The username compatible input field looks like a username field\\n   *    or the form itself looks like a sign-in or sign-up form.\\n   * Additionally, if an input is formless and its autocomplete attribute is\\n   * set to 'username' (this check is done in the DOM to avoid firing excessive events),\\n   * we construct a FormLike object using this input and perform the same logic\\n   * described above to determine if the new FormLike object is username-only.\\n   *\\n   * @param {FormLike} form\\n   *                  the form to check.\\n   * @param {Object}  recipe=null\\n   *                  A relevant field override recipe to use.\\n   * @returns {Element} The username field or null (if the form is not a\\n   *                    username-only form).\\n   */\\n  getUsernameFieldFromUsernameOnlyForm(form, recipe = null) {\\n    let candidate = null;\\n    for (let element of form.elements) {\\n      // We are looking for a username-only form, so if there is a password\\n      // field in the form, this is NOT a username-only form.\\n      if (element.hasBeenTypePassword) {\\n        return null;\\n      }\\n\\n      // Ignore input fields whose type are not username compatiable, ex, hidden.\\n      if (!Logic.isUsernameFieldType(element)) {\\n        continue;\\n      }\\n\\n      if (\\n        recipe?.notUsernameSelector &&\\n        element.matches(recipe.notUsernameSelector)\\n      ) {\\n        continue;\\n      }\\n\\n      // If there are more than two input fields whose type is username\\n      // compatiable, this is NOT a username-only form.\\n      if (candidate) {\\n        return null;\\n      }\\n      candidate = element;\\n    }\\n    if (\\n      candidate &&\\n      this.#isProbablyAUsernameLoginForm(form.rootElement, candidate)\\n    ) {\\n      return candidate;\\n    }\\n\\n    return null;\\n  }\\n\\n  /**\\n   * @param {LoginForm} form - the LoginForm to look for password fields in.\\n   * @param {Object} options\\n   * @param {bool} [options.skipEmptyFields=false] - Whether to ignore password fields with no value.\\n   *                                                 Used at capture time since saving empty values isn't\\n   *                                                 useful.\\n   * @param {Object} [options.fieldOverrideRecipe=null] - A relevant field override recipe to use.\\n   * @return {Array|null} Array of password field elements for the specified form.\\n   *                      If no pw fields are found, or if more than 5 are found, then null\\n   *                      is returned.\\n   */\\n  static _getPasswordFields(\\n    form,\\n    {\\n      fieldOverrideRecipe = null,\\n      minPasswordLength = 0,\\n      ignoreConnect = false,\\n    } = {}\\n  ) {\\n    // Locate the password fields in the form.\\n    let pwFields = [];\\n    for (let i = 0; i < form.elements.length; i++) {\\n      let element = form.elements[i];\\n      if (\\n        !HTMLInputElement.isInstance(element) ||\\n        !element.hasBeenTypePassword ||\\n        (!element.isConnected && !ignoreConnect)\\n      ) {\\n        continue;\\n      }\\n\\n      // Exclude ones matching a `notPasswordSelector`, if specified.\\n      if (\\n        fieldOverrideRecipe?.notPasswordSelector &&\\n        element.matches(fieldOverrideRecipe.notPasswordSelector)\\n      ) {\\n        LoginFormState.logger(\\n          `Skipping password field with id: ${element.id}, name: ${element.name} due to recipe ${fieldOverrideRecipe}.`\\n        );\\n        continue;\\n      }\\n\\n      // XXX: Bug 780449 tracks our handling of emoji and multi-code-point characters in\\n      // password fields. To avoid surprises, we should be consistent with the visual\\n      // representation of the masked password\\n      if (\\n        minPasswordLength &&\\n        element.value.trim().length < minPasswordLength\\n      ) {\\n        LoginFormState.logger(\\n          `Skipping password field with id: ${element.id}, name: ${element.name} as value is too short.`\\n        );\\n        continue; // Ignore empty or too-short passwords fields\\n      }\\n\\n      pwFields[pwFields.length] = {\\n        index: i,\\n        element,\\n      };\\n    }\\n\\n    // If too few or too many fields, bail out.\\n    if (!pwFields.length) {\\n      LoginFormState.logger(\\\"Form ignored, no password fields.\\\");\\n      return null;\\n    }\\n\\n    if (pwFields.length > 5) {\\n      LoginFormState.logger(\\n        `Form ignored, too many password fields:  ${pwFields.length}.`\\n      );\\n      return null;\\n    }\\n\\n    return pwFields;\\n  }\\n\\n  /**\\n   * Stores passed arguments, and returns whether or not they match the args given the last time\\n   * this method was called with the same [formLikeRoot]. This is used to avoid sending duplicate\\n   * messages to the parent.\\n   *\\n   * @param {Element} formLikeRoot\\n   * @param {string} usernameValue\\n   * @param {string} passwordValue\\n   * @param {boolean?} [dismissed=false]\\n   * @param {boolean?} [triggeredByFillingGenerated=false] whether or not this call was triggered by a generated\\n   *        password being filled into a form-like element.\\n   *\\n   * @returns {boolean} true if args match the most recently passed values\\n   */\\n  compareAndUpdatePreviouslySentValues(\\n    formLikeRoot,\\n    usernameValue,\\n    passwordValue,\\n    dismissed = false,\\n    triggeredByFillingGenerated = false\\n  ) {\\n    const lastSentValues =\\n      this.lastSubmittedValuesByRootElement.get(formLikeRoot);\\n    if (lastSentValues) {\\n      if (dismissed && !lastSentValues.dismissed) {\\n        // preserve previous dismissed value if it was false (i.e. shown/open)\\n        dismissed = false;\\n      }\\n      if (\\n        lastSentValues.username == usernameValue &&\\n        lastSentValues.password == passwordValue &&\\n        lastSentValues.dismissed == dismissed &&\\n        lastSentValues.triggeredByFillingGenerated ==\\n          triggeredByFillingGenerated\\n      ) {\\n        LoginFormState.logger(\\n          \\\"compareAndUpdatePreviouslySentValues: values are equivalent, returning true.\\\"\\n        );\\n        return true;\\n      }\\n    }\\n\\n    // Save the last submitted values so we don't prompt twice for the same values using\\n    // different capture methods e.g. a form submit event and upon navigation.\\n    this.lastSubmittedValuesByRootElement.set(formLikeRoot, {\\n      username: usernameValue,\\n      password: passwordValue,\\n      dismissed,\\n      triggeredByFillingGenerated,\\n    });\\n    LoginFormState.logger(\\n      \\\"compareAndUpdatePreviouslySentValues: values not equivalent, returning false.\\\"\\n    );\\n    return false;\\n  }\\n\\n  fillConfirmFieldWithGeneratedPassword(passwordField) {\\n    const form = lazy.LoginFormFactory.createFromField(passwordField);\\n    const previousGeneratedPasswordField = form.elements.some(\\n      inp => inp !== passwordField && this.generatedPasswordFields.has(inp)\\n    );\\n    if (previousGeneratedPasswordField) {\\n      LoginFormState.logger(\\n        \\\"Previously-filled generated password input found.\\\"\\n      );\\n      return;\\n    }\\n\\n    const confirmPasswordInput = Logic.findConfirmationField(\\n      passwordField,\\n      lazy.LoginFormFactory\\n    );\\n\\n    if (confirmPasswordInput && !confirmPasswordInput.value) {\\n      this._treatAsGeneratedPasswordField(confirmPasswordInput);\\n      confirmPasswordInput.setUserInput(passwordField.value);\\n      LoginFormState._highlightFilledField(confirmPasswordInput);\\n    }\\n  }\\n\\n  /**\\n   * Returns the username and password fields found in the form.\\n   * Can handle complex forms by trying to figure out what the\\n   * relevant fields are.\\n   *\\n   * @param {LoginForm} form\\n   * @param {bool} isSubmission\\n   * @param {Set} recipes\\n   * @param {Object} options\\n   * @param {bool} [options.ignoreConnect] - Whether to ignore checking isConnected\\n   *                                         of the element.\\n   * @return {Object} {usernameField, newPasswordField, oldPasswordField, confirmPasswordField}\\n   *\\n   * usernameField may be null.\\n   * newPasswordField may be null. If null, this is a username-only form.\\n   * oldPasswordField may be null. If null, newPasswordField is just\\n   * \\\"theLoginField\\\". If not null, the form is apparently a\\n   * change-password field, with oldPasswordField containing the password\\n   * that is being changed.\\n   *\\n   * Note that even though we can create a LoginForm from a text field,\\n   * this method will only return a non-null usernameField if the\\n   * LoginForm has a password field.\\n   */\\n  _getFormFields(form, isSubmission, recipes, { ignoreConnect = false } = {}) {\\n    let usernameField = null;\\n    let newPasswordField = null;\\n    let oldPasswordField = null;\\n    let confirmPasswordField = null;\\n    let emptyResult = {\\n      usernameField: null,\\n      newPasswordField: null,\\n      oldPasswordField: null,\\n      confirmPasswordField: null,\\n    };\\n\\n    let pwFields = null;\\n    let fieldOverrideRecipe = lazy.LoginRecipesContent.getFieldOverrides(\\n      recipes,\\n      form\\n    );\\n    if (fieldOverrideRecipe) {\\n      LoginFormState.logger(\\\"fieldOverrideRecipe found \\\", fieldOverrideRecipe);\\n      let pwOverrideField = lazy.LoginRecipesContent.queryLoginField(\\n        form,\\n        fieldOverrideRecipe.passwordSelector\\n      );\\n      if (pwOverrideField) {\\n        LoginFormState.logger(\\\"pwOverrideField found \\\", pwOverrideField);\\n        // The field from the password override may be in a different LoginForm.\\n        let formLike = lazy.LoginFormFactory.createFromField(pwOverrideField);\\n        pwFields = [\\n          {\\n            index: [...formLike.elements].indexOf(pwOverrideField),\\n            element: pwOverrideField,\\n          },\\n        ];\\n      }\\n\\n      let usernameOverrideField = lazy.LoginRecipesContent.queryLoginField(\\n        form,\\n        fieldOverrideRecipe.usernameSelector\\n      );\\n      if (usernameOverrideField) {\\n        usernameField = usernameOverrideField;\\n      }\\n    }\\n\\n    if (!pwFields) {\\n      // Locate the password field(s) in the form. Up to 5 supported.\\n      // If there's no password field, there's nothing for us to do.\\n      const minSubmitPasswordLength = 2;\\n      pwFields = LoginFormState._getPasswordFields(form, {\\n        fieldOverrideRecipe,\\n        minPasswordLength: isSubmission ? minSubmitPasswordLength : 0,\\n        ignoreConnect,\\n      });\\n    }\\n\\n    // Check whether this is a username-only form when the form doesn't have\\n    // a password field. Note that recipes are not supported in username-only\\n    // forms currently (Bug 1708455).\\n    if (!pwFields) {\\n      if (!lazy.LoginHelper.usernameOnlyFormEnabled) {\\n        return emptyResult;\\n      }\\n\\n      usernameField = this.getUsernameFieldFromUsernameOnlyForm(\\n        form,\\n        fieldOverrideRecipe\\n      );\\n\\n      if (usernameField) {\\n        LoginFormState.logger(\\n          `Found username field with name: ${usernameField.name}.`\\n        );\\n      }\\n\\n      return {\\n        ...emptyResult,\\n        usernameField,\\n      };\\n    }\\n\\n    if (!usernameField) {\\n      // Searching backwards from the first password field until we find a field\\n      // that looks like a \\\"username\\\" field. If no \\\"username\\\" field is found,\\n      // consider an email-like field a username field, if any.\\n      // If neither a username-like or an email-like field exists, assume the\\n      // first text field before the password field is the username.\\n      // We might not find a username field if the user is already logged in to the site.\\n      //\\n      // Note: We only search fields precede the first password field because we\\n      // don't see sites putting a username field after a password field. We can\\n      // extend searching to all fields in the form if this turns out not to be the case.\\n\\n      for (let i = pwFields[0].index - 1; i >= 0; i--) {\\n        let element = form.elements[i];\\n        if (!Logic.isUsernameFieldType(element, { ignoreConnect })) {\\n          continue;\\n        }\\n\\n        if (\\n          fieldOverrideRecipe?.notUsernameSelector &&\\n          element.matches(fieldOverrideRecipe.notUsernameSelector)\\n        ) {\\n          continue;\\n        }\\n\\n        // Assume the first text field is the username by default.\\n        // It will be replaced if we find a likely username field afterward.\\n        if (!usernameField) {\\n          usernameField = element;\\n        }\\n\\n        if (this.isProbablyAUsernameField(element)) {\\n          // An username field is found, we are done.\\n          usernameField = element;\\n          break;\\n        } else if (this.isProbablyAnEmailField(element)) {\\n          // An email field is found, consider it a username field but continue\\n          // to search for an \\\"username\\\" field.\\n          // In current implementation, if another email field is found during\\n          // the process, we will use the new one.\\n          usernameField = element;\\n        }\\n      }\\n    }\\n\\n    if (!usernameField) {\\n      LoginFormState.logger(\\\"No username field found.\\\");\\n    } else {\\n      LoginFormState.logger(\\n        `Found username field with name: ${usernameField.name}.`\\n      );\\n    }\\n\\n    let pwGeneratedFields = pwFields.filter(pwField =>\\n      this.generatedPasswordFields.has(pwField.element)\\n    );\\n    if (pwGeneratedFields.length) {\\n      // we have at least the newPasswordField\\n      [newPasswordField, confirmPasswordField] = pwGeneratedFields.map(\\n        pwField => pwField.element\\n      );\\n      // if the user filled a field with a generated password,\\n      // a field immediately previous to that is most likely the old password field\\n      let idx = pwFields.findIndex(\\n        pwField => pwField.element === newPasswordField\\n      );\\n      if (idx > 0) {\\n        oldPasswordField = pwFields[idx - 1].element;\\n      }\\n      return {\\n        ...emptyResult,\\n        usernameField,\\n        newPasswordField,\\n        oldPasswordField: oldPasswordField || null,\\n        confirmPasswordField: confirmPasswordField || null,\\n      };\\n    }\\n\\n    // If we're not submitting a form (it's a page load), there are no\\n    // password field values for us to use for identifying fields. So,\\n    // just assume the first password field is the one to be filled in.\\n    if (!isSubmission || pwFields.length == 1) {\\n      let passwordField = pwFields[0].element;\\n      LoginFormState.logger(\\n        `Found Password field with name: ${passwordField.name}.`\\n      );\\n      return {\\n        ...emptyResult,\\n        usernameField,\\n        newPasswordField: passwordField,\\n        oldPasswordField: null,\\n      };\\n    }\\n\\n    // We're looking for both new and old password field\\n    // Try to figure out what is in the form based on the password values.\\n    let pw1 = pwFields[0].element.value;\\n    let pw2 = pwFields[1] ? pwFields[1].element.value : null;\\n    let pw3 = pwFields[2] ? pwFields[2].element.value : null;\\n\\n    if (pwFields.length == 3) {\\n      // Look for two identical passwords, that's the new password\\n\\n      if (pw1 == pw2 && pw2 == pw3) {\\n        // All 3 passwords the same? Weird! Treat as if 1 pw field.\\n        newPasswordField = pwFields[0].element;\\n        oldPasswordField = null;\\n      } else if (pw1 == pw2) {\\n        newPasswordField = pwFields[0].element;\\n        oldPasswordField = pwFields[2].element;\\n      } else if (pw2 == pw3) {\\n        oldPasswordField = pwFields[0].element;\\n        newPasswordField = pwFields[2].element;\\n      } else if (pw1 == pw3) {\\n        // A bit odd, but could make sense with the right page layout.\\n        newPasswordField = pwFields[0].element;\\n        oldPasswordField = pwFields[1].element;\\n      } else {\\n        // We can't tell which of the 3 passwords should be saved.\\n        LoginFormState.logger(`Form ignored -- all 3 pw fields differ.`);\\n        return emptyResult;\\n      }\\n    } else if (pw1 == pw2) {\\n      // pwFields.length == 2\\n      // Treat as if 1 pw field\\n      newPasswordField = pwFields[0].element;\\n      oldPasswordField = null;\\n    } else {\\n      // Just assume that the 2nd password is the new password\\n      oldPasswordField = pwFields[0].element;\\n      newPasswordField = pwFields[1].element;\\n    }\\n    LoginFormState.logger(\\n      `New Password field id: ${newPasswordField.id}, name: ${newPasswordField.name}.`\\n    );\\n\\n    LoginFormState.logger(\\n      oldPasswordField\\n        ? `Old Password field id: ${oldPasswordField.id}, name: ${oldPasswordField.name}.`\\n        : \\\"No Old password field.\\\"\\n    );\\n    return {\\n      ...emptyResult,\\n      usernameField,\\n      newPasswordField,\\n      oldPasswordField,\\n    };\\n  }\\n\\n  /**\\n   * Returns the username and password fields found in the form by input\\n   * element into form.\\n   *\\n   * @param {HTMLInputElement} aField\\n   *                           A form field\\n   * @return {Array} [usernameField, newPasswordField, oldPasswordField]\\n   *\\n   * Details of these values are the same as _getFormFields.\\n   */\\n  getUserNameAndPasswordFields(aField) {\\n    const noResult = [null, null, null];\\n    if (!HTMLInputElement.isInstance(aField)) {\\n      throw new Error(\\\"getUserNameAndPasswordFields: input element required\\\");\\n    }\\n\\n    if (aField.nodePrincipal.isNullPrincipal || !aField.isConnected) {\\n      return noResult;\\n    }\\n\\n    // If the element is not a login form field, return all null.\\n    if (!aField.hasBeenTypePassword && !Logic.isUsernameFieldType(aField)) {\\n      return noResult;\\n    }\\n\\n    const form = lazy.LoginFormFactory.createFromField(aField);\\n    const doc = aField.ownerDocument;\\n    const formOrigin = Logic.getLoginOrigin(doc.documentURI);\\n    const recipes = lazy.LoginRecipesContent.getRecipes(\\n      formOrigin,\\n      doc.defaultView\\n    );\\n    const { usernameField, newPasswordField, oldPasswordField } =\\n      this._getFormFields(form, false, recipes);\\n\\n    return [usernameField, newPasswordField, oldPasswordField];\\n  }\\n\\n  /**\\n   * Verify if a field is a valid login form field and\\n   * returns some information about it's LoginForm.\\n   *\\n   * @param {Element} aField\\n   *                  A form field we want to verify.\\n   *\\n   * @returns {Object} an object with information about the\\n   *                   LoginForm username and password field\\n   *                   or null if the passed field is invalid.\\n   */\\n  getFieldContext(aField) {\\n    // If the element is not a proper form field, return null.\\n    if (\\n      !HTMLInputElement.isInstance(aField) ||\\n      (!aField.hasBeenTypePassword && !Logic.isUsernameFieldType(aField)) ||\\n      aField.nodePrincipal.isNullPrincipal ||\\n      aField.nodePrincipal.schemeIs(\\\"about\\\") ||\\n      !aField.ownerDocument\\n    ) {\\n      return null;\\n    }\\n    let { hasBeenTypePassword } = aField;\\n\\n    // This array provides labels that correspond to the return values from\\n    // `getUserNameAndPasswordFields` so we can know which one aField is.\\n    const LOGIN_FIELD_ORDER = [\\\"username\\\", \\\"new-password\\\", \\\"current-password\\\"];\\n    let usernameAndPasswordFields = this.getUserNameAndPasswordFields(aField);\\n    let fieldNameHint;\\n    let indexOfFieldInUsernameAndPasswordFields =\\n      usernameAndPasswordFields.indexOf(aField);\\n    if (indexOfFieldInUsernameAndPasswordFields == -1) {\\n      // For fields in the form that are neither username nor password,\\n      // set fieldNameHint to \\\"other\\\". Right now, in contextmenu, we treat both\\n      // \\\"username\\\" and \\\"other\\\" field as username fields.\\n      fieldNameHint = hasBeenTypePassword ? \\\"current-password\\\" : \\\"other\\\";\\n    } else {\\n      fieldNameHint =\\n        LOGIN_FIELD_ORDER[indexOfFieldInUsernameAndPasswordFields];\\n    }\\n    let [, newPasswordField] = usernameAndPasswordFields;\\n\\n    return {\\n      activeField: {\\n        disabled: aField.disabled || aField.readOnly,\\n        fieldNameHint,\\n      },\\n      // `passwordField` may be the same as `activeField`.\\n      passwordField: {\\n        found: !!newPasswordField,\\n        disabled:\\n          newPasswordField &&\\n          (newPasswordField.disabled || newPasswordField.readOnly),\\n      },\\n    };\\n  }\\n}\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/LoginFormState.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.sys.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.sys.mjs ***!
  \************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n/**\\n * Code that we can share across Firefox Desktop, Firefox Android and Firefox iOS.\\n */\\n\\nimport { XPCOMUtils } from \\\"resource://gre/modules/XPCOMUtils.sys.mjs\\\";\\nimport { NewPasswordModel } from \\\"resource://gre/modules/shared/NewPasswordModel.sys.mjs\\\";\\n\\nclass Logic {\\n  static inputTypeIsCompatibleWithUsername(input) {\\n    const fieldType = input.getAttribute(\\\"type\\\")?.toLowerCase() || input.type;\\n    return (\\n      [\\\"text\\\", \\\"email\\\", \\\"url\\\", \\\"tel\\\", \\\"number\\\", \\\"search\\\"].includes(fieldType) ||\\n      fieldType?.includes(\\\"user\\\")\\n    );\\n  }\\n\\n  /**\\n   * Test whether the element has the keyword in its attributes.\\n   * The tested attributes include id, name, className, and placeholder.\\n   */\\n  static elementAttrsMatchRegex(element, regex) {\\n    if (\\n      regex.test(element.id) ||\\n      regex.test(element.name) ||\\n      regex.test(element.className)\\n    ) {\\n      return true;\\n    }\\n\\n    const placeholder = element.getAttribute(\\\"placeholder\\\");\\n    return placeholder && regex.test(placeholder);\\n  }\\n\\n  /**\\n   * Infer whether a form is a sign-in form by searching keywords\\n   * in its attributes\\n   *\\n   * @param {Element} element\\n   *                  the form we want to check.\\n   *\\n   * @returns {boolean} True if any of the rules matches\\n   */\\n  static isInferredLoginForm(formElement) {\\n    // This is copied from 'loginFormAttrRegex' in NewPasswordModel.sys.mjs\\n    const loginExpr =\\n      /login|log in|log on|log-on|sign in|sigin|sign\\\\/in|sign-in|sign on|sign-on/i;\\n\\n    if (Logic.elementAttrsMatchRegex(formElement, loginExpr)) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  /**\\n   * Search for keywords that indicates the input field is not likely a\\n   * field of a username login form.\\n   *\\n   * @param {Element} element\\n   *                  the input field we want to check.\\n   *\\n   * @returns {boolean} True if any of the rules matches\\n   */\\n  static isInferredNonUsernameField(element) {\\n    const expr = /\\\\b(search|code|add)\\\\b/i;\\n\\n    if (\\n      Logic.elementAttrsMatchRegex(element, expr) ||\\n      Logic.hasLabelMatchingRegex(element, expr)\\n    ) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  /**\\n   * Infer whether an input field is a username field by searching\\n   * 'username' keyword in its attributes\\n   *\\n   * @param {Element} element\\n   *                  the field we want to check.\\n   *\\n   * @returns {boolean} True if any of the rules matches\\n   */\\n  static isInferredUsernameField(element) {\\n    const expr = /username/i;\\n\\n    let ac = element.getAutocompleteInfo()?.fieldName;\\n    if (ac && ac == \\\"username\\\") {\\n      return true;\\n    }\\n\\n    if (\\n      Logic.elementAttrsMatchRegex(element, expr) ||\\n      Logic.hasLabelMatchingRegex(element, expr)\\n    ) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  /**\\n   * Infer whether an input field is an email field by searching\\n   * 'email' keyword in its attributes.\\n   *\\n   * @param {Element} element\\n   *                  the field we want to check.\\n   *\\n   * @returns {boolean} True if any of the rules matches\\n   */\\n  static isInferredEmailField(element) {\\n    const expr = /email|邮箱/i;\\n\\n    if (element.type == \\\"email\\\") {\\n      return true;\\n    }\\n\\n    let ac = element.getAutocompleteInfo()?.fieldName;\\n    if (ac && ac == \\\"email\\\") {\\n      return true;\\n    }\\n\\n    if (\\n      Logic.elementAttrsMatchRegex(element, expr) ||\\n      Logic.hasLabelMatchingRegex(element, expr)\\n    ) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  /**\\n   * Test whether associated labels of the element have the keyword.\\n   * This is a simplified rule of hasLabelMatchingRegex in NewPasswordModel.sys.mjs\\n   */\\n  static hasLabelMatchingRegex(element, regex) {\\n    return regex.test(element.labels?.[0]?.textContent);\\n  }\\n\\n  /**\\n   * Get the parts of the URL we want for identification.\\n   * Strip out things like the userPass portion and handle javascript:.\\n   */\\n  static getLoginOrigin(uriString, allowJS = false) {\\n    try {\\n      const mozProxyRegex = /^moz-proxy:\\\\/\\\\//i;\\n      if (mozProxyRegex.test(uriString)) {\\n        // Special handling for moz-proxy URIs\\n        const uri = new URL(uriString.replace(mozProxyRegex, \\\"https://\\\"));\\n        return `moz-proxy://${uri.host}`;\\n      }\\n\\n      const uri = new URL(uriString);\\n      if (uri.protocol === \\\"javascript:\\\") {\\n        return allowJS ? \\\"javascript:\\\" : null;\\n      }\\n\\n      // Ensure the URL has a host\\n      // Execption: file URIs See Bug 1651186\\n      return uri.host || uri.protocol === \\\"file:\\\"\\n        ? `${uri.protocol}//${uri.host}`\\n        : null;\\n    } catch {\\n      return null;\\n    }\\n  }\\n\\n  static getFormActionOrigin(form) {\\n    let uriString = form.action;\\n\\n    // A blank or missing action submits to where it came from.\\n    if (uriString == \\\"\\\") {\\n      // ala bug 297761\\n      uriString = form.baseURI;\\n    }\\n\\n    return this.getLoginOrigin(uriString, true);\\n  }\\n\\n  /**\\n   * Checks if a field type is username compatible.\\n   *\\n   * @param {Element} element\\n   *                  the field we want to check.\\n   * @param {Object} options\\n   * @param {bool} [options.ignoreConnect] - Whether to ignore checking isConnected\\n   *                                         of the element.\\n   *\\n   * @returns {Boolean} true if the field type is one\\n   *                    of the username types.\\n   */\\n  static isUsernameFieldType(element, { ignoreConnect = false } = {}) {\\n    if (!HTMLInputElement.isInstance(element)) {\\n      return false;\\n    }\\n\\n    if (!element.isConnected && !ignoreConnect) {\\n      // If the element isn't connected then it isn't visible to the user so\\n      // shouldn't be considered. It must have been connected in the past.\\n      return false;\\n    }\\n\\n    if (element.hasBeenTypePassword) {\\n      return false;\\n    }\\n\\n    if (!Logic.inputTypeIsCompatibleWithUsername(element)) {\\n      return false;\\n    }\\n\\n    let acFieldName = element.getAutocompleteInfo().fieldName;\\n    if (\\n      !(\\n        acFieldName == \\\"username\\\" ||\\n        acFieldName == \\\"webauthn\\\" ||\\n        // Bug 1540154: Some sites use tel/email on their username fields.\\n        acFieldName == \\\"email\\\" ||\\n        acFieldName == \\\"tel\\\" ||\\n        acFieldName == \\\"tel-national\\\" ||\\n        acFieldName == \\\"off\\\" ||\\n        acFieldName == \\\"on\\\" ||\\n        acFieldName == \\\"\\\"\\n      )\\n    ) {\\n      return false;\\n    }\\n    return true;\\n  }\\n\\n  /**\\n   * Checks if a field type is password compatible.\\n   *\\n   * @param {Element} element\\n   *                  the field we want to check.\\n   * @param {Object} options\\n   * @param {bool} [options.ignoreConnect] - Whether to ignore checking isConnected\\n   *                                         of the element.\\n   *\\n   * @returns {Boolean} true if the field can\\n   *                    be treated as a password input\\n   */\\n  static isPasswordFieldType(element, { ignoreConnect = false } = {}) {\\n    if (!HTMLInputElement.isInstance(element)) {\\n      return false;\\n    }\\n\\n    if (!element.isConnected && !ignoreConnect) {\\n      // If the element isn't connected then it isn't visible to the user so\\n      // shouldn't be considered. It must have been connected in the past.\\n      return false;\\n    }\\n\\n    if (!element.hasBeenTypePassword) {\\n      return false;\\n    }\\n\\n    // Ensure the element is of a type that could have autocomplete.\\n    // These include the types with user-editable values. If not, even if it used to be\\n    // a type=password, we can't treat it as a password input now\\n    let acInfo = element.getAutocompleteInfo();\\n    if (!acInfo) {\\n      return false;\\n    }\\n\\n    return true;\\n  }\\n\\n  static #cachedNewPasswordScore = new WeakMap();\\n\\n  static isProbablyANewPasswordField(inputElement) {\\n    const autocompleteInfo = inputElement.getAutocompleteInfo();\\n    if (autocompleteInfo.fieldName === \\\"new-password\\\") {\\n      return true;\\n    }\\n\\n    if (Logic.newPasswordFieldFathomThreshold == -1) {\\n      // Fathom is disabled\\n      return false;\\n    }\\n\\n    let score = this.#cachedNewPasswordScore.get(inputElement);\\n    if (score) {\\n      return score >= Logic.newPasswordFieldFathomThreshold;\\n    }\\n\\n    const { rules, type } = NewPasswordModel;\\n    const results = rules.against(inputElement);\\n    score = results.get(inputElement).scoreFor(type);\\n    this.#cachedNewPasswordScore.set(inputElement, score);\\n    return score >= Logic.newPasswordFieldFathomThreshold;\\n  }\\n\\n  static findConfirmationField(passwordField, formFactory) {\\n    const form = formFactory.createFromField(passwordField);\\n    let confirmPasswordInput = null;\\n    const MAX_CONFIRM_PASSWORD_DISTANCE = 3;\\n\\n    const startIndex = form.elements.indexOf(passwordField);\\n    if (startIndex === -1) {\\n      throw new Error(\\n        \\\"Password field is not in the form's elements collection\\\"\\n      );\\n    }\\n\\n    // Get a list of input fields to search in.\\n    // Pre-filter type=hidden fields; they don't count against the distance threshold\\n    const afterFields = form.elements\\n      .slice(startIndex + 1)\\n      .filter(elem => elem.type !== \\\"hidden\\\");\\n\\n    const acFieldName = passwordField.getAutocompleteInfo()?.fieldName;\\n\\n    // Match same autocomplete values first\\n    if (acFieldName === \\\"new-password\\\") {\\n      const matchIndex = afterFields.findIndex(\\n        elem =>\\n          Logic.isPasswordFieldType(elem) &&\\n          elem.getAutocompleteInfo().fieldName === acFieldName &&\\n          !elem.disabled &&\\n          !elem.readOnly\\n      );\\n      if (matchIndex >= 0 && matchIndex < MAX_CONFIRM_PASSWORD_DISTANCE) {\\n        confirmPasswordInput = afterFields[matchIndex];\\n      }\\n    }\\n\\n    if (!confirmPasswordInput) {\\n      for (\\n        let idx = 0;\\n        idx < Math.min(MAX_CONFIRM_PASSWORD_DISTANCE, afterFields.length);\\n        idx++\\n      ) {\\n        if (\\n          Logic.isPasswordFieldType(afterFields[idx]) &&\\n          !afterFields[idx].disabled &&\\n          !afterFields[idx].readOnly\\n        ) {\\n          confirmPasswordInput = afterFields[idx];\\n          break;\\n        }\\n      }\\n    }\\n\\n    return confirmPasswordInput;\\n  }\\n\\n  /**\\n   * Transforms the parsed rules returned from PasswordRulesParser into a Map for easier access.\\n   * The returned Map could have the following keys: \\\"allowed\\\", \\\"required\\\", \\\"maxlength\\\", \\\"minlength\\\", and \\\"max-consecutive\\\"\\n   * @example\\n   * // Returns a Map with a key-value pair of \\\"allowed\\\": \\\"ascii-printable\\\"\\n   * transformRulesToMap([{ _name: \\\"allowed\\\", value: [{ _name: \\\"ascii-printable\\\" }] }])\\n   * @param {Object[]} rules rules from PasswordRulesParser.parsePasswordRules\\n   * @return {Map} mapped rules\\n   */\\n  static transformRulesToMap(rules) {\\n    let map = new Map();\\n    for (let rule of rules) {\\n      let { _name, value } = rule;\\n      if (\\n        _name === \\\"minlength\\\" ||\\n        _name === \\\"maxlength\\\" ||\\n        _name === \\\"max-consecutive\\\"\\n      ) {\\n        map.set(_name, value);\\n      } else {\\n        let _value = [];\\n        if (map.get(_name)) {\\n          _value = map.get(_name);\\n        }\\n        for (let _class of value) {\\n          let { _name: _className } = _class;\\n          if (_className) {\\n            _value.push(_className);\\n          } else {\\n            let { _characters } = _class;\\n            _value.push(_characters);\\n          }\\n        }\\n        map.set(_name, _value);\\n      }\\n    }\\n    return map;\\n  }\\n}\\n\\nXPCOMUtils.defineLazyPreferenceGetter(\\n  Logic,\\n  \\\"newPasswordFieldFathomThreshold\\\",\\n  \\\"signon.generation.confidenceThreshold\\\",\\n  null,\\n  null,\\n  pref => parseFloat(pref)\\n);\\n\\nexport { Logic };\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/NewPasswordModel.sys.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/NewPasswordModel.sys.mjs ***!
  \*********************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n/**\\n * Machine learning model for identifying new password input elements\\n * using Fathom.\\n */\\n\\nimport {\\n  dom,\\n  element,\\n  out,\\n  rule,\\n  ruleset,\\n  score,\\n  type,\\n  utils,\\n  clusters,\\n} from \\\"resource://gre/modules/third_party/fathom/fathom.mjs\\\";\\n\\nlet { identity, isVisible, min, setDefault } = utils;\\nlet { euclidean } = clusters;\\n\\n/**\\n * ----- Start of model -----\\n *\\n * Everything below this comment up to the \\\"End of model\\\" comment is copied from:\\n * https://github.com/mozilla-services/fathom-login-forms/blob/78d4bf8f301b5aa6d62c06b45e826a0dd9df1afa/new-password/rulesets.js#L14-L613\\n * Deviations from that file:\\n *   - Remove import statements, instead using ``ChromeUtils.defineModuleGetter`` and destructuring assignments above.\\n *   - Set ``DEVELOPMENT`` constant to ``false``.\\n */\\n\\n// Whether this is running in the Vectorizer, rather than in-application, in a\\n// privileged Chrome context\\nconst DEVELOPMENT = false;\\n\\n// Run me with confidence cutoff = 0.75.\\nconst coefficients = {\\n  new: [\\n    [\\\"hasNewLabel\\\", 2.9195094108581543],\\n    [\\\"hasConfirmLabel\\\", 2.1672143936157227],\\n    [\\\"hasCurrentLabel\\\", -2.1813206672668457],\\n    [\\\"closestLabelMatchesNew\\\", 2.965045213699341],\\n    [\\\"closestLabelMatchesConfirm\\\", 2.698647975921631],\\n    [\\\"closestLabelMatchesCurrent\\\", -2.147423505783081],\\n    [\\\"hasNewAriaLabel\\\", 2.8312134742736816],\\n    [\\\"hasConfirmAriaLabel\\\", 1.5153108835220337],\\n    [\\\"hasCurrentAriaLabel\\\", -4.368860244750977],\\n    [\\\"hasNewPlaceholder\\\", 1.4374250173568726],\\n    [\\\"hasConfirmPlaceholder\\\", 1.717592477798462],\\n    [\\\"hasCurrentPlaceholder\\\", -1.9401700496673584],\\n    [\\\"forgotPasswordInFormLinkTextContent\\\", -0.6736700534820557],\\n    [\\\"forgotPasswordInFormLinkHref\\\", -1.3025357723236084],\\n    [\\\"forgotPasswordInFormLinkTitle\\\", -2.9019577503204346],\\n    [\\\"forgotInFormLinkTextContent\\\", -1.2455425262451172],\\n    [\\\"forgotInFormLinkHref\\\", 0.4884686768054962],\\n    [\\\"forgotPasswordInFormButtonTextContent\\\", -0.8015769720077515],\\n    [\\\"forgotPasswordOnPageLinkTextContent\\\", 0.04422328248620033],\\n    [\\\"forgotPasswordOnPageLinkHref\\\", -1.0331494808197021],\\n    [\\\"forgotPasswordOnPageLinkTitle\\\", -0.08798415213823318],\\n    [\\\"forgotPasswordOnPageButtonTextContent\\\", -1.5396910905838013],\\n    [\\\"elementAttrsMatchNew\\\", 2.8492355346679688],\\n    [\\\"elementAttrsMatchConfirm\\\", 1.9043376445770264],\\n    [\\\"elementAttrsMatchCurrent\\\", -2.056903839111328],\\n    [\\\"elementAttrsMatchPassword1\\\", 1.5833512544631958],\\n    [\\\"elementAttrsMatchPassword2\\\", 1.3928000926971436],\\n    [\\\"elementAttrsMatchLogin\\\", 1.738782525062561],\\n    [\\\"formAttrsMatchRegister\\\", 2.1345033645629883],\\n    [\\\"formHasRegisterAction\\\", 1.9337323904037476],\\n    [\\\"formButtonIsRegister\\\", 3.0930404663085938],\\n    [\\\"formAttrsMatchLogin\\\", -0.5816961526870728],\\n    [\\\"formHasLoginAction\\\", -0.18886367976665497],\\n    [\\\"formButtonIsLogin\\\", -2.332860231399536],\\n    [\\\"hasAutocompleteCurrentPassword\\\", -0.029974736273288727],\\n    [\\\"formHasRememberMeCheckbox\\\", 0.8600837588310242],\\n    [\\\"formHasRememberMeLabel\\\", 0.06663893908262253],\\n    [\\\"formHasNewsletterCheckbox\\\", -1.4851698875427246],\\n    [\\\"formHasNewsletterLabel\\\", 2.416919231414795],\\n    [\\\"closestHeaderAboveIsLoginy\\\", -2.0047383308410645],\\n    [\\\"closestHeaderAboveIsRegistery\\\", 2.19451642036438],\\n    [\\\"nextInputIsConfirmy\\\", 2.5344431400299072],\\n    [\\\"formHasMultipleVisibleInput\\\", 2.81270694732666],\\n    [\\\"firstFieldInFormWithThreePasswordFields\\\", -2.8964080810546875],\\n  ],\\n};\\n\\nconst biases = [[\\\"new\\\", -1.3525885343551636]];\\n\\nconst passwordStringRegex =\\n  /password|passwort|رمز عبور|mot de passe|パスワード|비밀번호|암호|wachtwoord|senha|Пароль|parol|密码|contraseña|heslo|كلمة السر|kodeord|Κωδικός|pass code|Kata sandi|hasło|รหัสผ่าน|Şifre/i;\\nconst passwordAttrRegex = /pw|pwd|passwd|pass/i;\\nconst newStringRegex =\\n  /new|erstellen|create|choose|設定|신규|Créer|Nouveau|baru|nouă|nieuw/i;\\nconst newAttrRegex = /new/i;\\nconst confirmStringRegex =\\n  /wiederholen|wiederholung|confirm|repeat|confirmation|verify|retype|repite|確認|の確認|تکرار|re-enter|확인|bevestigen|confirme|Повторите|tassyklamak|再次输入|ještě jednou|gentag|re-type|confirmar|Répéter|conferma|Repetaţi|again|reenter|再入力|재입력|Ulangi|Bekræft/i;\\nconst confirmAttrRegex = /confirm|retype/i;\\nconst currentAttrAndStringRegex =\\n  /current|old|aktuelles|derzeitiges|当前|Atual|actuel|curentă|sekarang/i;\\nconst forgotStringRegex =\\n  /vergessen|vergeten|forgot|oublié|dimenticata|Esqueceu|esqueci|Забыли|忘记|找回|Zapomenuté|lost|忘れた|忘れられた|忘れの方|재설정|찾기|help|فراموشی| را فراموش کرده اید|Восстановить|Unuttu|perdus|重新設定|reset|recover|change|remind|find|request|restore|trouble/i;\\nconst forgotHrefRegex =\\n  /forgot|reset|recover|change|lost|remind|find|request|restore/i;\\nconst password1Regex =\\n  /pw1|pwd1|pass1|passwd1|password1|pwone|pwdone|passone|passwdone|passwordone|pwfirst|pwdfirst|passfirst|passwdfirst|passwordfirst/i;\\nconst password2Regex =\\n  /pw2|pwd2|pass2|passwd2|password2|pwtwo|pwdtwo|passtwo|passwdtwo|passwordtwo|pwsecond|pwdsecond|passsecond|passwdsecond|passwordsecond/i;\\nconst loginRegex =\\n  /login|log in|log on|log-on|Войти|sign in|sigin|sign\\\\/in|sign-in|sign on|sign-on|ورود|登录|Přihlásit se|Přihlaste|Авторизоваться|Авторизация|entrar|ログイン|로그인|inloggen|Συνδέσου|accedi|ログオン|Giriş Yap|登入|connecter|connectez-vous|Connexion|Вход/i;\\nconst loginFormAttrRegex =\\n  /login|log in|log on|log-on|sign in|sigin|sign\\\\/in|sign-in|sign on|sign-on/i;\\nconst registerStringRegex =\\n  /create[a-zA-Z\\\\s]+account|activate[a-zA-Z\\\\s]+account|Zugang anlegen|Angaben prüfen|Konto erstellen|register|sign up|ثبت نام|登録|注册|cadastr|Зарегистрироваться|Регистрация|Bellige alynmak|تسجيل|ΕΓΓΡΑΦΗΣ|Εγγραφή|Créer mon compte|Créer un compte|Mendaftar|가입하기|inschrijving|Zarejestruj się|Deschideți un cont|Создать аккаунт|ร่วม|Üye Ol|registr|new account|ساخت حساب کاربری|Schrijf je|S'inscrire/i;\\nconst registerActionRegex =\\n  /register|signup|sign-up|create-account|account\\\\/create|join|new_account|user\\\\/create|sign\\\\/up|membership\\\\/create/i;\\nconst registerFormAttrRegex =\\n  /signup|join|register|regform|registration|new_user|AccountCreate|create_customer|CreateAccount|CreateAcct|create-account|reg-form|newuser|new-reg|new-form|new_membership/i;\\nconst rememberMeAttrRegex =\\n  /remember|auto_login|auto-login|save_mail|save-mail|ricordami|manter|mantenha|savelogin|auto login/i;\\nconst rememberMeStringRegex =\\n  /remember me|keep me logged in|keep me signed in|save email address|save id|stay signed in|ricordami|次回からログオンIDの入力を省略する|メールアドレスを保存する|を保存|아이디저장|아이디 저장|로그인 상태 유지|lembrar|manter conectado|mantenha-me conectado|Запомни меня|запомнить меня|Запомните меня|Не спрашивать в следующий раз|下次自动登录|记住我/i;\\nconst newsletterStringRegex = /newsletter|ニュースレター/i;\\nconst passwordStringAndAttrRegex = new RegExp(\\n  passwordStringRegex.source + \\\"|\\\" + passwordAttrRegex.source,\\n  \\\"i\\\"\\n);\\n\\nfunction makeRuleset(coeffs, biases) {\\n  // HTMLElement => (selector => Array<HTMLElement>) nested map to cache querySelectorAll calls.\\n  let elementToSelectors;\\n  // We want to clear the cache each time the model is executed to get the latest DOM snapshot\\n  // for each classification.\\n  function clearCache() {\\n    // WeakMaps do not have a clear method\\n    elementToSelectors = new WeakMap();\\n  }\\n\\n  function hasLabelMatchingRegex(element, regex) {\\n    // Check element.labels\\n    const labels = element.labels;\\n    // TODO: Should I be concerned with multiple labels?\\n    if (labels !== null && labels.length) {\\n      return regex.test(labels[0].textContent);\\n    }\\n\\n    // Check element.aria-labelledby\\n    let labelledBy = element.getAttribute(\\\"aria-labelledby\\\");\\n    if (labelledBy !== null) {\\n      labelledBy = labelledBy\\n        .split(\\\" \\\")\\n        .map(id => element.getRootNode().getElementById(id))\\n        .filter(el => el);\\n      if (labelledBy.length === 1) {\\n        return regex.test(labelledBy[0].textContent);\\n      } else if (labelledBy.length > 1) {\\n        return regex.test(\\n          min(labelledBy, node => euclidean(node, element)).textContent\\n        );\\n      }\\n    }\\n\\n    const parentElement = element.parentElement;\\n    // Bug 1634819: element.parentElement is null if element.parentNode is a ShadowRoot\\n    if (!parentElement) {\\n      return false;\\n    }\\n    // Check if the input is in a <td>, and, if so, check the textContent of the containing <tr>\\n    if (parentElement.tagName === \\\"TD\\\" && parentElement.parentElement) {\\n      // TODO: How bad is the assumption that the <tr> won't be the parent of the <td>?\\n      return regex.test(parentElement.parentElement.textContent);\\n    }\\n\\n    // Check if the input is in a <dd>, and, if so, check the textContent of the preceding <dt>\\n    if (\\n      parentElement.tagName === \\\"DD\\\" &&\\n      // previousElementSibling can be null\\n      parentElement.previousElementSibling\\n    ) {\\n      return regex.test(parentElement.previousElementSibling.textContent);\\n    }\\n    return false;\\n  }\\n\\n  function closestLabelMatchesRegex(element, regex) {\\n    const previousElementSibling = element.previousElementSibling;\\n    if (\\n      previousElementSibling !== null &&\\n      previousElementSibling.tagName === \\\"LABEL\\\"\\n    ) {\\n      return regex.test(previousElementSibling.textContent);\\n    }\\n\\n    const nextElementSibling = element.nextElementSibling;\\n    if (nextElementSibling !== null && nextElementSibling.tagName === \\\"LABEL\\\") {\\n      return regex.test(nextElementSibling.textContent);\\n    }\\n\\n    const closestLabelWithinForm = closestSelectorElementWithinElement(\\n      element,\\n      element.form,\\n      \\\"label\\\"\\n    );\\n    return containsRegex(\\n      regex,\\n      closestLabelWithinForm,\\n      closestLabelWithinForm => closestLabelWithinForm.textContent\\n    );\\n  }\\n\\n  function containsRegex(regex, thingOrNull, thingToString = identity) {\\n    return thingOrNull !== null && regex.test(thingToString(thingOrNull));\\n  }\\n\\n  function closestSelectorElementWithinElement(\\n    toElement,\\n    withinElement,\\n    querySelector\\n  ) {\\n    if (withinElement !== null) {\\n      let nodeList = Array.from(withinElement.querySelectorAll(querySelector));\\n      if (nodeList.length) {\\n        return min(nodeList, node => euclidean(node, toElement));\\n      }\\n    }\\n    return null;\\n  }\\n\\n  function hasAriaLabelMatchingRegex(element, regex) {\\n    return containsRegex(regex, element.getAttribute(\\\"aria-label\\\"));\\n  }\\n\\n  function hasPlaceholderMatchingRegex(element, regex) {\\n    return containsRegex(regex, element.getAttribute(\\\"placeholder\\\"));\\n  }\\n\\n  function testRegexesAgainstAnchorPropertyWithinElement(\\n    property,\\n    element,\\n    ...regexes\\n  ) {\\n    return hasSomeMatchingPredicateForSelectorWithinElement(\\n      element,\\n      \\\"a\\\",\\n      anchor => {\\n        const propertyValue = anchor[property];\\n        return regexes.every(regex => regex.test(propertyValue));\\n      }\\n    );\\n  }\\n\\n  function testFormButtonsAgainst(element, stringRegex) {\\n    const form = element.form;\\n    if (form !== null) {\\n      let inputs = Array.from(\\n        form.querySelectorAll(\\\"input[type=submit],input[type=button]\\\")\\n      );\\n      inputs = inputs.filter(input => {\\n        return stringRegex.test(input.value);\\n      });\\n      if (inputs.length) {\\n        return true;\\n      }\\n\\n      return hasSomeMatchingPredicateForSelectorWithinElement(\\n        form,\\n        \\\"button\\\",\\n        button => {\\n          return (\\n            stringRegex.test(button.value) ||\\n            stringRegex.test(button.textContent) ||\\n            stringRegex.test(button.id) ||\\n            stringRegex.test(button.title)\\n          );\\n        }\\n      );\\n    }\\n    return false;\\n  }\\n\\n  function hasAutocompleteCurrentPassword(fnode) {\\n    return fnode.element.autocomplete === \\\"current-password\\\";\\n  }\\n\\n  // Check cache before calling querySelectorAll on element\\n  function getElementDescendants(element, selector) {\\n    // Use the element to look up the selector map:\\n    const selectorToDescendants = setDefault(\\n      elementToSelectors,\\n      element,\\n      () => new Map()\\n    );\\n\\n    // Use the selector to grab the descendants:\\n    return setDefault(selectorToDescendants, selector, () =>\\n      Array.from(element.querySelectorAll(selector))\\n    );\\n  }\\n\\n  /**\\n   * Return whether the form element directly after this one looks like a\\n   * confirm-password input.\\n   */\\n  function nextInputIsConfirmy(fnode) {\\n    const form = fnode.element.form;\\n    const me = fnode.element;\\n    if (form !== null) {\\n      let afterMe = false;\\n      for (const formEl of form.elements) {\\n        if (formEl === me) {\\n          afterMe = true;\\n        } else if (afterMe) {\\n          if (\\n            formEl.type === \\\"password\\\" &&\\n            !formEl.disabled &&\\n            formEl.getAttribute(\\\"aria-hidden\\\") !== \\\"true\\\"\\n          ) {\\n            // Now we're looking at a passwordy, visible input[type=password]\\n            // directly after me.\\n            return elementAttrsMatchRegex(formEl, confirmAttrRegex);\\n            // We could check other confirmy smells as well. Balance accuracy\\n            // against time and complexity.\\n          }\\n          // We look only at the very next element, so we may be thrown off by\\n          // Hide buttons and such.\\n          break;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * Returns true when the number of visible input found in the form is over\\n   * the given threshold.\\n   *\\n   * Since the idea in the signal is based on the fact that registration pages\\n   * often have multiple inputs, this rule only selects inputs whose type is\\n   * either email, password, text, tel or empty, which are more likely a input\\n   * field for users to fill their information.\\n   */\\n  function formHasMultipleVisibleInput(element, selector, threshold) {\\n    let form = element.form;\\n    if (!form) {\\n      // For password fields that don't have an associated form, we apply a heuristic\\n      // to find a \\\"form\\\" for it. The heuristic works as follow:\\n      // 1. Locate the closest preceding input.\\n      // 2. Find the lowest common ancestor of the password field and the closet\\n      //    preceding input.\\n      // 3. Assume the common ancestor is the \\\"form\\\" of the password input.\\n      const previous = closestElementAbove(element, selector);\\n      if (!previous) {\\n        return false;\\n      }\\n      form = findLowestCommonAncestor(previous, element);\\n      if (!form) {\\n        return false;\\n      }\\n    }\\n    const inputs = Array.from(form.querySelectorAll(selector));\\n    for (const input of inputs) {\\n      // don't need to check visibility for the element we're testing against\\n      if (element === input || isVisible(input)) {\\n        threshold--;\\n        if (threshold === 0) {\\n          return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * Returns true when there are three password fields in the form and the passed\\n   * element is the first one.\\n   *\\n   * The signal is based on that change-password forms with 3 password fields often\\n   * have the \\\"current password\\\", \\\"new password\\\", and \\\"confirm password\\\" pattern.\\n   */\\n  function firstFieldInFormWithThreePasswordFields(fnode) {\\n    const element = fnode.element;\\n    const form = element.form;\\n    if (form) {\\n      let elements = form.querySelectorAll(\\n        \\\"input[type=password]:not([disabled], [aria-hidden=true])\\\"\\n      );\\n      // Only care forms with three password fields. If there are more than three password\\n      // fields found, probably we include some hidden fields, so just ignore it.\\n      if (elements.length == 3 && elements[0] == element) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  function hasSomeMatchingPredicateForSelectorWithinElement(\\n    element,\\n    selector,\\n    matchingPredicate\\n  ) {\\n    if (element === null) {\\n      return false;\\n    }\\n    const elements = getElementDescendants(element, selector);\\n    return elements.some(matchingPredicate);\\n  }\\n\\n  function textContentMatchesRegexes(element, ...regexes) {\\n    const textContent = element.textContent;\\n    return regexes.every(regex => regex.test(textContent));\\n  }\\n\\n  function closestHeaderAboveMatchesRegex(element, regex) {\\n    const closestHeader = closestElementAbove(\\n      element,\\n      \\\"h1,h2,h3,h4,h5,h6,div[class*=heading],div[class*=header],div[class*=title],legend\\\"\\n    );\\n    if (closestHeader !== null) {\\n      return regex.test(closestHeader.textContent);\\n    }\\n    return false;\\n  }\\n\\n  function closestElementAbove(element, selector) {\\n    let elements = Array.from(element.ownerDocument.querySelectorAll(selector));\\n    for (let i = elements.length - 1; i >= 0; --i) {\\n      if (\\n        element.compareDocumentPosition(elements[i]) &\\n        Node.DOCUMENT_POSITION_PRECEDING\\n      ) {\\n        return elements[i];\\n      }\\n    }\\n    return null;\\n  }\\n\\n  function findLowestCommonAncestor(elementA, elementB) {\\n    // Walk up the ancestor chain of both elements and compare whether the\\n    // ancestors in the depth are the same. If they are not the same, the\\n    // ancestor in the previous run is the lowest common ancestor.\\n    function getAncestorChain(element) {\\n      let ancestors = [];\\n      let p = element.parentNode;\\n      while (p) {\\n        ancestors.push(p);\\n        p = p.parentNode;\\n      }\\n      return ancestors;\\n    }\\n\\n    let aAncestors = getAncestorChain(elementA);\\n    let bAncestors = getAncestorChain(elementB);\\n    let posA = aAncestors.length - 1;\\n    let posB = bAncestors.length - 1;\\n    for (; posA >= 0 && posB >= 0; posA--, posB--) {\\n      if (aAncestors[posA] != bAncestors[posB]) {\\n        return aAncestors[posA + 1];\\n      }\\n    }\\n    return null;\\n  }\\n\\n  function elementAttrsMatchRegex(element, regex) {\\n    if (element !== null) {\\n      return (\\n        regex.test(element.id) ||\\n        regex.test(element.name) ||\\n        regex.test(element.className)\\n      );\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * Let us compactly represent a collection of rules that all take a single\\n   * type with no .when() clause and have only a score() call on the right-hand\\n   * side.\\n   */\\n  function* simpleScoringRulesTakingType(inType, ruleMap) {\\n    for (const [name, scoringCallback] of Object.entries(ruleMap)) {\\n      yield rule(type(inType), score(scoringCallback), { name });\\n    }\\n  }\\n\\n  return ruleset(\\n    [\\n      rule(\\n        DEVELOPMENT\\n          ? dom(\\n              \\\"input[type=password]:not([disabled], [aria-hidden=true])\\\"\\n            ).when(isVisible)\\n          : element(\\\"input\\\"),\\n        type(\\\"new\\\").note(clearCache)\\n      ),\\n      ...simpleScoringRulesTakingType(\\\"new\\\", {\\n        hasNewLabel: fnode =>\\n          hasLabelMatchingRegex(fnode.element, newStringRegex),\\n        hasConfirmLabel: fnode =>\\n          hasLabelMatchingRegex(fnode.element, confirmStringRegex),\\n        hasCurrentLabel: fnode =>\\n          hasLabelMatchingRegex(fnode.element, currentAttrAndStringRegex),\\n        closestLabelMatchesNew: fnode =>\\n          closestLabelMatchesRegex(fnode.element, newStringRegex),\\n        closestLabelMatchesConfirm: fnode =>\\n          closestLabelMatchesRegex(fnode.element, confirmStringRegex),\\n        closestLabelMatchesCurrent: fnode =>\\n          closestLabelMatchesRegex(fnode.element, currentAttrAndStringRegex),\\n        hasNewAriaLabel: fnode =>\\n          hasAriaLabelMatchingRegex(fnode.element, newStringRegex),\\n        hasConfirmAriaLabel: fnode =>\\n          hasAriaLabelMatchingRegex(fnode.element, confirmStringRegex),\\n        hasCurrentAriaLabel: fnode =>\\n          hasAriaLabelMatchingRegex(fnode.element, currentAttrAndStringRegex),\\n        hasNewPlaceholder: fnode =>\\n          hasPlaceholderMatchingRegex(fnode.element, newStringRegex),\\n        hasConfirmPlaceholder: fnode =>\\n          hasPlaceholderMatchingRegex(fnode.element, confirmStringRegex),\\n        hasCurrentPlaceholder: fnode =>\\n          hasPlaceholderMatchingRegex(fnode.element, currentAttrAndStringRegex),\\n        forgotPasswordInFormLinkTextContent: fnode =>\\n          testRegexesAgainstAnchorPropertyWithinElement(\\n            \\\"textContent\\\",\\n            fnode.element.form,\\n            passwordStringRegex,\\n            forgotStringRegex\\n          ),\\n        forgotPasswordInFormLinkHref: fnode =>\\n          testRegexesAgainstAnchorPropertyWithinElement(\\n            \\\"href\\\",\\n            fnode.element.form,\\n            passwordStringAndAttrRegex,\\n            forgotHrefRegex\\n          ),\\n        forgotPasswordInFormLinkTitle: fnode =>\\n          testRegexesAgainstAnchorPropertyWithinElement(\\n            \\\"title\\\",\\n            fnode.element.form,\\n            passwordStringRegex,\\n            forgotStringRegex\\n          ),\\n        forgotInFormLinkTextContent: fnode =>\\n          testRegexesAgainstAnchorPropertyWithinElement(\\n            \\\"textContent\\\",\\n            fnode.element.form,\\n            forgotStringRegex\\n          ),\\n        forgotInFormLinkHref: fnode =>\\n          testRegexesAgainstAnchorPropertyWithinElement(\\n            \\\"href\\\",\\n            fnode.element.form,\\n            forgotHrefRegex\\n          ),\\n        forgotPasswordInFormButtonTextContent: fnode =>\\n          hasSomeMatchingPredicateForSelectorWithinElement(\\n            fnode.element.form,\\n            \\\"button\\\",\\n            button =>\\n              textContentMatchesRegexes(\\n                button,\\n                passwordStringRegex,\\n                forgotStringRegex\\n              )\\n          ),\\n        forgotPasswordOnPageLinkTextContent: fnode =>\\n          testRegexesAgainstAnchorPropertyWithinElement(\\n            \\\"textContent\\\",\\n            fnode.element.ownerDocument,\\n            passwordStringRegex,\\n            forgotStringRegex\\n          ),\\n        forgotPasswordOnPageLinkHref: fnode =>\\n          testRegexesAgainstAnchorPropertyWithinElement(\\n            \\\"href\\\",\\n            fnode.element.ownerDocument,\\n            passwordStringAndAttrRegex,\\n            forgotHrefRegex\\n          ),\\n        forgotPasswordOnPageLinkTitle: fnode =>\\n          testRegexesAgainstAnchorPropertyWithinElement(\\n            \\\"title\\\",\\n            fnode.element.ownerDocument,\\n            passwordStringRegex,\\n            forgotStringRegex\\n          ),\\n        forgotPasswordOnPageButtonTextContent: fnode =>\\n          hasSomeMatchingPredicateForSelectorWithinElement(\\n            fnode.element.ownerDocument,\\n            \\\"button\\\",\\n            button =>\\n              textContentMatchesRegexes(\\n                button,\\n                passwordStringRegex,\\n                forgotStringRegex\\n              )\\n          ),\\n        elementAttrsMatchNew: fnode =>\\n          elementAttrsMatchRegex(fnode.element, newAttrRegex),\\n        elementAttrsMatchConfirm: fnode =>\\n          elementAttrsMatchRegex(fnode.element, confirmAttrRegex),\\n        elementAttrsMatchCurrent: fnode =>\\n          elementAttrsMatchRegex(fnode.element, currentAttrAndStringRegex),\\n        elementAttrsMatchPassword1: fnode =>\\n          elementAttrsMatchRegex(fnode.element, password1Regex),\\n        elementAttrsMatchPassword2: fnode =>\\n          elementAttrsMatchRegex(fnode.element, password2Regex),\\n        elementAttrsMatchLogin: fnode =>\\n          elementAttrsMatchRegex(fnode.element, loginRegex),\\n        formAttrsMatchRegister: fnode =>\\n          elementAttrsMatchRegex(fnode.element.form, registerFormAttrRegex),\\n        formHasRegisterAction: fnode =>\\n          containsRegex(\\n            registerActionRegex,\\n            fnode.element.form,\\n            form => form.action\\n          ),\\n        formButtonIsRegister: fnode =>\\n          testFormButtonsAgainst(fnode.element, registerStringRegex),\\n        formAttrsMatchLogin: fnode =>\\n          elementAttrsMatchRegex(fnode.element.form, loginFormAttrRegex),\\n        formHasLoginAction: fnode =>\\n          containsRegex(loginRegex, fnode.element.form, form => form.action),\\n        formButtonIsLogin: fnode =>\\n          testFormButtonsAgainst(fnode.element, loginRegex),\\n        hasAutocompleteCurrentPassword,\\n        formHasRememberMeCheckbox: fnode =>\\n          hasSomeMatchingPredicateForSelectorWithinElement(\\n            fnode.element.form,\\n            \\\"input[type=checkbox]\\\",\\n            checkbox =>\\n              rememberMeAttrRegex.test(checkbox.id) ||\\n              rememberMeAttrRegex.test(checkbox.name)\\n          ),\\n        formHasRememberMeLabel: fnode =>\\n          hasSomeMatchingPredicateForSelectorWithinElement(\\n            fnode.element.form,\\n            \\\"label\\\",\\n            label => rememberMeStringRegex.test(label.textContent)\\n          ),\\n        formHasNewsletterCheckbox: fnode =>\\n          hasSomeMatchingPredicateForSelectorWithinElement(\\n            fnode.element.form,\\n            \\\"input[type=checkbox]\\\",\\n            checkbox =>\\n              checkbox.id.includes(\\\"newsletter\\\") ||\\n              checkbox.name.includes(\\\"newsletter\\\")\\n          ),\\n        formHasNewsletterLabel: fnode =>\\n          hasSomeMatchingPredicateForSelectorWithinElement(\\n            fnode.element.form,\\n            \\\"label\\\",\\n            label => newsletterStringRegex.test(label.textContent)\\n          ),\\n        closestHeaderAboveIsLoginy: fnode =>\\n          closestHeaderAboveMatchesRegex(fnode.element, loginRegex),\\n        closestHeaderAboveIsRegistery: fnode =>\\n          closestHeaderAboveMatchesRegex(fnode.element, registerStringRegex),\\n        nextInputIsConfirmy,\\n        formHasMultipleVisibleInput: fnode =>\\n          formHasMultipleVisibleInput(\\n            fnode.element,\\n            \\\"input[type=email],input[type=password],input[type=text],input[type=tel]\\\",\\n            3\\n          ),\\n        firstFieldInFormWithThreePasswordFields,\\n      }),\\n      rule(type(\\\"new\\\"), out(\\\"new\\\")),\\n    ],\\n    coeffs,\\n    biases\\n  );\\n}\\n\\n/*\\n * ----- End of model -----\\n */\\n\\nexport const NewPasswordModel = {\\n  type: \\\"new\\\",\\n  rules: makeRuleset([...coefficients.new], biases),\\n};\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/NewPasswordModel.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n\\\"use strict\\\";\\n\\n// This array defines overrides that webpack will use when bundling the JS on iOS\\n// in order to load the right modules\\nconst ModuleOverrides = {\\n  \\\"AppConstants.sys.mjs\\\": \\\"Helpers.ios.mjs\\\",\\n  \\\"XPCOMUtils.sys.mjs\\\": \\\"Helpers.ios.mjs\\\",\\n  \\\"Region.sys.mjs\\\": \\\"Helpers.ios.mjs\\\",\\n  \\\"OSKeyStore.sys.mjs\\\": \\\"Helpers.ios.mjs\\\",\\n  \\\"ContentDOMReference.sys.mjs\\\": \\\"Helpers.ios.mjs\\\",\\n  \\\"FormAutofill.sys.mjs\\\": \\\"FormAutofill.ios.sys.mjs\\\",\\n  \\\"EntryFile.sys.mjs\\\": \\\"FormAutofillChild.ios.sys.mjs\\\",\\n  \\\"LoginHelper.sys.mjs\\\": \\\"EmptyModule.sys.mjs\\\",\\n  \\\"MLAutofill.sys.mjs\\\": \\\"EmptyModule.sys.mjs\\\",\\n  \\\"LoginRecipes.sys.mjs\\\": \\\"EmptyModule.sys.mjs\\\",\\n  \\\"Timer.sys.mjs\\\": \\\"TranslationsHelpers.ios.mjs\\\",\\n};\\n\\n// We need this because not all webpack libraries used in iOS are ES Modules\\n// Hence we defer to CommonJS.\\n// eslint-disable-next-line no-undef\\nmodule.exports = { ModuleOverrides };\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PasswordGenerator.sys.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PasswordGenerator.sys.mjs ***!
  \**********************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this file,\\n * You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n/**\\n * This file is a port of a subset of Chromium's implementation from\\n * https://cs.chromium.org/chromium/src/components/password_manager/core/browser/generation/password_generator.cc?l=93&rcl=a896a3ac4ea731b5ab3d2ab5bd76a139885d5c4f\\n * which is Copyright 2018 The Chromium Authors. All rights reserved.\\n */\\n\\nconst DEFAULT_PASSWORD_LENGTH = 15;\\nconst MAX_UINT8 = Math.pow(2, 8) - 1;\\nconst MAX_UINT32 = Math.pow(2, 32) - 1;\\n\\n// Some characters are removed due to visual similarity:\\nconst LOWER_CASE_ALPHA = \\\"abcdefghijkmnpqrstuvwxyz\\\"; // no 'l' or 'o'\\nconst UPPER_CASE_ALPHA = \\\"ABCDEFGHJKLMNPQRSTUVWXYZ\\\"; // no 'I' or 'O'\\nconst DIGITS = \\\"23456789\\\"; // no '1' or '0'\\nconst SPECIAL_CHARACTERS = \\\"-~!@#$%^&*_+=)}:;\\\\\\\"'>,.?]\\\";\\n\\nconst REQUIRED_CHARACTER_CLASSES = [\\n  LOWER_CASE_ALPHA,\\n  UPPER_CASE_ALPHA,\\n  DIGITS,\\n  SPECIAL_CHARACTERS,\\n];\\n\\n// Consts for different password rules\\nconst REQUIRED = \\\"required\\\";\\nconst MAX_LENGTH = \\\"maxlength\\\";\\nconst MIN_LENGTH = \\\"minlength\\\";\\nconst MAX_CONSECUTIVE = \\\"max-consecutive\\\";\\nconst UPPER = \\\"upper\\\";\\nconst LOWER = \\\"lower\\\";\\nconst DIGIT = \\\"digit\\\";\\nconst SPECIAL = \\\"special\\\";\\n\\n// Default password rules\\nconst DEFAULT_RULES = new Map();\\nDEFAULT_RULES.set(MIN_LENGTH, REQUIRED_CHARACTER_CLASSES.length);\\nDEFAULT_RULES.set(MAX_LENGTH, MAX_UINT8);\\nDEFAULT_RULES.set(REQUIRED, [UPPER, LOWER, DIGIT, SPECIAL]);\\n\\nexport const PasswordGenerator = {\\n  /**\\n   * @param {Object} options\\n   * @param {number} options.length - length of the generated password if there are no rules that override the length\\n   * @param {Map} options.rules - map of password rules\\n   * @returns {string} password that was generated\\n   * @throws Error if `length` is invalid\\n   * @copyright 2018 The Chromium Authors. All rights reserved.\\n   * @see https://cs.chromium.org/chromium/src/components/password_manager/core/browser/generation/password_generator.cc?l=93&rcl=a896a3ac4ea731b5ab3d2ab5bd76a139885d5c4f\\n   */\\n  generatePassword({\\n    length = DEFAULT_PASSWORD_LENGTH,\\n    rules = DEFAULT_RULES,\\n    inputMaxLength,\\n  }) {\\n    rules = new Map([...DEFAULT_RULES, ...rules]);\\n    if (rules.get(MIN_LENGTH) > length) {\\n      length = rules.get(MIN_LENGTH);\\n    }\\n    if (rules.get(MAX_LENGTH) < length) {\\n      length = rules.get(MAX_LENGTH);\\n    }\\n    if (inputMaxLength > 0 && inputMaxLength < length) {\\n      length = inputMaxLength;\\n    }\\n\\n    let password = \\\"\\\";\\n    let requiredClasses = [];\\n    let allRequiredCharacters = \\\"\\\";\\n\\n    // Generate one character of each required class and/or required character list from the rules\\n    this._addRequiredClassesAndCharacters(rules, requiredClasses);\\n\\n    // Generate one of each required class\\n    for (const charClassString of requiredClasses) {\\n      password +=\\n        charClassString[this._randomUInt8Index(charClassString.length)];\\n      if (Array.isArray(charClassString)) {\\n        // Convert array into single string so that commas aren't\\n        // concatenated with each character in the arbitrary character array.\\n        allRequiredCharacters += charClassString.join(\\\"\\\");\\n      } else {\\n        allRequiredCharacters += charClassString;\\n      }\\n    }\\n\\n    // Now fill the rest of the password with random characters.\\n    while (password.length < length) {\\n      password +=\\n        allRequiredCharacters[\\n          this._randomUInt8Index(allRequiredCharacters.length)\\n        ];\\n    }\\n\\n    // So far the password contains the minimally required characters at the\\n    // the beginning. Therefore, we create a random permutation.\\n    password = this._shuffleString(password);\\n\\n    // Make sure the password passes the \\\"max-consecutive\\\" rule, if the rule exists\\n    if (rules.has(MAX_CONSECUTIVE)) {\\n      // Ensures that a password isn't shuffled an infinite number of times.\\n      const DEFAULT_NUMBER_OF_SHUFFLES = 15;\\n      let shuffleCount = 0;\\n      let consecutiveFlag = this._checkConsecutiveCharacters(\\n        password,\\n        rules.get(MAX_CONSECUTIVE)\\n      );\\n      while (!consecutiveFlag) {\\n        password = this._shuffleString(password);\\n        consecutiveFlag = this._checkConsecutiveCharacters(\\n          password,\\n          rules.get(MAX_CONSECUTIVE)\\n        );\\n        ++shuffleCount;\\n        if (shuffleCount === DEFAULT_NUMBER_OF_SHUFFLES) {\\n          consecutiveFlag = true;\\n        }\\n      }\\n    }\\n\\n    return password;\\n  },\\n\\n  /**\\n   * Adds special characters and/or other required characters to the requiredCharacters array.\\n   * @param {Map} rules\\n   * @param {string[]} requiredClasses\\n   */\\n  _addRequiredClassesAndCharacters(rules, requiredClasses) {\\n    for (const charClass of rules.get(REQUIRED)) {\\n      if (charClass === UPPER) {\\n        requiredClasses.push(UPPER_CASE_ALPHA);\\n      } else if (charClass === LOWER) {\\n        requiredClasses.push(LOWER_CASE_ALPHA);\\n      } else if (charClass === DIGIT) {\\n        requiredClasses.push(DIGITS);\\n      } else if (charClass === SPECIAL) {\\n        requiredClasses.push(SPECIAL_CHARACTERS);\\n      } else {\\n        requiredClasses.push(charClass);\\n      }\\n    }\\n  },\\n\\n  /**\\n   * @param range to generate the number in\\n   * @returns a random number in range [0, range).\\n   * @copyright 2018 The Chromium Authors. All rights reserved.\\n   * @see https://cs.chromium.org/chromium/src/base/rand_util.cc?l=58&rcl=648a59893e4ed5303b5c381b03ce0c75e4165617\\n   */\\n  _randomUInt8Index(range) {\\n    if (range > MAX_UINT8) {\\n      throw new Error(\\\"`range` cannot fit into uint8\\\");\\n    }\\n    // We must discard random results above this number, as they would\\n    // make the random generator non-uniform (consider e.g. if\\n    // MAX_UINT64 was 7 and |range| was 5, then a result of 1 would be twice\\n    // as likely as a result of 3 or 4).\\n    // See https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#Modulo_bias\\n    const MAX_ACCEPTABLE_VALUE = Math.floor(MAX_UINT8 / range) * range - 1;\\n\\n    const randomValueArr = new Uint8Array(1);\\n    do {\\n      crypto.getRandomValues(randomValueArr);\\n    } while (randomValueArr[0] > MAX_ACCEPTABLE_VALUE);\\n    return randomValueArr[0] % range;\\n  },\\n\\n  /**\\n   * Shuffle the order of characters in a string.\\n   * @param {string} str to shuffle\\n   * @returns {string} shuffled string\\n   */\\n  _shuffleString(str) {\\n    let arr = Array.from(str);\\n    // Generate all the random numbers that will be needed.\\n    const randomValues = new Uint32Array(arr.length - 1);\\n    crypto.getRandomValues(randomValues);\\n\\n    // Fisher-Yates Shuffle\\n    // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\\n    for (let i = arr.length - 1; i > 0; i--) {\\n      const j = Math.floor((randomValues[i - 1] / MAX_UINT32) * (i + 1));\\n      [arr[i], arr[j]] = [arr[j], arr[i]];\\n    }\\n    return arr.join(\\\"\\\");\\n  },\\n\\n  /**\\n   * Determine the number of consecutive characters in a string.\\n   * This is primarily used to validate the \\\"max-consecutive\\\" rule\\n   * of a generated password.\\n   * @param {string} generatedPassword\\n   * @param {number} value the number of consecutive characters allowed\\n   * @return {boolean} `true` if the generatePassword has less than the value argument number of characters, `false` otherwise\\n   */\\n  _checkConsecutiveCharacters(generatedPassword, value) {\\n    let max = 0;\\n    for (let start = 0, end = 1; end < generatedPassword.length; ) {\\n      if (generatedPassword[end] === generatedPassword[start]) {\\n        if (max < end - start + 1) {\\n          max = end - start + 1;\\n          if (max > value) {\\n            return false;\\n          }\\n        }\\n        end++;\\n      } else {\\n        start = end++;\\n      }\\n    }\\n    return true;\\n  },\\n  _getUpperCaseCharacters() {\\n    return UPPER_CASE_ALPHA;\\n  },\\n  _getLowerCaseCharacters() {\\n    return LOWER_CASE_ALPHA;\\n  },\\n  _getDigits() {\\n    return DIGITS;\\n  },\\n  _getSpecialCharacters() {\\n    return SPECIAL_CHARACTERS;\\n  },\\n};\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PasswordGenerator.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PasswordRulesParser.sys.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PasswordRulesParser.sys.mjs ***!
  \************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"// Sourced from https://github.com/apple/password-manager-resources/blob/5f6da89483e75cdc4165a6fc4756796e0ced7a21/tools/PasswordRulesParser.js\\n// Copyright (c) 2019 - 2020 Apple Inc. Licensed under MIT License.\\n\\nexport const PasswordRulesParser = {\\n  parsePasswordRules,\\n};\\n\\nconst Identifier = {\\n  ASCII_PRINTABLE: \\\"ascii-printable\\\",\\n  DIGIT: \\\"digit\\\",\\n  LOWER: \\\"lower\\\",\\n  SPECIAL: \\\"special\\\",\\n  UNICODE: \\\"unicode\\\",\\n  UPPER: \\\"upper\\\",\\n};\\n\\nconst RuleName = {\\n  ALLOWED: \\\"allowed\\\",\\n  MAX_CONSECUTIVE: \\\"max-consecutive\\\",\\n  REQUIRED: \\\"required\\\",\\n  MIN_LENGTH: \\\"minlength\\\",\\n  MAX_LENGTH: \\\"maxlength\\\",\\n};\\n\\nconst CHARACTER_CLASS_START_SENTINEL = \\\"[\\\";\\nconst CHARACTER_CLASS_END_SENTINEL = \\\"]\\\";\\nconst PROPERTY_VALUE_SEPARATOR = \\\",\\\";\\nconst PROPERTY_SEPARATOR = \\\";\\\";\\nconst PROPERTY_VALUE_START_SENTINEL = \\\":\\\";\\n\\nconst SPACE_CODE_POINT = \\\" \\\".codePointAt(0);\\n\\nconst SHOULD_NOT_BE_REACHED = \\\"Should not be reached\\\";\\n\\nclass Rule {\\n  constructor(name, value) {\\n    this._name = name;\\n    this.value = value;\\n  }\\n  get name() {\\n    return this._name;\\n  }\\n  toString() {\\n    return JSON.stringify(this);\\n  }\\n}\\n\\nclass NamedCharacterClass {\\n  constructor(name) {\\n    console.assert(_isValidRequiredOrAllowedPropertyValueIdentifier(name));\\n    this._name = name;\\n  }\\n  get name() {\\n    return this._name.toLowerCase();\\n  }\\n  toString() {\\n    return this._name;\\n  }\\n  toHTMLString() {\\n    return this._name;\\n  }\\n}\\n\\nclass CustomCharacterClass {\\n  constructor(characters) {\\n    console.assert(characters instanceof Array);\\n    this._characters = characters;\\n  }\\n  get characters() {\\n    return this._characters;\\n  }\\n  toString() {\\n    return `[${this._characters.join(\\\"\\\")}]`;\\n  }\\n  toHTMLString() {\\n    return `[${this._characters.join(\\\"\\\").replace('\\\"', \\\"&quot;\\\")}]`;\\n  }\\n}\\n\\n// MARK: Lexer functions\\n\\nfunction _isIdentifierCharacter(c) {\\n  console.assert(c.length === 1);\\n  return (c >= \\\"a\\\" && c <= \\\"z\\\") || (c >= \\\"A\\\" && c <= \\\"Z\\\") || c === \\\"-\\\";\\n}\\n\\nfunction _isASCIIDigit(c) {\\n  console.assert(c.length === 1);\\n  return c >= \\\"0\\\" && c <= \\\"9\\\";\\n}\\n\\nfunction _isASCIIPrintableCharacter(c) {\\n  console.assert(c.length === 1);\\n  return c >= \\\" \\\" && c <= \\\"~\\\";\\n}\\n\\nfunction _isASCIIWhitespace(c) {\\n  console.assert(c.length === 1);\\n  return c === \\\" \\\" || c === \\\"\\\\f\\\" || c === \\\"\\\\n\\\" || c === \\\"\\\\r\\\" || c === \\\"\\\\t\\\";\\n}\\n\\n// MARK: ASCII printable character bit set and canonicalization functions\\n\\nfunction _bitSetIndexForCharacter(c) {\\n  console.assert(c.length == 1);\\n  return c.codePointAt(0) - SPACE_CODE_POINT;\\n}\\n\\nfunction _characterAtBitSetIndex(index) {\\n  return String.fromCodePoint(index + SPACE_CODE_POINT);\\n}\\n\\nfunction _markBitsForNamedCharacterClass(bitSet, namedCharacterClass) {\\n  console.assert(bitSet instanceof Array);\\n  console.assert(namedCharacterClass.name !== Identifier.UNICODE);\\n  console.assert(namedCharacterClass.name !== Identifier.ASCII_PRINTABLE);\\n  if (namedCharacterClass.name === Identifier.UPPER) {\\n    bitSet.fill(\\n      true,\\n      _bitSetIndexForCharacter(\\\"A\\\"),\\n      _bitSetIndexForCharacter(\\\"Z\\\") + 1\\n    );\\n  } else if (namedCharacterClass.name === Identifier.LOWER) {\\n    bitSet.fill(\\n      true,\\n      _bitSetIndexForCharacter(\\\"a\\\"),\\n      _bitSetIndexForCharacter(\\\"z\\\") + 1\\n    );\\n  } else if (namedCharacterClass.name === Identifier.DIGIT) {\\n    bitSet.fill(\\n      true,\\n      _bitSetIndexForCharacter(\\\"0\\\"),\\n      _bitSetIndexForCharacter(\\\"9\\\") + 1\\n    );\\n  } else if (namedCharacterClass.name === Identifier.SPECIAL) {\\n    bitSet.fill(\\n      true,\\n      _bitSetIndexForCharacter(\\\" \\\"),\\n      _bitSetIndexForCharacter(\\\"/\\\") + 1\\n    );\\n    bitSet.fill(\\n      true,\\n      _bitSetIndexForCharacter(\\\":\\\"),\\n      _bitSetIndexForCharacter(\\\"@\\\") + 1\\n    );\\n    bitSet.fill(\\n      true,\\n      _bitSetIndexForCharacter(\\\"[\\\"),\\n      _bitSetIndexForCharacter(\\\"`\\\") + 1\\n    );\\n    bitSet.fill(\\n      true,\\n      _bitSetIndexForCharacter(\\\"{\\\"),\\n      _bitSetIndexForCharacter(\\\"~\\\") + 1\\n    );\\n  } else {\\n    console.assert(false, SHOULD_NOT_BE_REACHED, namedCharacterClass);\\n  }\\n}\\n\\nfunction _markBitsForCustomCharacterClass(bitSet, customCharacterClass) {\\n  for (let character of customCharacterClass.characters) {\\n    bitSet[_bitSetIndexForCharacter(character)] = true;\\n  }\\n}\\n\\nfunction _canonicalizedPropertyValues(\\n  propertyValues,\\n  keepCustomCharacterClassFormatCompliant\\n) {\\n  let asciiPrintableBitSet = new Array(\\n    \\\"~\\\".codePointAt(0) - \\\" \\\".codePointAt(0) + 1\\n  );\\n\\n  for (let propertyValue of propertyValues) {\\n    if (propertyValue instanceof NamedCharacterClass) {\\n      if (propertyValue.name === Identifier.UNICODE) {\\n        return [new NamedCharacterClass(Identifier.UNICODE)];\\n      }\\n\\n      if (propertyValue.name === Identifier.ASCII_PRINTABLE) {\\n        return [new NamedCharacterClass(Identifier.ASCII_PRINTABLE)];\\n      }\\n\\n      _markBitsForNamedCharacterClass(asciiPrintableBitSet, propertyValue);\\n    } else if (propertyValue instanceof CustomCharacterClass) {\\n      _markBitsForCustomCharacterClass(asciiPrintableBitSet, propertyValue);\\n    }\\n  }\\n\\n  let charactersSeen = [];\\n\\n  function checkRange(start, end) {\\n    let temp = [];\\n    for (\\n      let i = _bitSetIndexForCharacter(start);\\n      i <= _bitSetIndexForCharacter(end);\\n      ++i\\n    ) {\\n      if (asciiPrintableBitSet[i]) {\\n        temp.push(_characterAtBitSetIndex(i));\\n      }\\n    }\\n\\n    let result =\\n      temp.length ===\\n      _bitSetIndexForCharacter(end) - _bitSetIndexForCharacter(start) + 1;\\n    if (!result) {\\n      charactersSeen = charactersSeen.concat(temp);\\n    }\\n    return result;\\n  }\\n\\n  let hasAllUpper = checkRange(\\\"A\\\", \\\"Z\\\");\\n  let hasAllLower = checkRange(\\\"a\\\", \\\"z\\\");\\n  let hasAllDigits = checkRange(\\\"0\\\", \\\"9\\\");\\n\\n  // Check for special characters, accounting for characters that are given special treatment (i.e. '-' and ']')\\n  let hasAllSpecial = false;\\n  let hasDash = false;\\n  let hasRightSquareBracket = false;\\n  let temp = [];\\n  for (\\n    let i = _bitSetIndexForCharacter(\\\" \\\");\\n    i <= _bitSetIndexForCharacter(\\\"/\\\");\\n    ++i\\n  ) {\\n    if (!asciiPrintableBitSet[i]) {\\n      continue;\\n    }\\n\\n    let character = _characterAtBitSetIndex(i);\\n    if (keepCustomCharacterClassFormatCompliant && character === \\\"-\\\") {\\n      hasDash = true;\\n    } else {\\n      temp.push(character);\\n    }\\n  }\\n  for (\\n    let i = _bitSetIndexForCharacter(\\\":\\\");\\n    i <= _bitSetIndexForCharacter(\\\"@\\\");\\n    ++i\\n  ) {\\n    if (asciiPrintableBitSet[i]) {\\n      temp.push(_characterAtBitSetIndex(i));\\n    }\\n  }\\n  for (\\n    let i = _bitSetIndexForCharacter(\\\"[\\\");\\n    i <= _bitSetIndexForCharacter(\\\"`\\\");\\n    ++i\\n  ) {\\n    if (!asciiPrintableBitSet[i]) {\\n      continue;\\n    }\\n\\n    let character = _characterAtBitSetIndex(i);\\n    if (keepCustomCharacterClassFormatCompliant && character === \\\"]\\\") {\\n      hasRightSquareBracket = true;\\n    } else {\\n      temp.push(character);\\n    }\\n  }\\n  for (\\n    let i = _bitSetIndexForCharacter(\\\"{\\\");\\n    i <= _bitSetIndexForCharacter(\\\"~\\\");\\n    ++i\\n  ) {\\n    if (asciiPrintableBitSet[i]) {\\n      temp.push(_characterAtBitSetIndex(i));\\n    }\\n  }\\n\\n  if (hasDash) {\\n    temp.unshift(\\\"-\\\");\\n  }\\n  if (hasRightSquareBracket) {\\n    temp.push(\\\"]\\\");\\n  }\\n\\n  let numberOfSpecialCharacters =\\n    _bitSetIndexForCharacter(\\\"/\\\") -\\n    _bitSetIndexForCharacter(\\\" \\\") +\\n    1 +\\n    (_bitSetIndexForCharacter(\\\"@\\\") - _bitSetIndexForCharacter(\\\":\\\") + 1) +\\n    (_bitSetIndexForCharacter(\\\"`\\\") - _bitSetIndexForCharacter(\\\"[\\\") + 1) +\\n    (_bitSetIndexForCharacter(\\\"~\\\") - _bitSetIndexForCharacter(\\\"{\\\") + 1);\\n  hasAllSpecial = temp.length === numberOfSpecialCharacters;\\n  if (!hasAllSpecial) {\\n    charactersSeen = charactersSeen.concat(temp);\\n  }\\n\\n  let result = [];\\n  if (hasAllUpper && hasAllLower && hasAllDigits && hasAllSpecial) {\\n    return [new NamedCharacterClass(Identifier.ASCII_PRINTABLE)];\\n  }\\n  if (hasAllUpper) {\\n    result.push(new NamedCharacterClass(Identifier.UPPER));\\n  }\\n  if (hasAllLower) {\\n    result.push(new NamedCharacterClass(Identifier.LOWER));\\n  }\\n  if (hasAllDigits) {\\n    result.push(new NamedCharacterClass(Identifier.DIGIT));\\n  }\\n  if (hasAllSpecial) {\\n    result.push(new NamedCharacterClass(Identifier.SPECIAL));\\n  }\\n  if (charactersSeen.length) {\\n    result.push(new CustomCharacterClass(charactersSeen));\\n  }\\n  return result;\\n}\\n\\n// MARK: Parser functions\\n\\nfunction _indexOfNonWhitespaceCharacter(input, position = 0) {\\n  console.assert(position >= 0);\\n  console.assert(position <= input.length);\\n\\n  let length = input.length;\\n  while (position < length && _isASCIIWhitespace(input[position])) {\\n    ++position;\\n  }\\n\\n  return position;\\n}\\n\\nfunction _parseIdentifier(input, position) {\\n  console.assert(position >= 0);\\n  console.assert(position < input.length);\\n  console.assert(_isIdentifierCharacter(input[position]));\\n\\n  let length = input.length;\\n  let seenIdentifiers = [];\\n  do {\\n    let c = input[position];\\n    if (!_isIdentifierCharacter(c)) {\\n      break;\\n    }\\n\\n    seenIdentifiers.push(c);\\n    ++position;\\n  } while (position < length);\\n\\n  return [seenIdentifiers.join(\\\"\\\"), position];\\n}\\n\\nfunction _isValidRequiredOrAllowedPropertyValueIdentifier(identifier) {\\n  return (\\n    identifier && Object.values(Identifier).includes(identifier.toLowerCase())\\n  );\\n}\\n\\nfunction _parseCustomCharacterClass(input, position) {\\n  console.assert(position >= 0);\\n  console.assert(position < input.length);\\n  console.assert(input[position] === CHARACTER_CLASS_START_SENTINEL);\\n\\n  let length = input.length;\\n  ++position;\\n  if (position >= length) {\\n    console.error(\\\"Found end-of-line instead of character class character\\\");\\n    return [null, position];\\n  }\\n\\n  let initialPosition = position;\\n  let result = [];\\n  do {\\n    let c = input[position];\\n    if (!_isASCIIPrintableCharacter(c)) {\\n      ++position;\\n      continue;\\n    }\\n\\n    if (c === \\\"-\\\" && position - initialPosition > 0) {\\n      // FIXME: Should this be an error?\\n      console.warn(\\n        \\\"Ignoring '-'; a '-' may only appear as the first character in a character class\\\"\\n      );\\n      ++position;\\n      continue;\\n    }\\n\\n    result.push(c);\\n    ++position;\\n    if (c === CHARACTER_CLASS_END_SENTINEL) {\\n      break;\\n    }\\n  } while (position < length);\\n\\n  if (\\n    (position < length && input[position] !== CHARACTER_CLASS_END_SENTINEL) ||\\n    (position == length && input[position - 1] == CHARACTER_CLASS_END_SENTINEL)\\n  ) {\\n    // Fix up result; we over consumed.\\n    result.pop();\\n    return [result, position];\\n  }\\n\\n  if (position < length && input[position] == CHARACTER_CLASS_END_SENTINEL) {\\n    return [result, position + 1];\\n  }\\n\\n  console.error(\\\"Found end-of-line instead of end of character class\\\");\\n  return [null, position];\\n}\\n\\nfunction _parsePasswordRequiredOrAllowedPropertyValue(input, position) {\\n  console.assert(position >= 0);\\n  console.assert(position < input.length);\\n\\n  let length = input.length;\\n  let propertyValues = [];\\n  while (true) {\\n    if (_isIdentifierCharacter(input[position])) {\\n      let identifierStartPosition = position;\\n      var [propertyValue, position] = _parseIdentifier(input, position);\\n      if (!_isValidRequiredOrAllowedPropertyValueIdentifier(propertyValue)) {\\n        console.error(\\n          \\\"Unrecognized property value identifier: \\\" + propertyValue\\n        );\\n        return [null, identifierStartPosition];\\n      }\\n      propertyValues.push(new NamedCharacterClass(propertyValue));\\n    } else if (input[position] == CHARACTER_CLASS_START_SENTINEL) {\\n      var [propertyValue, position] = _parseCustomCharacterClass(\\n        input,\\n        position\\n      );\\n      if (propertyValue && propertyValue.length) {\\n        propertyValues.push(new CustomCharacterClass(propertyValue));\\n      }\\n    } else {\\n      console.error(\\n        \\\"Failed to find start of property value: \\\" + input.substr(position)\\n      );\\n      return [null, position];\\n    }\\n\\n    position = _indexOfNonWhitespaceCharacter(input, position);\\n    if (position >= length || input[position] === PROPERTY_SEPARATOR) {\\n      break;\\n    }\\n\\n    if (input[position] === PROPERTY_VALUE_SEPARATOR) {\\n      position = _indexOfNonWhitespaceCharacter(input, position + 1);\\n      if (position >= length) {\\n        console.error(\\n          \\\"Found end-of-line instead of start of next property value\\\"\\n        );\\n        return [null, position];\\n      }\\n      continue;\\n    }\\n\\n    console.error(\\n      \\\"Failed to find start of next property or property value: \\\" +\\n        input.substr(position)\\n    );\\n    return [null, position];\\n  }\\n  return [propertyValues, position];\\n}\\n\\nfunction _parsePasswordRule(input, position) {\\n  console.assert(position >= 0);\\n  console.assert(position < input.length);\\n  console.assert(_isIdentifierCharacter(input[position]));\\n\\n  let length = input.length;\\n\\n  let mayBeIdentifierStartPosition = position;\\n  var [identifier, position] = _parseIdentifier(input, position);\\n  if (!Object.values(RuleName).includes(identifier)) {\\n    console.error(\\\"Unrecognized property name: \\\" + identifier);\\n    return [null, mayBeIdentifierStartPosition];\\n  }\\n\\n  if (position >= length) {\\n    console.error(\\\"Found end-of-line instead of start of property value\\\");\\n    return [null, position];\\n  }\\n\\n  if (input[position] !== PROPERTY_VALUE_START_SENTINEL) {\\n    console.error(\\n      \\\"Failed to find start of property value: \\\" + input.substr(position)\\n    );\\n    return [null, position];\\n  }\\n\\n  let property = { name: identifier, value: null };\\n\\n  position = _indexOfNonWhitespaceCharacter(input, position + 1);\\n  // Empty value\\n  if (position >= length || input[position] === PROPERTY_SEPARATOR) {\\n    return [new Rule(property.name, property.value), position];\\n  }\\n\\n  switch (identifier) {\\n    case RuleName.ALLOWED:\\n    case RuleName.REQUIRED: {\\n      var [\\n        propertyValue,\\n        position,\\n      ] = _parsePasswordRequiredOrAllowedPropertyValue(input, position);\\n      if (propertyValue) {\\n        property.value = propertyValue;\\n      }\\n      return [new Rule(property.name, property.value), position];\\n    }\\n    case RuleName.MAX_CONSECUTIVE: {\\n      var [propertyValue, position] = _parseMaxConsecutivePropertyValue(\\n        input,\\n        position\\n      );\\n      if (propertyValue) {\\n        property.value = propertyValue;\\n      }\\n      return [new Rule(property.name, property.value), position];\\n    }\\n    case RuleName.MIN_LENGTH:\\n    case RuleName.MAX_LENGTH: {\\n      var [propertyValue, position] = _parseMinLengthMaxLengthPropertyValue(\\n        input,\\n        position\\n      );\\n      if (propertyValue) {\\n        property.value = propertyValue;\\n      }\\n      return [new Rule(property.name, property.value), position];\\n    }\\n  }\\n  console.assert(false, SHOULD_NOT_BE_REACHED);\\n}\\n\\nfunction _parseMinLengthMaxLengthPropertyValue(input, position) {\\n  return _parseInteger(input, position);\\n}\\n\\nfunction _parseMaxConsecutivePropertyValue(input, position) {\\n  return _parseInteger(input, position);\\n}\\n\\nfunction _parseInteger(input, position) {\\n  console.assert(position >= 0);\\n  console.assert(position < input.length);\\n\\n  if (!_isASCIIDigit(input[position])) {\\n    console.error(\\n      \\\"Failed to parse value of type integer; not a number: \\\" +\\n        input.substr(position)\\n    );\\n    return [null, position];\\n  }\\n\\n  let length = input.length;\\n  let initialPosition = position;\\n  let result = 0;\\n  do {\\n    result = 10 * result + parseInt(input[position], 10);\\n    ++position;\\n  } while (\\n    position < length &&\\n    input[position] !== PROPERTY_SEPARATOR &&\\n    _isASCIIDigit(input[position])\\n  );\\n\\n  if (position >= length || input[position] === PROPERTY_SEPARATOR) {\\n    return [result, position];\\n  }\\n\\n  console.error(\\n    \\\"Failed to parse value of type integer; not a number: \\\" +\\n      input.substr(initialPosition)\\n  );\\n  return [null, position];\\n}\\n\\nfunction _parsePasswordRulesInternal(input) {\\n  let parsedProperties = [];\\n  let length = input.length;\\n\\n  var position = _indexOfNonWhitespaceCharacter(input);\\n  while (position < length) {\\n    if (!_isIdentifierCharacter(input[position])) {\\n      console.warn(\\n        \\\"Failed to find start of property: \\\" + input.substr(position)\\n      );\\n      return parsedProperties;\\n    }\\n\\n    var [parsedProperty, position] = _parsePasswordRule(input, position);\\n    if (parsedProperty && parsedProperty.value) {\\n      parsedProperties.push(parsedProperty);\\n    }\\n\\n    position = _indexOfNonWhitespaceCharacter(input, position);\\n    if (position >= length) {\\n      break;\\n    }\\n\\n    if (input[position] === PROPERTY_SEPARATOR) {\\n      position = _indexOfNonWhitespaceCharacter(input, position + 1);\\n      if (position >= length) {\\n        return parsedProperties;\\n      }\\n\\n      continue;\\n    }\\n\\n    console.error(\\n      \\\"Failed to find start of next property: \\\" + input.substr(position)\\n    );\\n    return null;\\n  }\\n\\n  return parsedProperties;\\n}\\n\\nfunction parsePasswordRules(input, formatRulesForMinifiedVersion) {\\n  let passwordRules = _parsePasswordRulesInternal(input) || [];\\n\\n  // When formatting rules for minified version, we should keep the formatted rules\\n  // as similar to the input as possible. Avoid copying required rules to allowed rules.\\n  let suppressCopyingRequiredToAllowed = formatRulesForMinifiedVersion;\\n\\n  let newPasswordRules = [];\\n  let newAllowedValues = [];\\n  let minimumMaximumConsecutiveCharacters = null;\\n  let maximumMinLength = 0;\\n  let minimumMaxLength = null;\\n\\n  for (let rule of passwordRules) {\\n    switch (rule.name) {\\n      case RuleName.MAX_CONSECUTIVE:\\n        minimumMaximumConsecutiveCharacters = minimumMaximumConsecutiveCharacters\\n          ? Math.min(rule.value, minimumMaximumConsecutiveCharacters)\\n          : rule.value;\\n        break;\\n\\n      case RuleName.MIN_LENGTH:\\n        maximumMinLength = Math.max(rule.value, maximumMinLength);\\n        break;\\n\\n      case RuleName.MAX_LENGTH:\\n        minimumMaxLength = minimumMaxLength\\n          ? Math.min(rule.value, minimumMaxLength)\\n          : rule.value;\\n        break;\\n\\n      case RuleName.REQUIRED:\\n        rule.value = _canonicalizedPropertyValues(\\n          rule.value,\\n          formatRulesForMinifiedVersion\\n        );\\n        newPasswordRules.push(rule);\\n        if (!suppressCopyingRequiredToAllowed) {\\n          newAllowedValues = newAllowedValues.concat(rule.value);\\n        }\\n        break;\\n\\n      case RuleName.ALLOWED:\\n        newAllowedValues = newAllowedValues.concat(rule.value);\\n        break;\\n    }\\n  }\\n\\n  newAllowedValues = _canonicalizedPropertyValues(\\n    newAllowedValues,\\n    suppressCopyingRequiredToAllowed\\n  );\\n  if (!suppressCopyingRequiredToAllowed && !newAllowedValues.length) {\\n    newAllowedValues = [new NamedCharacterClass(Identifier.ASCII_PRINTABLE)];\\n  }\\n  if (newAllowedValues.length) {\\n    newPasswordRules.push(new Rule(RuleName.ALLOWED, newAllowedValues));\\n  }\\n\\n  if (minimumMaximumConsecutiveCharacters !== null) {\\n    newPasswordRules.push(\\n      new Rule(RuleName.MAX_CONSECUTIVE, minimumMaximumConsecutiveCharacters)\\n    );\\n  }\\n\\n  if (maximumMinLength > 0) {\\n    newPasswordRules.push(new Rule(RuleName.MIN_LENGTH, maximumMinLength));\\n  }\\n\\n  if (minimumMaxLength !== null) {\\n    newPasswordRules.push(new Rule(RuleName.MAX_LENGTH, minimumMaxLength));\\n  }\\n\\n  return newPasswordRules;\\n}\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PasswordRulesParser.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs":
/*!****************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs ***!
  \****************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Apache License, Version\\n * 2.0. If a copy of the Apache License was not distributed with this file, You\\n * can obtain one at https://www.apache.org/licenses/LICENSE-2.0 */\\n\\n// This library came from https://github.com/andreasgal/PhoneNumber.js but will\\n// be further maintained by our own in Form Autofill codebase.\\n\\nimport { PHONE_NUMBER_META_DATA } from \\\"resource://gre/modules/shared/PhoneNumberMetaData.sys.mjs\\\";\\n\\nconst lazy = {};\\n\\nChromeUtils.defineESModuleGetters(lazy, {\\n  PhoneNumberNormalizer:\\n    \\\"resource://gre/modules/shared/PhoneNumberNormalizer.sys.mjs\\\",\\n});\\n\\nexport var PhoneNumber = (function (dataBase) {\\n  const MAX_PHONE_NUMBER_LENGTH = 50;\\n  const NON_ALPHA_CHARS = /[^a-zA-Z]/g;\\n  const NON_DIALABLE_CHARS = /[^,#+\\\\*\\\\d]/g;\\n  const NON_DIALABLE_CHARS_ONCE = new RegExp(NON_DIALABLE_CHARS.source);\\n  const SPLIT_FIRST_GROUP = /^(\\\\d+)(.*)$/;\\n  const LEADING_PLUS_CHARS_PATTERN = /^[+\\\\uFF0B]+/g;\\n\\n  // Format of the string encoded meta data. If the name contains \\\"^\\\" or \\\"$\\\"\\n  // we will generate a regular expression from the value, with those special\\n  // characters as prefix/suffix.\\n  const META_DATA_ENCODING = [\\n    \\\"region\\\",\\n    \\\"^(?:internationalPrefix)\\\",\\n    \\\"nationalPrefix\\\",\\n    \\\"^(?:nationalPrefixForParsing)\\\",\\n    \\\"nationalPrefixTransformRule\\\",\\n    \\\"nationalPrefixFormattingRule\\\",\\n    \\\"^possiblePattern$\\\",\\n    \\\"^nationalPattern$\\\",\\n    \\\"formats\\\",\\n  ];\\n\\n  const FORMAT_ENCODING = [\\n    \\\"^pattern$\\\",\\n    \\\"nationalFormat\\\",\\n    \\\"^leadingDigits\\\",\\n    \\\"nationalPrefixFormattingRule\\\",\\n    \\\"internationalFormat\\\",\\n  ];\\n\\n  let regionCache = Object.create(null);\\n\\n  // Parse an array of strings into a convenient object. We store meta\\n  // data as arrays since thats much more compact than JSON.\\n  function ParseArray(array, encoding, obj) {\\n    for (let n = 0; n < encoding.length; ++n) {\\n      let value = array[n];\\n      if (!value) {\\n        continue;\\n      }\\n      let field = encoding[n];\\n      let fieldAlpha = field.replace(NON_ALPHA_CHARS, \\\"\\\");\\n      if (field != fieldAlpha) {\\n        value = new RegExp(field.replace(fieldAlpha, value));\\n      }\\n      obj[fieldAlpha] = value;\\n    }\\n    return obj;\\n  }\\n\\n  // Parse string encoded meta data into a convenient object\\n  // representation.\\n  function ParseMetaData(countryCode, md) {\\n    let array = JSON.parse(md);\\n    md = ParseArray(array, META_DATA_ENCODING, { countryCode });\\n    regionCache[md.region] = md;\\n    return md;\\n  }\\n\\n  // Parse string encoded format data into a convenient object\\n  // representation.\\n  function ParseFormat(md) {\\n    let formats = md.formats;\\n    if (!formats) {\\n      return;\\n    }\\n    // Bail if we already parsed the format definitions.\\n    if (!Array.isArray(formats[0])) {\\n      return;\\n    }\\n    for (let n = 0; n < formats.length; ++n) {\\n      formats[n] = ParseArray(formats[n], FORMAT_ENCODING, {});\\n    }\\n  }\\n\\n  // Search for the meta data associated with a region identifier (\\\"US\\\") in\\n  // our database, which is indexed by country code (\\\"1\\\"). Since we have\\n  // to walk the entire database for this, we cache the result of the lookup\\n  // for future reference.\\n  function FindMetaDataForRegion(region) {\\n    // Check in the region cache first. This will find all entries we have\\n    // already resolved (parsed from a string encoding).\\n    let md = regionCache[region];\\n    if (md) {\\n      return md;\\n    }\\n    for (let countryCode in dataBase) {\\n      let entry = dataBase[countryCode];\\n      // Each entry is a string encoded object of the form '[\\\"US..', or\\n      // an array of strings. We don't want to parse the string here\\n      // to save memory, so we just substring the region identifier\\n      // and compare it. For arrays, we compare against all region\\n      // identifiers with that country code. We skip entries that are\\n      // of type object, because they were already resolved (parsed into\\n      // an object), and their country code should have been in the cache.\\n      if (Array.isArray(entry)) {\\n        for (let n = 0; n < entry.length; n++) {\\n          if (typeof entry[n] == \\\"string\\\" && entry[n].substr(2, 2) == region) {\\n            if (n > 0) {\\n              // Only the first entry has the formats field set.\\n              // Parse the main country if we haven't already and use\\n              // the formats field from the main country.\\n              if (typeof entry[0] == \\\"string\\\") {\\n                entry[0] = ParseMetaData(countryCode, entry[0]);\\n              }\\n              let formats = entry[0].formats;\\n              let current = ParseMetaData(countryCode, entry[n]);\\n              current.formats = formats;\\n              entry[n] = current;\\n              return entry[n];\\n            }\\n\\n            entry[n] = ParseMetaData(countryCode, entry[n]);\\n            return entry[n];\\n          }\\n        }\\n        continue;\\n      }\\n      if (typeof entry == \\\"string\\\" && entry.substr(2, 2) == region) {\\n        dataBase[countryCode] = ParseMetaData(countryCode, entry);\\n        return dataBase[countryCode];\\n      }\\n    }\\n  }\\n\\n  // Format a national number for a given region. The boolean flag \\\"intl\\\"\\n  // indicates whether we want the national or international format.\\n  function FormatNumber(regionMetaData, number, intl) {\\n    // We lazily parse the format description in the meta data for the region,\\n    // so make sure to parse it now if we haven't already done so.\\n    ParseFormat(regionMetaData);\\n    let formats = regionMetaData.formats;\\n    if (!formats) {\\n      return null;\\n    }\\n    for (let n = 0; n < formats.length; ++n) {\\n      let format = formats[n];\\n      // The leading digits field is optional. If we don't have it, just\\n      // use the matching pattern to qualify numbers.\\n      if (format.leadingDigits && !format.leadingDigits.test(number)) {\\n        continue;\\n      }\\n      if (!format.pattern.test(number)) {\\n        continue;\\n      }\\n      if (intl) {\\n        // If there is no international format, just fall back to the national\\n        // format.\\n        let internationalFormat = format.internationalFormat;\\n        if (!internationalFormat) {\\n          internationalFormat = format.nationalFormat;\\n        }\\n        // Some regions have numbers that can't be dialed from outside the\\n        // country, indicated by \\\"NA\\\" for the international format of that\\n        // number format pattern.\\n        if (internationalFormat == \\\"NA\\\") {\\n          return null;\\n        }\\n        // Prepend \\\"+\\\" and the country code.\\n        number =\\n          \\\"+\\\" +\\n          regionMetaData.countryCode +\\n          \\\" \\\" +\\n          number.replace(format.pattern, internationalFormat);\\n      } else {\\n        number = number.replace(format.pattern, format.nationalFormat);\\n        // The region has a national prefix formatting rule, and it can be overwritten\\n        // by each actual number format rule.\\n        let nationalPrefixFormattingRule =\\n          regionMetaData.nationalPrefixFormattingRule;\\n        if (format.nationalPrefixFormattingRule) {\\n          nationalPrefixFormattingRule = format.nationalPrefixFormattingRule;\\n        }\\n        if (nationalPrefixFormattingRule) {\\n          // The prefix formatting rule contains two magic markers, \\\"$NP\\\" and \\\"$FG\\\".\\n          // \\\"$NP\\\" will be replaced by the national prefix, and \\\"$FG\\\" with the\\n          // first group of numbers.\\n          let match = number.match(SPLIT_FIRST_GROUP);\\n          if (match) {\\n            let firstGroup = match[1];\\n            let rest = match[2];\\n            let prefix = nationalPrefixFormattingRule;\\n            prefix = prefix.replace(\\\"$NP\\\", regionMetaData.nationalPrefix);\\n            prefix = prefix.replace(\\\"$FG\\\", firstGroup);\\n            number = prefix + rest;\\n          }\\n        }\\n      }\\n      return number == \\\"NA\\\" ? null : number;\\n    }\\n    return null;\\n  }\\n\\n  function NationalNumber(regionMetaData, number) {\\n    this.region = regionMetaData.region;\\n    this.regionMetaData = regionMetaData;\\n    this.number = number;\\n  }\\n\\n  // NationalNumber represents the result of parsing a phone number. We have\\n  // three getters on the prototype that format the number in national and\\n  // international format. Once called, the getters put a direct property\\n  // onto the object, caching the result.\\n  NationalNumber.prototype = {\\n    // +1 949-726-2896\\n    get internationalFormat() {\\n      let value = FormatNumber(this.regionMetaData, this.number, true);\\n      Object.defineProperty(this, \\\"internationalFormat\\\", {\\n        value,\\n        enumerable: true,\\n      });\\n      return value;\\n    },\\n    // (949) 726-2896\\n    get nationalFormat() {\\n      let value = FormatNumber(this.regionMetaData, this.number, false);\\n      Object.defineProperty(this, \\\"nationalFormat\\\", {\\n        value,\\n        enumerable: true,\\n      });\\n      return value;\\n    },\\n    // +19497262896\\n    get internationalNumber() {\\n      let value = this.internationalFormat\\n        ? this.internationalFormat.replace(NON_DIALABLE_CHARS, \\\"\\\")\\n        : null;\\n      Object.defineProperty(this, \\\"internationalNumber\\\", {\\n        value,\\n        enumerable: true,\\n      });\\n      return value;\\n    },\\n    // 9497262896\\n    get nationalNumber() {\\n      let value = this.nationalFormat\\n        ? this.nationalFormat.replace(NON_DIALABLE_CHARS, \\\"\\\")\\n        : null;\\n      Object.defineProperty(this, \\\"nationalNumber\\\", {\\n        value,\\n        enumerable: true,\\n      });\\n      return value;\\n    },\\n    // country name 'US'\\n    get countryName() {\\n      let value = this.region ? this.region : null;\\n      Object.defineProperty(this, \\\"countryName\\\", { value, enumerable: true });\\n      return value;\\n    },\\n    // country code '+1'\\n    get countryCode() {\\n      let value = this.regionMetaData.countryCode\\n        ? \\\"+\\\" + this.regionMetaData.countryCode\\n        : null;\\n      Object.defineProperty(this, \\\"countryCode\\\", { value, enumerable: true });\\n      return value;\\n    },\\n  };\\n\\n  // Check whether the number is valid for the given region.\\n  function IsValidNumber(number, md) {\\n    return md.possiblePattern.test(number);\\n  }\\n\\n  // Check whether the number is a valid national number for the given region.\\n  /* eslint-disable no-unused-vars */\\n  function IsNationalNumber(number, md) {\\n    return IsValidNumber(number, md) && md.nationalPattern.test(number);\\n  }\\n\\n  // Determine the country code a number starts with, or return null if\\n  // its not a valid country code.\\n  function ParseCountryCode(number) {\\n    for (let n = 1; n <= 3; ++n) {\\n      let cc = number.substr(0, n);\\n      if (dataBase[cc]) {\\n        return cc;\\n      }\\n    }\\n    return null;\\n  }\\n\\n  // Parse a national number for a specific region. Return null if the\\n  // number is not a valid national number (it might still be a possible\\n  // number for parts of that region).\\n  function ParseNationalNumber(number, md) {\\n    if (!md.possiblePattern.test(number) || !md.nationalPattern.test(number)) {\\n      return null;\\n    }\\n    // Success.\\n    return new NationalNumber(md, number);\\n  }\\n\\n  function ParseNationalNumberAndCheckNationalPrefix(number, md) {\\n    let ret;\\n\\n    // This is not an international number. See if its a national one for\\n    // the current region. National numbers can start with the national\\n    // prefix, or without.\\n    if (md.nationalPrefixForParsing) {\\n      // Some regions have specific national prefix parse rules. Apply those.\\n      let withoutPrefix = number.replace(\\n        md.nationalPrefixForParsing,\\n        md.nationalPrefixTransformRule || \\\"\\\"\\n      );\\n      ret = ParseNationalNumber(withoutPrefix, md);\\n      if (ret) {\\n        return ret;\\n      }\\n    } else {\\n      // If there is no specific national prefix rule, just strip off the\\n      // national prefix from the beginning of the number (if there is one).\\n      let nationalPrefix = md.nationalPrefix;\\n      if (\\n        nationalPrefix &&\\n        number.indexOf(nationalPrefix) == 0 &&\\n        (ret = ParseNationalNumber(number.substr(nationalPrefix.length), md))\\n      ) {\\n        return ret;\\n      }\\n    }\\n    ret = ParseNationalNumber(number, md);\\n    if (ret) {\\n      return ret;\\n    }\\n  }\\n\\n  function ParseNumberByCountryCode(number, countryCode) {\\n    let ret;\\n\\n    // Lookup the meta data for the region (or regions) and if the rest of\\n    // the number parses for that region, return the parsed number.\\n    let entry = dataBase[countryCode];\\n    if (Array.isArray(entry)) {\\n      for (let n = 0; n < entry.length; ++n) {\\n        if (typeof entry[n] == \\\"string\\\") {\\n          entry[n] = ParseMetaData(countryCode, entry[n]);\\n        }\\n        if (n > 0) {\\n          entry[n].formats = entry[0].formats;\\n        }\\n        ret = ParseNationalNumberAndCheckNationalPrefix(number, entry[n]);\\n        if (ret) {\\n          return ret;\\n        }\\n      }\\n      return null;\\n    }\\n    if (typeof entry == \\\"string\\\") {\\n      entry = dataBase[countryCode] = ParseMetaData(countryCode, entry);\\n    }\\n    return ParseNationalNumberAndCheckNationalPrefix(number, entry);\\n  }\\n\\n  // Parse an international number that starts with the country code. Return\\n  // null if the number is not a valid international number.\\n  function ParseInternationalNumber(number) {\\n    // Parse and strip the country code.\\n    let countryCode = ParseCountryCode(number);\\n    if (!countryCode) {\\n      return null;\\n    }\\n    number = number.substr(countryCode.length);\\n\\n    return ParseNumberByCountryCode(number, countryCode);\\n  }\\n\\n  // Parse a number and transform it into the national format, removing any\\n  // international dial prefixes and country codes.\\n  function ParseNumber(number, defaultRegion) {\\n    let ret;\\n\\n    // Remove formating characters and whitespace.\\n    number = lazy.PhoneNumberNormalizer.Normalize(number);\\n\\n    // If there is no defaultRegion or the defaultRegion is the global region,\\n    // we can't parse international access codes.\\n    if ((!defaultRegion || defaultRegion === \\\"001\\\") && number[0] !== \\\"+\\\") {\\n      return null;\\n    }\\n\\n    // Detect and strip leading '+'.\\n    if (number[0] === \\\"+\\\") {\\n      return ParseInternationalNumber(\\n        number.replace(LEADING_PLUS_CHARS_PATTERN, \\\"\\\")\\n      );\\n    }\\n\\n    // If \\\"defaultRegion\\\" is a country code, use it to parse the number directly.\\n    let matches = String(defaultRegion).match(/^\\\\+?(\\\\d+)/);\\n    if (matches) {\\n      let countryCode = ParseCountryCode(matches[1]);\\n      if (!countryCode) {\\n        return null;\\n      }\\n      return ParseNumberByCountryCode(number, countryCode);\\n    }\\n\\n    // Lookup the meta data for the given region.\\n    let md = FindMetaDataForRegion(defaultRegion.toUpperCase());\\n    if (!md) {\\n      dump(\\\"Couldn't find Meta Data for region: \\\" + defaultRegion + \\\"\\\\n\\\");\\n      return null;\\n    }\\n\\n    // See if the number starts with an international prefix, and if the\\n    // number resulting from stripping the code is valid, then remove the\\n    // prefix and flag the number as international.\\n    if (md.internationalPrefix.test(number)) {\\n      let possibleNumber = number.replace(md.internationalPrefix, \\\"\\\");\\n      ret = ParseInternationalNumber(possibleNumber);\\n      if (ret) {\\n        return ret;\\n      }\\n    }\\n\\n    ret = ParseNationalNumberAndCheckNationalPrefix(number, md);\\n    if (ret) {\\n      return ret;\\n    }\\n\\n    // Now lets see if maybe its an international number after all, but\\n    // without '+' or the international prefix.\\n    ret = ParseInternationalNumber(number);\\n    if (ret) {\\n      return ret;\\n    }\\n\\n    // If the number matches the possible numbers of the current region,\\n    // return it as a possible number.\\n    if (md.possiblePattern.test(number)) {\\n      return new NationalNumber(md, number);\\n    }\\n\\n    // We couldn't parse the number at all.\\n    return null;\\n  }\\n\\n  function IsPlainPhoneNumber(number) {\\n    if (typeof number !== \\\"string\\\") {\\n      return false;\\n    }\\n\\n    let length = number.length;\\n    let isTooLong = length > MAX_PHONE_NUMBER_LENGTH;\\n    let isEmpty = length === 0;\\n    return !(isTooLong || isEmpty || NON_DIALABLE_CHARS_ONCE.test(number));\\n  }\\n\\n  return {\\n    IsPlain: IsPlainPhoneNumber,\\n    IsValid: IsValidNumber,\\n    Parse: ParseNumber,\\n    FindMetaDataForRegion,\\n  };\\n})(PHONE_NUMBER_META_DATA);\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs ***!
  \************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Apache License, Version\\n * 2.0. If a copy of the Apache License was not distributed with this file, You\\n * can obtain one at https://www.apache.org/licenses/LICENSE-2.0 */\\n\\n/*\\n * This data was generated base on libphonenumber v8.4.1 via the script in\\n * https://github.com/andreasgal/PhoneNumber.js\\n *\\n * The XML format of libphonenumber has changed since v8.4.2 so we can only stay\\n * in this version for now.\\n */\\n\\nexport var PHONE_NUMBER_META_DATA = {\\n  46: '[\\\"SE\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,12}\\\",\\\"[1-35-9]\\\\\\\\\\\\\\\\d{5,11}|4\\\\\\\\\\\\\\\\d{6,8}\\\",[[\\\"(8)(\\\\\\\\\\\\\\\\d{2,3})(\\\\\\\\\\\\\\\\d{2,3})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1-$2 $3 $4\\\",\\\"8\\\",null,\\\"$1 $2 $3 $4\\\"],[\\\"([1-69]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2,3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1-$2 $3 $4\\\",\\\"1[013689]|2[0136]|3[1356]|4[0246]|54|6[03]|90\\\",null,\\\"$1 $2 $3 $4\\\"],[\\\"([1-469]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1-$2 $3\\\",\\\"1[136]|2[136]|3[356]|4[0246]|6[03]|90\\\",null,\\\"$1 $2 $3\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1-$2 $3 $4\\\",\\\"1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[0-5]|4[0-3])\\\",null,\\\"$1 $2 $3 $4\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2,3})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1-$2 $3\\\",\\\"1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[0-5]|4[0-3])\\\",null,\\\"$1 $2 $3\\\"],[\\\"(7\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1-$2 $3 $4\\\",\\\"7\\\",null,\\\"$1 $2 $3 $4\\\"],[\\\"(77)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1-$2$3\\\",\\\"7\\\",null,\\\"$1 $2 $3\\\"],[\\\"(20)(\\\\\\\\\\\\\\\\d{2,3})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1-$2 $3\\\",\\\"20\\\",null,\\\"$1 $2 $3\\\"],[\\\"(9[034]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1-$2 $3 $4\\\",\\\"9[034]\\\",null,\\\"$1 $2 $3 $4\\\"],[\\\"(9[034]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"9[034]\\\",null,\\\"$1 $2\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1-$2 $3 $4 $5\\\",\\\"25[245]|67[3-6]\\\",null,\\\"$1 $2 $3 $4 $5\\\"]]]',\\n  299: '[\\\"GL\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{6}\\\",\\\"[1-689]\\\\\\\\\\\\\\\\d{5}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  385: '[\\\"HR\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,9}\\\",\\\"[1-7]\\\\\\\\\\\\\\\\d{5,8}|[89]\\\\\\\\\\\\\\\\d{6,8}\\\",[[\\\"(1)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"1\\\",null],[\\\"([2-5]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"[2-5]\\\",null],[\\\"(9\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"9\\\",null],[\\\"(6[01])(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2,3})\\\",\\\"$1 $2 $3\\\",\\\"6[01]\\\",null],[\\\"([67]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"[67]\\\",null],[\\\"(80[01])(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2,3})\\\",\\\"$1 $2 $3\\\",\\\"8\\\",null],[\\\"(80[01])(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"8\\\",null]]]',\\n  670: '[\\\"TL\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,8}\\\",\\\"[2-489]\\\\\\\\\\\\\\\\d{6}|7\\\\\\\\\\\\\\\\d{6,7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[2-489]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"7\\\",null]]]',\\n  258: '[\\\"MZ\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8,9}\\\",\\\"[28]\\\\\\\\\\\\\\\\d{7,8}\\\",[[\\\"([28]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"2|8[2-7]\\\",null],[\\\"(80\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"80\\\",null]]]',\\n  359: '[\\\"BG\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,9}\\\",\\\"[23567]\\\\\\\\\\\\\\\\d{5,7}|[489]\\\\\\\\\\\\\\\\d{6,8}\\\",[[\\\"(2)(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"2\\\",null],[\\\"(2)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"2\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"43[124-7]|70[1-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3\\\",\\\"43[124-7]|70[1-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[78]00\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"999\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2,3})\\\",\\\"$1 $2 $3\\\",\\\"[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"48|8[7-9]|9[08]\\\",null]]]',\\n  682: '[\\\"CK\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{5}\\\",\\\"[2-8]\\\\\\\\\\\\\\\\d{4}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2\\\",null,null]]]',\\n  852: '[\\\"HK\\\",\\\"00(?:[126-9]|30|5[09])?\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{5,11}\\\",\\\"[235-7]\\\\\\\\\\\\\\\\d{7}|8\\\\\\\\\\\\\\\\d{7,8}|9\\\\\\\\\\\\\\\\d{4,10}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[235-7]|[89](?:0[1-9]|[1-9])\\\",null],[\\\"(800)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"800\\\",null],[\\\"(900)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"900\\\",null],[\\\"(900)(\\\\\\\\\\\\\\\\d{2,5})\\\",\\\"$1 $2\\\",\\\"900\\\",null]]]',\\n  998: '[\\\"UZ\\\",\\\"810\\\",\\\"8\\\",null,null,\\\"$NP $FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"[679]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([679]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",null,null]]]',\\n  291: '[\\\"ER\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,7}\\\",\\\"[178]\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  95: '[\\\"MM\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,10}\\\",\\\"[1478]\\\\\\\\\\\\\\\\d{5,7}|[256]\\\\\\\\\\\\\\\\d{5,8}|9(?:[279]\\\\\\\\\\\\\\\\d{0,2}|[58]|[34]\\\\\\\\\\\\\\\\d{1,2}|6\\\\\\\\\\\\\\\\d?)\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"1|2[245]\\\",null],[\\\"(2)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"251\\\",null],[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"16|2\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"67|81\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"[4-8]\\\",null],[\\\"(9)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4,6})\\\",\\\"$1 $2 $3\\\",\\\"9(?:2[0-4]|[35-9]|4[137-9])\\\",null],[\\\"(9)([34]\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"9(?:3[0-36]|4[0-57-9])\\\",null],[\\\"(9)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"92[56]\\\",null],[\\\"(9)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"93\\\",null]]]',\\n  266: '[\\\"LS\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[2568]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  245: '[\\\"GW\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"(?:4(?:0\\\\\\\\\\\\\\\\d{5}|4\\\\\\\\\\\\\\\\d{7})|9\\\\\\\\\\\\\\\\d{8})\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"44|9[567]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"40\\\",null]]]',\\n  374: '[\\\"AM\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"($NP$FG)\\\",\\\"\\\\\\\\\\\\\\\\d{5,8}\\\",\\\"[1-9]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"1|47\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"4[1349]|[5-7]|9[1-9]\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"[23]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"8|90\\\",\\\"$NP $FG\\\"]]]',\\n  61: [\\n    '[\\\"AU\\\",\\\"(?:14(?:1[14]|34|4[17]|[56]6|7[47]|88))?001[14-689]\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{6,10}\\\",\\\"1\\\\\\\\\\\\\\\\d{4,9}|[2-578]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([2378])(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[2378]\\\",\\\"($NP$FG)\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[45]|14\\\",\\\"$NP$FG\\\"],[\\\"(16)(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2\\\",\\\"16\\\",\\\"$NP$FG\\\"],[\\\"(16)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2,4})\\\",\\\"$1 $2 $3\\\",\\\"16\\\",\\\"$NP$FG\\\"],[\\\"(1[389]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"1(?:[38]0|90)\\\",\\\"$FG\\\"],[\\\"(180)(2\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2\\\",\\\"180\\\",\\\"$FG\\\"],[\\\"(19\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2\\\",\\\"19[13]\\\",\\\"$FG\\\"],[\\\"(19\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"19[679]\\\",\\\"$FG\\\"],[\\\"(13)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3\\\",\\\"13[1-9]\\\",\\\"$FG\\\"]]]',\\n    '[\\\"CC\\\",\\\"(?:14(?:1[14]|34|4[17]|[56]6|7[47]|88))?001[14-689]\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{6,10}\\\",\\\"[1458]\\\\\\\\\\\\\\\\d{5,9}\\\"]',\\n    '[\\\"CX\\\",\\\"(?:14(?:1[14]|34|4[17]|[56]6|7[47]|88))?001[14-689]\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{6,10}\\\",\\\"[1458]\\\\\\\\\\\\\\\\d{5,9}\\\"]',\\n  ],\\n  500: '[\\\"FK\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{5}\\\",\\\"[2-7]\\\\\\\\\\\\\\\\d{4}\\\"]',\\n  261: '[\\\"MG\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"[23]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([23]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",null,null]]]',\\n  92: '[\\\"PK\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"($NP$FG)\\\",\\\"\\\\\\\\\\\\\\\\d{6,12}\\\",\\\"1\\\\\\\\\\\\\\\\d{8}|[2-8]\\\\\\\\\\\\\\\\d{5,11}|9(?:[013-9]\\\\\\\\\\\\\\\\d{4,9}|2\\\\\\\\\\\\\\\\d(?:111\\\\\\\\\\\\\\\\d{6}|\\\\\\\\\\\\\\\\d{3,7}))\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(111)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)1\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(111)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"2[349]|45|54|60|72|8[2-5]|9[2-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{7,8})\\\",\\\"$1 $2\\\",\\\"(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{6,7})\\\",\\\"$1 $2\\\",\\\"2[349]|45|54|60|72|8[2-5]|9[2-9]\\\",null],[\\\"(3\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1 $2\\\",\\\"3\\\",\\\"$NP$FG\\\"],[\\\"([15]\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5,6})\\\",\\\"$1 $2\\\",\\\"58[12]|1\\\",null],[\\\"(586\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"586\\\",null],[\\\"([89]00)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3\\\",\\\"[89]00\\\",\\\"$NP$FG\\\"]]]',\\n  234: '[\\\"NG\\\",\\\"009\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,14}\\\",\\\"[1-6]\\\\\\\\\\\\\\\\d{5,8}|9\\\\\\\\\\\\\\\\d{5,9}|[78]\\\\\\\\\\\\\\\\d{5,13}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"[12]|9(?:0[3-9]|[1-9])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2,3})\\\",\\\"$1 $2 $3\\\",\\\"[3-6]|7(?:[1-79]|0[1-9])|8[2-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"70|8[01]|90[235-9]\\\",null],[\\\"([78]00)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4,5})\\\",\\\"$1 $2 $3\\\",\\\"[78]00\\\",null],[\\\"([78]00)(\\\\\\\\\\\\\\\\d{5})(\\\\\\\\\\\\\\\\d{5,6})\\\",\\\"$1 $2 $3\\\",\\\"[78]00\\\",null],[\\\"(78)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"78\\\",null]]]',\\n  350: '[\\\"GI\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[2568]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"2\\\",null]]]',\\n  45: '[\\\"DK\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[2-9]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",null,null]]]',\\n  963: '[\\\"SY\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,9}\\\",\\\"[1-59]\\\\\\\\\\\\\\\\d{7,8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"[1-5]\\\",null],[\\\"(9\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"9\\\",null]]]',\\n  226: '[\\\"BF\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[25-7]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",null,null]]]',\\n  974: '[\\\"QA\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,8}\\\",\\\"[2-8]\\\\\\\\\\\\\\\\d{6,7}\\\",[[\\\"([28]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[28]\\\",null],[\\\"([3-7]\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[3-7]\\\",null]]]',\\n  218: '[\\\"LY\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"[25679]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([25679]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1-$2\\\",null,null]]]',\\n  51: '[\\\"PE\\\",\\\"19(?:1[124]|77|90)00\\\",\\\"0\\\",null,null,\\\"($NP$FG)\\\",\\\"\\\\\\\\\\\\\\\\d{6,9}\\\",\\\"[14-9]\\\\\\\\\\\\\\\\d{7,8}\\\",[[\\\"(1)(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1 $2\\\",\\\"1\\\",null],[\\\"([4-8]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"[4-7]|8[2-4]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"80\\\",null],[\\\"(9\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"9\\\",\\\"$FG\\\"]]]',\\n  62: '[\\\"ID\\\",\\\"0(?:0[1789]|10(?:00|1[67]))\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,12}\\\",\\\"(?:[1-79]\\\\\\\\\\\\\\\\d{6,10}|8\\\\\\\\\\\\\\\\d{7,11})\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5,8})\\\",\\\"$1 $2\\\",\\\"2[124]|[36]1\\\",\\\"($NP$FG)\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5,8})\\\",\\\"$1 $2\\\",\\\"[4579]|2[035-9]|[36][02-9]\\\",\\\"($NP$FG)\\\"],[\\\"(8\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3,4})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1-$2-$3\\\",\\\"8[1-35-9]\\\",null],[\\\"(8\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4,5})\\\",\\\"$1-$2-$3\\\",\\\"8[1-35-9]\\\",null],[\\\"(1)(500)(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"15\\\",\\\"$FG\\\"],[\\\"(177)(\\\\\\\\\\\\\\\\d{6,8})\\\",\\\"$1 $2\\\",\\\"17\\\",null],[\\\"(800)(\\\\\\\\\\\\\\\\d{5,7})\\\",\\\"$1 $2\\\",\\\"800\\\",null],[\\\"(804)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"804\\\",null],[\\\"(80\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"80[79]\\\",null]]]',\\n  298: '[\\\"FO\\\",\\\"00\\\",null,\\\"(10(?:01|[12]0|88))\\\",null,null,\\\"\\\\\\\\\\\\\\\\d{6}\\\",\\\"[2-9]\\\\\\\\\\\\\\\\d{5}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1\\\",null,null]]]',\\n  381: '[\\\"RS\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,12}\\\",\\\"[126-9]\\\\\\\\\\\\\\\\d{4,11}|3(?:[0-79]\\\\\\\\\\\\\\\\d{3,10}|8[2-9]\\\\\\\\\\\\\\\\d{2,9})\\\",[[\\\"([23]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4,9})\\\",\\\"$1 $2\\\",\\\"(?:2[389]|39)0\\\",null],[\\\"([1-3]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{5,10})\\\",\\\"$1 $2\\\",\\\"1|2(?:[0-24-7]|[389][1-9])|3(?:[0-8]|9[1-9])\\\",null],[\\\"(6\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{6,8})\\\",\\\"$1 $2\\\",\\\"6\\\",null],[\\\"([89]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3,9})\\\",\\\"$1 $2\\\",\\\"[89]\\\",null],[\\\"(7[26])(\\\\\\\\\\\\\\\\d{4,9})\\\",\\\"$1 $2\\\",\\\"7[26]\\\",null],[\\\"(7[08]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4,9})\\\",\\\"$1 $2\\\",\\\"7[08]\\\",null]]]',\\n  975: '[\\\"BT\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{6,8}\\\",\\\"[1-8]\\\\\\\\\\\\\\\\d{6,7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"1|77\\\",null],[\\\"([2-8])(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[2-68]|7[246]\\\",null]]]',\\n  34: '[\\\"ES\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[5-9]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([89]00)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[89]00\\\",null],[\\\"([5-9]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[568]|[79][0-8]\\\",null]]]',\\n  881: '[\\\"001\\\",null,null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[67]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2 $3\\\",\\\"[67]\\\",null]]]',\\n  855: '[\\\"KH\\\",\\\"00[14-9]\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{6,10}\\\",\\\"[1-9]\\\\\\\\\\\\\\\\d{7,9}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"1\\\\\\\\\\\\\\\\d[1-9]|[2-9]\\\",\\\"$NP$FG\\\"],[\\\"(1[89]00)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"1[89]0\\\",null]]]',\\n  420: '[\\\"CZ\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{9,12}\\\",\\\"[2-8]\\\\\\\\\\\\\\\\d{8}|9\\\\\\\\\\\\\\\\d{8,11}\\\",[[\\\"([2-9]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[2-8]|9[015-7]\\\",null],[\\\"(96\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"96\\\",null],[\\\"(9\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"9[36]\\\",null]]]',\\n  216: '[\\\"TN\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[2-57-9]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  673: '[\\\"BN\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}\\\",\\\"[2-578]\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"([2-578]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  290: [\\n    '[\\\"SH\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{4,5}\\\",\\\"[256]\\\\\\\\\\\\\\\\d{4}\\\"]',\\n    '[\\\"TA\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{4}\\\",\\\"8\\\\\\\\\\\\\\\\d{3}\\\"]',\\n  ],\\n  882: '[\\\"001\\\",null,null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,12}\\\",\\\"[13]\\\\\\\\\\\\\\\\d{6,11}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"3[23]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"16|342\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"34[57]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"348\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3,4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"16\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4,5})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2 $3\\\",\\\"16|39\\\",null]]]',\\n  267: '[\\\"BW\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,8}\\\",\\\"[2-79]\\\\\\\\\\\\\\\\d{6,7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[2-6]\\\",null],[\\\"(7\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"7\\\",null],[\\\"(90)(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"9\\\",null]]]',\\n  94: '[\\\"LK\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"[1-9]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{1})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2 $3\\\",\\\"[1-689]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"7\\\",null]]]',\\n  356: '[\\\"MT\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[2357-9]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  375: '[\\\"BY\\\",\\\"810\\\",\\\"8\\\",\\\"8?0?\\\",null,null,\\\"\\\\\\\\\\\\\\\\d{5,11}\\\",\\\"[1-4]\\\\\\\\\\\\\\\\d{8}|800\\\\\\\\\\\\\\\\d{3,7}|[89]\\\\\\\\\\\\\\\\d{9,10}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2-$3-$4\\\",\\\"17[0-3589]|2[4-9]|[34]\\\",\\\"$NP 0$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2-$3-$4\\\",\\\"1(?:5[24]|6[235]|7[467])|2(?:1[246]|2[25]|3[26])\\\",\\\"$NP 0$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2-$3\\\",\\\"1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])\\\",\\\"$NP 0$FG\\\"],[\\\"([89]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"8[01]|9\\\",\\\"$NP $FG\\\"],[\\\"(82\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"82\\\",\\\"$NP $FG\\\"],[\\\"(800)(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2\\\",\\\"800\\\",\\\"$NP $FG\\\"],[\\\"(800)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2,4})\\\",\\\"$1 $2 $3\\\",\\\"800\\\",\\\"$NP $FG\\\"]]]',\\n  690: '[\\\"TK\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{4,7}\\\",\\\"[2-47]\\\\\\\\\\\\\\\\d{3,6}\\\"]',\\n  507: '[\\\"PA\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,8}\\\",\\\"[1-9]\\\\\\\\\\\\\\\\d{6,7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"[1-57-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"6\\\",null]]]',\\n  692: '[\\\"MH\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}\\\",\\\"[2-6]\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",null,null]]]',\\n  250: '[\\\"RW\\\",\\\"00\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{8,9}\\\",\\\"[027-9]\\\\\\\\\\\\\\\\d{7,8}\\\",[[\\\"(2\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"2\\\",\\\"$FG\\\"],[\\\"([7-9]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[7-9]\\\",\\\"$NP$FG\\\"],[\\\"(0\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"0\\\",null]]]',\\n  81: '[\\\"JP\\\",\\\"010\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{8,17}\\\",\\\"[1-9]\\\\\\\\\\\\\\\\d{8,9}|00(?:[36]\\\\\\\\\\\\\\\\d{7,14}|7\\\\\\\\\\\\\\\\d{5,7}|8\\\\\\\\\\\\\\\\d{7})\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1-$2-$3\\\",\\\"(?:12|57|99)0\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"800\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"0077\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1-$2-$3\\\",\\\"0077\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"0088\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1-$2-$3\\\",\\\"00(?:37|66)\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4,5})\\\",\\\"$1-$2-$3\\\",\\\"00(?:37|66)\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{5})(\\\\\\\\\\\\\\\\d{5,6})\\\",\\\"$1-$2-$3\\\",\\\"00(?:37|66)\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{6})(\\\\\\\\\\\\\\\\d{6,7})\\\",\\\"$1-$2-$3\\\",\\\"00(?:37|66)\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"[2579]0|80[1-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|5(?:76|97)|499|746|8(?:3[89]|63|47|51)|9(?:49|80|9[16])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"1(?:2[3-6]|3[3-9]|4[2-6]|5[2-8]|[68][2-7]|7[2-689]|9[1-578])|2(?:2[03-689]|3[3-58]|4[0-468]|5[04-8]|6[013-8]|7[06-9]|8[02-57-9]|9[13])|4(?:2[28]|3[689]|6[035-7]|7[05689]|80|9[3-5])|5(?:3[1-36-9]|4[4578]|5[013-8]|6[1-9]|7[2-8]|8[14-7]|9[4-9])|7(?:2[15]|3[5-9]|4[02-9]|6[135-8]|7[0-4689]|9[014-9])|8(?:2[49]|3[3-8]|4[5-8]|5[2-9]|6[35-9]|7[579]|8[03-579]|9[2-8])|9(?:[23]0|4[02-46-9]|5[024-79]|6[4-9]|7[2-47-9]|8[02-7]|9[3-7])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"1|2(?:2[37]|5[5-9]|64|78|8[39]|91)|4(?:2[2689]|64|7[347])|5(?:[2-589]|39)|60|8(?:[46-9]|3[279]|2[124589])|9(?:[235-8]|93)\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"2(?:9[14-79]|74|[34]7|[56]9)|82|993\\\",null],[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"3|4(?:2[09]|7[01])|6[1-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"[2479][1-9]\\\",null]]]',\\n  237: '[\\\"CM\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8,9}\\\",\\\"[2368]\\\\\\\\\\\\\\\\d{7,8}\\\",[[\\\"([26])(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4 $5\\\",\\\"[26]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[23]|88\\\",null],[\\\"(800)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"80\\\",null]]]',\\n  351: '[\\\"PT\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[2-46-9]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(2\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"2[12]\\\",null],[\\\"([2-46-9]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"2[3-9]|[346-9]\\\",null]]]',\\n  246: '[\\\"IO\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}\\\",\\\"3\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  227: '[\\\"NE\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[0289]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[289]|09\\\",null],[\\\"(08)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"08\\\",null]]]',\\n  27: '[\\\"ZA\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,9}\\\",\\\"[1-79]\\\\\\\\\\\\\\\\d{8}|8\\\\\\\\\\\\\\\\d{4,8}\\\",[[\\\"(860)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"860\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2\\\",\\\"8[1-4]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2,3})\\\",\\\"$1 $2 $3\\\",\\\"8[1-4]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[1-79]|8(?:[0-57]|6[1-9])\\\",null]]]',\\n  962: '[\\\"JO\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{8,9}\\\",\\\"[235-9]\\\\\\\\\\\\\\\\d{7,8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[2356]|87\\\",\\\"($NP$FG)\\\"],[\\\"(7)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"7[457-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5,6})\\\",\\\"$1 $2\\\",\\\"70|8[0158]|9\\\",null]]]',\\n  387: '[\\\"BA\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,9}\\\",\\\"[3-9]\\\\\\\\\\\\\\\\d{7,8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2-$3\\\",\\\"[3-5]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"6[1-356]|[7-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"6[047]\\\",null]]]',\\n  33: '[\\\"FR\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[1-9]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([1-79])(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4 $5\\\",\\\"[1-79]\\\",null],[\\\"(1\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2\\\",\\\"11\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(8\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"8\\\",\\\"$NP $FG\\\"]]]',\\n  972: '[\\\"IL\\\",\\\"0(?:0|1[2-9])\\\",\\\"0\\\",null,null,\\\"$FG\\\",\\\"\\\\\\\\\\\\\\\\d{4,12}\\\",\\\"1\\\\\\\\\\\\\\\\d{6,11}|[2-589]\\\\\\\\\\\\\\\\d{3}(?:\\\\\\\\\\\\\\\\d{3,6})?|6\\\\\\\\\\\\\\\\d{3}|7\\\\\\\\\\\\\\\\d{6,9}\\\",[[\\\"([2-489])(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"[2-489]\\\",\\\"$NP$FG\\\"],[\\\"([57]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"[57]\\\",\\\"$NP$FG\\\"],[\\\"(153)(\\\\\\\\\\\\\\\\d{1,2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3 $4\\\",\\\"153\\\",null],[\\\"(1)([7-9]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1-$2-$3-$4\\\",\\\"1[7-9]\\\",null],[\\\"(1255)(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1-$2\\\",\\\"125\\\",null],[\\\"(1200)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1-$2-$3\\\",\\\"120\\\",null],[\\\"(1212)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1-$2-$3\\\",\\\"121\\\",null],[\\\"(1599)(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1-$2\\\",\\\"15\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})\\\",\\\"*$1\\\",\\\"[2-689]\\\",null]]]',\\n  248: '[\\\"SC\\\",\\\"0(?:[02]|10?)\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{6,7}\\\",\\\"[24689]\\\\\\\\\\\\\\\\d{5,6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[246]\\\",null]]]',\\n  297: '[\\\"AW\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}\\\",\\\"[25-9]\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  421: '[\\\"SK\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,9}\\\",\\\"(?:[2-68]\\\\\\\\\\\\\\\\d{5,8}|9\\\\\\\\\\\\\\\\d{6,8})\\\",[[\\\"(2)(1[67])(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"21[67]\\\",null],[\\\"([3-5]\\\\\\\\\\\\\\\\d)(1[67])(\\\\\\\\\\\\\\\\d{2,3})\\\",\\\"$1 $2 $3\\\",\\\"[3-5]\\\",null],[\\\"(2)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1/$2 $3 $4\\\",\\\"2\\\",null],[\\\"([3-5]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1/$2 $3 $4\\\",\\\"[3-5]\\\",null],[\\\"([689]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[689]\\\",null],[\\\"(9090)(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2\\\",\\\"9090\\\",null]]]',\\n  672: '[\\\"NF\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{5,6}\\\",\\\"[13]\\\\\\\\\\\\\\\\d{5}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"1\\\",null],[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"3\\\",null]]]',\\n  870: '[\\\"001\\\",null,null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[35-7]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  883: '[\\\"001\\\",null,null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{9}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"51\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"510\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"510\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"51[13]\\\",null]]]',\\n  264: '[\\\"NA\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{8,9}\\\",\\\"[68]\\\\\\\\\\\\\\\\d{7,8}\\\",[[\\\"(8\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"8[1235]\\\",null],[\\\"(6\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"6\\\",null],[\\\"(88)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"88\\\",null],[\\\"(870)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"870\\\",null]]]',\\n  878: '[\\\"001\\\",null,null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{12}\\\",\\\"1\\\\\\\\\\\\\\\\d{11}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  239: '[\\\"ST\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}\\\",\\\"[29]\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  357: '[\\\"CY\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[257-9]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",null,null]]]',\\n  240: '[\\\"GQ\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[23589]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[235]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"[89]\\\",null]]]',\\n  506: '[\\\"CR\\\",\\\"00\\\",null,\\\"(19(?:0[012468]|1[09]|20|66|77|99))\\\",null,null,\\\"\\\\\\\\\\\\\\\\d{8,10}\\\",\\\"[24-9]\\\\\\\\\\\\\\\\d{7,9}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[24-7]|8[3-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"[89]0\\\",null]]]',\\n  86: '[\\\"CN\\\",\\\"(1(?:[129]\\\\\\\\\\\\\\\\d{3}|79\\\\\\\\\\\\\\\\d{2}))?00\\\",\\\"0\\\",\\\"(1(?:[129]\\\\\\\\\\\\\\\\d{3}|79\\\\\\\\\\\\\\\\d{2}))|0\\\",null,null,\\\"\\\\\\\\\\\\\\\\d{4,12}\\\",\\\"[1-7]\\\\\\\\\\\\\\\\d{6,11}|8[0-357-9]\\\\\\\\\\\\\\\\d{6,9}|9\\\\\\\\\\\\\\\\d{7,10}\\\",[[\\\"(80\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"80[2678]\\\",\\\"$NP$FG\\\"],[\\\"([48]00)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[48]00\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{5,6})\\\",\\\"$1\\\",\\\"100|95\\\",null,\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5,6})\\\",\\\"$1 $2\\\",\\\"(?:10|2\\\\\\\\\\\\\\\\d)[19]\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5,6})\\\",\\\"$1 $2\\\",\\\"[3-9]\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3,4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[2-9]\\\",null,\\\"NA\\\"],[\\\"(21)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4,6})\\\",\\\"$1 $2 $3\\\",\\\"21\\\",\\\"$NP$FG\\\"],[\\\"([12]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"10[1-9]|2[02-9]\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"3(?:1[02-9]|35|49|5|7[02-68]|9[1-68])|4(?:1[02-9]|2[179]|[35][2-9]|6[4789]|7\\\\\\\\\\\\\\\\d|8[23])|5(?:3[03-9]|4[36]|5[02-9]|6[1-46]|7[028]|80|9[2-46-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[04-9]|4[3-6]|6[2368])|8(?:1[236-8]|2[5-7]|3|5[1-9]|7[02-9]|8[3678]|9[1-7])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"3(?:11|7[179])|4(?:[15]1|3[1-35])|5(?:1|2[37]|3[12]|51|7[13-79]|9[15])|7(?:31|5[457]|6[09]|91)|8(?:[57]1|98)\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"807\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1[3-578]\\\",null],[\\\"(10800)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"108\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{7,8})\\\",\\\"$1 $2\\\",\\\"950\\\",null]]]',\\n  257: '[\\\"BI\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[267]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",null,null]]]',\\n  683: '[\\\"NU\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{4}\\\",\\\"[1-5]\\\\\\\\\\\\\\\\d{3}\\\"]',\\n  43: '[\\\"AT\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{3,13}\\\",\\\"[1-9]\\\\\\\\\\\\\\\\d{3,12}\\\",[[\\\"(116\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1\\\",\\\"116\\\",\\\"$FG\\\"],[\\\"(1)(\\\\\\\\\\\\\\\\d{3,12})\\\",\\\"$1 $2\\\",\\\"1\\\",null],[\\\"(5\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3,5})\\\",\\\"$1 $2\\\",\\\"5[079]\\\",null],[\\\"(5\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"5[079]\\\",null],[\\\"(5\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4,7})\\\",\\\"$1 $2 $3\\\",\\\"5[079]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,10})\\\",\\\"$1 $2\\\",\\\"316|46|51|732|6(?:5[0-3579]|[6-9])|7(?:[28]0)|[89]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3,9})\\\",\\\"$1 $2\\\",\\\"2|3(?:1[1-578]|[3-8])|4[2378]|5[2-6]|6(?:[12]|4[1-9]|5[468])|7(?:2[1-8]|35|4[1-8]|[5-79])\\\",null]]]',\\n  247: '[\\\"AC\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{5,6}\\\",\\\"[46]\\\\\\\\\\\\\\\\d{4}|[01589]\\\\\\\\\\\\\\\\d{5}\\\"]',\\n  675: '[\\\"PG\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,8}\\\",\\\"[1-9]\\\\\\\\\\\\\\\\d{6,7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[13-689]|27\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"20|7\\\",null]]]',\\n  376: '[\\\"AD\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{6,9}\\\",\\\"[16]\\\\\\\\\\\\\\\\d{5,8}|[37-9]\\\\\\\\\\\\\\\\d{5}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2\\\",\\\"[137-9]|6[0-8]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"180\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"690\\\",null]]]',\\n  63: '[\\\"PH\\\",\\\"00\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{5,13}\\\",\\\"2\\\\\\\\\\\\\\\\d{5,7}|[3-9]\\\\\\\\\\\\\\\\d{7,9}|1800\\\\\\\\\\\\\\\\d{7,9}\\\",[[\\\"(2)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"2\\\",\\\"($NP$FG)\\\"],[\\\"(2)(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"2\\\",\\\"($NP$FG)\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4,6})\\\",\\\"$1 $2\\\",\\\"3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|5(?:22|44)|642|8(?:62|8[245])\\\",\\\"($NP$FG)\\\"],[\\\"(\\\\\\\\\\\\\\\\d{5})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"346|4(?:27|9[35])|883\\\",\\\"($NP$FG)\\\"],[\\\"([3-8]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[3-8]\\\",\\\"($NP$FG)\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"81|9\\\",\\\"$NP$FG\\\"],[\\\"(1800)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1\\\",null],[\\\"(1800)(\\\\\\\\\\\\\\\\d{1,2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3 $4\\\",\\\"1\\\",null]]]',\\n  236: '[\\\"CF\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[278]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",null,null]]]',\\n  590: [\\n    '[\\\"GP\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[56]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([56]90)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2-$3\\\",null,null]]]',\\n    '[\\\"BL\\\",\\\"00\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[56]\\\\\\\\\\\\\\\\d{8}\\\"]',\\n    '[\\\"MF\\\",\\\"00\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[56]\\\\\\\\\\\\\\\\d{8}\\\"]',\\n  ],\\n  53: '[\\\"CU\\\",\\\"119\\\",\\\"0\\\",null,null,\\\"($NP$FG)\\\",\\\"\\\\\\\\\\\\\\\\d{4,8}\\\",\\\"[2-57]\\\\\\\\\\\\\\\\d{5,7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{6,7})\\\",\\\"$1 $2\\\",\\\"7\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4,6})\\\",\\\"$1 $2\\\",\\\"[2-4]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1 $2\\\",\\\"5\\\",\\\"$NP$FG\\\"]]]',\\n  64: '[\\\"NZ\\\",\\\"0(?:0|161)\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,11}\\\",\\\"6[235-9]\\\\\\\\\\\\\\\\d{6}|[2-57-9]\\\\\\\\\\\\\\\\d{7,10}\\\",[[\\\"([34679])(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2 $3\\\",\\\"[346]|7[2-57-9]|9[1-9]\\\",null],[\\\"(24099)(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2\\\",\\\"240\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"21\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,5})\\\",\\\"$1 $2 $3\\\",\\\"2(?:1[1-9]|[69]|7[0-35-9])|70|86\\\",null],[\\\"(2\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3,4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"2[028]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"2(?:10|74)|5|[89]0\\\",null]]]',\\n  965: '[\\\"KW\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,8}\\\",\\\"[12569]\\\\\\\\\\\\\\\\d{6,7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2\\\",\\\"[16]|2(?:[0-35-9]|4[0-35-9])|9[024-9]|52[25]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"244|5(?:[015]|66)\\\",null]]]',\\n  224: '[\\\"GN\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8,9}\\\",\\\"[367]\\\\\\\\\\\\\\\\d{7,8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"3\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[67]\\\",null]]]',\\n  973: '[\\\"BH\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[136-9]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  32: '[\\\"BE\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{8,9}\\\",\\\"[1-9]\\\\\\\\\\\\\\\\d{7,8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"4[6-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[23]|4[23]|9[2-4]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[156]|7[018]|8(?:0[1-9]|[1-79])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"(?:80|9)0\\\",null]]]',\\n  249: '[\\\"SD\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[19]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  678: '[\\\"VU\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{5,7}\\\",\\\"[2-57-9]\\\\\\\\\\\\\\\\d{4,6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[579]\\\",null]]]',\\n  52: '[\\\"MX\\\",\\\"0[09]\\\",\\\"01\\\",\\\"0[12]|04[45](\\\\\\\\\\\\\\\\d{10})\\\",\\\"1$1\\\",\\\"$NP $FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,11}\\\",\\\"[1-9]\\\\\\\\\\\\\\\\d{9,10}\\\",[[\\\"([358]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"33|55|81\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[2467]|3[0-2457-9]|5[089]|8[02-9]|9[0-35-9]\\\",null],[\\\"(1)([358]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"044 $2 $3 $4\\\",\\\"1(?:33|55|81)\\\",\\\"$FG\\\",\\\"$1 $2 $3 $4\\\"],[\\\"(1)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"044 $2 $3 $4\\\",\\\"1(?:[2467]|3[0-2457-9]|5[089]|8[2-9]|9[1-35-9])\\\",\\\"$FG\\\",\\\"$1 $2 $3 $4\\\"]]]',\\n  968: '[\\\"OM\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"(?:5|[279]\\\\\\\\\\\\\\\\d)\\\\\\\\\\\\\\\\d{6}|800\\\\\\\\\\\\\\\\d{5,6}\\\",[[\\\"(2\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"2\\\",null],[\\\"([79]\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[79]\\\",null],[\\\"([58]00)(\\\\\\\\\\\\\\\\d{4,6})\\\",\\\"$1 $2\\\",\\\"[58]\\\",null]]]',\\n  599: [\\n    '[\\\"CW\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,8}\\\",\\\"[169]\\\\\\\\\\\\\\\\d{6,7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[13-7]\\\",null],[\\\"(9)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"9\\\",null]]]',\\n    '[\\\"BQ\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}\\\",\\\"[347]\\\\\\\\\\\\\\\\d{6}\\\"]',\\n  ],\\n  800: '[\\\"001\\\",null,null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  386: '[\\\"SI\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,8}\\\",\\\"[1-7]\\\\\\\\\\\\\\\\d{6,7}|[89]\\\\\\\\\\\\\\\\d{4,7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[12]|3[24-8]|4[24-8]|5[2-8]|7[3-8]\\\",\\\"($NP$FG)\\\"],[\\\"([3-7]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[37][01]|4[0139]|51|6\\\",null],[\\\"([89][09])(\\\\\\\\\\\\\\\\d{3,6})\\\",\\\"$1 $2\\\",\\\"[89][09]\\\",null],[\\\"([58]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"59|8[1-3]\\\",null]]]',\\n  679: '[\\\"FJ\\\",\\\"0(?:0|52)\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{4})?\\\",\\\"[35-9]\\\\\\\\\\\\\\\\d{6}|0\\\\\\\\\\\\\\\\d{10}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[35-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"0\\\",null]]]',\\n  238: '[\\\"CV\\\",\\\"0\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}\\\",\\\"[259]\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  691: '[\\\"FM\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}\\\",\\\"[39]\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  262: [\\n    '[\\\"RE\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[268]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([268]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",null,null]]]',\\n    '[\\\"YT\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[268]\\\\\\\\\\\\\\\\d{8}\\\"]',\\n  ],\\n  241: '[\\\"GA\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,8}\\\",\\\"0?\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[2-7]\\\",\\\"0$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"0\\\",null]]]',\\n  370: '[\\\"LT\\\",\\\"00\\\",\\\"8\\\",\\\"[08]\\\",null,\\\"($NP-$FG)\\\",\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[3-9]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"([34]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"37|4(?:1|5[45]|6[2-4])\\\",null],[\\\"([3-6]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"3[148]|4(?:[24]|6[09])|528|6\\\",null],[\\\"([7-9]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[7-9]\\\",\\\"$NP $FG\\\"],[\\\"(5)(2\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"52[0-79]\\\",null]]]',\\n  256: '[\\\"UG\\\",\\\"00[057]\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,9}\\\",\\\"\\\\\\\\\\\\\\\\d{9}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"[7-9]|20(?:[013-8]|2[5-9])|4(?:6[45]|[7-9])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1 $2\\\",\\\"3|4(?:[1-5]|6[0-36-9])\\\",null],[\\\"(2024)(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"2024\\\",null]]]',\\n  677: '[\\\"SB\\\",\\\"0[01]\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{5,7}\\\",\\\"[1-9]\\\\\\\\\\\\\\\\d{4,6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"[7-9]\\\",null]]]',\\n  377: '[\\\"MC\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{8,9}\\\",\\\"[34689]\\\\\\\\\\\\\\\\d{7,8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[39]\\\",\\\"$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"4\\\",null],[\\\"(6)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4 $5\\\",\\\"6\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3\\\",\\\"8\\\",\\\"$FG\\\"]]]',\\n  382: '[\\\"ME\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,9}\\\",\\\"[2-9]\\\\\\\\\\\\\\\\d{7,8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[2-57-9]|6[036-9]\\\",null]]]',\\n  231: '[\\\"LR\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"2\\\\\\\\\\\\\\\\d{7,8}|[378]\\\\\\\\\\\\\\\\d{8}|4\\\\\\\\\\\\\\\\d{6}|5\\\\\\\\\\\\\\\\d{6,8}\\\",[[\\\"(2\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"2\\\",null],[\\\"([4-5])(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[45]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[23578]\\\",null]]]',\\n  591: '[\\\"BO\\\",\\\"00(1\\\\\\\\\\\\\\\\d)?\\\",\\\"0\\\",\\\"0(1\\\\\\\\\\\\\\\\d)?\\\",null,null,\\\"\\\\\\\\\\\\\\\\d{7,8}\\\",\\\"[23467]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"([234])(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1 $2\\\",\\\"[234]\\\",null],[\\\"([67]\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1\\\",\\\"[67]\\\",null]]]',\\n  808: '[\\\"001\\\",null,null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  964: '[\\\"IQ\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,10}\\\",\\\"[1-7]\\\\\\\\\\\\\\\\d{7,9}\\\",[[\\\"(1)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1\\\",null],[\\\"([2-6]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"[2-6]\\\",null],[\\\"(7\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"7\\\",null]]]',\\n  225: '[\\\"CI\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[02-8]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",null,null]]]',\\n  992: '[\\\"TJ\\\",\\\"810\\\",\\\"8\\\",null,null,\\\"$FG\\\",\\\"\\\\\\\\\\\\\\\\d{3,9}\\\",\\\"[3-57-9]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([349]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[34]7|91[78]\\\",null],[\\\"([457-9]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"4[148]|[578]|9(?:1[59]|[0235-9])\\\",null],[\\\"(331700)(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3\\\",\\\"331\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"3[1-5]\\\",null]]]',\\n  55: '[\\\"BR\\\",\\\"00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)\\\",\\\"0\\\",\\\"(?:0|90)(?:(1[245]|2[135]|[34]1)(\\\\\\\\\\\\\\\\d{10,11}))?\\\",\\\"$2\\\",null,\\\"\\\\\\\\\\\\\\\\d{8,11}\\\",\\\"[1-46-9]\\\\\\\\\\\\\\\\d{7,10}|5(?:[0-4]\\\\\\\\\\\\\\\\d{7,9}|5(?:[2-8]\\\\\\\\\\\\\\\\d{7}|9\\\\\\\\\\\\\\\\d{7,8}))\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"[2-9](?:[1-9]|0[1-9])\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{5})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"9(?:[1-9]|0[1-9])\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3,5})\\\",\\\"$1\\\",\\\"1[125689]\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2-$3\\\",\\\"[1-9][1-9]\\\",\\\"($FG)\\\"],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2-$3\\\",\\\"(?:[14689][1-9]|2[12478]|3[1-578]|5[1-5]|7[13-579])9\\\",\\\"($FG)\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"(?:300|40(?:0|20))\\\",null],[\\\"([3589]00)(\\\\\\\\\\\\\\\\d{2,3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[3589]00\\\",\\\"$NP$FG\\\"]]]',\\n  674: '[\\\"NR\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}\\\",\\\"[458]\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  967: '[\\\"YE\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,9}\\\",\\\"[1-7]\\\\\\\\\\\\\\\\d{6,8}\\\",[[\\\"([1-7])(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"[1-6]|7[24-68]\\\",null],[\\\"(7\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"7[0137]\\\",null]]]',\\n  49: '[\\\"DE\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{2,15}\\\",\\\"[1-35-9]\\\\\\\\\\\\\\\\d{3,14}|4(?:[0-8]\\\\\\\\\\\\\\\\d{3,12}|9(?:[0-37]\\\\\\\\\\\\\\\\d|4(?:[1-35-8]|4\\\\\\\\\\\\\\\\d?)|5\\\\\\\\\\\\\\\\d{1,2}|6[1-8]\\\\\\\\\\\\\\\\d?)\\\\\\\\\\\\\\\\d{2,8})\\\",[[\\\"(1\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{7,8})\\\",\\\"$1 $2\\\",\\\"1[67]\\\",null],[\\\"(15\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"15[0568]\\\",null],[\\\"(1\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1 $2\\\",\\\"15\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3,11})\\\",\\\"$1 $2\\\",\\\"3[02]|40|[68]9\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,11})\\\",\\\"$1 $2\\\",\\\"2(?:\\\\\\\\\\\\\\\\d1|0[2389]|1[24]|28|34)|3(?:[3-9][15]|40)|[4-8][1-9]1|9(?:06|[1-9]1)\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{2,11})\\\",\\\"$1 $2\\\",\\\"[24-6]|[7-9](?:\\\\\\\\\\\\\\\\d[1-9]|[1-9]\\\\\\\\\\\\\\\\d)|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])\\\",null],[\\\"(3\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{1,10})\\\",\\\"$1 $2\\\",\\\"3\\\",null],[\\\"(800)(\\\\\\\\\\\\\\\\d{7,12})\\\",\\\"$1 $2\\\",\\\"800\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4,10})\\\",\\\"$1 $2 $3\\\",\\\"(?:18|90)0|137\\\",null],[\\\"(1\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5,11})\\\",\\\"$1 $2\\\",\\\"181\\\",null],[\\\"(18\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"185\\\",null],[\\\"(18\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1 $2\\\",\\\"18[68]\\\",null],[\\\"(18\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{8})\\\",\\\"$1 $2\\\",\\\"18[2-579]\\\",null],[\\\"(700)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"700\\\",null],[\\\"(138)(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"138\\\",null],[\\\"(15[013-68])(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{8})\\\",\\\"$1 $2 $3\\\",\\\"15[013-68]\\\",null],[\\\"(15[279]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1 $2 $3\\\",\\\"15[279]\\\",null],[\\\"(1[67]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{7,8})\\\",\\\"$1 $2 $3\\\",\\\"1(?:6[023]|7)\\\",null]]]',\\n  31: '[\\\"NL\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,10}\\\",\\\"1\\\\\\\\\\\\\\\\d{4,8}|[2-7]\\\\\\\\\\\\\\\\d{8}|[89]\\\\\\\\\\\\\\\\d{6,9}\\\",[[\\\"([1-578]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1[035]|2[0346]|3[03568]|4[0356]|5[0358]|7|8[4578]\\\",null],[\\\"([1-5]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"1[16-8]|2[259]|3[124]|4[17-9]|5[124679]\\\",null],[\\\"(6)(\\\\\\\\\\\\\\\\d{8})\\\",\\\"$1 $2\\\",\\\"6[0-57-9]\\\",null],[\\\"(66)(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1 $2\\\",\\\"66\\\",null],[\\\"(14)(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2\\\",\\\"14\\\",\\\"$FG\\\"],[\\\"([89]0\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4,7})\\\",\\\"$1 $2\\\",\\\"80|9\\\",null]]]',\\n  970: '[\\\"PS\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{4,10}\\\",\\\"[24589]\\\\\\\\\\\\\\\\d{7,8}|1(?:[78]\\\\\\\\\\\\\\\\d{8}|[49]\\\\\\\\\\\\\\\\d{2,3})\\\",[[\\\"([2489])(2\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[2489]\\\",null],[\\\"(5[69]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"5\\\",null],[\\\"(1[78]00)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"1[78]\\\",\\\"$FG\\\"]]]',\\n  58: '[\\\"VE\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,10}\\\",\\\"[24589]\\\\\\\\\\\\\\\\d{9}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1-$2\\\",null,null]]]',\\n  856: '[\\\"LA\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,10}\\\",\\\"[2-8]\\\\\\\\\\\\\\\\d{7,9}\\\",[[\\\"(20)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"20\\\",null],[\\\"([2-8]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"2[13]|3[14]|[4-8]\\\",null],[\\\"(30)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"30\\\",null]]]',\\n  354: '[\\\"IS\\\",\\\"1(?:0(?:01|10|20)|100)|00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"[4-9]\\\\\\\\\\\\\\\\d{6}|38\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[4-9]\\\",null],[\\\"(3\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"3\\\",null]]]',\\n  242: '[\\\"CG\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[028]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[02]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"8\\\",null]]]',\\n  423: '[\\\"LI\\\",\\\"00\\\",\\\"0\\\",\\\"0|10(?:01|20|66)\\\",null,null,\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"6\\\\\\\\\\\\\\\\d{8}|[23789]\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3\\\",\\\"[23789]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"6[56]\\\",null],[\\\"(69)(7\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"697\\\",null]]]',\\n  213: '[\\\"DZ\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{8,9}\\\",\\\"(?:[1-4]|[5-9]\\\\\\\\\\\\\\\\d)\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"([1-4]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[1-4]\\\",null],[\\\"([5-8]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[5-8]\\\",null],[\\\"(9\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"9\\\",null]]]',\\n  371: '[\\\"LV\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[2689]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"([2689]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  503: '[\\\"SV\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,8}|\\\\\\\\\\\\\\\\d{11}\\\",\\\"[267]\\\\\\\\\\\\\\\\d{7}|[89]\\\\\\\\\\\\\\\\d{6}(?:\\\\\\\\\\\\\\\\d{4})?\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[267]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[89]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[89]\\\",null]]]',\\n  685: '[\\\"WS\\\",\\\"0\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{5,7}\\\",\\\"[2-8]\\\\\\\\\\\\\\\\d{4,6}\\\",[[\\\"(8\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2\\\",\\\"8\\\",null],[\\\"(7\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"7\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1\\\",\\\"[2-6]\\\",null]]]',\\n  880: '[\\\"BD\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,10}\\\",\\\"[2-79]\\\\\\\\\\\\\\\\d{5,9}|1\\\\\\\\\\\\\\\\d{9}|8[0-7]\\\\\\\\\\\\\\\\d{4,8}\\\",[[\\\"(2)(\\\\\\\\\\\\\\\\d{7,8})\\\",\\\"$1-$2\\\",\\\"2\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4,6})\\\",\\\"$1-$2\\\",\\\"[3-79]1\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3,6})\\\",\\\"$1-$2\\\",\\\"1|3(?:0|[2-58]2)|4(?:0|[25]2|3[23]|[4689][25])|5(?:[02-578]2|6[25])|6(?:[0347-9]2|[26][25])|7[02-9]2|8(?:[023][23]|[4-7]2)|9(?:[02][23]|[458]2|6[016])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,7})\\\",\\\"$1-$2\\\",\\\"[3-79][2-9]|8\\\",null]]]',\\n  265: '[\\\"MW\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"(?:1(?:\\\\\\\\\\\\\\\\d{2})?|[2789]\\\\\\\\\\\\\\\\d{2})\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"1\\\",null],[\\\"(2\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"2\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[1789]\\\",null]]]',\\n  65: '[\\\"SG\\\",\\\"0[0-3]\\\\\\\\\\\\\\\\d\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8,11}\\\",\\\"[36]\\\\\\\\\\\\\\\\d{7}|[17-9]\\\\\\\\\\\\\\\\d{7,10}\\\",[[\\\"([3689]\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[369]|8[1-9]\\\",null],[\\\"(1[89]00)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1[89]\\\",null],[\\\"(7000)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"70\\\",null],[\\\"(800)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"80\\\",null]]]',\\n  504: '[\\\"HN\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[237-9]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",null,null]]]',\\n  688: '[\\\"TV\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{5,7}\\\",\\\"[279]\\\\\\\\\\\\\\\\d{4,6}\\\"]',\\n  84: '[\\\"VN\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,10}\\\",\\\"[167]\\\\\\\\\\\\\\\\d{6,9}|[2-59]\\\\\\\\\\\\\\\\d{7,9}|8\\\\\\\\\\\\\\\\d{6,8}\\\",[[\\\"([17]99)(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[17]99\\\",null],[\\\"([48])(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"4|8(?:[1-57]|6[0-79]|9[0-7])\\\",null],[\\\"([235-7]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"2[025-79]|3[0136-9]|5[2-9]|6[0-46-8]|7[02-79]\\\",null],[\\\"(80)(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"80\\\",null],[\\\"(69\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4,5})\\\",\\\"$1 $2\\\",\\\"69\\\",null],[\\\"([235-7]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"2[0-489]|3[25]|5[01]|65|7[18]\\\",null],[\\\"([89]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"8(?:68|8|9[89])|9\\\",null],[\\\"(1[2689]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1(?:[26]|8[68]|99)\\\",null],[\\\"(1[89]00)(\\\\\\\\\\\\\\\\d{4,6})\\\",\\\"$1 $2\\\",\\\"1[89]0\\\",\\\"$FG\\\"]]]',\\n  255: '[\\\"TZ\\\",\\\"00[056]\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"\\\\\\\\\\\\\\\\d{9}\\\",[[\\\"([24]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[24]\\\",null],[\\\"([67]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[67]\\\",null],[\\\"([89]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[89]\\\",null]]]',\\n  222: '[\\\"MR\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[2-48]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"([2-48]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",null,null]]]',\\n  230: '[\\\"MU\\\",\\\"0(?:0|[2-7]0|33)\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,8}\\\",\\\"[2-9]\\\\\\\\\\\\\\\\d{6,7}\\\",[[\\\"([2-46-9]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[2-46-9]\\\",null],[\\\"(5\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"5\\\",null]]]',\\n  592: '[\\\"GY\\\",\\\"001\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}\\\",\\\"[2-46-9]\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  41: '[\\\"CH\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{9}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[2-9]\\\\\\\\\\\\\\\\d{8}|860\\\\\\\\\\\\\\\\d{9}\\\",[[\\\"([2-9]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[2-7]|[89]1\\\",null],[\\\"([89]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"8[047]|90\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4 $5\\\",\\\"860\\\",null]]]',\\n  39: [\\n    '[\\\"IT\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{6,11}\\\",\\\"[01589]\\\\\\\\\\\\\\\\d{5,10}|3(?:[12457-9]\\\\\\\\\\\\\\\\d{8}|[36]\\\\\\\\\\\\\\\\d{7,9})\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3,4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"0[26]|55\\\",null],[\\\"(0[26])(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2 $3\\\",\\\"0[26]\\\",null],[\\\"(0[26])(\\\\\\\\\\\\\\\\d{4,6})\\\",\\\"$1 $2\\\",\\\"0[26]\\\",null],[\\\"(0\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3,4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"0[13-57-9][0159]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,6})\\\",\\\"$1 $2\\\",\\\"0[13-57-9][0159]|8(?:03|4[17]|9[245])\\\",null],[\\\"(0\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"0[13-57-9][2-46-8]\\\",null],[\\\"(0\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2,6})\\\",\\\"$1 $2\\\",\\\"0[13-57-9][2-46-8]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"[13]|8(?:00|4[08]|9[59])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"894\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"3\\\",null]]]',\\n    '[\\\"VA\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{6,11}\\\",\\\"(?:0(?:878\\\\\\\\\\\\\\\\d{5}|6698\\\\\\\\\\\\\\\\d{5})|[1589]\\\\\\\\\\\\\\\\d{5,10}|3(?:[12457-9]\\\\\\\\\\\\\\\\d{8}|[36]\\\\\\\\\\\\\\\\d{7,9}))\\\"]',\\n  ],\\n  993: '[\\\"TM\\\",\\\"810\\\",\\\"8\\\",null,null,\\\"($NP $FG)\\\",\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[1-6]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2-$3-$4\\\",\\\"12\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"6\\\",\\\"$NP $FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2-$3-$4\\\",\\\"13|[2-5]\\\",null]]]',\\n  888: '[\\\"001\\\",null,null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{11}\\\",\\\"\\\\\\\\\\\\\\\\d{11}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  353: '[\\\"IE\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"($NP$FG)\\\",\\\"\\\\\\\\\\\\\\\\d{5,10}\\\",\\\"[124-9]\\\\\\\\\\\\\\\\d{6,9}\\\",[[\\\"(1)(\\\\\\\\\\\\\\\\d{3,4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"2[24-9]|47|58|6[237-9]|9[35-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"40[24]|50[45]\\\",null],[\\\"(48)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"48\\\",null],[\\\"(818)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"81\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"[24-69]|7[14]\\\",null],[\\\"([78]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3,4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"76|8[35-9]\\\",\\\"$NP$FG\\\"],[\\\"(700)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"70\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"1(?:8[059]|5)\\\",\\\"$FG\\\"]]]',\\n  966: '[\\\"SA\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,10}\\\",\\\"1\\\\\\\\\\\\\\\\d{7,8}|(?:[2-467]|92)\\\\\\\\\\\\\\\\d{7}|5\\\\\\\\\\\\\\\\d{8}|8\\\\\\\\\\\\\\\\d{9}\\\",[[\\\"([1-467])(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[1-467]\\\",null],[\\\"(1\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1[1-467]\\\",null],[\\\"(5\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"5\\\",null],[\\\"(92\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"92\\\",\\\"$FG\\\"],[\\\"(800)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"80\\\",\\\"$FG\\\"],[\\\"(811)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"81\\\",null]]]',\\n  380: '[\\\"UA\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,9}\\\",\\\"[3-9]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([3-9]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[38]9|4(?:[45][0-5]|87)|5(?:0|6[37]|7[37])|6[36-8]|7|9[1-9]\\\",null],[\\\"([3-689]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"3[1-8]2|4[13678]2|5(?:[12457]2|6[24])|6(?:[49]2|[12][29]|5[24])|8[0-8]|90\\\",null],[\\\"([3-6]\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"3(?:5[013-9]|[1-46-8])|4(?:[137][013-9]|6|[45][6-9]|8[4-6])|5(?:[1245][013-9]|6[0135-9]|3|7[4-6])|6(?:[49][013-9]|5[0135-9]|[12][13-8])\\\",null]]]',\\n  98: '[\\\"IR\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{4,10}\\\",\\\"[1-8]\\\\\\\\\\\\\\\\d{9}|9(?:[0-4]\\\\\\\\\\\\\\\\d{8}|9\\\\\\\\\\\\\\\\d{2,8})\\\",[[\\\"(21)(\\\\\\\\\\\\\\\\d{3,5})\\\",\\\"$1 $2\\\",\\\"21\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[1-8]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2\\\",\\\"9\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2,3})\\\",\\\"$1 $2 $3\\\",\\\"9\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"9\\\",null]]]',\\n  971: '[\\\"AE\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,12}\\\",\\\"[2-79]\\\\\\\\\\\\\\\\d{7,8}|800\\\\\\\\\\\\\\\\d{2,9}\\\",[[\\\"([2-4679])(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[2-4679][2-8]\\\",null],[\\\"(5\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"5\\\",null],[\\\"([479]00)(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2 $3\\\",\\\"[479]0\\\",\\\"$FG\\\"],[\\\"([68]00)(\\\\\\\\\\\\\\\\d{2,9})\\\",\\\"$1 $2\\\",\\\"60|8\\\",\\\"$FG\\\"]]]',\\n  30: '[\\\"GR\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{10}\\\",\\\"[26-9]\\\\\\\\\\\\\\\\d{9}\\\",[[\\\"([27]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"21|7\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"2[2-9]1|[689]\\\",null],[\\\"(2\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"2[2-9][02-9]\\\",null]]]',\\n  228: '[\\\"TG\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[29]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[29]\\\",null]]]',\\n  48: '[\\\"PL\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{6,9}\\\",\\\"[12]\\\\\\\\\\\\\\\\d{6,8}|[3-57-9]\\\\\\\\\\\\\\\\d{8}|6\\\\\\\\\\\\\\\\d{5,8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[14]|2[0-57-9]|3[2-4]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{1})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[12]2\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"26|39|5[0137]|6[0469]|7[02389]|8[08]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2,3})\\\",\\\"$1 $2 $3\\\",\\\"64\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2\\\",\\\"64\\\",null]]]',\\n  886: '[\\\"TW\\\",\\\"0(?:0[25679]|19)\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,10}\\\",\\\"2\\\\\\\\\\\\\\\\d{6,8}|[3-689]\\\\\\\\\\\\\\\\d{7,8}|7\\\\\\\\\\\\\\\\d{7,9}\\\",[[\\\"(20)(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"202\\\",null],[\\\"(20)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"20[013-9]\\\",null],[\\\"([2-8])(\\\\\\\\\\\\\\\\d{3,4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"2[23-8]|[3-6]|[78][1-9]\\\",null],[\\\"([89]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"80|9\\\",null],[\\\"(70)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"70\\\",null]]]',\\n  212: [\\n    '[\\\"MA\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[5-9]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([5-7]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1-$2\\\",\\\"5(?:2[015-7]|3[0-4])|[67]\\\",null],[\\\"([58]\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1-$2\\\",\\\"5(?:2[2-489]|3[5-9]|92)|892\\\",null],[\\\"(5\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"5(?:29|38)\\\",null],[\\\"([5]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"5(?:4[067]|5[03])\\\",null],[\\\"(8[09])(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1-$2\\\",\\\"8(?:0|9[013-9])\\\",null]]]',\\n    '[\\\"EH\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[5-9]\\\\\\\\\\\\\\\\d{8}\\\"]',\\n  ],\\n  372: '[\\\"EE\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{4,10}\\\",\\\"1\\\\\\\\\\\\\\\\d{3,4}|[3-9]\\\\\\\\\\\\\\\\d{6,7}|800\\\\\\\\\\\\\\\\d{6,7}\\\",[[\\\"([3-79]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]\\\",null],[\\\"(70)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"70\\\",null],[\\\"(8000)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"800\\\",null],[\\\"([458]\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2\\\",\\\"40|5|8(?:00|[1-5])\\\",null]]]',\\n  598: '[\\\"UY\\\",\\\"0(?:1[3-9]\\\\\\\\\\\\\\\\d|0)\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,8}\\\",\\\"[2489]\\\\\\\\\\\\\\\\d{6,7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[24]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"9[1-9]\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[89]0\\\",\\\"$NP$FG\\\"]]]',\\n  502: '[\\\"GT\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[2-7]\\\\\\\\\\\\\\\\d{7}|1[89]\\\\\\\\\\\\\\\\d{9}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[2-7]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1\\\",null]]]',\\n  82: '[\\\"KR\\\",\\\"00(?:[124-68]|3\\\\\\\\\\\\\\\\d{2}|7(?:[0-8]\\\\\\\\\\\\\\\\d|9[0-79]))\\\",\\\"0\\\",\\\"0(8[1-46-8]|85\\\\\\\\\\\\\\\\d{2})?\\\",null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{3,14}\\\",\\\"007\\\\\\\\\\\\\\\\d{9,11}|[1-7]\\\\\\\\\\\\\\\\d{3,9}|8\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{5})(\\\\\\\\\\\\\\\\d{3,4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"00798\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{5})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3 $4\\\",\\\"00798\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"1(?:0|1[19]|[69]9|5[458])|[57]0\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3,4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"1(?:[01]|5[1-4]|6[2-8]|[7-9])|[68]0|[3-6][1-9][1-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"131\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"131\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"13[2-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3-$4\\\",\\\"30\\\",null],[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3,4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"2[1-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1-$2\\\",\\\"21[0-46-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1-$2\\\",\\\"[3-6][1-9]1\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"1(?:5[246-9]|6[04678]|8[03579])\\\",\\\"$FG\\\"]]]',\\n  253: '[\\\"DJ\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[27]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",null,null]]]',\\n  91: '[\\\"IN\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,13}\\\",\\\"008\\\\\\\\\\\\\\\\d{9}|1\\\\\\\\\\\\\\\\d{7,12}|[2-9]\\\\\\\\\\\\\\\\d{9,10}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{5})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"600|7(?:[02-8]|19|9[037-9])|8(?:0[015-9]|[1-9]|20)|9\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"11|2[02]|33|4[04]|79[1-9]|80[2-46]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1(?:2[0-249]|3[0-25]|4[145]|[59][14]|7[1257]|[68][1-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|[36][25]|22|4[28]|5[12]|[78]1|9[15])|6(?:12|[2-4]1|5[17]|6[13]|7[14]|80)|7(?:12|2[14]|3[134]|4[47]|5[15]|[67]1|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"1(?:[23579]|[468][1-9])|[2-8]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"008\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"140\\\",\\\"$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"160\\\",\\\"$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4,5})\\\",\\\"$1 $2\\\",\\\"180\\\",\\\"$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{2,4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"180\\\",\\\"$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3,4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"186\\\",\\\"$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"18[06]\\\",\\\"$FG\\\"]]]',\\n  389: '[\\\"MK\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,8}\\\",\\\"[2-578]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(2)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"2\\\",null],[\\\"([347]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[347]\\\",null],[\\\"([58]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[58]\\\",null]]]',\\n  1: [\\n    '[\\\"US\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[2-9]\\\\\\\\\\\\\\\\d{9}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",null,null,\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"($1) $2-$3\\\",null,null,\\\"$1-$2-$3\\\"]]]',\\n    '[\\\"AI\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[2589]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"AS\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[5689]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"BB\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[2589]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"BM\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[4589]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"BS\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[2589]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"CA\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[2-9]\\\\\\\\\\\\\\\\d{9}|3\\\\\\\\\\\\\\\\d{6}\\\"]',\\n    '[\\\"DM\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[57-9]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"DO\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[589]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"GD\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[4589]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"GU\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[5689]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"JM\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[589]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"KN\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[589]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"KY\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[3589]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"LC\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[5789]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"MP\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[5689]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"MS\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[5689]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"PR\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[5789]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"SX\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[5789]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"TC\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[5689]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"TT\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[589]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"AG\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[2589]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"VC\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[5789]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"VG\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[2589]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n    '[\\\"VI\\\",\\\"011\\\",\\\"1\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"[3589]\\\\\\\\\\\\\\\\d{9}\\\"]',\\n  ],\\n  60: '[\\\"MY\\\",\\\"00\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{6,10}\\\",\\\"[13-9]\\\\\\\\\\\\\\\\d{7,9}\\\",[[\\\"([4-79])(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2 $3\\\",\\\"[4-79]\\\",\\\"$NP$FG\\\"],[\\\"(3)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2 $3\\\",\\\"3\\\",\\\"$NP$FG\\\"],[\\\"([18]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1-$2 $3\\\",\\\"1[02-46-9][1-9]|8\\\",\\\"$NP$FG\\\"],[\\\"(1)([36-8]00)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3-$4\\\",\\\"1[36-8]0\\\",null],[\\\"(11)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2 $3\\\",\\\"11\\\",\\\"$NP$FG\\\"],[\\\"(15[49])(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2 $3\\\",\\\"15\\\",\\\"$NP$FG\\\"]]]',\\n  355: '[\\\"AL\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,9}\\\",\\\"[2-57]\\\\\\\\\\\\\\\\d{7}|6\\\\\\\\\\\\\\\\d{8}|8\\\\\\\\\\\\\\\\d{5,7}|9\\\\\\\\\\\\\\\\d{5}\\\",[[\\\"(4)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"4[0-6]\\\",null],[\\\"(6\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"6\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[2358][2-5]|4[7-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,5})\\\",\\\"$1 $2\\\",\\\"[235][16-9]|8[016-9]|[79]\\\",null]]]',\\n  254: '[\\\"KE\\\",\\\"000\\\",\\\"0\\\",\\\"005|0\\\",null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,10}\\\",\\\"20\\\\\\\\\\\\\\\\d{6,7}|[4-9]\\\\\\\\\\\\\\\\d{6,9}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5,7})\\\",\\\"$1 $2\\\",\\\"[24-6]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"7\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"[89]\\\",null]]]',\\n  223: '[\\\"ML\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[246-9]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[246-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1\\\",\\\"67|74\\\",null,\\\"NA\\\"]]]',\\n  686: '[\\\"KI\\\",\\\"00\\\",null,\\\"0\\\",null,null,\\\"\\\\\\\\\\\\\\\\d{5,8}\\\",\\\"[2458]\\\\\\\\\\\\\\\\d{4}|3\\\\\\\\\\\\\\\\d{4,7}|7\\\\\\\\\\\\\\\\d{7}\\\"]',\\n  994: '[\\\"AZ\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"($NP$FG)\\\",\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"[1-9]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"(?:1[28]|2(?:[45]2|[0-36])|365)\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[4-8]\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"9\\\",\\\"$NP$FG\\\"]]]',\\n  979: '[\\\"001\\\",null,null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"\\\\\\\\\\\\\\\\d{9}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  66: '[\\\"TH\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{4}|\\\\\\\\\\\\\\\\d{8,10}\\\",\\\"[2-9]\\\\\\\\\\\\\\\\d{7,8}|1\\\\\\\\\\\\\\\\d{3}(?:\\\\\\\\\\\\\\\\d{5,6})?\\\",[[\\\"(2)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"2\\\",null],[\\\"([13-9]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"14|[3-9]\\\",null],[\\\"(1[89]00)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"1\\\",\\\"$FG\\\"]]]',\\n  233: '[\\\"GH\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"[235]\\\\\\\\\\\\\\\\d{8}|8\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[235]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"8\\\",null]]]',\\n  593: '[\\\"EC\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"($NP$FG)\\\",\\\"\\\\\\\\\\\\\\\\d{7,11}\\\",\\\"1\\\\\\\\\\\\\\\\d{9,10}|[2-8]\\\\\\\\\\\\\\\\d{7}|9\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2-$3\\\",\\\"[247]|[356][2-8]\\\",null,\\\"$1-$2-$3\\\"],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"9\\\",\\\"$NP$FG\\\"],[\\\"(1800)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"1\\\",\\\"$FG\\\"]]]',\\n  509: '[\\\"HT\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[2-489]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  54: '[\\\"AR\\\",\\\"00\\\",\\\"0\\\",\\\"0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\\\\\\\\\\\\\\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))?15)?\\\",\\\"9$1\\\",\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,11}\\\",\\\"11\\\\\\\\\\\\\\\\d{8}|[2368]\\\\\\\\\\\\\\\\d{9}|9\\\\\\\\\\\\\\\\d{10}\\\",[[\\\"([68]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2-$3\\\",\\\"[68]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"[2-9]\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"[2-9]\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"[2-9]\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"(9)(11)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$2 15-$3-$4\\\",\\\"911\\\",null,\\\"$1 $2 $3-$4\\\"],[\\\"(9)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$2 15-$3-$4\\\",\\\"9(?:2[234689]|3[3-8])\\\",null,\\\"$1 $2 $3-$4\\\"],[\\\"(9)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$2 15-$3-$4\\\",\\\"9[23]\\\",null,\\\"$1 $2 $3-$4\\\"],[\\\"(11)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2-$3\\\",\\\"1\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2-$3\\\",\\\"2(?:2[013]|3[067]|49|6[01346]|80|9[147-9])|3(?:36|4[1-358]|5[138]|6[24]|7[069]|8[013578])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2-$3\\\",\\\"[23]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1\\\",\\\"1[012]|911\\\",\\\"$FG\\\",\\\"NA\\\"]]]',\\n  57: '[\\\"CO\\\",\\\"00(?:4(?:[14]4|56)|[579])\\\",\\\"0\\\",\\\"0([3579]|4(?:44|56))?\\\",null,null,\\\"\\\\\\\\\\\\\\\\d{7,11}\\\",\\\"(?:[13]\\\\\\\\\\\\\\\\d{0,3}|[24-8])\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1 $2\\\",\\\"1(?:8[2-9]|9[0-3]|[2-7])|[24-8]\\\",\\\"($FG)\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1 $2\\\",\\\"3\\\",null],[\\\"(1)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1-$2-$3\\\",\\\"1(?:80|9[04])\\\",\\\"$NP$FG\\\",\\\"$1 $2 $3\\\"]]]',\\n  597: '[\\\"SR\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{6,7}\\\",\\\"[2-8]\\\\\\\\\\\\\\\\d{5,6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1-$2\\\",\\\"[2-4]|5[2-58]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1-$2-$3\\\",\\\"56\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"[6-8]\\\",null]]]',\\n  676: '[\\\"TO\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{5,7}\\\",\\\"[02-8]\\\\\\\\\\\\\\\\d{4,6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1-$2\\\",\\\"[1-6]|7[0-4]|8[05]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"7[5-9]|8[47-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2\\\",\\\"0\\\",null]]]',\\n  505: '[\\\"NI\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[12578]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  850: '[\\\"KP\\\",\\\"00|99\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,8}|\\\\\\\\\\\\\\\\d{10}\\\",\\\"1\\\\\\\\\\\\\\\\d{9}|[28]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1\\\",null],[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"2\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"8\\\",null]]]',\\n  7: [\\n    '[\\\"RU\\\",\\\"810\\\",\\\"8\\\",null,null,\\\"$NP ($FG)\\\",\\\"\\\\\\\\\\\\\\\\d{10}\\\",\\\"[3489]\\\\\\\\\\\\\\\\d{9}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1-$2-$3\\\",\\\"[1-79]\\\",\\\"$FG\\\",\\\"NA\\\"],[\\\"([3489]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2-$3-$4\\\",\\\"[34689]\\\",null],[\\\"(7\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"7\\\",null]]]',\\n    '[\\\"KZ\\\",\\\"810\\\",\\\"8\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{10}\\\",\\\"(?:33\\\\\\\\\\\\\\\\d|7\\\\\\\\\\\\\\\\d{2}|80[09])\\\\\\\\\\\\\\\\d{7}\\\"]',\\n  ],\\n  268: '[\\\"SZ\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[027]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[027]\\\",null]]]',\\n  501: '[\\\"BZ\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}(?:\\\\\\\\\\\\\\\\d{4})?\\\",\\\"[2-8]\\\\\\\\\\\\\\\\d{6}|0\\\\\\\\\\\\\\\\d{10}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"[2-8]\\\",null],[\\\"(0)(800)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1-$2-$3-$4\\\",\\\"0\\\",null]]]',\\n  252: '[\\\"SO\\\",\\\"00\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{6,9}\\\",\\\"[1-9]\\\\\\\\\\\\\\\\d{5,8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1\\\",\\\"[134]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"2[0-79]|[13-5]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1 $2\\\",\\\"24|[67]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"8[125]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5,7})\\\",\\\"$1 $2\\\",\\\"15|28|6[1-35-9]|799|9[2-9]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"3[59]|4[89]|6[24-6]|79|8[08]|90\\\",null]]]',\\n  229: '[\\\"BJ\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{4,8}\\\",\\\"[2689]\\\\\\\\\\\\\\\\d{7}|7\\\\\\\\\\\\\\\\d{3}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",null,null]]]',\\n  680: '[\\\"PW\\\",\\\"01[12]\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}\\\",\\\"[2-8]\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  263: '[\\\"ZW\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{3,10}\\\",\\\"2(?:[012457-9]\\\\\\\\\\\\\\\\d{3,8}|6(?:[14]\\\\\\\\\\\\\\\\d{7}|\\\\\\\\\\\\\\\\d{4}))|[13-79]\\\\\\\\\\\\\\\\d{4,9}|8[06]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([49])(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2,4})\\\",\\\"$1 $2 $3\\\",\\\"4|9[2-9]\\\",null],[\\\"(7\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"7\\\",null],[\\\"(86\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"86[24]\\\",null],[\\\"([2356]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3,5})\\\",\\\"$1 $2\\\",\\\"2(?:0[45]|2[278]|[49]8|[78])|3(?:08|17|3[78]|7[1569]|8[37]|98)|5[15][78]|6(?:[29]8|[38]7|6[78]|75|[89]8)\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"2(?:1[39]|2[0157]|6[14]|7[35]|84)|329\\\",null],[\\\"([1-356]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3,5})\\\",\\\"$1 $2\\\",\\\"1[3-9]|2[0569]|3[0-69]|5[05689]|6[0-46-9]\\\",null],[\\\"([235]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"[23]9|54\\\",null],[\\\"([25]\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,5})\\\",\\\"$1 $2\\\",\\\"(?:25|54)8\\\",null],[\\\"(8\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"86\\\",null],[\\\"(80\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"80\\\",null]]]',\\n  90: '[\\\"TR\\\",\\\"00\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,10}\\\",\\\"[2-589]\\\\\\\\\\\\\\\\d{9}|444\\\\\\\\\\\\\\\\d{4}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[23]|4(?:[0-35-9]|4[0-35-9])\\\",\\\"($NP$FG)\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"5[02-69]\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"51|[89]\\\",\\\"$NP$FG\\\"],[\\\"(444)(\\\\\\\\\\\\\\\\d{1})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"444\\\",null]]]',\\n  352: '[\\\"LU\\\",\\\"00\\\",null,\\\"(15(?:0[06]|1[12]|35|4[04]|55|6[26]|77|88|99)\\\\\\\\\\\\\\\\d)\\\",null,null,\\\"\\\\\\\\\\\\\\\\d{4,11}\\\",\\\"[24-9]\\\\\\\\\\\\\\\\d{3,10}|3(?:[0-46-9]\\\\\\\\\\\\\\\\d{2,9}|5[013-9]\\\\\\\\\\\\\\\\d{1,8})\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2\\\",\\\"[2-5]|7[1-9]|[89](?:[1-9]|0[2-9])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3\\\",\\\"[2-5]|7[1-9]|[89](?:[1-9]|0[2-9])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"20\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{1,2})\\\",\\\"$1 $2 $3 $4\\\",\\\"2(?:[0367]|4[3-8])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"20\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{1,2})\\\",\\\"$1 $2 $3 $4 $5\\\",\\\"2(?:[0367]|4[3-8])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{1,4})\\\",\\\"$1 $2 $3 $4\\\",\\\"2(?:[12589]|4[12])|[3-5]|7[1-9]|8(?:[1-9]|0[2-9])|9(?:[1-9]|0[2-46-9])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"70|80[01]|90[015]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"6\\\",null]]]',\\n  47: [\\n    '[\\\"NO\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{5}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"0\\\\\\\\\\\\\\\\d{4}|[2-9]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"([489]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[489]\\\",null],[\\\"([235-7]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[235-7]\\\",null]]]',\\n    '[\\\"SJ\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{5}(?:\\\\\\\\\\\\\\\\d{3})?\\\",\\\"0\\\\\\\\\\\\\\\\d{4}|[45789]\\\\\\\\\\\\\\\\d{7}\\\"]',\\n  ],\\n  243: '[\\\"CD\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"[2-6]\\\\\\\\\\\\\\\\d{6}|[18]\\\\\\\\\\\\\\\\d{6,8}|9\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"12\\\",null],[\\\"([89]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"8[0-2459]|9\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"88\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"[1-6]\\\",null]]]',\\n  220: '[\\\"GM\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}\\\",\\\"[2-9]\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  687: '[\\\"NC\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{6}\\\",\\\"[2-57-9]\\\\\\\\\\\\\\\\d{5}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1.$2.$3\\\",\\\"[2-46-9]|5[0-4]\\\",null]]]',\\n  995: '[\\\"GE\\\",\\\"00\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{6,9}\\\",\\\"[34578]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[348]\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"7\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"5\\\",\\\"$FG\\\"]]]',\\n  961: '[\\\"LB\\\",\\\"00\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,8}\\\",\\\"[13-9]\\\\\\\\\\\\\\\\d{6,7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[13-6]|7(?:[2-57]|62|8[0-7]|9[04-9])|8[02-9]|9\\\",\\\"$NP$FG\\\"],[\\\"([7-9]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[89][01]|7(?:[01]|6[013-9]|8[89]|9[1-3])\\\",null]]]',\\n  40: '[\\\"RO\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,9}\\\",\\\"[23]\\\\\\\\\\\\\\\\d{5,8}|[7-9]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[23]1\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[23]1\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[23][3-7]|[7-9]\\\",null],[\\\"(2\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2\\\",\\\"2[3-6]\\\",null]]]',\\n  232: '[\\\"SL\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"($NP$FG)\\\",\\\"\\\\\\\\\\\\\\\\d{6,8}\\\",\\\"[2-9]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",null,null]]]',\\n  594: '[\\\"GF\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[56]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",null,null]]]',\\n  976: '[\\\"MN\\\",\\\"001\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,10}\\\",\\\"[12]\\\\\\\\\\\\\\\\d{7,9}|[57-9]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"([12]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[12]1\\\",null],[\\\"([12]2\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{5,6})\\\",\\\"$1 $2\\\",\\\"[12]2[1-3]\\\",null],[\\\"([12]\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"[12](?:27|[3-5])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"[57-9]\\\",\\\"$FG\\\"],[\\\"([12]\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4,5})\\\",\\\"$1 $2\\\",\\\"[12](?:27|[3-5])\\\",null]]]',\\n  20: '[\\\"EG\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,10}\\\",\\\"1\\\\\\\\\\\\\\\\d{4,9}|[2456]\\\\\\\\\\\\\\\\d{8}|3\\\\\\\\\\\\\\\\d{7}|[89]\\\\\\\\\\\\\\\\d{8,9}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{7,8})\\\",\\\"$1 $2\\\",\\\"[23]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1[012]|[89]00\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{6,7})\\\",\\\"$1 $2\\\",\\\"1[35]|[4-6]|[89][2-9]\\\",null]]]',\\n  689: '[\\\"PF\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{6}(?:\\\\\\\\\\\\\\\\d{2})?\\\",\\\"4\\\\\\\\\\\\\\\\d{5,7}|8\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"4[09]|8[79]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3\\\",\\\"44\\\",null]]]',\\n  56: '[\\\"CL\\\",\\\"(?:0|1(?:1[0-69]|2[0-57]|5[13-58]|69|7[0167]|8[018]))0\\\",\\\"0\\\",\\\"0|(1(?:1[0-69]|2[0-57]|5[13-58]|69|7[0167]|8[018]))\\\",null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,11}\\\",\\\"(?:[2-9]|600|123)\\\\\\\\\\\\\\\\d{7,8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"2[23]\\\",\\\"($FG)\\\"],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[357]|4[1-35]|6[13-57]\\\",\\\"($FG)\\\"],[\\\"(9)(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"9\\\",null],[\\\"(44)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"44\\\",null],[\\\"([68]00)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"60|8\\\",\\\"$FG\\\"],[\\\"(600)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"60\\\",\\\"$FG\\\"],[\\\"(1230)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1\\\",\\\"$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{5})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"219\\\",\\\"($FG)\\\"],[\\\"(\\\\\\\\\\\\\\\\d{4,5})\\\",\\\"$1\\\",\\\"[1-9]\\\",\\\"$FG\\\",\\\"NA\\\"]]]',\\n  596: '[\\\"MQ\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[56]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",null,null]]]',\\n  508: '[\\\"PM\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6}\\\",\\\"[45]\\\\\\\\\\\\\\\\d{5}\\\",[[\\\"([45]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  269: '[\\\"KM\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7}\\\",\\\"[3478]\\\\\\\\\\\\\\\\d{6}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  358: [\\n    '[\\\"FI\\\",\\\"00|99(?:[02469]|5(?:11|33|5[59]|88|9[09]))\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,12}\\\",\\\"1\\\\\\\\\\\\\\\\d{4,11}|[2-9]\\\\\\\\\\\\\\\\d{4,10}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,7})\\\",\\\"$1 $2\\\",\\\"(?:[1-3]00|[6-8]0)\\\",null],[\\\"(116\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1\\\",\\\"116\\\",\\\"$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4,10})\\\",\\\"$1 $2\\\",\\\"[14]|2[09]|50|7[135]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{4,11})\\\",\\\"$1 $2\\\",\\\"[25689][1-8]|3\\\",null]]]',\\n    '[\\\"AX\\\",\\\"00|99(?:[02469]|5(?:11|33|5[59]|88|9[09]))\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,12}\\\",\\\"1\\\\\\\\\\\\\\\\d{5,11}|[35]\\\\\\\\\\\\\\\\d{5,9}|[27]\\\\\\\\\\\\\\\\d{4,9}|4\\\\\\\\\\\\\\\\d{5,10}|6\\\\\\\\\\\\\\\\d{7,9}|8\\\\\\\\\\\\\\\\d{6,9}\\\"]',\\n  ],\\n  251: '[\\\"ET\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"[1-59]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([1-59]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  681: '[\\\"WF\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{6}\\\",\\\"[4-8]\\\\\\\\\\\\\\\\d{5}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  853: '[\\\"MO\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[268]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"([268]\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",null,null]]]',\\n  44: [\\n    '[\\\"GB\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{4,10}\\\",\\\"\\\\\\\\\\\\\\\\d{7,10}\\\",[[\\\"(7\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"7(?:[1-5789]|62)\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"2|5[56]|7[06]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1(?:1|\\\\\\\\\\\\\\\\d1)|3|9[018]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{5})(\\\\\\\\\\\\\\\\d{4,5})\\\",\\\"$1 $2\\\",\\\"1(?:38|5[23]|69|76|94)\\\",null],[\\\"(1\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{5,6})\\\",\\\"$1 $2\\\",\\\"1\\\",null],[\\\"(800)(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2\\\",\\\"800\\\",null],[\\\"(845)(46)(4\\\\\\\\\\\\\\\\d)\\\",\\\"$1 $2 $3\\\",\\\"845\\\",null],[\\\"(8\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"8(?:4[2-5]|7[0-3])\\\",null],[\\\"(80\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"80\\\",null],[\\\"([58]00)(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"[58]00\\\",null]]]',\\n    '[\\\"GG\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,10}\\\",\\\"[135789]\\\\\\\\\\\\\\\\d{6,9}\\\"]',\\n    '[\\\"IM\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,10}\\\",\\\"[135789]\\\\\\\\\\\\\\\\d{6,9}\\\"]',\\n    '[\\\"JE\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,10}\\\",\\\"[135789]\\\\\\\\\\\\\\\\d{6,9}\\\"]',\\n  ],\\n  244: '[\\\"AO\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[29]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",null,null]]]',\\n  211: '[\\\"SS\\\",\\\"00\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[19]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",null,\\\"$NP$FG\\\"]]]',\\n  373: '[\\\"MD\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[235-9]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"22|3\\\",null],[\\\"([25-7]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"2[13-9]|[5-7]\\\",null],[\\\"([89]\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"[89]\\\",null]]]',\\n  996: '[\\\"KG\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{5,10}\\\",\\\"[235-8]\\\\\\\\\\\\\\\\d{8,9}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[25-7]|31[25]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{4})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"3(?:1[36]|[2-9])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3 $4\\\",\\\"8\\\",null]]]',\\n  93: '[\\\"AF\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{7,9}\\\",\\\"[2-7]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([2-7]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[2-7]\\\",null]]]',\\n  260: '[\\\"ZM\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[289]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"([29]\\\\\\\\\\\\\\\\d)(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1 $2\\\",\\\"[29]\\\",null],[\\\"(800)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"8\\\",null]]]',\\n  378: '[\\\"SM\\\",\\\"00\\\",null,\\\"(?:0549)?([89]\\\\\\\\\\\\\\\\d{5})\\\",\\\"0549$1\\\",null,\\\"\\\\\\\\\\\\\\\\d{6,10}\\\",\\\"[05-7]\\\\\\\\\\\\\\\\d{7,9}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[5-7]\\\",null],[\\\"(0549)(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"0\\\",null,\\\"($1) $2\\\"],[\\\"(\\\\\\\\\\\\\\\\d{6})\\\",\\\"0549 $1\\\",\\\"[89]\\\",null,\\\"(0549) $1\\\"]]]',\\n  235: '[\\\"TD\\\",\\\"00|16\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{8}\\\",\\\"[2679]\\\\\\\\\\\\\\\\d{7}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",null,null]]]',\\n  960: '[\\\"MV\\\",\\\"0(?:0|19)\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{7,10}\\\",\\\"[346-8]\\\\\\\\\\\\\\\\d{6,9}|9(?:00\\\\\\\\\\\\\\\\d{7}|\\\\\\\\\\\\\\\\d{6})\\\",[[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1-$2\\\",\\\"[3467]|9(?:[1-9]|0[1-9])\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"[89]00\\\",null]]]',\\n  221: '[\\\"SN\\\",\\\"00\\\",null,null,null,null,\\\"\\\\\\\\\\\\\\\\d{9}\\\",\\\"[3789]\\\\\\\\\\\\\\\\d{8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"[379]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{2})\\\",\\\"$1 $2 $3 $4\\\",\\\"8\\\",null]]]',\\n  595: '[\\\"PY\\\",\\\"00\\\",\\\"0\\\",null,null,null,\\\"\\\\\\\\\\\\\\\\d{5,9}\\\",\\\"5[0-5]\\\\\\\\\\\\\\\\d{4,7}|[2-46-9]\\\\\\\\\\\\\\\\d{5,8}\\\",[[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{5})\\\",\\\"$1 $2\\\",\\\"(?:[26]1|3[289]|4[124678]|7[123]|8[1236])\\\",\\\"($NP$FG)\\\"],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"(?:[26]1|3[289]|4[124678]|7[123]|8[1236])\\\",\\\"($NP$FG)\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,6})\\\",\\\"$1 $2\\\",\\\"[2-9]0\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1 $2\\\",\\\"9[1-9]\\\",\\\"$NP$FG\\\"],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"8700\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4,5})\\\",\\\"$1 $2\\\",\\\"[2-8][1-9]\\\",\\\"($NP$FG)\\\"],[\\\"(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3})\\\",\\\"$1 $2 $3\\\",\\\"[2-8][1-9]\\\",\\\"$NP$FG\\\"]]]',\\n  977: '[\\\"NP\\\",\\\"00\\\",\\\"0\\\",null,null,\\\"$NP$FG\\\",\\\"\\\\\\\\\\\\\\\\d{6,10}\\\",\\\"[1-8]\\\\\\\\\\\\\\\\d{7}|9(?:[1-69]\\\\\\\\\\\\\\\\d{6,8}|7[2-6]\\\\\\\\\\\\\\\\d{5,7}|8\\\\\\\\\\\\\\\\d{8})\\\",[[\\\"(1)(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1-$2\\\",\\\"1[2-6]\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{6})\\\",\\\"$1-$2\\\",\\\"1[01]|[2-8]|9(?:[1-69]|7[15-9])\\\",null],[\\\"(9\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{7})\\\",\\\"$1-$2\\\",\\\"9(?:6[013]|7[245]|8)\\\",\\\"$FG\\\"]]]',\\n  36: '[\\\"HU\\\",\\\"00\\\",\\\"06\\\",null,null,\\\"($FG)\\\",\\\"\\\\\\\\\\\\\\\\d{6,9}\\\",\\\"[1-9]\\\\\\\\\\\\\\\\d{7,8}\\\",[[\\\"(1)(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{4})\\\",\\\"$1 $2 $3\\\",\\\"1\\\",null],[\\\"(\\\\\\\\\\\\\\\\d{2})(\\\\\\\\\\\\\\\\d{3})(\\\\\\\\\\\\\\\\d{3,4})\\\",\\\"$1 $2 $3\\\",\\\"[2-9]\\\",null]]]',\\n};\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs ***!
  \**************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Apache License, Version\\n * 2.0. If a copy of the Apache License was not distributed with this file, You\\n * can obtain one at https://www.apache.org/licenses/LICENSE-2.0 */\\n\\n// This library came from https://github.com/andreasgal/PhoneNumber.js but will\\n// be further maintained by our own in Form Autofill codebase.\\n\\nexport var PhoneNumberNormalizer = (function () {\\n  const UNICODE_DIGITS = /[\\\\uFF10-\\\\uFF19\\\\u0660-\\\\u0669\\\\u06F0-\\\\u06F9]/g;\\n  const VALID_ALPHA_PATTERN = /[a-zA-Z]/g;\\n  const LEADING_PLUS_CHARS_PATTERN = /^[+\\\\uFF0B]+/g;\\n  const NON_DIALABLE_CHARS = /[^,#+\\\\*\\\\d]/g;\\n\\n  // Map letters to numbers according to the ITU E.161 standard\\n  let E161 = {\\n    a: 2,\\n    b: 2,\\n    c: 2,\\n    d: 3,\\n    e: 3,\\n    f: 3,\\n    g: 4,\\n    h: 4,\\n    i: 4,\\n    j: 5,\\n    k: 5,\\n    l: 5,\\n    m: 6,\\n    n: 6,\\n    o: 6,\\n    p: 7,\\n    q: 7,\\n    r: 7,\\n    s: 7,\\n    t: 8,\\n    u: 8,\\n    v: 8,\\n    w: 9,\\n    x: 9,\\n    y: 9,\\n    z: 9,\\n  };\\n\\n  // Normalize a number by converting unicode numbers and symbols to their\\n  // ASCII equivalents and removing all non-dialable characters.\\n  function NormalizeNumber(number, numbersOnly) {\\n    if (typeof number !== \\\"string\\\") {\\n      return \\\"\\\";\\n    }\\n\\n    number = number.replace(UNICODE_DIGITS, function (ch) {\\n      return String.fromCharCode(48 + (ch.charCodeAt(0) & 0xf));\\n    });\\n    if (!numbersOnly) {\\n      number = number.replace(VALID_ALPHA_PATTERN, function (ch) {\\n        return String(E161[ch.toLowerCase()] || 0);\\n      });\\n    }\\n    number = number.replace(LEADING_PLUS_CHARS_PATTERN, \\\"+\\\");\\n    number = number.replace(NON_DIALABLE_CHARS, \\\"\\\");\\n    return number;\\n  }\\n\\n  return {\\n    Normalize: NormalizeNumber,\\n  };\\n})();\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/TranslationsHelpers.ios.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/TranslationsHelpers.ios.mjs ***!
  \************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nimport \\\"resource://gre/modules/shared/Helpers.ios.mjs\\\";\\n\\nNode.prototype.ownerGlobal = window;\\n\\nObject.defineProperty(Node.prototype, \\\"flattenedTreeParentNode\\\", {\\n  get() {\\n    return this.parentElement ?? null;\\n  },\\n  configurable: true,\\n});\\n\\nexport const Cu = {\\n  // NOTE(Issam): Is this enough ? Or maybe we can use WeakRefs.\\n  isDeadWrapper: (node) => !node?.isConnected,\\n  isInAutomation: false,\\n};\\nglobalThis.Cu = Cu;\\n\\n/// Mock for DOMParser.parseFromSafeString\\n/// Currently just uses `parseFromString`.\\n/// `parseFromSafeString` is a gecko API that is not standard.\\n/// See: https://searchfox.org/firefox-main/source/dom/base/DOMParser.cpp#122\\n/// TODO(Issam): Implement a safer version (e.g., using DOMPurify to sanitize input HTML)\\nDOMParser.prototype.parseFromSafeString = function (str, type) {\\n  return this.parseFromString(str, type);\\n};\\n\\nexport const setTimeout = globalThis.setTimeout.bind(window);\\nexport const clearTimeout = globalThis.clearTimeout.bind(window);\\n\\n\\n\\n// TODO(Issam): Implement this for debugging\\nglobalThis.console.createInstance = () => ({\\n  log: (...whatever) => console.log(\\\"createInstance --- \\\", ...whatever),\\n  warn: (...whatever) => console.warn(\\\"createInstance --- \\\", ...whatever),\\n  error: (...whatever) => console.error(\\\"createInstance --- \\\", ...whatever),\\n  shouldLog: () => false, // TODO(Issam): Maybe enable for webpack dev builds\\n});\\n\\nglobalThis.ChromeUtils = globalThis.ChromeUtils || {};\\nglobalThis.ChromeUtils.addProfilerMarker = () => { };\\nglobalThis.ChromeUtils.domProcessChild = {\\n  getActor: () => globalThis,\\n};\\nglobalThis.ChromeUtils.now = () => performance.now();\\n\\n/// TODO(Issam): Copy over implementation from: \\n/// https://searchfox.org/firefox-main/source/toolkit/components/mozintl/mozIntl.sys.mjs#1044-1058\\nglobalThis.Services = {\\n  intl: {\\n    getScriptDirection: () => \\\"ltr\\\",\\n  }\\n};\\n\\n// // QUESTION(Issam): It would be better if the code in the engine ingests these as is.\\n// // TODO(Issam): Can we send the binary data as is from siwift and use new Uint8Array(byteArray) only \\n// // to convert the binary array to a typed one.\\n// const base64ToArrayBuffer = (base64) => {\\n//   const binaryString = atob(base64);\\n//   const length = binaryString.length;\\n//   const bytes = new Uint8Array(length);\\n//   for (let i = 0; i < length; i++) {\\n//     bytes[i] = binaryString.charCodeAt(i);\\n//   }\\n//   return bytes;\\n// };\\n\\n// // QUESTION(Issam): It would be better if the code in the engine ingests these as is.\\n// // TODO(Issam): Can we send the binary data as is from siwift and use new Uint8Array(byteArray) only \\n// // to convert the binary array to a typed one.\\nconst base64ToArrayBuffer = (base64) => {\\n  const binary = atob(base64);\\n  return Uint8Array.from(binary, c => c.charCodeAt(0)).buffer;\\n}\\n\\n// // NOTE(Issam): Wasm is bundled using webpack. Language models are fetched from swift.\\n// // Is this a good approach ?\\n// export const getAllModels = async (sourceLanguage, targetLanguage) => {\\n//   // NOTE(Issam): Most processing is done in swift. If we manage to accept base64 encoded models\\n//   // Then we can omit the processing here all together.\\n//   // TODO(Issam): models in base64 to array buffer\\n//   // languageModelFiles: {\\n//   //     lex: {buffer: \\\"\\\"}\\n//   //     vocab: {buffer: \\\"\\\"}\\n//   //     model: {buffer: \\\"\\\"}\\n//   // }\\n//   const modelsForLanguagePair =\\n//     await webkit.messageHandlers.translationsBackground.postMessage({\\n//       type: \\\"getModels\\\",\\n//       payload: {\\n//         sourceLanguage,\\n//         targetLanguage,\\n//       },\\n//     });\\n\\n//   const languageModelFiles = modelsForLanguagePair.languageModelFiles;\\n//   for (const model of Object.values(languageModelFiles)) {\\n//     model.buffer = base64ToArrayBuffer(model.buffer);\\n//   }\\n//   return modelsForLanguagePair;\\n// };\\n\\nglobalThis.TE_getLogLevel = () => { };\\nglobalThis.TE_log = (message) => console.log(\\\"TE_log ---- \\\", message);\\nglobalThis.log = (message) => console.log(\\\"log ---- \\\", message);\\n\\nglobalThis.TE_logError = (...error) =>\\n  console.error(\\\"TE_error ---- \\\", ...error);\\nglobalThis.TE_getLogLevel = () => { };\\nglobalThis.TE_destroyEngineProcess = () => { };\\nglobalThis.TE_reportEnginePerformance = () => { };\\nglobalThis.TE_requestEnginePayload = async ({ sourceLanguage, targetLanguage  }) => {\\n  const modelsURL = `translations://app/models?from=${encodeURIComponent(sourceLanguage)}&to=${encodeURIComponent(targetLanguage)}`;\\n  const modelsResponse = await fetch(modelsURL);\\n  if (!modelsResponse.ok) throw new Error(`Model fetch failed: ${modelsResponse.status}`);\\n  const translationModelPayloads = await modelsResponse.json();\\n  // TODO(Issam): I hate this extra processing we should just send it as a binary array. \\n  const processedPayloads = processTranslationPayloads(translationModelPayloads);\\n  // TODO(Issam): Use Promise.all to parallelize this with fetching the wasm so we don't wait for one then the other.\\n  const translatorURL = `translations://app/translator`;\\n  const translatorResponse = await fetch(translatorURL);\\n  if (!translatorResponse.ok) throw new Error(`Translator fetch failed: ${translatorResponse.status}`);\\n  const bergamotTranslator = await translatorResponse.json();\\n\\n  return {\\n    bergamotWasmArrayBuffer: base64ToArrayBuffer(bergamotTranslator.wasm),\\n    translationModelPayloads: processedPayloads,\\n    isMocked: false,\\n  };\\n};\\nglobalThis.TE_reportEngineStatus = () => { };\\nglobalThis.TE_resolveForceShutdown = () => { };\\nglobalThis.TE_addProfilerMarker = () => { };\\n\\n\\n// TODO(Issam): We should figure a better way to do this instead of all the extra processing here.\\n// Maybe we can send the binary data as is from swift and use new Uint8Array(byteArray) only \\n// to convert the binary array to a typed one.\\nconst processTranslationPayloads = (payloads) =>\\n  payloads.map(payload => {\\n    const processedFiles = {};\\n    for (const [type, file] of Object.entries(payload.languageModelFiles)) {\\n      processedFiles[type] = {\\n        ...file,\\n        buffer: base64ToArrayBuffer(file.buffer),\\n      };\\n    }\\n    return { ...payload, languageModelFiles: processedFiles };\\n  });\\n\\n// NOTE(Issam): Calling new Worker(url) will cause a security error since we are loading from an unsafe context.\\n// To bypass this we inline the worker and override the Worker constructor. This way we don't have to touch the shared code.\\n// We are only calling this to load translations-engine.worker.js for now, so it's hardcoded\\nconst OriginalWorker = globalThis.Worker;\\nglobalThis.Worker = class extends OriginalWorker {\\n  constructor(url, options) {\\n    if (url.endsWith(\\\"translations-engine.worker.js\\\")) {\\n      const translationsWorker = require(\\\"Assets/CC_Script/translations-engine.worker.js\\\");\\n      return new translationsWorker();\\n    }\\n    return new OriginalWorker(url, options);\\n  }\\n};\\n\\n// NOTE(Issam): importScripts is resolved at runtime which is problematic. The best solution I found for this is to:\\n// - Override it to use require so webpack can build the deps graph.\\n// - Use script-loader to expose loadBergamot to the worker since it's not an es module.\\nglobalThis.importScripts = (moduleURI) => {\\n  const moduleName = moduleURI.split(\\\"/\\\").pop();\\n  require(`script-loader!./${moduleName}`);\\n};\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/TranslationsHelpers.ios.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/TranslationsUtils.mjs":
/*!******************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/TranslationsUtils.mjs ***!
  \******************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n/**\\n * @typedef {import(\\\"./translations\\\").LanguagePair} LanguagePair\\n */\\n\\n/**\\n * A set of global static utility functions that are useful throughout the\\n * Translations ecosystem within the Firefox code base.\\n */\\nexport class TranslationsUtils {\\n  /**\\n   * Checks if the language tag string parses as a valid BCP-47 language tag.\\n   *\\n   * @param {string} langTag - A BCP-47 language tag.\\n   * @returns {boolean} - True if the given language tag parses or false if it does not.\\n   */\\n  static isLangTagValid(langTag) {\\n    if (!langTag) {\\n      return false;\\n    }\\n\\n    try {\\n      new Intl.Locale(langTag);\\n      return true;\\n    } catch {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * Normalizes the language tag for comparison within the Translations ecosystem.\\n   *\\n   * Prefers to compare languages with a script tag if one is available, only resorting\\n   * to returning the language tag in isolation if a script tag could not be derived.\\n   *\\n   * @param {string} langTag - A BCP-47 language tag.\\n   * @returns {string} - A BCP-47 language tag normalized for Translations.\\n   */\\n  static #normalizeLangTag(langTag) {\\n    let locale = new Intl.Locale(langTag);\\n\\n    if (!locale.script) {\\n      // Attempt to populate a script tag via likely subtags.\\n      locale = locale.maximize();\\n    }\\n\\n    if (locale.script) {\\n      // If the locale has a script, use it.\\n      return `${locale.language}-${locale.script}`;\\n    }\\n\\n    return locale.language;\\n  }\\n\\n  /**\\n   * Compares two BCP-47 language tags for Translations compatibility.\\n   *\\n   * If one language tag belongs to one of our models, and the other\\n   * language tag is determined to be a match, then it is determined\\n   * that the model is compatible to for translation with that language.\\n   *\\n   * @param {string} lhsLangTag - The left-hand-side language tag to compare.\\n   * @param {string} rhsLangTag - The right-hand-side language tag to compare.\\n   *\\n   * @returns {boolean}\\n   *  `true`  if the language tags match, either directly or after normalization.\\n   *  `false` if either tag is invalid or empty, or if they do not match.\\n   *\\n   * @see https://datatracker.ietf.org/doc/html/rfc5646#appendix-A\\n   */\\n  static langTagsMatch(lhsLangTag, rhsLangTag) {\\n    if (!lhsLangTag || !rhsLangTag) {\\n      return false;\\n    }\\n\\n    if (lhsLangTag === rhsLangTag) {\\n      // A simple direct match.\\n      return true;\\n    }\\n\\n    if (lhsLangTag.split(\\\"-\\\")[0] !== rhsLangTag.split(\\\"-\\\")[0]) {\\n      // The language components of the tags do not match so there is no need to normalize them and compare.\\n      return false;\\n    }\\n\\n    try {\\n      return (\\n        TranslationsUtils.#normalizeLangTag(lhsLangTag) ===\\n        TranslationsUtils.#normalizeLangTag(rhsLangTag)\\n      );\\n    } catch {\\n      // One of the locales is not valid, just continue on to return false.\\n    }\\n\\n    return false;\\n  }\\n\\n  /**\\n   * Serializes a language pair into a unique key that is human readable. This is useful\\n   * for caching, deduplicating, and logging.\\n   *\\n   * e.g.\\n   *   \\\"en -> fr\\\"\\n   *   \\\"en -> fr,base\\\"\\n   *   \\\"zh-Hans,tiny -> fr,base\\\"\\n   *\\n   * @param {LanguagePair} languagePair\\n   */\\n  static serializeLanguagePair({\\n    sourceLanguage,\\n    targetLanguage,\\n    sourceVariant,\\n    targetVariant,\\n  }) {\\n    let key = sourceLanguage;\\n    if (sourceVariant) {\\n      key += `,${sourceVariant}`;\\n    }\\n    key += ` -> ${targetLanguage}`;\\n    if (targetVariant) {\\n      key += `,${targetVariant}`;\\n    }\\n    return key;\\n  }\\n}\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/TranslationsUtils.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/addressFormLayout.mjs":
/*!******************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/addressFormLayout.mjs ***!
  \******************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nconst lazy = {};\\nChromeUtils.defineESModuleGetters(lazy, {\\n  FormAutofill: \\\"resource://autofill/FormAutofill.sys.mjs\\\",\\n  FormAutofillUtils: \\\"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\\\",\\n});\\n\\n// Defines template descriptors for generating elements in convertLayoutToUI.\\nconst fieldTemplates = {\\n  commonAttributes(item) {\\n    return {\\n      id: item.fieldId,\\n      name: item.fieldId,\\n      required: item.required,\\n      value: item.value ?? \\\"\\\",\\n      // Conditionally add pattern attribute since pattern=\\\"\\\"/false/undefined\\n      // results in weird behaviour.\\n      ...(item.pattern && { pattern: item.pattern }),\\n    };\\n  },\\n  input(item) {\\n    return {\\n      tag: \\\"input\\\",\\n      type: item.type ?? \\\"text\\\",\\n      ...this.commonAttributes(item),\\n    };\\n  },\\n  textarea(item) {\\n    return {\\n      tag: \\\"textarea\\\",\\n      ...this.commonAttributes(item),\\n    };\\n  },\\n  select(item) {\\n    return {\\n      tag: \\\"select\\\",\\n      children: item.options.map(({ value, text }) => ({\\n        tag: \\\"option\\\",\\n        selected: value === item.value,\\n        value,\\n        text,\\n      })),\\n      ...this.commonAttributes(item),\\n    };\\n  },\\n};\\n\\n/**\\n * Creates an HTML element with specified attributes and children.\\n *\\n * @param {string} tag - Tag name for the element to create.\\n * @param {object} options - Options object containing attributes and children.\\n * @param {object} options.attributes - Element's Attributes/Props (id, class, etc.)\\n * @param {Array} options.children - Element's children (array of objects with tag and options).\\n * @returns {HTMLElement} The newly created element.\\n */\\nconst createElement = (tag, { children = [], ...attributes }) => {\\n  const element = document.createElement(tag);\\n\\n  for (let [attributeName, attributeValue] of Object.entries(attributes)) {\\n    if (attributeName in element) {\\n      element[attributeName] = attributeValue;\\n    } else {\\n      element.setAttribute(attributeName, attributeValue);\\n    }\\n  }\\n\\n  for (let { tag: childTag, ...childRest } of children) {\\n    element.appendChild(createElement(childTag, childRest));\\n  }\\n\\n  return element;\\n};\\n\\n/**\\n * Generator that creates UI elements from `fields` object, using localization from `l10nStrings`.\\n *\\n * @param {Array} fields - Array of objects as returned from `FormAutofillUtils.getFormLayout`.\\n * @param {object} l10nStrings - Key-value pairs for field label localization.\\n * @yields {HTMLElement} - A localized label element with constructed from a field.\\n */\\nfunction* convertLayoutToUI(fields, l10nStrings) {\\n  for (const item of fields) {\\n    // eslint-disable-next-line no-nested-ternary\\n    const fieldTag = item.options\\n      ? \\\"select\\\"\\n      : item.multiline\\n        ? \\\"textarea\\\"\\n        : \\\"input\\\";\\n\\n    const fieldUI = {\\n      label: {\\n        id: `${item.fieldId}-container`,\\n        class: `container ${item.newLine ? \\\"new-line\\\" : \\\"\\\"}`,\\n      },\\n      field: fieldTemplates[fieldTag](item),\\n      span: {\\n        class: \\\"label-text\\\",\\n        textContent: l10nStrings[item.l10nId] ?? \\\"\\\",\\n      },\\n    };\\n\\n    const label = createElement(\\\"label\\\", fieldUI.label);\\n    const { tag, ...rest } = fieldUI.field;\\n    const span = createElement(\\\"span\\\", fieldUI.span);\\n    label.appendChild(span);\\n    const field = createElement(tag, rest);\\n    label.appendChild(field);\\n    yield label;\\n  }\\n}\\n\\n/**\\n * Retrieves the current form data from the current form element on the page.\\n * NOTE: We are intentionally not using FormData here because on iOS we have states where\\n *       selects are disabled and FormData ignores disabled elements. We want getCurrentFormData\\n *       to always refelect the exact state of the form.\\n *\\n * @returns {object} An object containing key-value pairs of form data.\\n */\\nexport const getCurrentFormData = () => {\\n  const formData = {};\\n  for (const element of document.querySelector(\\\"form\\\").elements) {\\n    formData[element.name] = element.value ?? \\\"\\\";\\n  }\\n  return formData;\\n};\\n\\n/**\\n * Checks if the form can be submitted based on the number of non-empty values.\\n * TODO(Bug 1891734): Add address validation. Right now we don't do any validation. (2 fields mimics the old behaviour ).\\n *\\n * @returns {boolean} True if the form can be submitted\\n */\\nexport const canSubmitForm = () => {\\n  const formData = getCurrentFormData();\\n  const validValues = Object.values(formData).filter(Boolean);\\n  return validValues.length >= 2;\\n};\\n\\n/**\\n * Generates a form layout based on record data and localization strings.\\n *\\n * @param {HTMLFormElement} formElement - Target form element.\\n * @param {object} record - Address record, includes at least country code defaulted to FormAutofill.DEFAULT_REGION.\\n * @param {object} l10nStrings - Localization strings map.\\n */\\nexport const createFormLayoutFromRecord = (\\n  formElement,\\n  record = { country: lazy.FormAutofill.DEFAULT_REGION },\\n  l10nStrings = {}\\n) => {\\n  // Always clear select values because they are not persisted between countries.\\n  // For example from US with state NY, we don't want the address-level1 to be NY\\n  // when changing to another country that doesn't have state options\\n  const selects = formElement.querySelectorAll(\\\"select:not(#country)\\\");\\n  for (const select of selects) {\\n    select.value = \\\"\\\";\\n  }\\n\\n  // Get old data to persist before clearing form\\n  const formData = getCurrentFormData();\\n  record = {\\n    ...record,\\n    ...formData,\\n  };\\n\\n  formElement.innerHTML = \\\"\\\";\\n  const fields = lazy.FormAutofillUtils.getFormLayout(record);\\n\\n  const layoutGenerator = convertLayoutToUI(fields, l10nStrings);\\n\\n  for (const fieldElement of layoutGenerator) {\\n    formElement.appendChild(fieldElement);\\n  }\\n\\n  document.querySelector(\\\"#country\\\").addEventListener(\\n    \\\"change\\\",\\n    ev =>\\n      // Allow some time for the user to type\\n      // before we set the new country and re-render\\n      setTimeout(() => {\\n        record.country = ev.target.value;\\n        createFormLayoutFromRecord(formElement, record, l10nStrings);\\n      }, 300),\\n    { once: true }\\n  );\\n\\n  // Used to notify tests that the form has been updated and is ready\\n  window.dispatchEvent(new CustomEvent(\\\"FormReadyForTests\\\"));\\n};\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/addressFormLayout.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js ***!
  \*******************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nfunction loadBergamot(Module) {\\n  var BERGAMOT_VERSION_FULL = \\\"v0.6.0+4a6a44c0\\\";\\n  null;\\n\\n  var Module = typeof Module != \\\"undefined\\\" ? Module : {};\\n\\n  var moduleOverrides = Object.assign({}, Module);\\n\\n  var arguments_ = [];\\n\\n  var thisProgram = \\\"./this.program\\\";\\n\\n  var quit_ = (status, toThrow) => {\\n    throw toThrow;\\n  };\\n\\n  var ENVIRONMENT_IS_WEB = typeof window == \\\"object\\\";\\n\\n  var ENVIRONMENT_IS_WORKER = typeof importScripts == \\\"function\\\";\\n\\n  var ENVIRONMENT_IS_NODE =\\n    typeof process == \\\"object\\\" &&\\n    typeof process.versions == \\\"object\\\" &&\\n    typeof process.versions.node == \\\"string\\\";\\n\\n  var scriptDirectory = \\\"\\\";\\n\\n  function locateFile(path) {\\n    if (Module.locateFile) {\\n      return Module.locateFile(path, scriptDirectory);\\n    }\\n    return scriptDirectory + path;\\n  }\\n\\n  var read_, readAsync, readBinary, setWindowTitle;\\n\\n  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\\n    if (ENVIRONMENT_IS_WORKER) {\\n      scriptDirectory = self.location.href;\\n    } else if (typeof document != \\\"undefined\\\" && document.currentScript) {\\n      scriptDirectory = document.currentScript.src;\\n    }\\n    if (scriptDirectory.indexOf(\\\"blob:\\\") !== 0) {\\n      scriptDirectory = scriptDirectory.substr(\\n        0,\\n        scriptDirectory.replace(/[?#].*/, \\\"\\\").lastIndexOf(\\\"/\\\") + 1\\n      );\\n    } else {\\n      scriptDirectory = \\\"\\\";\\n    }\\n    {\\n      read_ = url => {\\n        var xhr = new XMLHttpRequest();\\n        xhr.open(\\\"GET\\\", url, false);\\n        xhr.send(null);\\n        return xhr.responseText;\\n      };\\n      if (ENVIRONMENT_IS_WORKER) {\\n        readBinary = url => {\\n          var xhr = new XMLHttpRequest();\\n          xhr.open(\\\"GET\\\", url, false);\\n          xhr.responseType = \\\"arraybuffer\\\";\\n          xhr.send(null);\\n          return new Uint8Array(xhr.response);\\n        };\\n      }\\n      readAsync = (url, onload, onerror) => {\\n        var xhr = new XMLHttpRequest();\\n        xhr.open(\\\"GET\\\", url, true);\\n        xhr.responseType = \\\"arraybuffer\\\";\\n        xhr.onload = () => {\\n          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {\\n            onload(xhr.response);\\n            return;\\n          }\\n          onerror();\\n        };\\n        xhr.onerror = onerror;\\n        xhr.send(null);\\n      };\\n    }\\n    setWindowTitle = title => (document.title = title);\\n  } else {\\n  }\\n\\n  var out = Module.print || console.log.bind(console);\\n\\n  var err = Module.printErr || console.warn.bind(console);\\n\\n  Object.assign(Module, moduleOverrides);\\n\\n  moduleOverrides = null;\\n\\n  if (Module.arguments) {\\n    arguments_ = Module.arguments;\\n  }\\n\\n  if (Module.thisProgram) {\\n    thisProgram = Module.thisProgram;\\n  }\\n\\n  if (Module.quit) {\\n    quit_ = Module.quit;\\n  }\\n\\n  var tempRet0 = 0;\\n\\n  var setTempRet0 = value => {\\n    tempRet0 = value;\\n  };\\n\\n  var wasmBinary;\\n\\n  if (Module.wasmBinary) {\\n    wasmBinary = Module.wasmBinary;\\n  }\\n\\n  var noExitRuntime = Module.noExitRuntime || true;\\n\\n  if (typeof WebAssembly != \\\"object\\\") {\\n    abort(\\\"no native wasm support detected\\\");\\n  }\\n\\n  function setValue(ptr, value, type = \\\"i8\\\", noSafe) {\\n    if (type.charAt(type.length - 1) === \\\"*\\\") {\\n      type = \\\"i32\\\";\\n    }\\n    switch (type) {\\n      case \\\"i1\\\":\\n        HEAP8[ptr >> 0] = value;\\n        break;\\n\\n      case \\\"i8\\\":\\n        HEAP8[ptr >> 0] = value;\\n        break;\\n\\n      case \\\"i16\\\":\\n        HEAP16[ptr >> 1] = value;\\n        break;\\n\\n      case \\\"i32\\\":\\n        HEAP32[ptr >> 2] = value;\\n        break;\\n\\n      case \\\"i64\\\":\\n        ((tempI64 = [\\n          value >>> 0,\\n          ((tempDouble = value),\\n          +Math.abs(tempDouble) >= 1\\n            ? tempDouble > 0\\n              ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) |\\n                  0) >>>\\n                0\\n              : ~~+Math.ceil(\\n                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296\\n                ) >>> 0\\n            : 0),\\n        ]),\\n          (HEAP32[ptr >> 2] = tempI64[0]),\\n          (HEAP32[(ptr + 4) >> 2] = tempI64[1]));\\n        break;\\n\\n      case \\\"float\\\":\\n        HEAPF32[ptr >> 2] = value;\\n        break;\\n\\n      case \\\"double\\\":\\n        HEAPF64[ptr >> 3] = value;\\n        break;\\n\\n      default:\\n        abort(\\\"invalid type for setValue: \\\" + type);\\n    }\\n  }\\n\\n  var wasmMemory;\\n\\n  var ABORT = false;\\n\\n  var EXITSTATUS;\\n\\n  function assert(condition, text) {\\n    if (!condition) {\\n      abort(text);\\n    }\\n  }\\n\\n  var UTF8Decoder =\\n    typeof TextDecoder != \\\"undefined\\\" ? new TextDecoder(\\\"utf8\\\") : undefined;\\n\\n  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\\n    var endIdx = idx + maxBytesToRead;\\n    var endPtr = idx;\\n    while (heapOrArray[endPtr] && !(endPtr >= endIdx)) {\\n      ++endPtr;\\n    }\\n    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\\n      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\\n    }\\n    var str = \\\"\\\";\\n    while (idx < endPtr) {\\n      var u0 = heapOrArray[idx++];\\n      if (!(u0 & 128)) {\\n        str += String.fromCharCode(u0);\\n        continue;\\n      }\\n      var u1 = heapOrArray[idx++] & 63;\\n      if ((u0 & 224) == 192) {\\n        str += String.fromCharCode(((u0 & 31) << 6) | u1);\\n        continue;\\n      }\\n      var u2 = heapOrArray[idx++] & 63;\\n      if ((u0 & 240) == 224) {\\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\\n      } else {\\n        u0 =\\n          ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\\n      }\\n      if (u0 < 65536) {\\n        str += String.fromCharCode(u0);\\n      } else {\\n        var ch = u0 - 65536;\\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\\n      }\\n    }\\n\\n    return str;\\n  }\\n\\n  function UTF8ToString(ptr, maxBytesToRead) {\\n    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \\\"\\\";\\n  }\\n\\n  function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\\n    if (!(maxBytesToWrite > 0)) {\\n      return 0;\\n    }\\n    var startIdx = outIdx;\\n    var endIdx = outIdx + maxBytesToWrite - 1;\\n    for (var i = 0; i < str.length; ++i) {\\n      var u = str.charCodeAt(i);\\n      if (u >= 55296 && u <= 57343) {\\n        var u1 = str.charCodeAt(++i);\\n        u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);\\n      }\\n      if (u <= 127) {\\n        if (outIdx >= endIdx) {\\n          break;\\n        }\\n        heap[outIdx++] = u;\\n      } else if (u <= 2047) {\\n        if (outIdx + 1 >= endIdx) {\\n          break;\\n        }\\n        heap[outIdx++] = 192 | (u >> 6);\\n        heap[outIdx++] = 128 | (u & 63);\\n      } else if (u <= 65535) {\\n        if (outIdx + 2 >= endIdx) {\\n          break;\\n        }\\n        heap[outIdx++] = 224 | (u >> 12);\\n        heap[outIdx++] = 128 | ((u >> 6) & 63);\\n        heap[outIdx++] = 128 | (u & 63);\\n      } else {\\n        if (outIdx + 3 >= endIdx) {\\n          break;\\n        }\\n        heap[outIdx++] = 240 | (u >> 18);\\n        heap[outIdx++] = 128 | ((u >> 12) & 63);\\n        heap[outIdx++] = 128 | ((u >> 6) & 63);\\n        heap[outIdx++] = 128 | (u & 63);\\n      }\\n    }\\n    heap[outIdx] = 0;\\n    return outIdx - startIdx;\\n  }\\n\\n  function stringToUTF8(str, outPtr, maxBytesToWrite) {\\n    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\\n  }\\n\\n  function lengthBytesUTF8(str) {\\n    var len = 0;\\n    for (var i = 0; i < str.length; ++i) {\\n      var u = str.charCodeAt(i);\\n      if (u >= 55296 && u <= 57343) {\\n        u = (65536 + ((u & 1023) << 10)) | (str.charCodeAt(++i) & 1023);\\n      }\\n      if (u <= 127) {\\n        ++len;\\n      } else if (u <= 2047) {\\n        len += 2;\\n      } else if (u <= 65535) {\\n        len += 3;\\n      } else {\\n        len += 4;\\n      }\\n    }\\n    return len;\\n  }\\n\\n  var UTF16Decoder =\\n    typeof TextDecoder != \\\"undefined\\\" ? new TextDecoder(\\\"utf-16le\\\") : undefined;\\n\\n  function UTF16ToString(ptr, maxBytesToRead) {\\n    var endPtr = ptr;\\n    var idx = endPtr >> 1;\\n    var maxIdx = idx + maxBytesToRead / 2;\\n    while (!(idx >= maxIdx) && HEAPU16[idx]) {\\n      ++idx;\\n    }\\n    endPtr = idx << 1;\\n    if (endPtr - ptr > 32 && UTF16Decoder) {\\n      return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\\n    }\\n    var str = \\\"\\\";\\n    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\\n      var codeUnit = HEAP16[(ptr + i * 2) >> 1];\\n      if (codeUnit == 0) {\\n        break;\\n      }\\n      str += String.fromCharCode(codeUnit);\\n    }\\n    return str;\\n  }\\n\\n  function stringToUTF16(str, outPtr, maxBytesToWrite) {\\n    if (maxBytesToWrite === undefined) {\\n      maxBytesToWrite = 2147483647;\\n    }\\n    if (maxBytesToWrite < 2) {\\n      return 0;\\n    }\\n    maxBytesToWrite -= 2;\\n    var startPtr = outPtr;\\n    var numCharsToWrite =\\n      maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\\n    for (var i = 0; i < numCharsToWrite; ++i) {\\n      var codeUnit = str.charCodeAt(i);\\n      HEAP16[outPtr >> 1] = codeUnit;\\n      outPtr += 2;\\n    }\\n    HEAP16[outPtr >> 1] = 0;\\n    return outPtr - startPtr;\\n  }\\n\\n  function lengthBytesUTF16(str) {\\n    return str.length * 2;\\n  }\\n\\n  function UTF32ToString(ptr, maxBytesToRead) {\\n    var i = 0;\\n    var str = \\\"\\\";\\n    while (!(i >= maxBytesToRead / 4)) {\\n      var utf32 = HEAP32[(ptr + i * 4) >> 2];\\n      if (utf32 == 0) {\\n        break;\\n      }\\n      ++i;\\n      if (utf32 >= 65536) {\\n        var ch = utf32 - 65536;\\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\\n      } else {\\n        str += String.fromCharCode(utf32);\\n      }\\n    }\\n    return str;\\n  }\\n\\n  function stringToUTF32(str, outPtr, maxBytesToWrite) {\\n    if (maxBytesToWrite === undefined) {\\n      maxBytesToWrite = 2147483647;\\n    }\\n    if (maxBytesToWrite < 4) {\\n      return 0;\\n    }\\n    var startPtr = outPtr;\\n    var endPtr = startPtr + maxBytesToWrite - 4;\\n    for (var i = 0; i < str.length; ++i) {\\n      var codeUnit = str.charCodeAt(i);\\n      if (codeUnit >= 55296 && codeUnit <= 57343) {\\n        var trailSurrogate = str.charCodeAt(++i);\\n        codeUnit =\\n          (65536 + ((codeUnit & 1023) << 10)) | (trailSurrogate & 1023);\\n      }\\n      HEAP32[outPtr >> 2] = codeUnit;\\n      outPtr += 4;\\n      if (outPtr + 4 > endPtr) {\\n        break;\\n      }\\n    }\\n    HEAP32[outPtr >> 2] = 0;\\n    return outPtr - startPtr;\\n  }\\n\\n  function lengthBytesUTF32(str) {\\n    var len = 0;\\n    for (var i = 0; i < str.length; ++i) {\\n      var codeUnit = str.charCodeAt(i);\\n      if (codeUnit >= 55296 && codeUnit <= 57343) {\\n        ++i;\\n      }\\n      len += 4;\\n    }\\n    return len;\\n  }\\n\\n  function allocateUTF8(str) {\\n    var size = lengthBytesUTF8(str) + 1;\\n    var ret = _malloc(size);\\n    if (ret) {\\n      stringToUTF8Array(str, HEAP8, ret, size);\\n    }\\n    return ret;\\n  }\\n\\n  function writeArrayToMemory(array, buffer) {\\n    HEAP8.set(array, buffer);\\n  }\\n\\n  function writeAsciiToMemory(str, buffer, dontAddNull) {\\n    for (var i = 0; i < str.length; ++i) {\\n      HEAP8[buffer++ >> 0] = str.charCodeAt(i);\\n    }\\n    if (!dontAddNull) {\\n      HEAP8[buffer >> 0] = 0;\\n    }\\n  }\\n\\n  var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\\n\\n  function updateGlobalBufferAndViews(buf) {\\n    const mb = (buf.byteLength / 1_000_000).toFixed();\\n    Module.print(`Growing wasm buffer to ${mb}MB (${buf.byteLength} bytes).`);\\n\\n    buffer = buf;\\n    Module.HEAP8 = HEAP8 = new Int8Array(buf);\\n    Module.HEAP16 = HEAP16 = new Int16Array(buf);\\n    Module.HEAP32 = HEAP32 = new Int32Array(buf);\\n    Module.HEAPU8 = HEAPU8 = new Uint8Array(buf);\\n    Module.HEAPU16 = HEAPU16 = new Uint16Array(buf);\\n    Module.HEAPU32 = HEAPU32 = new Uint32Array(buf);\\n    Module.HEAPF32 = HEAPF32 = new Float32Array(buf);\\n    Module.HEAPF64 = HEAPF64 = new Float64Array(buf);\\n  }\\n\\n  var INITIAL_MEMORY = Module.INITIAL_MEMORY || 16777216;\\n\\n  if (Module.wasmMemory) {\\n    wasmMemory = Module.wasmMemory;\\n  } else {\\n    wasmMemory = new WebAssembly.Memory({\\n      initial: INITIAL_MEMORY / 65536,\\n      maximum: 2147483648 / 65536,\\n    });\\n  }\\n\\n  if (wasmMemory) {\\n    buffer = wasmMemory.buffer;\\n  }\\n\\n  INITIAL_MEMORY = buffer.byteLength;\\n\\n  updateGlobalBufferAndViews(buffer);\\n\\n  var wasmTable;\\n\\n  var __ATPRERUN__ = [];\\n\\n  var __ATINIT__ = [];\\n\\n  var __ATPOSTRUN__ = [];\\n\\n  var runtimeInitialized = false;\\n\\n  function keepRuntimeAlive() {\\n    return noExitRuntime;\\n  }\\n\\n  function preRun() {\\n    if (Module.preRun) {\\n      if (typeof Module.preRun == \\\"function\\\") {\\n        Module.preRun = [Module.preRun];\\n      }\\n      while (Module.preRun.length) {\\n        addOnPreRun(Module.preRun.shift());\\n      }\\n    }\\n    callRuntimeCallbacks(__ATPRERUN__);\\n  }\\n\\n  function initRuntime() {\\n    runtimeInitialized = true;\\n    callRuntimeCallbacks(__ATINIT__);\\n  }\\n\\n  function postRun() {\\n    if (Module.postRun) {\\n      if (typeof Module.postRun == \\\"function\\\") {\\n        Module.postRun = [Module.postRun];\\n      }\\n      while (Module.postRun.length) {\\n        addOnPostRun(Module.postRun.shift());\\n      }\\n    }\\n    callRuntimeCallbacks(__ATPOSTRUN__);\\n  }\\n\\n  function addOnPreRun(cb) {\\n    __ATPRERUN__.unshift(cb);\\n  }\\n\\n  function addOnInit(cb) {\\n    __ATINIT__.unshift(cb);\\n  }\\n\\n  function addOnPostRun(cb) {\\n    __ATPOSTRUN__.unshift(cb);\\n  }\\n\\n  var runDependencies = 0;\\n\\n  var runDependencyWatcher = null;\\n\\n  var dependenciesFulfilled = null;\\n\\n  function addRunDependency(id) {\\n    runDependencies++;\\n    if (Module.monitorRunDependencies) {\\n      Module.monitorRunDependencies(runDependencies);\\n    }\\n  }\\n\\n  function removeRunDependency(id) {\\n    runDependencies--;\\n    if (Module.monitorRunDependencies) {\\n      Module.monitorRunDependencies(runDependencies);\\n    }\\n    if (runDependencies == 0) {\\n      if (runDependencyWatcher !== null) {\\n        clearInterval(runDependencyWatcher);\\n        runDependencyWatcher = null;\\n      }\\n      if (dependenciesFulfilled) {\\n        var callback = dependenciesFulfilled;\\n        dependenciesFulfilled = null;\\n        callback();\\n      }\\n    }\\n  }\\n\\n  Module.preloadedImages = {};\\n\\n  Module.preloadedAudios = {};\\n\\n  function abort(what) {\\n    {\\n      if (Module.onAbort) {\\n        Module.onAbort(what);\\n      }\\n    }\\n    what = \\\"Aborted(\\\" + what + \\\")\\\";\\n    err(what);\\n    ABORT = true;\\n    EXITSTATUS = 1;\\n    what += \\\". Build with -s ASSERTIONS=1 for more info.\\\";\\n    var e = new WebAssembly.RuntimeError(what);\\n    throw e;\\n  }\\n\\n  var dataURIPrefix = \\\"data:application/octet-stream;base64,\\\";\\n\\n  function isDataURI(filename) {\\n    return filename.startsWith(dataURIPrefix);\\n  }\\n\\n  var wasmBinaryFile;\\n\\n  wasmBinaryFile = \\\"bergamot-translator.wasm\\\";\\n\\n  if (!isDataURI(wasmBinaryFile)) {\\n    wasmBinaryFile = locateFile(wasmBinaryFile);\\n  }\\n\\n  function getBinary(file) {\\n    try {\\n      if (file == wasmBinaryFile && wasmBinary) {\\n        return new Uint8Array(wasmBinary);\\n      }\\n      if (readBinary) {\\n        return readBinary(file);\\n      }\\n      throw \\\"both async and sync fetching of the wasm failed\\\";\\n    } catch (err) {\\n      abort(err);\\n    }\\n  }\\n\\n  function getBinaryPromise() {\\n    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\\n      if (typeof fetch == \\\"function\\\") {\\n        return fetch(wasmBinaryFile, {\\n          credentials: \\\"same-origin\\\",\\n        })\\n          .then(function (response) {\\n            if (!response.ok) {\\n              throw (\\n                \\\"failed to load wasm binary file at '\\\" + wasmBinaryFile + \\\"'\\\"\\n              );\\n            }\\n            return response.arrayBuffer();\\n          })\\n          .catch(function () {\\n            return getBinary(wasmBinaryFile);\\n          });\\n      }\\n    }\\n    return Promise.resolve().then(function () {\\n      return getBinary(wasmBinaryFile);\\n    });\\n  }\\n\\n  function createWasm() {\\n    var info = {\\n      env: asmLibraryArg,\\n      wasm_gemm: createWasmGemm(),\\n      wasi_snapshot_preview1: asmLibraryArg,\\n    };\\n    function receiveInstance(instance, module) {\\n      var exports = instance.exports;\\n      Module.asm = exports;\\n      wasmTable = Module.asm.__indirect_function_table;\\n      addOnInit(Module.asm.__wasm_call_ctors);\\n      exportAsmFunctions(exports);\\n      removeRunDependency(\\\"wasm-instantiate\\\");\\n    }\\n    addRunDependency(\\\"wasm-instantiate\\\");\\n    function receiveInstantiationResult(result) {\\n      receiveInstance(result.instance);\\n    }\\n    function instantiateArrayBuffer(receiver) {\\n      // This function has been patched from the original version.\\n      // See Bug 1988289.\\n      return getBinaryPromise()\\n        .then(binary => {\\n          const module = new WebAssembly.Module(binary);\\n          const instance = new WebAssembly.Instance(module, info);\\n          return { module, instance };\\n        })\\n        .then(function (instance) {\\n          return instance;\\n        })\\n        .then(receiver, function (reason) {\\n          err(\\\"failed to asynchronously prepare wasm: \\\" + reason);\\n          abort(reason);\\n        });\\n    }\\n    function instantiateAsync() {\\n      if (\\n        !wasmBinary &&\\n        typeof WebAssembly.instantiateStreaming == \\\"function\\\" &&\\n        !isDataURI(wasmBinaryFile) &&\\n        typeof fetch == \\\"function\\\"\\n      ) {\\n        return fetch(wasmBinaryFile, {\\n          credentials: \\\"same-origin\\\",\\n        }).then(function (response) {\\n          var result = WebAssembly.instantiateStreaming(response, info);\\n          return result.then(receiveInstantiationResult, function (reason) {\\n            err(\\\"wasm streaming compile failed: \\\" + reason);\\n            err(\\\"falling back to ArrayBuffer instantiation\\\");\\n            return instantiateArrayBuffer(receiveInstantiationResult);\\n          });\\n        });\\n      }\\n      return instantiateArrayBuffer(receiveInstantiationResult);\\n    }\\n    if (Module.instantiateWasm) {\\n      try {\\n        var exports = Module.instantiateWasm(info, receiveInstance);\\n        return exports;\\n      } catch (e) {\\n        err(\\\"Module.instantiateWasm callback failed with error: \\\" + e);\\n        return false;\\n      }\\n    }\\n    instantiateAsync();\\n    return {};\\n  }\\n\\n  var tempDouble;\\n\\n  var tempI64;\\n\\n  var ASM_CONSTS = {\\n    1427332($0, $1, $2, $3, $4) {\\n      if (!Module.getOrCreateSentenceSegmenter) {\\n        Module.getOrCreateSentenceSegmenter = (function () {\\n          let segmenters = new Map();\\n          return function (lang) {\\n            let segmenter = segmenters.get(lang);\\n            if (!segmenter) {\\n              segmenter = new Intl.Segmenter(lang, {\\n                granularity: \\\"sentence\\\",\\n              });\\n              segmenters.set(lang, segmenter);\\n            }\\n            return segmenter;\\n          };\\n        })();\\n      }\\n      const inputUTF16 = UTF8ToString($0);\\n      const lang = UTF8ToString($1);\\n      const segmenter = Module.getOrCreateSentenceSegmenter(lang);\\n      const sentencesUTF16 = Array.from(segmenter.segment(inputUTF16));\\n      const sentenceCount = sentencesUTF16.length;\\n      const bytesPerInt = 4;\\n      const startsPtr = _malloc(sentenceCount * bytesPerInt);\\n      const endsPtr = _malloc(sentenceCount * bytesPerInt);\\n      if (!startsPtr || !endsPtr) {\\n        throw new Error(\\\"Failed to allocate WASM memory for segmentation.\\\");\\n      }\\n      let sentenceEndUTF8 = 0;\\n      sentencesUTF16.forEach(({ segment: sentenceUTF16 }, index) => {\\n        const sentenceStartUTF8 = sentenceEndUTF8;\\n        sentenceEndUTF8 += lengthBytesUTF8(sentenceUTF16);\\n        setValue(startsPtr + index * bytesPerInt, sentenceStartUTF8, \\\"i32\\\");\\n        setValue(endsPtr + index * bytesPerInt, sentenceEndUTF8, \\\"i32\\\");\\n      });\\n      setValue($2, sentenceCount, \\\"i32\\\");\\n      setValue($3, startsPtr, \\\"i32\\\");\\n      setValue($4, endsPtr, \\\"i32\\\");\\n    },\\n  };\\n\\n  function callRuntimeCallbacks(callbacks) {\\n    while (callbacks.length) {\\n      var callback = callbacks.shift();\\n      if (typeof callback == \\\"function\\\") {\\n        callback(Module);\\n        continue;\\n      }\\n      var func = callback.func;\\n      if (typeof func == \\\"number\\\") {\\n        if (callback.arg === undefined) {\\n          getWasmTableEntry(func)();\\n        } else {\\n          getWasmTableEntry(func)(callback.arg);\\n        }\\n      } else {\\n        func(callback.arg === undefined ? null : callback.arg);\\n      }\\n    }\\n  }\\n\\n  function asmjsMangle(x) {\\n    var unmangledSymbols = [\\\"stackAlloc\\\", \\\"stackSave\\\", \\\"stackRestore\\\"];\\n    return x.indexOf(\\\"dynCall_\\\") == 0 || unmangledSymbols.includes(x)\\n      ? x\\n      : \\\"_\\\" + x;\\n  }\\n\\n  function exportAsmFunctions(asm) {\\n    var global_object = this;\\n    for (var __exportedFunc in asm) {\\n      var jsname = asmjsMangle(__exportedFunc);\\n      global_object[jsname] = Module[jsname] = asm[__exportedFunc];\\n    }\\n  }\\n\\n  var wasmTableMirror = [];\\n\\n  function getWasmTableEntry(funcPtr) {\\n    var func = wasmTableMirror[funcPtr];\\n    if (!func) {\\n      if (funcPtr >= wasmTableMirror.length) {\\n        wasmTableMirror.length = funcPtr + 1;\\n      }\\n      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\\n    }\\n    return func;\\n  }\\n\\n  function ___assert_fail(condition, filename, line, func) {\\n    abort(\\n      \\\"Assertion failed: \\\" +\\n        UTF8ToString(condition) +\\n        \\\", at: \\\" +\\n        [\\n          filename ? UTF8ToString(filename) : \\\"unknown filename\\\",\\n          line,\\n          func ? UTF8ToString(func) : \\\"unknown function\\\",\\n        ]\\n    );\\n  }\\n\\n  function ___cxa_allocate_exception(size) {\\n    return _malloc(size + 16) + 16;\\n  }\\n\\n  var exceptionCaught = [];\\n\\n  var exceptionLast = 0;\\n\\n  var uncaughtExceptionCount = 0;\\n\\n  function ___cxa_rethrow() {\\n    var catchInfo = exceptionCaught.pop();\\n    if (!catchInfo) {\\n      abort(\\\"no exception to throw\\\");\\n    }\\n    var info = catchInfo.get_exception_info();\\n    var ptr = catchInfo.get_base_ptr();\\n    if (!info.get_rethrown()) {\\n      exceptionCaught.push(catchInfo);\\n      info.set_rethrown(true);\\n      info.set_caught(false);\\n      uncaughtExceptionCount++;\\n    } else {\\n      catchInfo.free();\\n    }\\n    exceptionLast = ptr;\\n    throw ptr;\\n  }\\n\\n  function ExceptionInfo(excPtr) {\\n    this.excPtr = excPtr;\\n    this.ptr = excPtr - 16;\\n    this.set_type = function (type) {\\n      HEAP32[(this.ptr + 4) >> 2] = type;\\n    };\\n    this.get_type = function () {\\n      return HEAP32[(this.ptr + 4) >> 2];\\n    };\\n    this.set_destructor = function (destructor) {\\n      HEAP32[(this.ptr + 8) >> 2] = destructor;\\n    };\\n    this.get_destructor = function () {\\n      return HEAP32[(this.ptr + 8) >> 2];\\n    };\\n    this.set_refcount = function (refcount) {\\n      HEAP32[this.ptr >> 2] = refcount;\\n    };\\n    this.set_caught = function (caught) {\\n      caught = caught ? 1 : 0;\\n      HEAP8[(this.ptr + 12) >> 0] = caught;\\n    };\\n    this.get_caught = function () {\\n      return HEAP8[(this.ptr + 12) >> 0] != 0;\\n    };\\n    this.set_rethrown = function (rethrown) {\\n      rethrown = rethrown ? 1 : 0;\\n      HEAP8[(this.ptr + 13) >> 0] = rethrown;\\n    };\\n    this.get_rethrown = function () {\\n      return HEAP8[(this.ptr + 13) >> 0] != 0;\\n    };\\n    this.init = function (type, destructor) {\\n      this.set_type(type);\\n      this.set_destructor(destructor);\\n      this.set_refcount(0);\\n      this.set_caught(false);\\n      this.set_rethrown(false);\\n    };\\n    this.add_ref = function () {\\n      var value = HEAP32[this.ptr >> 2];\\n      HEAP32[this.ptr >> 2] = value + 1;\\n    };\\n    this.release_ref = function () {\\n      var prev = HEAP32[this.ptr >> 2];\\n      HEAP32[this.ptr >> 2] = prev - 1;\\n      return prev === 1;\\n    };\\n  }\\n\\n  function ___cxa_throw(ptr, type, destructor) {\\n    var info = new ExceptionInfo(ptr);\\n    info.init(type, destructor);\\n    exceptionLast = ptr;\\n    uncaughtExceptionCount++;\\n    throw ptr;\\n  }\\n\\n  var SYSCALLS = {\\n    buffers: [null, [], []],\\n    printChar(stream, curr) {\\n      var buffer = SYSCALLS.buffers[stream];\\n      if (curr === 0 || curr === 10) {\\n        (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\\n        buffer.length = 0;\\n      } else {\\n        buffer.push(curr);\\n      }\\n    },\\n    varargs: undefined,\\n    get() {\\n      SYSCALLS.varargs += 4;\\n      var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];\\n      return ret;\\n    },\\n    getStr(ptr) {\\n      var ret = UTF8ToString(ptr);\\n      return ret;\\n    },\\n    get64(low, high) {\\n      return low;\\n    },\\n  };\\n\\n  function ___syscall_faccessat(dirfd, path, amode, flags) {\\n    path = SYSCALLS.getStr(path);\\n    path = SYSCALLS.calculateAt(dirfd, path);\\n    return SYSCALLS.doAccess(path, amode);\\n  }\\n\\n  function ___syscall_fcntl64(fd, cmd, varargs) {\\n    SYSCALLS.varargs = varargs;\\n    return 0;\\n  }\\n\\n  function ___syscall_fstat64(fd, buf) {}\\n\\n  function ___syscall_getcwd(buf, size) {}\\n\\n  function ___syscall_ioctl(fd, op, varargs) {\\n    SYSCALLS.varargs = varargs;\\n    return 0;\\n  }\\n\\n  function ___syscall_lstat64(path, buf) {}\\n\\n  function ___syscall_newfstatat(dirfd, path, buf, flags) {}\\n\\n  function ___syscall_openat(dirfd, path, flags, varargs) {\\n    SYSCALLS.varargs = varargs;\\n  }\\n\\n  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {}\\n\\n  function ___syscall_rmdir(path) {}\\n\\n  function ___syscall_stat64(path, buf) {}\\n\\n  function ___syscall_unlinkat(dirfd, path, flags) {}\\n\\n  var structRegistrations = {};\\n\\n  function runDestructors(destructors) {\\n    while (destructors.length) {\\n      var ptr = destructors.pop();\\n      var del = destructors.pop();\\n      del(ptr);\\n    }\\n  }\\n\\n  function simpleReadValueFromPointer(pointer) {\\n    return this.fromWireType(HEAPU32[pointer >> 2]);\\n  }\\n\\n  var awaitingDependencies = {};\\n\\n  var registeredTypes = {};\\n\\n  var typeDependencies = {};\\n\\n  var char_0 = 48;\\n\\n  var char_9 = 57;\\n\\n  function makeLegalFunctionName(name) {\\n    if (undefined === name) {\\n      return \\\"_unknown\\\";\\n    }\\n    name = name.replace(/[^a-zA-Z0-9_]/g, \\\"$\\\");\\n    var f = name.charCodeAt(0);\\n    if (f >= char_0 && f <= char_9) {\\n      return \\\"_\\\" + name;\\n    }\\n    return name;\\n  }\\n\\n  function createNamedFunction(name, body) {\\n    name = makeLegalFunctionName(name);\\n    return function () {\\n      null;\\n      return body.apply(this, arguments);\\n    };\\n  }\\n\\n  function extendError(baseErrorType, errorName) {\\n    var errorClass = createNamedFunction(errorName, function (message) {\\n      this.name = errorName;\\n      this.message = message;\\n      var stack = new Error(message).stack;\\n      if (stack !== undefined) {\\n        this.stack =\\n          this.toString() + \\\"\\\\n\\\" + stack.replace(/^Error(:[^\\\\n]*)?\\\\n/, \\\"\\\");\\n      }\\n    });\\n    errorClass.prototype = Object.create(baseErrorType.prototype);\\n    errorClass.prototype.constructor = errorClass;\\n    errorClass.prototype.toString = function () {\\n      if (this.message === undefined) {\\n        return this.name;\\n      }\\n      return this.name + \\\": \\\" + this.message;\\n    };\\n    return errorClass;\\n  }\\n\\n  var InternalError = undefined;\\n\\n  function throwInternalError(message) {\\n    throw new InternalError(message);\\n  }\\n\\n  function whenDependentTypesAreResolved(\\n    myTypes,\\n    dependentTypes,\\n    getTypeConverters\\n  ) {\\n    myTypes.forEach(function (type) {\\n      typeDependencies[type] = dependentTypes;\\n    });\\n    function onComplete(typeConverters) {\\n      var myTypeConverters = getTypeConverters(typeConverters);\\n      if (myTypeConverters.length !== myTypes.length) {\\n        throwInternalError(\\\"Mismatched type converter count\\\");\\n      }\\n      for (var i = 0; i < myTypes.length; ++i) {\\n        registerType(myTypes[i], myTypeConverters[i]);\\n      }\\n    }\\n    var typeConverters = new Array(dependentTypes.length);\\n    var unregisteredTypes = [];\\n    var registered = 0;\\n    dependentTypes.forEach((dt, i) => {\\n      if (registeredTypes.hasOwnProperty(dt)) {\\n        typeConverters[i] = registeredTypes[dt];\\n      } else {\\n        unregisteredTypes.push(dt);\\n        if (!awaitingDependencies.hasOwnProperty(dt)) {\\n          awaitingDependencies[dt] = [];\\n        }\\n        awaitingDependencies[dt].push(() => {\\n          typeConverters[i] = registeredTypes[dt];\\n          ++registered;\\n          if (registered === unregisteredTypes.length) {\\n            onComplete(typeConverters);\\n          }\\n        });\\n      }\\n    });\\n    if (0 === unregisteredTypes.length) {\\n      onComplete(typeConverters);\\n    }\\n  }\\n\\n  function __embind_finalize_value_object(structType) {\\n    var reg = structRegistrations[structType];\\n    delete structRegistrations[structType];\\n    var rawConstructor = reg.rawConstructor;\\n    var rawDestructor = reg.rawDestructor;\\n    var fieldRecords = reg.fields;\\n    var fieldTypes = fieldRecords\\n      .map(field => field.getterReturnType)\\n      .concat(fieldRecords.map(field => field.setterArgumentType));\\n    whenDependentTypesAreResolved([structType], fieldTypes, fieldTypes => {\\n      var fields = {};\\n      fieldRecords.forEach((field, i) => {\\n        var fieldName = field.fieldName;\\n        var getterReturnType = fieldTypes[i];\\n        var getter = field.getter;\\n        var getterContext = field.getterContext;\\n        var setterArgumentType = fieldTypes[i + fieldRecords.length];\\n        var setter = field.setter;\\n        var setterContext = field.setterContext;\\n        fields[fieldName] = {\\n          read: ptr => {\\n            return getterReturnType.fromWireType(getter(getterContext, ptr));\\n          },\\n          write: (ptr, o) => {\\n            var destructors = [];\\n            setter(\\n              setterContext,\\n              ptr,\\n              setterArgumentType.toWireType(destructors, o, \\\"foo1\\\")\\n            );\\n            runDestructors(destructors);\\n          },\\n        };\\n      });\\n      return [\\n        {\\n          name: reg.name,\\n          fromWireType: function (ptr) {\\n            var rv = {};\\n            for (var i in fields) {\\n              rv[i] = fields[i].read(ptr);\\n            }\\n            rawDestructor(ptr);\\n            return rv;\\n          },\\n          toWireType: function (destructors, o) {\\n            for (var fieldName in fields) {\\n              if (!(fieldName in o)) {\\n                throw new TypeError('Missing field:  \\\"' + fieldName + '\\\"');\\n              }\\n            }\\n            var ptr = rawConstructor();\\n            for (fieldName in fields) {\\n              fields[fieldName].write(ptr, o[fieldName]);\\n            }\\n            if (destructors !== null) {\\n              destructors.push(rawDestructor, ptr);\\n            }\\n            return ptr;\\n          },\\n          argPackAdvance: 8,\\n          readValueFromPointer: simpleReadValueFromPointer,\\n          destructorFunction: rawDestructor,\\n        },\\n      ];\\n    });\\n  }\\n\\n  function __embind_register_bigint(\\n    primitiveType,\\n    name,\\n    size,\\n    minRange,\\n    maxRange\\n  ) {}\\n\\n  function getShiftFromSize(size) {\\n    switch (size) {\\n      case 1:\\n        return 0;\\n\\n      case 2:\\n        return 1;\\n\\n      case 4:\\n        return 2;\\n\\n      case 8:\\n        return 3;\\n\\n      default:\\n        throw new TypeError(\\\"Unknown type size: \\\" + size);\\n    }\\n  }\\n\\n  function embind_init_charCodes() {\\n    var codes = new Array(256);\\n    for (var i = 0; i < 256; ++i) {\\n      codes[i] = String.fromCharCode(i);\\n    }\\n    embind_charCodes = codes;\\n  }\\n\\n  var embind_charCodes = undefined;\\n\\n  function readLatin1String(ptr) {\\n    var ret = \\\"\\\";\\n    var c = ptr;\\n    while (HEAPU8[c]) {\\n      ret += embind_charCodes[HEAPU8[c++]];\\n    }\\n    return ret;\\n  }\\n\\n  var BindingError = undefined;\\n\\n  function throwBindingError(message) {\\n    throw new BindingError(message);\\n  }\\n\\n  function registerType(rawType, registeredInstance, options = {}) {\\n    if (!(\\\"argPackAdvance\\\" in registeredInstance)) {\\n      throw new TypeError(\\n        \\\"registerType registeredInstance requires argPackAdvance\\\"\\n      );\\n    }\\n    var name = registeredInstance.name;\\n    if (!rawType) {\\n      throwBindingError(\\n        'type \\\"' + name + '\\\" must have a positive integer typeid pointer'\\n      );\\n    }\\n    if (registeredTypes.hasOwnProperty(rawType)) {\\n      if (options.ignoreDuplicateRegistrations) {\\n        return;\\n      }\\n      throwBindingError(\\\"Cannot register type '\\\" + name + \\\"' twice\\\");\\n    }\\n    registeredTypes[rawType] = registeredInstance;\\n    delete typeDependencies[rawType];\\n    if (awaitingDependencies.hasOwnProperty(rawType)) {\\n      var callbacks = awaitingDependencies[rawType];\\n      delete awaitingDependencies[rawType];\\n      callbacks.forEach(cb => cb());\\n    }\\n  }\\n\\n  function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\\n    var shift = getShiftFromSize(size);\\n    name = readLatin1String(name);\\n    registerType(rawType, {\\n      name,\\n      fromWireType: function (wt) {\\n        return !!wt;\\n      },\\n      toWireType: function (destructors, o) {\\n        return o ? trueValue : falseValue;\\n      },\\n      argPackAdvance: 8,\\n      readValueFromPointer: function (pointer) {\\n        var heap;\\n        if (size === 1) {\\n          heap = HEAP8;\\n        } else if (size === 2) {\\n          heap = HEAP16;\\n        } else if (size === 4) {\\n          heap = HEAP32;\\n        } else {\\n          throw new TypeError(\\\"Unknown boolean type size: \\\" + name);\\n        }\\n        return this.fromWireType(heap[pointer >> shift]);\\n      },\\n      destructorFunction: null,\\n    });\\n  }\\n\\n  function ClassHandle_isAliasOf(other) {\\n    if (!(this instanceof ClassHandle)) {\\n      return false;\\n    }\\n    if (!(other instanceof ClassHandle)) {\\n      return false;\\n    }\\n    var leftClass = this.$$.ptrType.registeredClass;\\n    var left = this.$$.ptr;\\n    var rightClass = other.$$.ptrType.registeredClass;\\n    var right = other.$$.ptr;\\n    while (leftClass.baseClass) {\\n      left = leftClass.upcast(left);\\n      leftClass = leftClass.baseClass;\\n    }\\n    while (rightClass.baseClass) {\\n      right = rightClass.upcast(right);\\n      rightClass = rightClass.baseClass;\\n    }\\n    return leftClass === rightClass && left === right;\\n  }\\n\\n  function shallowCopyInternalPointer(o) {\\n    return {\\n      count: o.count,\\n      deleteScheduled: o.deleteScheduled,\\n      preservePointerOnDelete: o.preservePointerOnDelete,\\n      ptr: o.ptr,\\n      ptrType: o.ptrType,\\n      smartPtr: o.smartPtr,\\n      smartPtrType: o.smartPtrType,\\n    };\\n  }\\n\\n  function throwInstanceAlreadyDeleted(obj) {\\n    function getInstanceTypeName(handle) {\\n      return handle.$$.ptrType.registeredClass.name;\\n    }\\n    throwBindingError(getInstanceTypeName(obj) + \\\" instance already deleted\\\");\\n  }\\n\\n  var finalizationRegistry = false;\\n\\n  function detachFinalizer(handle) {}\\n\\n  function runDestructor($$) {\\n    if ($$.smartPtr) {\\n      $$.smartPtrType.rawDestructor($$.smartPtr);\\n    } else {\\n      $$.ptrType.registeredClass.rawDestructor($$.ptr);\\n    }\\n  }\\n\\n  function releaseClassHandle($$) {\\n    $$.count.value -= 1;\\n    var toDelete = 0 === $$.count.value;\\n    if (toDelete) {\\n      runDestructor($$);\\n    }\\n  }\\n\\n  function downcastPointer(ptr, ptrClass, desiredClass) {\\n    if (ptrClass === desiredClass) {\\n      return ptr;\\n    }\\n    if (undefined === desiredClass.baseClass) {\\n      return null;\\n    }\\n    var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\\n    if (rv === null) {\\n      return null;\\n    }\\n    return desiredClass.downcast(rv);\\n  }\\n\\n  var registeredPointers = {};\\n\\n  function getInheritedInstanceCount() {\\n    return Object.keys(registeredInstances).length;\\n  }\\n\\n  function getLiveInheritedInstances() {\\n    var rv = [];\\n    for (var k in registeredInstances) {\\n      if (registeredInstances.hasOwnProperty(k)) {\\n        rv.push(registeredInstances[k]);\\n      }\\n    }\\n    return rv;\\n  }\\n\\n  var deletionQueue = [];\\n\\n  function flushPendingDeletes() {\\n    while (deletionQueue.length) {\\n      var obj = deletionQueue.pop();\\n      obj.$$.deleteScheduled = false;\\n      obj.delete();\\n    }\\n  }\\n\\n  var delayFunction = undefined;\\n\\n  function setDelayFunction(fn) {\\n    delayFunction = fn;\\n    if (deletionQueue.length && delayFunction) {\\n      delayFunction(flushPendingDeletes);\\n    }\\n  }\\n\\n  function init_embind() {\\n    Module.getInheritedInstanceCount = getInheritedInstanceCount;\\n    Module.getLiveInheritedInstances = getLiveInheritedInstances;\\n    Module.flushPendingDeletes = flushPendingDeletes;\\n    Module.setDelayFunction = setDelayFunction;\\n  }\\n\\n  var registeredInstances = {};\\n\\n  function getBasestPointer(class_, ptr) {\\n    if (ptr === undefined) {\\n      throwBindingError(\\\"ptr should not be undefined\\\");\\n    }\\n    while (class_.baseClass) {\\n      ptr = class_.upcast(ptr);\\n      class_ = class_.baseClass;\\n    }\\n    return ptr;\\n  }\\n\\n  function getInheritedInstance(class_, ptr) {\\n    ptr = getBasestPointer(class_, ptr);\\n    return registeredInstances[ptr];\\n  }\\n\\n  function makeClassHandle(prototype, record) {\\n    if (!record.ptrType || !record.ptr) {\\n      throwInternalError(\\\"makeClassHandle requires ptr and ptrType\\\");\\n    }\\n    var hasSmartPtrType = !!record.smartPtrType;\\n    var hasSmartPtr = !!record.smartPtr;\\n    if (hasSmartPtrType !== hasSmartPtr) {\\n      throwInternalError(\\\"Both smartPtrType and smartPtr must be specified\\\");\\n    }\\n    record.count = {\\n      value: 1,\\n    };\\n    return attachFinalizer(\\n      Object.create(prototype, {\\n        $$: {\\n          value: record,\\n        },\\n      })\\n    );\\n  }\\n\\n  function RegisteredPointer_fromWireType(ptr) {\\n    var rawPointer = this.getPointee(ptr);\\n    if (!rawPointer) {\\n      this.destructor(ptr);\\n      return null;\\n    }\\n    var registeredInstance = getInheritedInstance(\\n      this.registeredClass,\\n      rawPointer\\n    );\\n    if (undefined !== registeredInstance) {\\n      if (0 === registeredInstance.$$.count.value) {\\n        registeredInstance.$$.ptr = rawPointer;\\n        registeredInstance.$$.smartPtr = ptr;\\n        return registeredInstance.clone();\\n      }\\n      var rv = registeredInstance.clone();\\n      this.destructor(ptr);\\n      return rv;\\n    }\\n    function makeDefaultHandle() {\\n      if (this.isSmartPointer) {\\n        return makeClassHandle(this.registeredClass.instancePrototype, {\\n          ptrType: this.pointeeType,\\n          ptr: rawPointer,\\n          smartPtrType: this,\\n          smartPtr: ptr,\\n        });\\n      }\\n      return makeClassHandle(this.registeredClass.instancePrototype, {\\n        ptrType: this,\\n        ptr,\\n      });\\n    }\\n    var actualType = this.registeredClass.getActualType(rawPointer);\\n    var registeredPointerRecord = registeredPointers[actualType];\\n    if (!registeredPointerRecord) {\\n      return makeDefaultHandle.call(this);\\n    }\\n    var toType;\\n    if (this.isConst) {\\n      toType = registeredPointerRecord.constPointerType;\\n    } else {\\n      toType = registeredPointerRecord.pointerType;\\n    }\\n    var dp = downcastPointer(\\n      rawPointer,\\n      this.registeredClass,\\n      toType.registeredClass\\n    );\\n    if (dp === null) {\\n      return makeDefaultHandle.call(this);\\n    }\\n    if (this.isSmartPointer) {\\n      return makeClassHandle(toType.registeredClass.instancePrototype, {\\n        ptrType: toType,\\n        ptr: dp,\\n        smartPtrType: this,\\n        smartPtr: ptr,\\n      });\\n    }\\n    return makeClassHandle(toType.registeredClass.instancePrototype, {\\n      ptrType: toType,\\n      ptr: dp,\\n    });\\n  }\\n\\n  function attachFinalizer(handle) {\\n    if (\\\"undefined\\\" === typeof FinalizationRegistry) {\\n      attachFinalizer = handle => handle;\\n      return handle;\\n    }\\n    finalizationRegistry = new FinalizationRegistry(info => {\\n      releaseClassHandle(info.$$);\\n    });\\n    attachFinalizer = handle => {\\n      var $$ = handle.$$;\\n      var hasSmartPtr = !!$$.smartPtr;\\n      if (hasSmartPtr) {\\n        var info = {\\n          $$,\\n        };\\n        finalizationRegistry.register(handle, info, handle);\\n      }\\n      return handle;\\n    };\\n    detachFinalizer = handle => finalizationRegistry.unregister(handle);\\n    return attachFinalizer(handle);\\n  }\\n\\n  function ClassHandle_clone() {\\n    if (!this.$$.ptr) {\\n      throwInstanceAlreadyDeleted(this);\\n    }\\n    if (this.$$.preservePointerOnDelete) {\\n      this.$$.count.value += 1;\\n      return this;\\n    }\\n    var clone = attachFinalizer(\\n      Object.create(Object.getPrototypeOf(this), {\\n        $$: {\\n          value: shallowCopyInternalPointer(this.$$),\\n        },\\n      })\\n    );\\n    clone.$$.count.value += 1;\\n    clone.$$.deleteScheduled = false;\\n    return clone;\\n  }\\n\\n  function ClassHandle_delete() {\\n    if (!this.$$.ptr) {\\n      throwInstanceAlreadyDeleted(this);\\n    }\\n    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\\n      throwBindingError(\\\"Object already scheduled for deletion\\\");\\n    }\\n    detachFinalizer(this);\\n    releaseClassHandle(this.$$);\\n    if (!this.$$.preservePointerOnDelete) {\\n      this.$$.smartPtr = undefined;\\n      this.$$.ptr = undefined;\\n    }\\n  }\\n\\n  function ClassHandle_isDeleted() {\\n    return !this.$$.ptr;\\n  }\\n\\n  function ClassHandle_deleteLater() {\\n    if (!this.$$.ptr) {\\n      throwInstanceAlreadyDeleted(this);\\n    }\\n    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\\n      throwBindingError(\\\"Object already scheduled for deletion\\\");\\n    }\\n    deletionQueue.push(this);\\n    if (deletionQueue.length === 1 && delayFunction) {\\n      delayFunction(flushPendingDeletes);\\n    }\\n    this.$$.deleteScheduled = true;\\n    return this;\\n  }\\n\\n  function init_ClassHandle() {\\n    ClassHandle.prototype.isAliasOf = ClassHandle_isAliasOf;\\n    ClassHandle.prototype.clone = ClassHandle_clone;\\n    ClassHandle.prototype.delete = ClassHandle_delete;\\n    ClassHandle.prototype.isDeleted = ClassHandle_isDeleted;\\n    ClassHandle.prototype.deleteLater = ClassHandle_deleteLater;\\n  }\\n\\n  function ClassHandle() {}\\n\\n  function ensureOverloadTable(proto, methodName, humanName) {\\n    if (undefined === proto[methodName].overloadTable) {\\n      var prevFunc = proto[methodName];\\n      proto[methodName] = function () {\\n        if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\\n          throwBindingError(\\n            \\\"Function '\\\" +\\n              humanName +\\n              \\\"' called with an invalid number of arguments (\\\" +\\n              arguments.length +\\n              \\\") - expects one of (\\\" +\\n              proto[methodName].overloadTable +\\n              \\\")!\\\"\\n          );\\n        }\\n        return proto[methodName].overloadTable[arguments.length].apply(\\n          this,\\n          arguments\\n        );\\n      };\\n      proto[methodName].overloadTable = [];\\n      proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\\n    }\\n  }\\n\\n  function exposePublicSymbol(name, value, numArguments) {\\n    if (Module.hasOwnProperty(name)) {\\n      if (\\n        undefined === numArguments ||\\n        (undefined !== Module[name].overloadTable &&\\n          undefined !== Module[name].overloadTable[numArguments])\\n      ) {\\n        throwBindingError(\\\"Cannot register public name '\\\" + name + \\\"' twice\\\");\\n      }\\n      ensureOverloadTable(Module, name, name);\\n      if (Module.hasOwnProperty(numArguments)) {\\n        throwBindingError(\\n          \\\"Cannot register multiple overloads of a function with the same number of arguments (\\\" +\\n            numArguments +\\n            \\\")!\\\"\\n        );\\n      }\\n      Module[name].overloadTable[numArguments] = value;\\n    } else {\\n      Module[name] = value;\\n      if (undefined !== numArguments) {\\n        Module[name].numArguments = numArguments;\\n      }\\n    }\\n  }\\n\\n  function RegisteredClass(\\n    name,\\n    constructor,\\n    instancePrototype,\\n    rawDestructor,\\n    baseClass,\\n    getActualType,\\n    upcast,\\n    downcast\\n  ) {\\n    this.name = name;\\n    this.constructor = constructor;\\n    this.instancePrototype = instancePrototype;\\n    this.rawDestructor = rawDestructor;\\n    this.baseClass = baseClass;\\n    this.getActualType = getActualType;\\n    this.upcast = upcast;\\n    this.downcast = downcast;\\n    this.pureVirtualFunctions = [];\\n  }\\n\\n  function upcastPointer(ptr, ptrClass, desiredClass) {\\n    while (ptrClass !== desiredClass) {\\n      if (!ptrClass.upcast) {\\n        throwBindingError(\\n          \\\"Expected null or instance of \\\" +\\n            desiredClass.name +\\n            \\\", got an instance of \\\" +\\n            ptrClass.name\\n        );\\n      }\\n      ptr = ptrClass.upcast(ptr);\\n      ptrClass = ptrClass.baseClass;\\n    }\\n    return ptr;\\n  }\\n\\n  function constNoSmartPtrRawPointerToWireType(destructors, handle) {\\n    if (handle === null) {\\n      if (this.isReference) {\\n        throwBindingError(\\\"null is not a valid \\\" + this.name);\\n      }\\n      return 0;\\n    }\\n    if (!handle.$$) {\\n      throwBindingError(\\n        'Cannot pass \\\"' + _embind_repr(handle) + '\\\" as a ' + this.name\\n      );\\n    }\\n    if (!handle.$$.ptr) {\\n      throwBindingError(\\n        \\\"Cannot pass deleted object as a pointer of type \\\" + this.name\\n      );\\n    }\\n    var handleClass = handle.$$.ptrType.registeredClass;\\n    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\\n    return ptr;\\n  }\\n\\n  function genericPointerToWireType(destructors, handle) {\\n    var ptr;\\n    if (handle === null) {\\n      if (this.isReference) {\\n        throwBindingError(\\\"null is not a valid \\\" + this.name);\\n      }\\n      if (this.isSmartPointer) {\\n        ptr = this.rawConstructor();\\n        if (destructors !== null) {\\n          destructors.push(this.rawDestructor, ptr);\\n        }\\n        return ptr;\\n      }\\n      return 0;\\n    }\\n    if (!handle.$$) {\\n      throwBindingError(\\n        'Cannot pass \\\"' + _embind_repr(handle) + '\\\" as a ' + this.name\\n      );\\n    }\\n    if (!handle.$$.ptr) {\\n      throwBindingError(\\n        \\\"Cannot pass deleted object as a pointer of type \\\" + this.name\\n      );\\n    }\\n    if (!this.isConst && handle.$$.ptrType.isConst) {\\n      throwBindingError(\\n        \\\"Cannot convert argument of type \\\" +\\n          (handle.$$.smartPtrType\\n            ? handle.$$.smartPtrType.name\\n            : handle.$$.ptrType.name) +\\n          \\\" to parameter type \\\" +\\n          this.name\\n      );\\n    }\\n    var handleClass = handle.$$.ptrType.registeredClass;\\n    ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\\n    if (this.isSmartPointer) {\\n      if (undefined === handle.$$.smartPtr) {\\n        throwBindingError(\\\"Passing raw pointer to smart pointer is illegal\\\");\\n      }\\n      switch (this.sharingPolicy) {\\n        case 0:\\n          if (handle.$$.smartPtrType === this) {\\n            ptr = handle.$$.smartPtr;\\n          } else {\\n            throwBindingError(\\n              \\\"Cannot convert argument of type \\\" +\\n                (handle.$$.smartPtrType\\n                  ? handle.$$.smartPtrType.name\\n                  : handle.$$.ptrType.name) +\\n                \\\" to parameter type \\\" +\\n                this.name\\n            );\\n          }\\n          break;\\n\\n        case 1:\\n          ptr = handle.$$.smartPtr;\\n          break;\\n\\n        case 2:\\n          if (handle.$$.smartPtrType === this) {\\n            ptr = handle.$$.smartPtr;\\n          } else {\\n            var clonedHandle = handle.clone();\\n            ptr = this.rawShare(\\n              ptr,\\n              Emval.toHandle(function () {\\n                clonedHandle.delete();\\n              })\\n            );\\n            if (destructors !== null) {\\n              destructors.push(this.rawDestructor, ptr);\\n            }\\n          }\\n          break;\\n\\n        default:\\n          throwBindingError(\\\"Unsupporting sharing policy\\\");\\n      }\\n    }\\n    return ptr;\\n  }\\n\\n  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\\n    if (handle === null) {\\n      if (this.isReference) {\\n        throwBindingError(\\\"null is not a valid \\\" + this.name);\\n      }\\n      return 0;\\n    }\\n    if (!handle.$$) {\\n      throwBindingError(\\n        'Cannot pass \\\"' + _embind_repr(handle) + '\\\" as a ' + this.name\\n      );\\n    }\\n    if (!handle.$$.ptr) {\\n      throwBindingError(\\n        \\\"Cannot pass deleted object as a pointer of type \\\" + this.name\\n      );\\n    }\\n    if (handle.$$.ptrType.isConst) {\\n      throwBindingError(\\n        \\\"Cannot convert argument of type \\\" +\\n          handle.$$.ptrType.name +\\n          \\\" to parameter type \\\" +\\n          this.name\\n      );\\n    }\\n    var handleClass = handle.$$.ptrType.registeredClass;\\n    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\\n    return ptr;\\n  }\\n\\n  function RegisteredPointer_getPointee(ptr) {\\n    if (this.rawGetPointee) {\\n      ptr = this.rawGetPointee(ptr);\\n    }\\n    return ptr;\\n  }\\n\\n  function RegisteredPointer_destructor(ptr) {\\n    if (this.rawDestructor) {\\n      this.rawDestructor(ptr);\\n    }\\n  }\\n\\n  function RegisteredPointer_deleteObject(handle) {\\n    if (handle !== null) {\\n      handle.delete();\\n    }\\n  }\\n\\n  function init_RegisteredPointer() {\\n    RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\\n    RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\\n    RegisteredPointer.prototype.argPackAdvance = 8;\\n    RegisteredPointer.prototype.readValueFromPointer =\\n      simpleReadValueFromPointer;\\n    RegisteredPointer.prototype.deleteObject = RegisteredPointer_deleteObject;\\n    RegisteredPointer.prototype.fromWireType = RegisteredPointer_fromWireType;\\n  }\\n\\n  function RegisteredPointer(\\n    name,\\n    registeredClass,\\n    isReference,\\n    isConst,\\n    isSmartPointer,\\n    pointeeType,\\n    sharingPolicy,\\n    rawGetPointee,\\n    rawConstructor,\\n    rawShare,\\n    rawDestructor\\n  ) {\\n    this.name = name;\\n    this.registeredClass = registeredClass;\\n    this.isReference = isReference;\\n    this.isConst = isConst;\\n    this.isSmartPointer = isSmartPointer;\\n    this.pointeeType = pointeeType;\\n    this.sharingPolicy = sharingPolicy;\\n    this.rawGetPointee = rawGetPointee;\\n    this.rawConstructor = rawConstructor;\\n    this.rawShare = rawShare;\\n    this.rawDestructor = rawDestructor;\\n    if (!isSmartPointer && registeredClass.baseClass === undefined) {\\n      if (isConst) {\\n        this.toWireType = constNoSmartPtrRawPointerToWireType;\\n        this.destructorFunction = null;\\n      } else {\\n        this.toWireType = nonConstNoSmartPtrRawPointerToWireType;\\n        this.destructorFunction = null;\\n      }\\n    } else {\\n      this.toWireType = genericPointerToWireType;\\n    }\\n  }\\n\\n  function replacePublicSymbol(name, value, numArguments) {\\n    if (!Module.hasOwnProperty(name)) {\\n      throwInternalError(\\\"Replacing nonexistant public symbol\\\");\\n    }\\n    if (\\n      undefined !== Module[name].overloadTable &&\\n      undefined !== numArguments\\n    ) {\\n      Module[name].overloadTable[numArguments] = value;\\n    } else {\\n      Module[name] = value;\\n      Module[name].argCount = numArguments;\\n    }\\n  }\\n\\n  function dynCallLegacy(sig, ptr, args) {\\n    var f = Module[\\\"dynCall_\\\" + sig];\\n    return args && args.length\\n      ? f.apply(null, [ptr].concat(args))\\n      : f.call(null, ptr);\\n  }\\n\\n  function dynCall(sig, ptr, args) {\\n    if (sig.includes(\\\"j\\\")) {\\n      return dynCallLegacy(sig, ptr, args);\\n    }\\n    return getWasmTableEntry(ptr).apply(null, args);\\n  }\\n\\n  function getDynCaller(sig, ptr) {\\n    var argCache = [];\\n    return function () {\\n      argCache.length = 0;\\n      Object.assign(argCache, arguments);\\n      return dynCall(sig, ptr, argCache);\\n    };\\n  }\\n\\n  function embind__requireFunction(signature, rawFunction) {\\n    signature = readLatin1String(signature);\\n    function makeDynCaller() {\\n      if (signature.includes(\\\"j\\\")) {\\n        return getDynCaller(signature, rawFunction);\\n      }\\n      return getWasmTableEntry(rawFunction);\\n    }\\n    var fp = makeDynCaller();\\n    if (typeof fp != \\\"function\\\") {\\n      throwBindingError(\\n        \\\"unknown function pointer with signature \\\" +\\n          signature +\\n          \\\": \\\" +\\n          rawFunction\\n      );\\n    }\\n    return fp;\\n  }\\n\\n  var UnboundTypeError = undefined;\\n\\n  function getTypeName(type) {\\n    var ptr = ___getTypeName(type);\\n    var rv = readLatin1String(ptr);\\n    _free(ptr);\\n    return rv;\\n  }\\n\\n  function throwUnboundTypeError(message, types) {\\n    var unboundTypes = [];\\n    var seen = {};\\n    function visit(type) {\\n      if (seen[type]) {\\n        return;\\n      }\\n      if (registeredTypes[type]) {\\n        return;\\n      }\\n      if (typeDependencies[type]) {\\n        typeDependencies[type].forEach(visit);\\n        return;\\n      }\\n      unboundTypes.push(type);\\n      seen[type] = true;\\n    }\\n    types.forEach(visit);\\n    throw new UnboundTypeError(\\n      message + \\\": \\\" + unboundTypes.map(getTypeName).join([\\\", \\\"])\\n    );\\n  }\\n\\n  function __embind_register_class(\\n    rawType,\\n    rawPointerType,\\n    rawConstPointerType,\\n    baseClassRawType,\\n    getActualTypeSignature,\\n    getActualType,\\n    upcastSignature,\\n    upcast,\\n    downcastSignature,\\n    downcast,\\n    name,\\n    destructorSignature,\\n    rawDestructor\\n  ) {\\n    name = readLatin1String(name);\\n    getActualType = embind__requireFunction(\\n      getActualTypeSignature,\\n      getActualType\\n    );\\n    if (upcast) {\\n      upcast = embind__requireFunction(upcastSignature, upcast);\\n    }\\n    if (downcast) {\\n      downcast = embind__requireFunction(downcastSignature, downcast);\\n    }\\n    rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\\n    var legalFunctionName = makeLegalFunctionName(name);\\n    exposePublicSymbol(legalFunctionName, function () {\\n      throwUnboundTypeError(\\n        \\\"Cannot construct \\\" + name + \\\" due to unbound types\\\",\\n        [baseClassRawType]\\n      );\\n    });\\n    whenDependentTypesAreResolved(\\n      [rawType, rawPointerType, rawConstPointerType],\\n      baseClassRawType ? [baseClassRawType] : [],\\n      function (base) {\\n        base = base[0];\\n        var baseClass;\\n        var basePrototype;\\n        if (baseClassRawType) {\\n          baseClass = base.registeredClass;\\n          basePrototype = baseClass.instancePrototype;\\n        } else {\\n          basePrototype = ClassHandle.prototype;\\n        }\\n        var constructor = createNamedFunction(legalFunctionName, function () {\\n          if (Object.getPrototypeOf(this) !== instancePrototype) {\\n            throw new BindingError(\\\"Use 'new' to construct \\\" + name);\\n          }\\n          if (undefined === registeredClass.constructor_body) {\\n            throw new BindingError(name + \\\" has no accessible constructor\\\");\\n          }\\n          var body = registeredClass.constructor_body[arguments.length];\\n          if (undefined === body) {\\n            throw new BindingError(\\n              \\\"Tried to invoke ctor of \\\" +\\n                name +\\n                \\\" with invalid number of parameters (\\\" +\\n                arguments.length +\\n                \\\") - expected (\\\" +\\n                Object.keys(registeredClass.constructor_body).toString() +\\n                \\\") parameters instead!\\\"\\n            );\\n          }\\n          return body.apply(this, arguments);\\n        });\\n        var instancePrototype = Object.create(basePrototype, {\\n          constructor: {\\n            value: constructor,\\n          },\\n        });\\n        constructor.prototype = instancePrototype;\\n        var registeredClass = new RegisteredClass(\\n          name,\\n          constructor,\\n          instancePrototype,\\n          rawDestructor,\\n          baseClass,\\n          getActualType,\\n          upcast,\\n          downcast\\n        );\\n        var referenceConverter = new RegisteredPointer(\\n          name,\\n          registeredClass,\\n          true,\\n          false,\\n          false\\n        );\\n        var pointerConverter = new RegisteredPointer(\\n          name + \\\"*\\\",\\n          registeredClass,\\n          false,\\n          false,\\n          false\\n        );\\n        var constPointerConverter = new RegisteredPointer(\\n          name + \\\" const*\\\",\\n          registeredClass,\\n          false,\\n          true,\\n          false\\n        );\\n        registeredPointers[rawType] = {\\n          pointerType: pointerConverter,\\n          constPointerType: constPointerConverter,\\n        };\\n        replacePublicSymbol(legalFunctionName, constructor);\\n        return [referenceConverter, pointerConverter, constPointerConverter];\\n      }\\n    );\\n  }\\n\\n  function heap32VectorToArray(count, firstElement) {\\n    var array = [];\\n    for (var i = 0; i < count; i++) {\\n      array.push(HEAP32[(firstElement >> 2) + i]);\\n    }\\n    return array;\\n  }\\n\\n  function __embind_register_class_constructor(\\n    rawClassType,\\n    argCount,\\n    rawArgTypesAddr,\\n    invokerSignature,\\n    invoker,\\n    rawConstructor\\n  ) {\\n    assert(argCount > 0);\\n    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\\n    invoker = embind__requireFunction(invokerSignature, invoker);\\n    whenDependentTypesAreResolved([], [rawClassType], function (classType) {\\n      classType = classType[0];\\n      var humanName = \\\"constructor \\\" + classType.name;\\n      if (undefined === classType.registeredClass.constructor_body) {\\n        classType.registeredClass.constructor_body = [];\\n      }\\n      if (\\n        undefined !== classType.registeredClass.constructor_body[argCount - 1]\\n      ) {\\n        throw new BindingError(\\n          \\\"Cannot register multiple constructors with identical number of parameters (\\\" +\\n            (argCount - 1) +\\n            \\\") for class '\\\" +\\n            classType.name +\\n            \\\"'! Overload resolution is currently only performed using the parameter count, not actual type info!\\\"\\n        );\\n      }\\n      classType.registeredClass.constructor_body[argCount - 1] = () => {\\n        throwUnboundTypeError(\\n          \\\"Cannot construct \\\" + classType.name + \\\" due to unbound types\\\",\\n          rawArgTypes\\n        );\\n      };\\n      whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\\n        argTypes.splice(1, 0, null);\\n        classType.registeredClass.constructor_body[argCount - 1] =\\n          craftInvokerFunction(\\n            humanName,\\n            argTypes,\\n            null,\\n            invoker,\\n            rawConstructor\\n          );\\n        return [];\\n      });\\n      return [];\\n    });\\n  }\\n\\n  function craftInvokerFunction(\\n    humanName,\\n    argTypes,\\n    classType,\\n    cppInvokerFunc,\\n    cppTargetFunc\\n  ) {\\n    var argCount = argTypes.length;\\n    if (argCount < 2) {\\n      throwBindingError(\\n        \\\"argTypes array size mismatch! Must at least get return value and 'this' types!\\\"\\n      );\\n    }\\n    var isClassMethodFunc = argTypes[1] !== null && classType !== null;\\n    var needsDestructorStack = false;\\n    for (var i = 1; i < argTypes.length; ++i) {\\n      if (\\n        argTypes[i] !== null &&\\n        argTypes[i].destructorFunction === undefined\\n      ) {\\n        needsDestructorStack = true;\\n        break;\\n      }\\n    }\\n    var returns = argTypes[0].name !== \\\"void\\\";\\n    var expectedArgCount = argCount - 2;\\n    var argsWired = new Array(expectedArgCount);\\n    var invokerFuncArgs = [];\\n    var destructors = [];\\n    return function () {\\n      if (arguments.length !== expectedArgCount) {\\n        throwBindingError(\\n          \\\"function \\\" +\\n            humanName +\\n            \\\" called with \\\" +\\n            arguments.length +\\n            \\\" arguments, expected \\\" +\\n            expectedArgCount +\\n            \\\" args!\\\"\\n        );\\n      }\\n      destructors.length = 0;\\n      var thisWired;\\n      invokerFuncArgs.length = isClassMethodFunc ? 2 : 1;\\n      invokerFuncArgs[0] = cppTargetFunc;\\n      if (isClassMethodFunc) {\\n        thisWired = argTypes[1].toWireType(destructors, this, \\\"foo2\\\");\\n        invokerFuncArgs[1] = thisWired;\\n      }\\n      for (var i = 0; i < expectedArgCount; ++i) {\\n        console.log('[dbg][issam][embind invoke]', humanName, 'argIndex', i, {\\n          expectedType: argTypes[i + 2]?.name,\\n          jsType: typeof arguments[i],\\n          isArrayBuffer: arguments[i] instanceof ArrayBuffer,\\n          isU8: arguments[i] instanceof Uint8Array,\\n          valueCtor: arguments[i]?.constructor?.name\\n        });\\n        if (arguments[i] === undefined) {\\n          console.error('[dbg][issam][embind invoke] ARG IS UNDEFINED at', humanName, 'argIndex', i);\\n          console.trace();\\n        }\\n        argsWired[i] = argTypes[i + 2].toWireType(destructors, arguments[i], \\\"foo3\\\");\\n        invokerFuncArgs.push(argsWired[i]);\\n      }\\n      var rv = cppInvokerFunc.apply(null, invokerFuncArgs);\\n      function onDone(rv) {\\n        if (needsDestructorStack) {\\n          runDestructors(destructors);\\n        } else {\\n          for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; i++) {\\n            var param = i === 1 ? thisWired : argsWired[i - 2];\\n            if (argTypes[i].destructorFunction !== null) {\\n              argTypes[i].destructorFunction(param);\\n            }\\n          }\\n        }\\n        if (returns) {\\n          return argTypes[0].fromWireType(rv);\\n        }\\n      }\\n      return onDone(rv);\\n    };\\n  }\\n\\n  function __embind_register_class_function(\\n    rawClassType,\\n    methodName,\\n    argCount,\\n    rawArgTypesAddr,\\n    invokerSignature,\\n    rawInvoker,\\n    context,\\n    isPureVirtual\\n  ) {\\n    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\\n    methodName = readLatin1String(methodName);\\n    rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\\n    whenDependentTypesAreResolved([], [rawClassType], function (classType) {\\n      classType = classType[0];\\n      var humanName = classType.name + \\\".\\\" + methodName;\\n      if (methodName.startsWith(\\\"@@\\\")) {\\n        methodName = Symbol[methodName.substring(2)];\\n      }\\n      if (isPureVirtual) {\\n        classType.registeredClass.pureVirtualFunctions.push(methodName);\\n      }\\n      function unboundTypesHandler() {\\n        throwUnboundTypeError(\\n          \\\"Cannot call \\\" + humanName + \\\" due to unbound types\\\",\\n          rawArgTypes\\n        );\\n      }\\n      var proto = classType.registeredClass.instancePrototype;\\n      var method = proto[methodName];\\n      if (\\n        undefined === method ||\\n        (undefined === method.overloadTable &&\\n          method.className !== classType.name &&\\n          method.argCount === argCount - 2)\\n      ) {\\n        unboundTypesHandler.argCount = argCount - 2;\\n        unboundTypesHandler.className = classType.name;\\n        proto[methodName] = unboundTypesHandler;\\n      } else {\\n        ensureOverloadTable(proto, methodName, humanName);\\n        proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\\n      }\\n      whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\\n        var memberFunction = craftInvokerFunction(\\n          humanName,\\n          argTypes,\\n          classType,\\n          rawInvoker,\\n          context\\n        );\\n        if (undefined === proto[methodName].overloadTable) {\\n          memberFunction.argCount = argCount - 2;\\n          proto[methodName] = memberFunction;\\n        } else {\\n          proto[methodName].overloadTable[argCount - 2] = memberFunction;\\n        }\\n        return [];\\n      });\\n      return [];\\n    });\\n  }\\n\\n  var emval_free_list = [];\\n\\n  var emval_handle_array = [\\n    {},\\n    {\\n      value: undefined,\\n    },\\n    {\\n      value: null,\\n    },\\n    {\\n      value: true,\\n    },\\n    {\\n      value: false,\\n    },\\n  ];\\n\\n  function __emval_decref(handle) {\\n    if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\\n      emval_handle_array[handle] = undefined;\\n      emval_free_list.push(handle);\\n    }\\n  }\\n\\n  function count_emval_handles() {\\n    var count = 0;\\n    for (var i = 5; i < emval_handle_array.length; ++i) {\\n      if (emval_handle_array[i] !== undefined) {\\n        ++count;\\n      }\\n    }\\n    return count;\\n  }\\n\\n  function get_first_emval() {\\n    for (var i = 5; i < emval_handle_array.length; ++i) {\\n      if (emval_handle_array[i] !== undefined) {\\n        return emval_handle_array[i];\\n      }\\n    }\\n    return null;\\n  }\\n\\n  function init_emval() {\\n    Module.count_emval_handles = count_emval_handles;\\n    Module.get_first_emval = get_first_emval;\\n  }\\n\\n  var Emval = {\\n    toValue: handle => {\\n      if (!handle) {\\n        throwBindingError(\\\"Cannot use deleted val. handle = \\\" + handle);\\n      }\\n      return emval_handle_array[handle].value;\\n    },\\n    toHandle: value => {\\n      switch (value) {\\n        case undefined:\\n          return 1;\\n\\n        case null:\\n          return 2;\\n\\n        case true:\\n          return 3;\\n\\n        case false:\\n          return 4;\\n\\n        default: {\\n          var handle = emval_free_list.length\\n            ? emval_free_list.pop()\\n            : emval_handle_array.length;\\n          emval_handle_array[handle] = {\\n            refcount: 1,\\n            value,\\n          };\\n          return handle;\\n        }\\n      }\\n    },\\n  };\\n\\n  function __embind_register_emval(rawType, name) {\\n    name = readLatin1String(name);\\n    registerType(rawType, {\\n      name,\\n      fromWireType: function (handle) {\\n        var rv = Emval.toValue(handle);\\n        __emval_decref(handle);\\n        return rv;\\n      },\\n      toWireType: function (destructors, value) {\\n        return Emval.toHandle(value);\\n      },\\n      argPackAdvance: 8,\\n      readValueFromPointer: simpleReadValueFromPointer,\\n      destructorFunction: null,\\n    });\\n  }\\n\\n  function _embind_repr(v) {\\n    if (v === null) {\\n      return \\\"null\\\";\\n    }\\n    var t = typeof v;\\n    if (t === \\\"object\\\" || t === \\\"array\\\" || t === \\\"function\\\") {\\n      return v.toString();\\n    }\\n    return \\\"\\\" + v;\\n  }\\n\\n  function floatReadValueFromPointer(name, shift) {\\n    switch (shift) {\\n      case 2:\\n        return function (pointer) {\\n          return this.fromWireType(HEAPF32[pointer >> 2]);\\n        };\\n\\n      case 3:\\n        return function (pointer) {\\n          return this.fromWireType(HEAPF64[pointer >> 3]);\\n        };\\n\\n      default:\\n        throw new TypeError(\\\"Unknown float type: \\\" + name);\\n    }\\n  }\\n\\n  function __embind_register_float(rawType, name, size) {\\n    var shift = getShiftFromSize(size);\\n    name = readLatin1String(name);\\n    registerType(rawType, {\\n      name,\\n      fromWireType: function (value) {\\n        return value;\\n      },\\n      toWireType: function (destructors, value) {\\n        return value;\\n      },\\n      argPackAdvance: 8,\\n      readValueFromPointer: floatReadValueFromPointer(name, shift),\\n      destructorFunction: null,\\n    });\\n  }\\n\\n  function integerReadValueFromPointer(name, shift, signed) {\\n    switch (shift) {\\n      case 0:\\n        return signed\\n          ? function readS8FromPointer(pointer) {\\n              return HEAP8[pointer];\\n            }\\n          : function readU8FromPointer(pointer) {\\n              return HEAPU8[pointer];\\n            };\\n\\n      case 1:\\n        return signed\\n          ? function readS16FromPointer(pointer) {\\n              return HEAP16[pointer >> 1];\\n            }\\n          : function readU16FromPointer(pointer) {\\n              return HEAPU16[pointer >> 1];\\n            };\\n\\n      case 2:\\n        return signed\\n          ? function readS32FromPointer(pointer) {\\n              return HEAP32[pointer >> 2];\\n            }\\n          : function readU32FromPointer(pointer) {\\n              return HEAPU32[pointer >> 2];\\n            };\\n\\n      default:\\n        throw new TypeError(\\\"Unknown integer type: \\\" + name);\\n    }\\n  }\\n\\n  function __embind_register_integer(\\n    primitiveType,\\n    name,\\n    size,\\n    minRange,\\n    maxRange\\n  ) {\\n    name = readLatin1String(name);\\n    if (maxRange === -1) {\\n      maxRange = 4294967295;\\n    }\\n    var shift = getShiftFromSize(size);\\n    var fromWireType = value => value;\\n    if (minRange === 0) {\\n      var bitshift = 32 - 8 * size;\\n      fromWireType = value => (value << bitshift) >>> bitshift;\\n    }\\n    var isUnsignedType = name.includes(\\\"unsigned\\\");\\n    var checkAssertions = (value, toTypeName) => {};\\n    var toWireType;\\n    if (isUnsignedType) {\\n      toWireType = function (destructors, value) {\\n        checkAssertions(value, this.name);\\n        return value >>> 0;\\n      };\\n    } else {\\n      toWireType = function (destructors, value) {\\n        checkAssertions(value, this.name);\\n        return value;\\n      };\\n    }\\n    registerType(primitiveType, {\\n      name,\\n      fromWireType: fromWireType,\\n      toWireType: toWireType,\\n      argPackAdvance: 8,\\n      readValueFromPointer: integerReadValueFromPointer(\\n        name,\\n        shift,\\n        minRange !== 0\\n      ),\\n      destructorFunction: null,\\n    });\\n  }\\n\\n  function __embind_register_memory_view(rawType, dataTypeIndex, name) {\\n    var typeMapping = [\\n      Int8Array,\\n      Uint8Array,\\n      Int16Array,\\n      Uint16Array,\\n      Int32Array,\\n      Uint32Array,\\n      Float32Array,\\n      Float64Array,\\n    ];\\n    var TA = typeMapping[dataTypeIndex];\\n    function decodeMemoryView(handle) {\\n      handle = handle >> 2;\\n      var heap = HEAPU32;\\n      var size = heap[handle];\\n      var data = heap[handle + 1];\\n      return new TA(buffer, data, size);\\n    }\\n    name = readLatin1String(name);\\n    registerType(\\n      rawType,\\n      {\\n        name,\\n        fromWireType: decodeMemoryView,\\n        argPackAdvance: 8,\\n        readValueFromPointer: decodeMemoryView,\\n      },\\n      {\\n        ignoreDuplicateRegistrations: true,\\n      }\\n    );\\n  }\\n\\n  function __embind_register_smart_ptr(\\n    rawType,\\n    rawPointeeType,\\n    name,\\n    sharingPolicy,\\n    getPointeeSignature,\\n    rawGetPointee,\\n    constructorSignature,\\n    rawConstructor,\\n    shareSignature,\\n    rawShare,\\n    destructorSignature,\\n    rawDestructor\\n  ) {\\n    name = readLatin1String(name);\\n    rawGetPointee = embind__requireFunction(getPointeeSignature, rawGetPointee);\\n    rawConstructor = embind__requireFunction(\\n      constructorSignature,\\n      rawConstructor\\n    );\\n    rawShare = embind__requireFunction(shareSignature, rawShare);\\n    rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\\n    whenDependentTypesAreResolved(\\n      [rawType],\\n      [rawPointeeType],\\n      function (pointeeType) {\\n        pointeeType = pointeeType[0];\\n        var registeredPointer = new RegisteredPointer(\\n          name,\\n          pointeeType.registeredClass,\\n          false,\\n          false,\\n          true,\\n          pointeeType,\\n          sharingPolicy,\\n          rawGetPointee,\\n          rawConstructor,\\n          rawShare,\\n          rawDestructor\\n        );\\n        return [registeredPointer];\\n      }\\n    );\\n  }\\n\\n  function __embind_register_std_string(rawType, name) {\\n    name = readLatin1String(name);\\n    var stdStringIsUTF8 = name === \\\"std::string\\\";\\n    registerType(rawType, {\\n      name,\\n      fromWireType: function (value) {\\n        var length = HEAPU32[value >> 2];\\n        var str;\\n        if (stdStringIsUTF8) {\\n          var decodeStartPtr = value + 4;\\n          for (var i = 0; i <= length; ++i) {\\n            var currentBytePtr = value + 4 + i;\\n            if (i == length || HEAPU8[currentBytePtr] == 0) {\\n              var maxRead = currentBytePtr - decodeStartPtr;\\n              var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\\n              if (str === undefined) {\\n                str = stringSegment;\\n              } else {\\n                str += String.fromCharCode(0);\\n                str += stringSegment;\\n              }\\n              decodeStartPtr = currentBytePtr + 1;\\n            }\\n          }\\n        } else {\\n          var a = new Array(length);\\n          for (var i = 0; i < length; ++i) {\\n            a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\\n          }\\n          str = a.join(\\\"\\\");\\n        }\\n        _free(value);\\n        return str;\\n      },\\n      toWireType: function (destructors, value, foo) {\\n        console.log(\\\"[dbg][issam][begamort-translator.js] value:\\\", value, foo);\\n        if (value instanceof ArrayBuffer) {\\n          value = new Uint8Array(value);\\n        }\\n        var getLength;\\n        var valueIsOfTypeString = typeof value == \\\"string\\\";\\n        if (\\n          !(\\n            valueIsOfTypeString ||\\n            value instanceof Uint8Array ||\\n            value instanceof Uint8ClampedArray ||\\n            value instanceof Int8Array\\n          )\\n        ) {\\n          console.log(\\\"[dbg][issam][begamort-translator.js] value:\\\", valueIsOfTypeString, value);\\n          throwBindingError(\\\"Cannot pass non-string to std::string\\\");\\n        }\\n        if (stdStringIsUTF8 && valueIsOfTypeString) {\\n          getLength = () => lengthBytesUTF8(value);\\n        } else {\\n          getLength = () => value.length;\\n        }\\n        var length = getLength();\\n        var ptr = _malloc(4 + length + 1);\\n        HEAPU32[ptr >> 2] = length;\\n        if (stdStringIsUTF8 && valueIsOfTypeString) {\\n          stringToUTF8(value, ptr + 4, length + 1);\\n        } else if (valueIsOfTypeString) {\\n          for (var i = 0; i < length; ++i) {\\n            var charCode = value.charCodeAt(i);\\n            if (charCode > 255) {\\n              _free(ptr);\\n              throwBindingError(\\n                \\\"String has UTF-16 code units that do not fit in 8 bits\\\"\\n              );\\n            }\\n            HEAPU8[ptr + 4 + i] = charCode;\\n          }\\n        } else {\\n          for (var i = 0; i < length; ++i) {\\n            HEAPU8[ptr + 4 + i] = value[i];\\n          }\\n        }\\n        if (destructors !== null) {\\n          destructors.push(_free, ptr);\\n        }\\n        return ptr;\\n      },\\n      argPackAdvance: 8,\\n      readValueFromPointer: simpleReadValueFromPointer,\\n      destructorFunction(ptr) {\\n        _free(ptr);\\n      },\\n    });\\n  }\\n\\n  function __embind_register_std_wstring(rawType, charSize, name) {\\n    name = readLatin1String(name);\\n    var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\\n    if (charSize === 2) {\\n      decodeString = UTF16ToString;\\n      encodeString = stringToUTF16;\\n      lengthBytesUTF = lengthBytesUTF16;\\n      getHeap = () => HEAPU16;\\n      shift = 1;\\n    } else if (charSize === 4) {\\n      decodeString = UTF32ToString;\\n      encodeString = stringToUTF32;\\n      lengthBytesUTF = lengthBytesUTF32;\\n      getHeap = () => HEAPU32;\\n      shift = 2;\\n    }\\n    registerType(rawType, {\\n      name,\\n      fromWireType: function (value) {\\n        var length = HEAPU32[value >> 2];\\n        var HEAP = getHeap();\\n        var str;\\n        var decodeStartPtr = value + 4;\\n        for (var i = 0; i <= length; ++i) {\\n          var currentBytePtr = value + 4 + i * charSize;\\n          if (i == length || HEAP[currentBytePtr >> shift] == 0) {\\n            var maxReadBytes = currentBytePtr - decodeStartPtr;\\n            var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\\n            if (str === undefined) {\\n              str = stringSegment;\\n            } else {\\n              str += String.fromCharCode(0);\\n              str += stringSegment;\\n            }\\n            decodeStartPtr = currentBytePtr + charSize;\\n          }\\n        }\\n        _free(value);\\n        return str;\\n      },\\n      toWireType: function (destructors, value) {\\n        if (!(typeof value == \\\"string\\\")) {\\n          throwBindingError(\\n            \\\"Cannot pass non-string to C++ string type \\\" + name\\n          );\\n        }\\n        var length = lengthBytesUTF(value);\\n        var ptr = _malloc(4 + length + charSize);\\n        HEAPU32[ptr >> 2] = length >> shift;\\n        encodeString(value, ptr + 4, length + charSize);\\n        if (destructors !== null) {\\n          destructors.push(_free, ptr);\\n        }\\n        return ptr;\\n      },\\n      argPackAdvance: 8,\\n      readValueFromPointer: simpleReadValueFromPointer,\\n      destructorFunction(ptr) {\\n        _free(ptr);\\n      },\\n    });\\n  }\\n\\n  function __embind_register_value_object(\\n    rawType,\\n    name,\\n    constructorSignature,\\n    rawConstructor,\\n    destructorSignature,\\n    rawDestructor\\n  ) {\\n    structRegistrations[rawType] = {\\n      name: readLatin1String(name),\\n      rawConstructor: embind__requireFunction(\\n        constructorSignature,\\n        rawConstructor\\n      ),\\n      rawDestructor: embind__requireFunction(\\n        destructorSignature,\\n        rawDestructor\\n      ),\\n      fields: [],\\n    };\\n  }\\n\\n  function __embind_register_value_object_field(\\n    structType,\\n    fieldName,\\n    getterReturnType,\\n    getterSignature,\\n    getter,\\n    getterContext,\\n    setterArgumentType,\\n    setterSignature,\\n    setter,\\n    setterContext\\n  ) {\\n    structRegistrations[structType].fields.push({\\n      fieldName: readLatin1String(fieldName),\\n      getterReturnType,\\n      getter: embind__requireFunction(getterSignature, getter),\\n      getterContext,\\n      setterArgumentType,\\n      setter: embind__requireFunction(setterSignature, setter),\\n      setterContext,\\n    });\\n  }\\n\\n  function __embind_register_void(rawType, name) {\\n    name = readLatin1String(name);\\n    registerType(rawType, {\\n      isVoid: true,\\n      name,\\n      argPackAdvance: 0,\\n      fromWireType: function () {\\n        return undefined;\\n      },\\n      toWireType: function (destructors, o) {\\n        return undefined;\\n      },\\n    });\\n  }\\n\\n  function __emscripten_date_now() {\\n    return Date.now();\\n  }\\n\\n  var nowIsMonotonic = true;\\n\\n  function __emscripten_get_now_is_monotonic() {\\n    return nowIsMonotonic;\\n  }\\n\\n  function requireRegisteredType(rawType, humanName) {\\n    var impl = registeredTypes[rawType];\\n    if (undefined === impl) {\\n      throwBindingError(\\n        humanName + \\\" has unknown type \\\" + getTypeName(rawType)\\n      );\\n    }\\n    return impl;\\n  }\\n\\n  function __emval_lookupTypes(argCount, argTypes) {\\n    var a = new Array(argCount);\\n    for (var i = 0; i < argCount; ++i) {\\n      a[i] = requireRegisteredType(\\n        HEAP32[(argTypes >> 2) + i],\\n        \\\"parameter \\\" + i\\n      );\\n    }\\n    return a;\\n  }\\n\\n  function __emval_call(handle, argCount, argTypes, argv) {\\n    handle = Emval.toValue(handle);\\n    var types = __emval_lookupTypes(argCount, argTypes);\\n    var args = new Array(argCount);\\n    for (var i = 0; i < argCount; ++i) {\\n      var type = types[i];\\n      args[i] = type.readValueFromPointer(argv);\\n      argv += type.argPackAdvance;\\n    }\\n    var rv = handle.apply(undefined, args);\\n    return Emval.toHandle(rv);\\n  }\\n\\n  function __emval_incref(handle) {\\n    if (handle > 4) {\\n      emval_handle_array[handle].refcount += 1;\\n    }\\n  }\\n\\n  function __emval_take_value(type, argv) {\\n    type = requireRegisteredType(type, \\\"_emval_take_value\\\");\\n    var v = type.readValueFromPointer(argv);\\n    return Emval.toHandle(v);\\n  }\\n\\n  function __localtime_js(time, tmPtr) {\\n    var date = new Date(HEAP32[time >> 2] * 1e3);\\n    HEAP32[tmPtr >> 2] = date.getSeconds();\\n    HEAP32[(tmPtr + 4) >> 2] = date.getMinutes();\\n    HEAP32[(tmPtr + 8) >> 2] = date.getHours();\\n    HEAP32[(tmPtr + 12) >> 2] = date.getDate();\\n    HEAP32[(tmPtr + 16) >> 2] = date.getMonth();\\n    HEAP32[(tmPtr + 20) >> 2] = date.getFullYear() - 1900;\\n    HEAP32[(tmPtr + 24) >> 2] = date.getDay();\\n    var start = new Date(date.getFullYear(), 0, 1);\\n    var yday = ((date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24)) | 0;\\n    HEAP32[(tmPtr + 28) >> 2] = yday;\\n    HEAP32[(tmPtr + 36) >> 2] = -(date.getTimezoneOffset() * 60);\\n    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\\n    var winterOffset = start.getTimezoneOffset();\\n    var dst =\\n      (summerOffset != winterOffset &&\\n        date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;\\n    HEAP32[(tmPtr + 32) >> 2] = dst;\\n  }\\n\\n  function __mmap_js(addr, len, prot, flags, fd, off, allocated, builtin) {\\n    return -52;\\n  }\\n\\n  function __munmap_js(addr, len, prot, flags, fd, offset) {}\\n\\n  function _tzset_impl(timezone, daylight, tzname) {\\n    var currentYear = new Date().getFullYear();\\n    var winter = new Date(currentYear, 0, 1);\\n    var summer = new Date(currentYear, 6, 1);\\n    var winterOffset = winter.getTimezoneOffset();\\n    var summerOffset = summer.getTimezoneOffset();\\n    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\\n    HEAP32[timezone >> 2] = stdTimezoneOffset * 60;\\n    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);\\n    function extractZone(date) {\\n      var match = date.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/);\\n      return match ? match[1] : \\\"GMT\\\";\\n    }\\n    var winterName = extractZone(winter);\\n    var summerName = extractZone(summer);\\n    var winterNamePtr = allocateUTF8(winterName);\\n    var summerNamePtr = allocateUTF8(summerName);\\n    if (summerOffset < winterOffset) {\\n      HEAP32[tzname >> 2] = winterNamePtr;\\n      HEAP32[(tzname + 4) >> 2] = summerNamePtr;\\n    } else {\\n      HEAP32[tzname >> 2] = summerNamePtr;\\n      HEAP32[(tzname + 4) >> 2] = winterNamePtr;\\n    }\\n  }\\n\\n  function __tzset_js(timezone, daylight, tzname) {\\n    if (__tzset_js.called) {\\n      return;\\n    }\\n    __tzset_js.called = true;\\n    _tzset_impl(timezone, daylight, tzname);\\n  }\\n\\n  function _abort() {\\n    abort(\\\"\\\");\\n  }\\n\\n  var readAsmConstArgsArray = [];\\n\\n  function readAsmConstArgs(sigPtr, buf) {\\n    readAsmConstArgsArray.length = 0;\\n    var ch;\\n    buf >>= 2;\\n    while ((ch = HEAPU8[sigPtr++])) {\\n      var readAsmConstArgsDouble = ch < 105;\\n      if (readAsmConstArgsDouble && buf & 1) {\\n        buf++;\\n      }\\n      readAsmConstArgsArray.push(\\n        readAsmConstArgsDouble ? HEAPF64[buf++ >> 1] : HEAP32[buf]\\n      );\\n      ++buf;\\n    }\\n    return readAsmConstArgsArray;\\n  }\\n\\n  function _emscripten_asm_const_int(code, sigPtr, argbuf) {\\n    var args = readAsmConstArgs(sigPtr, argbuf);\\n    return ASM_CONSTS[code].apply(null, args);\\n  }\\n\\n  function _emscripten_get_heap_max() {\\n    return 2147483648;\\n  }\\n\\n  var _emscripten_get_now;\\n\\n  _emscripten_get_now = () => performance.now();\\n\\n  function _emscripten_memcpy_big(dest, src, num) {\\n    HEAPU8.copyWithin(dest, src, src + num);\\n  }\\n\\n  function emscripten_realloc_buffer(size) {\\n    try {\\n      wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16);\\n      updateGlobalBufferAndViews(wasmMemory.buffer);\\n      return 1;\\n    } catch (e) {}\\n  }\\n\\n  function _emscripten_resize_heap(requestedSize) {\\n    var oldSize = HEAPU8.length;\\n    requestedSize = requestedSize >>> 0;\\n    var maxHeapSize = _emscripten_get_heap_max();\\n    if (requestedSize > maxHeapSize) {\\n      return false;\\n    }\\n    let alignUp = (x, multiple) => x + ((multiple - (x % multiple)) % multiple);\\n    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\\n      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\\n      overGrownHeapSize = Math.min(\\n        overGrownHeapSize,\\n        requestedSize + 100663296\\n      );\\n      var newSize = Math.min(\\n        maxHeapSize,\\n        alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)\\n      );\\n      var replacement = emscripten_realloc_buffer(newSize);\\n      if (replacement) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  var ENV = {};\\n\\n  function getExecutableName() {\\n    return thisProgram || \\\"./this.program\\\";\\n  }\\n\\n  function getEnvStrings() {\\n    if (!getEnvStrings.strings) {\\n      var lang =\\n        (\\n          (typeof navigator == \\\"object\\\" &&\\n            navigator.languages &&\\n            navigator.languages[0]) ||\\n          \\\"C\\\"\\n        ).replace(\\\"-\\\", \\\"_\\\") + \\\".UTF-8\\\";\\n      var env = {\\n        USER: \\\"web_user\\\",\\n        LOGNAME: \\\"web_user\\\",\\n        PATH: \\\"/\\\",\\n        PWD: \\\"/\\\",\\n        HOME: \\\"/home/web_user\\\",\\n        LANG: lang,\\n        _: getExecutableName(),\\n      };\\n      for (var x in ENV) {\\n        if (ENV[x] === undefined) {\\n          delete env[x];\\n        } else {\\n          env[x] = ENV[x];\\n        }\\n      }\\n      var strings = [];\\n      for (var x in env) {\\n        strings.push(x + \\\"=\\\" + env[x]);\\n      }\\n      getEnvStrings.strings = strings;\\n    }\\n    return getEnvStrings.strings;\\n  }\\n\\n  function _environ_get(__environ, environ_buf) {\\n    var bufSize = 0;\\n    getEnvStrings().forEach(function (string, i) {\\n      var ptr = environ_buf + bufSize;\\n      HEAP32[(__environ + i * 4) >> 2] = ptr;\\n      writeAsciiToMemory(string, ptr);\\n      bufSize += string.length + 1;\\n    });\\n    return 0;\\n  }\\n\\n  function _environ_sizes_get(penviron_count, penviron_buf_size) {\\n    var strings = getEnvStrings();\\n    HEAP32[penviron_count >> 2] = strings.length;\\n    var bufSize = 0;\\n    strings.forEach(function (string) {\\n      bufSize += string.length + 1;\\n    });\\n    HEAP32[penviron_buf_size >> 2] = bufSize;\\n    return 0;\\n  }\\n\\n  function _exit(status) {\\n    exit(status);\\n  }\\n\\n  function _fd_close(fd) {\\n    return 0;\\n  }\\n\\n  function _fd_read(fd, iov, iovcnt, pnum) {\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\n    var num = SYSCALLS.doReadv(stream, iov, iovcnt);\\n    HEAP32[pnum >> 2] = num;\\n    return 0;\\n  }\\n\\n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}\\n\\n  function _fd_write(fd, iov, iovcnt, pnum) {\\n    var num = 0;\\n    for (var i = 0; i < iovcnt; i++) {\\n      var ptr = HEAP32[iov >> 2];\\n      var len = HEAP32[(iov + 4) >> 2];\\n      iov += 8;\\n      for (var j = 0; j < len; j++) {\\n        SYSCALLS.printChar(fd, HEAPU8[ptr + j]);\\n      }\\n      num += len;\\n    }\\n    HEAP32[pnum >> 2] = num;\\n    return 0;\\n  }\\n\\n  function getRandomDevice() {\\n    if (\\n      typeof crypto == \\\"object\\\" &&\\n      typeof crypto.getRandomValues == \\\"function\\\"\\n    ) {\\n      var randomBuffer = new Uint8Array(1);\\n      return function () {\\n        crypto.getRandomValues(randomBuffer);\\n        return randomBuffer[0];\\n      };\\n    }\\n    return function () {\\n      abort(\\\"randomDevice\\\");\\n    };\\n  }\\n\\n  function _getentropy(buffer, size) {\\n    if (!_getentropy.randomDevice) {\\n      _getentropy.randomDevice = getRandomDevice();\\n    }\\n    for (var i = 0; i < size; i++) {\\n      HEAP8[(buffer + i) >> 0] = _getentropy.randomDevice();\\n    }\\n    return 0;\\n  }\\n\\n  function _pclose() {\\n    err(\\\"missing function: pclose\\\");\\n    abort(-1);\\n  }\\n\\n  function _setTempRet0(val) {\\n    setTempRet0(val);\\n  }\\n\\n  function __isLeapYear(year) {\\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\\n  }\\n\\n  function __arraySum(array, index) {\\n    var sum = 0;\\n    for (var i = 0; i <= index; sum += array[i++]) {}\\n    return sum;\\n  }\\n\\n  var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\n  var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\n  function __addDays(date, days) {\\n    var newDate = new Date(date.getTime());\\n    while (days > 0) {\\n      var leap = __isLeapYear(newDate.getFullYear());\\n      var currentMonth = newDate.getMonth();\\n      var daysInCurrentMonth = (\\n        leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR\\n      )[currentMonth];\\n      if (days > daysInCurrentMonth - newDate.getDate()) {\\n        days -= daysInCurrentMonth - newDate.getDate() + 1;\\n        newDate.setDate(1);\\n        if (currentMonth < 11) {\\n          newDate.setMonth(currentMonth + 1);\\n        } else {\\n          newDate.setMonth(0);\\n          newDate.setFullYear(newDate.getFullYear() + 1);\\n        }\\n      } else {\\n        newDate.setDate(newDate.getDate() + days);\\n        return newDate;\\n      }\\n    }\\n    return newDate;\\n  }\\n\\n  function _strftime(s, maxsize, format, tm) {\\n    var tm_zone = HEAP32[(tm + 40) >> 2];\\n    var date = {\\n      tm_sec: HEAP32[tm >> 2],\\n      tm_min: HEAP32[(tm + 4) >> 2],\\n      tm_hour: HEAP32[(tm + 8) >> 2],\\n      tm_mday: HEAP32[(tm + 12) >> 2],\\n      tm_mon: HEAP32[(tm + 16) >> 2],\\n      tm_year: HEAP32[(tm + 20) >> 2],\\n      tm_wday: HEAP32[(tm + 24) >> 2],\\n      tm_yday: HEAP32[(tm + 28) >> 2],\\n      tm_isdst: HEAP32[(tm + 32) >> 2],\\n      tm_gmtoff: HEAP32[(tm + 36) >> 2],\\n      tm_zone: tm_zone ? UTF8ToString(tm_zone) : \\\"\\\",\\n    };\\n    var pattern = UTF8ToString(format);\\n    var EXPANSION_RULES_1 = {\\n      \\\"%c\\\": \\\"%a %b %d %H:%M:%S %Y\\\",\\n      \\\"%D\\\": \\\"%m/%d/%y\\\",\\n      \\\"%F\\\": \\\"%Y-%m-%d\\\",\\n      \\\"%h\\\": \\\"%b\\\",\\n      \\\"%r\\\": \\\"%I:%M:%S %p\\\",\\n      \\\"%R\\\": \\\"%H:%M\\\",\\n      \\\"%T\\\": \\\"%H:%M:%S\\\",\\n      \\\"%x\\\": \\\"%m/%d/%y\\\",\\n      \\\"%X\\\": \\\"%H:%M:%S\\\",\\n      \\\"%Ec\\\": \\\"%c\\\",\\n      \\\"%EC\\\": \\\"%C\\\",\\n      \\\"%Ex\\\": \\\"%m/%d/%y\\\",\\n      \\\"%EX\\\": \\\"%H:%M:%S\\\",\\n      \\\"%Ey\\\": \\\"%y\\\",\\n      \\\"%EY\\\": \\\"%Y\\\",\\n      \\\"%Od\\\": \\\"%d\\\",\\n      \\\"%Oe\\\": \\\"%e\\\",\\n      \\\"%OH\\\": \\\"%H\\\",\\n      \\\"%OI\\\": \\\"%I\\\",\\n      \\\"%Om\\\": \\\"%m\\\",\\n      \\\"%OM\\\": \\\"%M\\\",\\n      \\\"%OS\\\": \\\"%S\\\",\\n      \\\"%Ou\\\": \\\"%u\\\",\\n      \\\"%OU\\\": \\\"%U\\\",\\n      \\\"%OV\\\": \\\"%V\\\",\\n      \\\"%Ow\\\": \\\"%w\\\",\\n      \\\"%OW\\\": \\\"%W\\\",\\n      \\\"%Oy\\\": \\\"%y\\\",\\n    };\\n    for (var rule in EXPANSION_RULES_1) {\\n      pattern = pattern.replace(new RegExp(rule, \\\"g\\\"), EXPANSION_RULES_1[rule]);\\n    }\\n    var WEEKDAYS = [\\n      \\\"Sunday\\\",\\n      \\\"Monday\\\",\\n      \\\"Tuesday\\\",\\n      \\\"Wednesday\\\",\\n      \\\"Thursday\\\",\\n      \\\"Friday\\\",\\n      \\\"Saturday\\\",\\n    ];\\n    var MONTHS = [\\n      \\\"January\\\",\\n      \\\"February\\\",\\n      \\\"March\\\",\\n      \\\"April\\\",\\n      \\\"May\\\",\\n      \\\"June\\\",\\n      \\\"July\\\",\\n      \\\"August\\\",\\n      \\\"September\\\",\\n      \\\"October\\\",\\n      \\\"November\\\",\\n      \\\"December\\\",\\n    ];\\n    function leadingSomething(value, digits, character) {\\n      var str = typeof value == \\\"number\\\" ? value.toString() : value || \\\"\\\";\\n      while (str.length < digits) {\\n        str = character[0] + str;\\n      }\\n      return str;\\n    }\\n    function leadingNulls(value, digits) {\\n      return leadingSomething(value, digits, \\\"0\\\");\\n    }\\n    function compareByDay(date1, date2) {\\n      function sgn(value) {\\n        return value < 0 ? -1 : value > 0 ? 1 : 0;\\n      }\\n      var compare;\\n      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\\n        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\\n          compare = sgn(date1.getDate() - date2.getDate());\\n        }\\n      }\\n      return compare;\\n    }\\n    function getFirstWeekStartDate(janFourth) {\\n      switch (janFourth.getDay()) {\\n        case 0:\\n          return new Date(janFourth.getFullYear() - 1, 11, 29);\\n\\n        case 1:\\n          return janFourth;\\n\\n        case 2:\\n          return new Date(janFourth.getFullYear(), 0, 3);\\n\\n        case 3:\\n          return new Date(janFourth.getFullYear(), 0, 2);\\n\\n        case 4:\\n          return new Date(janFourth.getFullYear(), 0, 1);\\n\\n        case 5:\\n          return new Date(janFourth.getFullYear() - 1, 11, 31);\\n\\n        case 6:\\n          return new Date(janFourth.getFullYear() - 1, 11, 30);\\n      }\\n    }\\n    function getWeekBasedYear(date) {\\n      var thisDate = __addDays(\\n        new Date(date.tm_year + 1900, 0, 1),\\n        date.tm_yday\\n      );\\n      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\\n      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\\n      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\\n      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\\n      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\\n        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\\n          return thisDate.getFullYear() + 1;\\n        }\\n        return thisDate.getFullYear();\\n      }\\n      return thisDate.getFullYear() - 1;\\n    }\\n    var EXPANSION_RULES_2 = {\\n      \\\"%a\\\": function (date) {\\n        return WEEKDAYS[date.tm_wday].substring(0, 3);\\n      },\\n      \\\"%A\\\": function (date) {\\n        return WEEKDAYS[date.tm_wday];\\n      },\\n      \\\"%b\\\": function (date) {\\n        return MONTHS[date.tm_mon].substring(0, 3);\\n      },\\n      \\\"%B\\\": function (date) {\\n        return MONTHS[date.tm_mon];\\n      },\\n      \\\"%C\\\": function (date) {\\n        var year = date.tm_year + 1900;\\n        return leadingNulls((year / 100) | 0, 2);\\n      },\\n      \\\"%d\\\": function (date) {\\n        return leadingNulls(date.tm_mday, 2);\\n      },\\n      \\\"%e\\\": function (date) {\\n        return leadingSomething(date.tm_mday, 2, \\\" \\\");\\n      },\\n      \\\"%g\\\": function (date) {\\n        return getWeekBasedYear(date).toString().substring(2);\\n      },\\n      \\\"%G\\\": function (date) {\\n        return getWeekBasedYear(date);\\n      },\\n      \\\"%H\\\": function (date) {\\n        return leadingNulls(date.tm_hour, 2);\\n      },\\n      \\\"%I\\\": function (date) {\\n        var twelveHour = date.tm_hour;\\n        if (twelveHour == 0) {\\n          twelveHour = 12;\\n        } else if (twelveHour > 12) {\\n          twelveHour -= 12;\\n        }\\n        return leadingNulls(twelveHour, 2);\\n      },\\n      \\\"%j\\\": function (date) {\\n        return leadingNulls(\\n          date.tm_mday +\\n            __arraySum(\\n              __isLeapYear(date.tm_year + 1900)\\n                ? __MONTH_DAYS_LEAP\\n                : __MONTH_DAYS_REGULAR,\\n              date.tm_mon - 1\\n            ),\\n          3\\n        );\\n      },\\n      \\\"%m\\\": function (date) {\\n        return leadingNulls(date.tm_mon + 1, 2);\\n      },\\n      \\\"%M\\\": function (date) {\\n        return leadingNulls(date.tm_min, 2);\\n      },\\n      \\\"%n\\\": function () {\\n        return \\\"\\\\n\\\";\\n      },\\n      \\\"%p\\\": function (date) {\\n        if (date.tm_hour >= 0 && date.tm_hour < 12) {\\n          return \\\"AM\\\";\\n        }\\n        return \\\"PM\\\";\\n      },\\n      \\\"%S\\\": function (date) {\\n        return leadingNulls(date.tm_sec, 2);\\n      },\\n      \\\"%t\\\": function () {\\n        return \\\"\\\\t\\\";\\n      },\\n      \\\"%u\\\": function (date) {\\n        return date.tm_wday || 7;\\n      },\\n      \\\"%U\\\": function (date) {\\n        var days = date.tm_yday + 7 - date.tm_wday;\\n        return leadingNulls(Math.floor(days / 7), 2);\\n      },\\n      \\\"%V\\\": function (date) {\\n        var val = Math.floor((date.tm_yday + 7 - ((date.tm_wday + 6) % 7)) / 7);\\n        if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\\n          val++;\\n        }\\n        if (!val) {\\n          val = 52;\\n          var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\\n          if (\\n            dec31 == 4 ||\\n            (dec31 == 5 && __isLeapYear((date.tm_year % 400) - 1))\\n          ) {\\n            val++;\\n          }\\n        } else if (val == 53) {\\n          var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\\n          if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date.tm_year))) {\\n            val = 1;\\n          }\\n        }\\n        return leadingNulls(val, 2);\\n      },\\n      \\\"%w\\\": function (date) {\\n        return date.tm_wday;\\n      },\\n      \\\"%W\\\": function (date) {\\n        var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);\\n        return leadingNulls(Math.floor(days / 7), 2);\\n      },\\n      \\\"%y\\\": function (date) {\\n        return (date.tm_year + 1900).toString().substring(2);\\n      },\\n      \\\"%Y\\\": function (date) {\\n        return date.tm_year + 1900;\\n      },\\n      \\\"%z\\\": function (date) {\\n        var off = date.tm_gmtoff;\\n        var ahead = off >= 0;\\n        off = Math.abs(off) / 60;\\n        off = (off / 60) * 100 + (off % 60);\\n        return (ahead ? \\\"+\\\" : \\\"-\\\") + String(\\\"0000\\\" + off).slice(-4);\\n      },\\n      \\\"%Z\\\": function (date) {\\n        return date.tm_zone;\\n      },\\n      \\\"%%\\\": function () {\\n        return \\\"%\\\";\\n      },\\n    };\\n    pattern = pattern.replace(/%%/g, \\\"\\\\0\\\\0\\\");\\n    for (var rule in EXPANSION_RULES_2) {\\n      if (pattern.includes(rule)) {\\n        pattern = pattern.replace(\\n          new RegExp(rule, \\\"g\\\"),\\n          EXPANSION_RULES_2[rule](date)\\n        );\\n      }\\n    }\\n    pattern = pattern.replace(/\\\\0\\\\0/g, \\\"%\\\");\\n    var bytes = intArrayFromString(pattern, false);\\n    if (bytes.length > maxsize) {\\n      return 0;\\n    }\\n    writeArrayToMemory(bytes, s);\\n    return bytes.length - 1;\\n  }\\n\\n  function _strftime_l(s, maxsize, format, tm) {\\n    return _strftime(s, maxsize, format, tm);\\n  }\\n\\n  InternalError = Module.InternalError = extendError(Error, \\\"InternalError\\\");\\n\\n  embind_init_charCodes();\\n\\n  BindingError = Module.BindingError = extendError(Error, \\\"BindingError\\\");\\n\\n  init_ClassHandle();\\n\\n  init_embind();\\n\\n  init_RegisteredPointer();\\n\\n  UnboundTypeError = Module.UnboundTypeError = extendError(\\n    Error,\\n    \\\"UnboundTypeError\\\"\\n  );\\n\\n  init_emval();\\n\\n  function intArrayFromString(stringy, dontAddNull, length) {\\n    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\\n    var u8array = new Array(len);\\n    var numBytesWritten = stringToUTF8Array(\\n      stringy,\\n      u8array,\\n      0,\\n      u8array.length\\n    );\\n    if (dontAddNull) {\\n      u8array.length = numBytesWritten;\\n    }\\n    return u8array;\\n  }\\n\\n  var asmLibraryArg = {\\n    __assert_fail: ___assert_fail,\\n    __cxa_allocate_exception: ___cxa_allocate_exception,\\n    __cxa_rethrow: ___cxa_rethrow,\\n    __cxa_throw: ___cxa_throw,\\n    __syscall_faccessat: ___syscall_faccessat,\\n    __syscall_fcntl64: ___syscall_fcntl64,\\n    __syscall_fstat64: ___syscall_fstat64,\\n    __syscall_getcwd: ___syscall_getcwd,\\n    __syscall_ioctl: ___syscall_ioctl,\\n    __syscall_lstat64: ___syscall_lstat64,\\n    __syscall_newfstatat: ___syscall_newfstatat,\\n    __syscall_openat: ___syscall_openat,\\n    __syscall_renameat: ___syscall_renameat,\\n    __syscall_rmdir: ___syscall_rmdir,\\n    __syscall_stat64: ___syscall_stat64,\\n    __syscall_unlinkat: ___syscall_unlinkat,\\n    _embind_finalize_value_object: __embind_finalize_value_object,\\n    _embind_register_bigint: __embind_register_bigint,\\n    _embind_register_bool: __embind_register_bool,\\n    _embind_register_class: __embind_register_class,\\n    _embind_register_class_constructor: __embind_register_class_constructor,\\n    _embind_register_class_function: __embind_register_class_function,\\n    _embind_register_emval: __embind_register_emval,\\n    _embind_register_float: __embind_register_float,\\n    _embind_register_integer: __embind_register_integer,\\n    _embind_register_memory_view: __embind_register_memory_view,\\n    _embind_register_smart_ptr: __embind_register_smart_ptr,\\n    _embind_register_std_string: __embind_register_std_string,\\n    _embind_register_std_wstring: __embind_register_std_wstring,\\n    _embind_register_value_object: __embind_register_value_object,\\n    _embind_register_value_object_field: __embind_register_value_object_field,\\n    _embind_register_void: __embind_register_void,\\n    _emscripten_date_now: __emscripten_date_now,\\n    _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,\\n    _emval_call: __emval_call,\\n    _emval_decref: __emval_decref,\\n    _emval_incref: __emval_incref,\\n    _emval_take_value: __emval_take_value,\\n    _localtime_js: __localtime_js,\\n    _mmap_js: __mmap_js,\\n    _munmap_js: __munmap_js,\\n    _tzset_js: __tzset_js,\\n    abort: _abort,\\n    emscripten_asm_const_int: _emscripten_asm_const_int,\\n    emscripten_get_heap_max: _emscripten_get_heap_max,\\n    emscripten_get_now: _emscripten_get_now,\\n    emscripten_memcpy_big: _emscripten_memcpy_big,\\n    emscripten_resize_heap: _emscripten_resize_heap,\\n    environ_get: _environ_get,\\n    environ_sizes_get: _environ_sizes_get,\\n    exit: _exit,\\n    fd_close: _fd_close,\\n    fd_read: _fd_read,\\n    fd_seek: _fd_seek,\\n    fd_write: _fd_write,\\n    getentropy: _getentropy,\\n    memory: wasmMemory,\\n    pclose: _pclose,\\n    setTempRet0: _setTempRet0,\\n    strftime_l: _strftime_l,\\n  };\\n\\n  var asm = createWasm();\\n\\n  var calledRun;\\n\\n  function ExitStatus(status) {\\n    this.name = \\\"ExitStatus\\\";\\n    this.message = \\\"Program terminated with exit(\\\" + status + \\\")\\\";\\n    this.status = status;\\n  }\\n\\n  dependenciesFulfilled = function runCaller() {\\n    if (!calledRun) {\\n      run();\\n    }\\n    if (!calledRun) {\\n      dependenciesFulfilled = runCaller;\\n    }\\n  };\\n\\n  function run(args) {\\n    args = args || arguments_;\\n    if (runDependencies > 0) {\\n      return;\\n    }\\n    preRun();\\n    if (runDependencies > 0) {\\n      return;\\n    }\\n    function doRun() {\\n      if (calledRun) {\\n        return;\\n      }\\n      calledRun = true;\\n      Module.calledRun = true;\\n      if (ABORT) {\\n        return;\\n      }\\n      initRuntime();\\n      if (Module.onRuntimeInitialized) {\\n        Module.onRuntimeInitialized();\\n      }\\n      postRun();\\n    }\\n    if (Module.setStatus) {\\n      Module.setStatus(\\\"Running...\\\");\\n      setTimeout(function () {\\n        setTimeout(function () {\\n          Module.setStatus(\\\"\\\");\\n        }, 1);\\n        doRun();\\n      }, 1);\\n    } else {\\n      doRun();\\n    }\\n  }\\n\\n  Module.run = run;\\n\\n  function exit(status, implicit) {\\n    EXITSTATUS = status;\\n    procExit(status);\\n  }\\n\\n  function procExit(code) {\\n    EXITSTATUS = code;\\n    if (!keepRuntimeAlive()) {\\n      if (Module.onExit) {\\n        Module.onExit(code);\\n      }\\n      ABORT = true;\\n    }\\n    quit_(code, new ExitStatus(code));\\n  }\\n\\n  if (Module.preInit) {\\n    if (typeof Module.preInit == \\\"function\\\") {\\n      Module.preInit = [Module.preInit];\\n    }\\n    while (Module.preInit.length) {\\n      Module.preInit.pop()();\\n    }\\n  }\\n\\n  run();\\n\\n  /* Use an optimized gemm implementation if available, otherwise use the fallback\\n   * implementation.\\n   */\\n  function createWasmGemm() {\\n    // A map of expected gemm function to the corresponding fallback gemm function names.\\n    const GEMM_TO_FALLBACK_FUNCTIONS_MAP = {\\n      int8_prepare_a: \\\"int8PrepareAFallback\\\",\\n      int8_prepare_b: \\\"int8PrepareBFallback\\\",\\n      int8_prepare_b_from_transposed: \\\"int8PrepareBFromTransposedFallback\\\",\\n      int8_prepare_b_from_quantized_transposed:\\n        \\\"int8PrepareBFromQuantizedTransposedFallback\\\",\\n      int8_prepare_bias: \\\"int8PrepareBiasFallback\\\",\\n      int8_multiply_and_add_bias: \\\"int8MultiplyAndAddBiasFallback\\\",\\n      int8_select_columns_of_b: \\\"int8SelectColumnsOfBFallback\\\",\\n    };\\n\\n    // Name of the optimized gemm implementation.\\n    const OPTIMIZED_GEMM = \\\"mozIntGemm\\\";\\n\\n    const optimizedGemmModule = WebAssembly[OPTIMIZED_GEMM];\\n    if (!optimizedGemmModule) {\\n      return fallbackGemm(GEMM_TO_FALLBACK_FUNCTIONS_MAP);\\n    }\\n\\n    const optimizedGemmModuleExports = new WebAssembly.Instance(\\n      optimizedGemmModule(),\\n      { \\\"\\\": { memory: wasmMemory } }\\n    ).exports;\\n    for (let key in GEMM_TO_FALLBACK_FUNCTIONS_MAP) {\\n      if (!optimizedGemmModuleExports[key]) {\\n        return fallbackGemm(GEMM_TO_FALLBACK_FUNCTIONS_MAP);\\n      }\\n    }\\n    Module.print(`Using optimized gemm (${OPTIMIZED_GEMM}) implementation`);\\n    return optimizedGemmModuleExports;\\n  }\\n\\n  // Return the fallback gemm implementation.\\n  function fallbackGemm(gemmToFallbackFunctionsMap) {\\n    // The fallback gemm implementation\\n    const FALLBACK_GEMM = \\\"asm\\\";\\n\\n    let fallbackGemmModuleExports = {};\\n    for (let key in gemmToFallbackFunctionsMap) {\\n      fallbackGemmModuleExports[key] = (...a) =>\\n        Module[FALLBACK_GEMM][gemmToFallbackFunctionsMap[key]](...a);\\n    }\\n    Module.print(`Using fallback gemm implementation`);\\n    return fallbackGemmModuleExports;\\n  }\\n\\n  return Module;\\n}\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/fathom.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/fathom.mjs ***!
  \*******************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/*\\nDO NOT TOUCH fathom.mjs DIRECTLY. See the README for instructions.\\n*/\\n\\n/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n/**\\n * A :func:`rule` depends on another rule which itself depends on the first\\n * rule again, either directly or indirectly.\\n */\\nclass CycleError extends Error {\\n}\\n\\n/**\\n  * An examined element was not contained in a browser ``window`` object, but\\n  * something needed it to be.\\n  */\\nclass NoWindowError extends Error {\\n}\\n\\nvar exceptions = /*#__PURE__*/Object.freeze({\\n  __proto__: null,\\n  CycleError: CycleError,\\n  NoWindowError: NoWindowError\\n});\\n\\n/**\\n * Return the passed-in arg. Useful as a default.\\n */\\nfunction identity(x) {\\n    return x;\\n}\\n\\n/*eslint-env browser*/\\n\\n/**\\n * From an iterable return the best item, according to an arbitrary comparator\\n * function. In case of a tie, the first item wins.\\n *\\n * @arg by {function} Given an item of the iterable, return a value to compare\\n * @arg isBetter {function} Return whether its first arg is better than its\\n *     second\\n */\\nfunction best(iterable, by, isBetter) {\\n    let bestSoFar, bestKeySoFar;\\n    let isFirst = true;\\n    forEach(\\n        function (item) {\\n            const key = by(item);\\n            if (isBetter(key, bestKeySoFar) || isFirst) {\\n                bestSoFar = item;\\n                bestKeySoFar = key;\\n                isFirst = false;\\n            }\\n        },\\n        iterable);\\n    if (isFirst) {\\n        throw new Error('Tried to call best() on empty iterable');\\n    }\\n    return bestSoFar;\\n}\\n\\n/**\\n * Return the maximum item from an iterable, as defined by >.\\n *\\n * Works with any type that works with >. If multiple items are equally great,\\n * return the first.\\n *\\n * @arg by {function} Given an item of the iterable, returns a value to\\n *     compare\\n */\\nfunction max(iterable, by = identity) {\\n    return best(iterable, by, (a, b) => a > b);\\n}\\n\\n/**\\n * Return an Array of maximum items from an iterable, as defined by > and ===.\\n *\\n * If an empty iterable is passed in, return [].\\n */\\nfunction maxes(iterable, by = identity) {\\n    let bests = [];\\n    let bestKeySoFar;\\n    let isFirst = true;\\n    forEach(\\n        function (item) {\\n            const key = by(item);\\n            if (key > bestKeySoFar || isFirst) {\\n                bests = [item];\\n                bestKeySoFar = key;\\n                isFirst = false;\\n            } else if (key === bestKeySoFar) {\\n                bests.push(item);\\n            }\\n        },\\n        iterable);\\n    return bests;\\n}\\n\\n/**\\n * Return the minimum item from an iterable, as defined by <.\\n *\\n * If multiple items are equally great, return the first.\\n */\\nfunction min(iterable, by = identity) {\\n    return best(iterable, by, (a, b) => a < b);\\n}\\n\\n/**\\n * Return the sum of an iterable, as defined by the + operator.\\n */\\nfunction sum(iterable) {\\n    let total;\\n    let isFirst = true;\\n    forEach(\\n        function assignOrAdd(addend) {\\n            if (isFirst) {\\n                total = addend;\\n                isFirst = false;\\n            } else {\\n                total += addend;\\n            }\\n        },\\n        iterable);\\n    return total;\\n}\\n\\n/**\\n * Return the number of items in an iterable, consuming it as a side effect.\\n */\\nfunction length(iterable) {\\n    let num = 0;\\n    // eslint-disable-next-line no-unused-vars\\n    for (let item of iterable) {\\n        num++;\\n    }\\n    return num;\\n}\\n\\n/**\\n * Iterate, depth first, over a DOM node. Return the original node first.\\n *\\n * @arg shouldTraverse {function} Given a node, say whether we should\\n *     include it and its children. Default: always true.\\n */\\nfunction *walk(element, shouldTraverse = element => true) {\\n    yield element;\\n    for (let child of element.childNodes) {\\n        if (shouldTraverse(child)) {\\n            for (let w of walk(child, shouldTraverse)) {\\n                yield w;\\n            }\\n        }\\n    }\\n}\\n\\nconst blockTags = new Set(\\n    ['ADDRESS', 'BLOCKQUOTE', 'BODY', 'CENTER', 'DIR', 'DIV', 'DL',\\n     'FIELDSET', 'FORM', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HR',\\n     'ISINDEX', 'MENU', 'NOFRAMES', 'NOSCRIPT', 'OL', 'P', 'PRE',\\n     'TABLE', 'UL', 'DD', 'DT', 'FRAMESET', 'LI', 'TBODY', 'TD',\\n     'TFOOT', 'TH', 'THEAD', 'TR', 'HTML']);\\n/**\\n * Return whether a DOM element is a block element by default (rather than by\\n * styling).\\n */\\nfunction isBlock(element) {\\n    return blockTags.has(element.tagName);\\n}\\n\\n/**\\n * Yield strings of text nodes within a normalized DOM node and its children,\\n * without venturing into any contained block elements.\\n *\\n * @arg shouldTraverse {function} Specify additional elements to exclude by\\n *     returning false\\n */\\nfunction *inlineTexts(element, shouldTraverse = element => true) {\\n    // TODO: Could we just use querySelectorAll() with a really long\\n    // selector rather than walk(), for speed?\\n    for (let child of walk(element,\\n                           element => !(isBlock(element) ||\\n                                        element.tagName === 'SCRIPT' &&\\n                                        element.tagName === 'STYLE')\\n                                      && shouldTraverse(element))) {\\n        if (child.nodeType === child.TEXT_NODE) {\\n            // wholeText() is not implemented by jsdom, so we use\\n            // textContent(). The result should be the same, since\\n            // we're calling it on only text nodes, but it may be\\n            // slower. On the positive side, it means we don't need to\\n            // normalize the DOM tree first.\\n            yield child.textContent;\\n        }\\n    }\\n}\\n\\n/**\\n * Return the total length of the inline text within an element, with\\n * whitespace collapsed.\\n *\\n * @arg shouldTraverse {function} Specify additional elements to exclude by\\n *     returning false\\n */\\nfunction inlineTextLength(element, shouldTraverse = element => true) {\\n    return sum(map(text => collapseWhitespace(text).length,\\n                   inlineTexts(element, shouldTraverse)));\\n}\\n\\n/**\\n * Return a string with each run of whitespace collapsed to a single space.\\n */\\nfunction collapseWhitespace(str) {\\n    return str.replace(/\\\\s{2,}/g, ' ');\\n}\\n\\n/**\\n * Return the ratio of the inline text length of the links in an element to the\\n * inline text length of the entire element.\\n *\\n * @arg inlineLength {number} Optionally, the precalculated inline\\n *     length of the fnode. If omitted, we will calculate it ourselves.\\n */\\nfunction linkDensity(fnode, inlineLength) {\\n    if (inlineLength === undefined) {\\n        inlineLength = inlineTextLength(fnode.element);\\n    }\\n    const lengthWithoutLinks = inlineTextLength(fnode.element,\\n                                                element => element.tagName !== 'A');\\n    return (inlineLength - lengthWithoutLinks) / inlineLength;\\n}\\n\\n/**\\n * Return whether an element is a text node that consist wholly of whitespace.\\n */\\nfunction isWhitespace(element) {\\n    return (element.nodeType === element.TEXT_NODE &&\\n            element.textContent.trim().length === 0);\\n}\\n\\n/**\\n * Get a key of a map, first setting it to a default value if it's missing.\\n */\\nfunction setDefault(map, key, defaultMaker) {\\n    if (map.has(key)) {\\n        return map.get(key);\\n    }\\n    const defaultValue = defaultMaker();\\n    map.set(key, defaultValue);\\n    return defaultValue;\\n}\\n\\n/**\\n * Get a key of a map or, if it's missing, a default value.\\n */\\nfunction getDefault(map, key, defaultMaker) {\\n    if (map.has(key)) {\\n        return map.get(key);\\n    }\\n    return defaultMaker();\\n}\\n\\n/**\\n * Return an Array, the reverse topological sort of the given nodes.\\n *\\n * @arg nodes An iterable of arbitrary things\\n * @arg nodesThatNeed {function} Take a node and returns an Array of nodes\\n *     that depend on it\\n */\\nfunction toposort(nodes, nodesThatNeed) {\\n    const ret = [];\\n    const todo = new Set(nodes);\\n    const inProgress = new Set();\\n\\n    function visit(node) {\\n        if (inProgress.has(node)) {\\n            throw new CycleError('The graph has a cycle.');\\n        }\\n        if (todo.has(node)) {\\n            inProgress.add(node);\\n            for (let needer of nodesThatNeed(node)) {\\n                visit(needer);\\n            }\\n            inProgress.delete(node);\\n            todo.delete(node);\\n            ret.push(node);\\n        }\\n    }\\n\\n    while (todo.size > 0) {\\n        visit(first(todo));\\n    }\\n    return ret;\\n}\\n\\n/**\\n * A Set with the additional methods it ought to have had\\n */\\nclass NiceSet extends Set {\\n    /**\\n     * Remove and return an arbitrary item. Throw an Error if I am empty.\\n     */\\n    pop() {\\n        for (let v of this.values()) {\\n            this.delete(v);\\n            return v;\\n        }\\n        throw new Error('Tried to pop from an empty NiceSet.');\\n    }\\n\\n    /**\\n     * Union another set or other iterable into myself.\\n     *\\n     * @return myself, for chaining\\n     */\\n    extend(otherSet) {\\n        for (let item of otherSet) {\\n            this.add(item);\\n        }\\n        return this;\\n    }\\n\\n    /**\\n     * Subtract another set from a copy of me.\\n     *\\n     * @return a copy of myself excluding the elements in ``otherSet``.\\n     */\\n    minus(otherSet) {\\n        const ret = new NiceSet(this);\\n        for (const item of otherSet) {\\n            ret.delete(item);\\n        }\\n        return ret;\\n    }\\n\\n    /**\\n     * Actually show the items in me.\\n     */\\n    toString() {\\n        return '{' + Array.from(this).join(', ') + '}';\\n    }\\n}\\n\\n/**\\n * Return the first item of an iterable.\\n */\\nfunction first(iterable) {\\n    for (let i of iterable) {\\n        return i;\\n    }\\n}\\n\\n/**\\n * Given any node in a DOM tree, return the root element of the tree, generally\\n * an HTML element.\\n */\\nfunction rootElement(element) {\\n    return element.ownerDocument.documentElement;\\n}\\n\\n/**\\n * Return the number of times a regex occurs within the string `haystack`.\\n *\\n * Caller must make sure `regex` has the 'g' option set.\\n */\\nfunction numberOfMatches(regex, haystack) {\\n    return (haystack.match(regex) || []).length;\\n}\\n\\n/**\\n * Wrap a scoring callback, and set its element to the page root iff a score is\\n * returned.\\n *\\n * This is used to build rulesets which classify entire pages rather than\\n * picking out specific elements.\\n *\\n * For example, these rules might classify a page as a \\\"login page\\\", influenced\\n * by whether they have login buttons or username fields:\\n *\\n * ``rule(type('loginPage'), score(page(pageContainsLoginButton))),``\\n * ``rule(type('loginPage'), score(page(pageContainsUsernameField)))``\\n */\\nfunction page(scoringFunction) {\\n    function wrapper(fnode) {\\n        const scoreAndTypeAndNote = scoringFunction(fnode);\\n        if (scoreAndTypeAndNote.score !== undefined) {\\n            scoreAndTypeAndNote.element = rootElement(fnode.element);\\n        }\\n        return scoreAndTypeAndNote;\\n    }\\n    return wrapper;\\n}\\n\\n/**\\n * Sort the elements by their position in the DOM.\\n *\\n * @arg fnodes {iterable} fnodes to sort\\n * @return {Array} sorted fnodes\\n */\\nfunction domSort(fnodes) {\\n    function compare(a, b) {\\n        const element = a.element;\\n        const position = element.compareDocumentPosition(b.element);\\n        if (position & element.DOCUMENT_POSITION_FOLLOWING) {\\n            return -1;\\n        } else if (position & element.DOCUMENT_POSITION_PRECEDING) {\\n            return 1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n    return Array.from(fnodes).sort(compare);\\n}\\n\\n/* istanbul ignore next */\\n/**\\n * Return the DOM element contained in a passed-in fnode. Return passed-in DOM\\n * elements verbatim.\\n *\\n * @arg fnodeOrElement {Node|Fnode}\\n */\\nfunction toDomElement(fnodeOrElement) {\\n    return isDomElement(fnodeOrElement) ? fnodeOrElement : fnodeOrElement.element;\\n}\\n\\n/**\\n * Checks whether any of the element's attribute values satisfy some condition.\\n *\\n * Example::\\n *\\n *     rule(type('foo'),\\n *          score(attributesMatch(element,\\n *                                attr => attr.includes('good'),\\n *                                ['id', 'alt']) ? 2 : 1))\\n *\\n * @arg element {Node} Element whose attributes you want to search\\n * @arg predicate {function} A condition to check. Take a string and\\n *     return a boolean. If an attribute has multiple values (e.g. the class\\n *     attribute), attributesMatch will check each one.\\n * @arg attrs {string[]} An Array of attributes you want to search. If none are\\n *     provided, search all.\\n * @return Whether any of the attribute values satisfy the predicate function\\n */\\nfunction attributesMatch(element, predicate, attrs = []) {\\n    const attributes = attrs.length === 0 ? Array.from(element.attributes).map(a => a.name) : attrs;\\n    for (let i = 0; i < attributes.length; i++) {\\n        const attr = element.getAttribute(attributes[i]);\\n        // If the attribute is an array, apply the scoring function to each element\\n        if (attr && ((Array.isArray(attr) && attr.some(predicate)) || predicate(attr))) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n/* istanbul ignore next */\\n/**\\n * Yield an element and each of its ancestors.\\n */\\nfunction *ancestors(element) {\\n    yield element;\\n    let parent;\\n    while ((parent = element.parentNode) !== null && parent.nodeType === parent.ELEMENT_NODE) {\\n        yield parent;\\n        element = parent;\\n    }\\n}\\n\\n/**\\n * Return the sigmoid of the argument: 1 / (1 + exp(-x)). This is useful for\\n * crunching a feature value that may have a wide range into the range (0, 1)\\n * without a hard ceiling: the sigmoid of even a very large number will be a\\n * little larger than that of a slightly smaller one.\\n *\\n * @arg x {Number} a number to be compressed into the range (0, 1)\\n */\\nfunction sigmoid(x) {\\n    return 1 / (1 + Math.exp(-x));\\n}\\n\\n/* istanbul ignore next */\\n/**\\n * Return whether an element is practically visible, considering things like 0\\n * size or opacity, ``visibility: hidden`` and ``overflow: hidden``.\\n *\\n * Merely being scrolled off the page in either horizontally or vertically\\n * doesn't count as invisible; the result of this function is meant to be\\n * independent of viewport size.\\n *\\n * @throws {NoWindowError} The element (or perhaps one of its ancestors) is not\\n *     in a window, so we can't find the `getComputedStyle()` routine to call.\\n *     That routine is the source of most of the information we use, so you\\n *     should pick a different strategy for non-window contexts.\\n */\\nfunction isVisible(fnodeOrElement) {\\n    // This could be 5x more efficient if https://github.com/w3c/csswg-drafts/issues/4122 happens.\\n    const element = toDomElement(fnodeOrElement);\\n    const elementWindow = windowForElement(element);\\n    const elementRect = element.getBoundingClientRect();\\n    const elementStyle = elementWindow.getComputedStyle(element);\\n    // Alternative to reading ``display: none`` due to Bug 1381071.\\n    if (elementRect.width === 0 && elementRect.height === 0 && elementStyle.overflow !== 'hidden') {\\n        return false;\\n    }\\n    if (elementStyle.visibility === 'hidden') {\\n        return false;\\n    }\\n    // Check if the element is irrevocably off-screen:\\n    if (elementRect.x + elementRect.width < 0 ||\\n        elementRect.y + elementRect.height < 0\\n    ) {\\n        return false;\\n    }\\n    for (const ancestor of ancestors(element)) {\\n        const isElement = ancestor === element;\\n        const style = isElement ? elementStyle : elementWindow.getComputedStyle(ancestor);\\n        if (style.opacity === '0') {\\n            return false;\\n        }\\n        if (style.display === 'contents') {\\n            // ``display: contents`` elements have no box themselves, but children are\\n            // still rendered.\\n            continue;\\n        }\\n        const rect = isElement ? elementRect : ancestor.getBoundingClientRect();\\n        if ((rect.width === 0 || rect.height === 0) && elementStyle.overflow === 'hidden') {\\n            // Zero-sized ancestors don’t make descendants hidden unless the descendant\\n            // has ``overflow: hidden``.\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n/**\\n * Return the extracted [r, g, b, a] values from a string like \\\"rgba(0, 5, 255, 0.8)\\\",\\n * and scale them to 0..1. If no alpha is specified, return undefined for it.\\n */\\nfunction rgbaFromString(str) {\\n    const m = str.match(/^rgba?\\\\s*\\\\(\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*(?:,\\\\s*(\\\\d+(?:\\\\.\\\\d+)?)\\\\s*)?\\\\)$/i);\\n    if (m) {\\n        return [m[1] / 255, m[2] / 255, m[3] / 255, m[4] === undefined ? undefined : parseFloat(m[4])];\\n    } else {\\n        throw new Error('Color ' + str + ' did not match pattern rgb[a](r, g, b[, a]).');\\n    }\\n}\\n\\n/**\\n * Return the saturation 0..1 of a color defined by RGB values 0..1.\\n */\\nfunction saturation(r, g, b) {\\n    const cMax = Math.max(r, g, b);\\n    const cMin = Math.min(r, g, b);\\n    const delta = cMax - cMin;\\n    const lightness = (cMax + cMin) / 2;\\n    const denom = (1 - (Math.abs(2 * lightness - 1)));\\n    // Return 0 if it's black (R, G, and B all 0).\\n    return (denom === 0) ? 0 : delta / denom;\\n}\\n\\n/**\\n * Scale a number to the range [0, 1] using a linear slope.\\n *\\n * For a rising line, the result is 0 until the input reaches zeroAt, then\\n * increases linearly until oneAt, at which it becomes 1. To make a falling\\n * line, where the result is 1 to the left and 0 to the right, use a zeroAt\\n * greater than oneAt.\\n */\\nfunction linearScale(number, zeroAt, oneAt) {\\n    const isRising = zeroAt < oneAt;\\n    if (isRising) {\\n        if (number <= zeroAt) {\\n            return 0;\\n        } else if (number >= oneAt) {\\n            return 1;\\n        }\\n    } else {\\n        if (number >= zeroAt) {\\n            return 0;\\n        } else if (number <= oneAt) {\\n            return 1;\\n        }\\n    }\\n    const slope = 1 / (oneAt - zeroAt);\\n    return slope * (number - zeroAt);\\n}\\n\\n// -------- Routines below this point are private to the framework. --------\\n\\n/**\\n * Flatten out an iterable of iterables into a single iterable of non-\\n * iterables. Does not consider strings to be iterable.\\n */\\nfunction *flatten(iterable) {\\n    for (const i of iterable) {\\n        if (typeof i !== 'string' && isIterable(i)) {\\n            yield *(flatten(i));\\n        } else {\\n            yield i;\\n        }\\n    }\\n}\\n\\n/**\\n * A lazy, top-level ``Array.map()`` workalike that works on anything iterable\\n */\\nfunction *map(fn, iterable) {\\n    for (const i of iterable) {\\n        yield fn(i);\\n    }\\n}\\n\\n/**\\n * A lazy, top-level ``Array.forEach()`` workalike that works on anything\\n * iterable\\n */\\nfunction forEach(fn, iterable) {\\n    for (const i of iterable) {\\n        fn(i);\\n    }\\n}\\n\\n/* istanbul ignore next */\\n/**\\n * @return whether a thing appears to be a DOM element.\\n */\\nfunction isDomElement(thing) {\\n    return thing.nodeName !== undefined;\\n}\\n\\nfunction isIterable(thing) {\\n    return thing && typeof thing[Symbol.iterator] === 'function';\\n}\\n\\n/**\\n * Return an backward iterator over an Array without reversing it in place.\\n */\\nfunction *reversed(array) {\\n    for (let i = array.length - 1; i >= 0; i--) {\\n        yield array[i];\\n    }\\n}\\n\\n/* istanbul ignore next */\\n/*\\n * Return the window an element is in.\\n *\\n * @throws {NoWindowError} There isn't such a window.\\n */\\nfunction windowForElement(element) {\\n    let doc = element.ownerDocument;\\n    if (doc === null) {\\n        // The element itself was a document.\\n        doc = element;\\n    }\\n    const win = doc.defaultView;\\n    if (win === null) {\\n        throw new NoWindowError();\\n    }\\n    return win;\\n}\\n\\nvar utilsForFrontend = /*#__PURE__*/Object.freeze({\\n  __proto__: null,\\n  identity: identity,\\n  best: best,\\n  max: max,\\n  maxes: maxes,\\n  min: min,\\n  sum: sum,\\n  length: length,\\n  walk: walk,\\n  isBlock: isBlock,\\n  inlineTexts: inlineTexts,\\n  inlineTextLength: inlineTextLength,\\n  collapseWhitespace: collapseWhitespace,\\n  linkDensity: linkDensity,\\n  isWhitespace: isWhitespace,\\n  setDefault: setDefault,\\n  getDefault: getDefault,\\n  toposort: toposort,\\n  NiceSet: NiceSet,\\n  first: first,\\n  rootElement: rootElement,\\n  numberOfMatches: numberOfMatches,\\n  page: page,\\n  domSort: domSort,\\n  toDomElement: toDomElement,\\n  attributesMatch: attributesMatch,\\n  ancestors: ancestors,\\n  sigmoid: sigmoid,\\n  isVisible: isVisible,\\n  rgbaFromString: rgbaFromString,\\n  saturation: saturation,\\n  linearScale: linearScale,\\n  flatten: flatten,\\n  map: map,\\n  forEach: forEach,\\n  isDomElement: isDomElement,\\n  reversed: reversed,\\n  windowForElement: windowForElement\\n});\\n\\n/**\\n * Return the number of stride nodes between 2 DOM nodes *at the same\\n * level of the tree*, without going up or down the tree.\\n *\\n * ``left`` xor ``right`` may also be undefined.\\n */\\nfunction numStrides(left, right) {\\n    let num = 0;\\n\\n    // Walk right from left node until we hit the right node or run out:\\n    let sibling = left;\\n    let shouldContinue = sibling && sibling !== right;\\n    while (shouldContinue) {\\n        sibling = sibling.nextSibling;\\n        if ((shouldContinue = sibling && sibling !== right) &&\\n            !isWhitespace(sibling)) {\\n            num += 1;\\n        }\\n    }\\n    if (sibling !== right) {  // Don't double-punish if left and right are siblings.\\n        // Walk left from right node:\\n        sibling = right;\\n        while (sibling) {\\n            sibling = sibling.previousSibling;\\n            if (sibling && !isWhitespace(sibling)) {\\n                num += 1;\\n            }\\n        }\\n    }\\n    return num;\\n}\\n\\n/**\\n * Return a topological distance between 2 DOM nodes or :term:`fnodes<fnode>`\\n * weighted according to the similarity of their ancestry in the DOM. For\\n * instance, if one node is situated inside ``<div><span><b><theNode>`` and the\\n * other node is at ``<differentDiv><span><b><otherNode>``, they are considered\\n * close to each other for clustering purposes. This is useful for picking out\\n * nodes which have similar purposes.\\n *\\n * Return ``Number.MAX_VALUE`` if one of the nodes contains the other.\\n *\\n * This is largely an implementation detail of :func:`clusters`, but you can\\n * call it yourself if you wish to implement your own clustering. Takes O(n log\\n * n) time.\\n *\\n * Note that the default costs may change; pass them in explicitly if they are\\n * important to you.\\n *\\n * @arg fnodeA {Node|Fnode}\\n * @arg fnodeB {Node|Fnode}\\n * @arg differentDepthCost {number} Cost for each level deeper one node is than\\n *    the other below their common ancestor\\n * @arg differentTagCost {number} Cost for a level below the common ancestor\\n *    where tagNames differ\\n * @arg sameTagCost {number} Cost for a level below the common ancestor where\\n *    tagNames are the same\\n * @arg strideCost {number} Cost for each stride node between A and B. Stride\\n *     nodes are siblings or siblings-of-ancestors that lie between the 2\\n *     nodes. These interposed nodes make it less likely that the 2 nodes\\n *     should be together in a cluster.\\n * @arg additionalCost {function} Return an additional cost, given 2 fnodes or\\n *    nodes.\\n *\\n */\\nfunction distance(fnodeA,\\n                         fnodeB,\\n                         {differentDepthCost = 2,\\n                          differentTagCost = 2,\\n                          sameTagCost = 1,\\n                          strideCost = 1,\\n                          additionalCost = (fnodeA, fnodeB) => 0} = {}) {\\n    // I was thinking of something that adds little cost for siblings. Up\\n    // should probably be more expensive than down (see middle example in the\\n    // Nokia paper).\\n\\n    // TODO: Test and tune default costs. They're off the cuff at the moment.\\n\\n    if (fnodeA === fnodeB) {\\n        return 0;\\n    }\\n\\n    const elementA = isDomElement(fnodeA) ? fnodeA : fnodeA.element;\\n    const elementB = isDomElement(fnodeB) ? fnodeB : fnodeB.element;\\n\\n    // Stacks that go from the common ancestor all the way to A and B:\\n    const aAncestors = [elementA];\\n    const bAncestors = [elementB];\\n\\n    let aAncestor = elementA;\\n    let bAncestor = elementB;\\n\\n    // Ascend to common parent, stacking them up for later reference:\\n    while (!aAncestor.contains(elementB)) {  // Note: an element does contain() itself.\\n        aAncestor = aAncestor.parentNode;\\n        aAncestors.push(aAncestor); //aAncestors = [a, b]. aAncestor = b // if a is outer: no loop here; aAncestors = [a]. aAncestor = a.\\n    }\\n\\n    // In compareDocumentPosition()'s opinion, inside implies after. Basically,\\n    // before and after pertain to opening tags.\\n    const comparison = elementA.compareDocumentPosition(elementB);\\n\\n    // If either contains the other, abort. We'd either return a misleading\\n    // number or else walk upward right out of the document while trying to\\n    // make the ancestor stack.\\n    if (comparison & (elementA.DOCUMENT_POSITION_CONTAINS | elementA.DOCUMENT_POSITION_CONTAINED_BY)) {\\n        return Number.MAX_VALUE;\\n    }\\n    // Make an ancestor stack for the right node too so we can walk\\n    // efficiently down to it:\\n    do {\\n        bAncestor = bAncestor.parentNode;  // Assumes we've early-returned above if A === B. This walks upward from the outer node and up out of the tree. It STARTS OUT with aAncestor === bAncestor!\\n        bAncestors.push(bAncestor);\\n    } while (bAncestor !== aAncestor);\\n\\n    // Figure out which node is left and which is right, so we can follow\\n    // sibling links in the appropriate directions when looking for stride\\n    // nodes:\\n    let left = aAncestors;\\n    let right = bAncestors;\\n    let cost = 0;\\n    if (comparison & elementA.DOCUMENT_POSITION_FOLLOWING) {\\n        // A is before, so it could contain the other node. What did I mean to do if one contained the other?\\n        left = aAncestors;\\n        right = bAncestors;\\n    } else if (comparison & elementA.DOCUMENT_POSITION_PRECEDING) {\\n        // A is after, so it might be contained by the other node.\\n        left = bAncestors;\\n        right = aAncestors;\\n    }\\n\\n    // Descend to both nodes in parallel, discounting the traversal\\n    // cost iff the nodes we hit look similar, implying the nodes dwell\\n    // within similar structures.\\n    while (left.length || right.length) {\\n        const l = left.pop();\\n        const r = right.pop();\\n        if (l === undefined || r === undefined) {\\n            // Punishment for being at different depths: same as ordinary\\n            // dissimilarity punishment for now\\n            cost += differentDepthCost;\\n        } else {\\n            // TODO: Consider similarity of classList.\\n            cost += l.tagName === r.tagName ? sameTagCost : differentTagCost;\\n        }\\n        // Optimization: strides might be a good dimension to eliminate.\\n        if (strideCost !== 0) {\\n            cost += numStrides(l, r) * strideCost;\\n        }\\n    }\\n\\n    return cost + additionalCost(fnodeA, fnodeB);\\n}\\n\\n/**\\n * Return the spatial distance between 2 fnodes or elements, assuming a\\n * rendered page.\\n *\\n * Specifically, return the distance in pixels between the centers of\\n * ``fnodeA.element.getBoundingClientRect()`` and\\n * ``fnodeB.element.getBoundingClientRect()``.\\n */\\nfunction euclidean(fnodeA, fnodeB) {\\n    /**\\n     * Return the horizontal distance from the left edge of the viewport to the\\n     * center of an element, given a DOMRect object for it. It doesn't matter\\n     * that the distance is affected by the page's scroll offset, since the 2\\n     * elements have the same offset.\\n     */\\n    function xCenter(domRect) {\\n        return domRect.left + domRect.width / 2;\\n    }\\n    function yCenter(domRect) {\\n        return domRect.top + domRect.height / 2;\\n    }\\n\\n    const elementA = toDomElement(fnodeA);\\n    const elementB = toDomElement(fnodeB);\\n    const aRect = elementA.getBoundingClientRect();\\n    const bRect = elementB.getBoundingClientRect();\\n    return Math.sqrt((xCenter(aRect) - xCenter(bRect)) ** 2 +\\n                     (yCenter(aRect) - yCenter(bRect)) ** 2);\\n}\\n\\n/** A lower-triangular matrix of inter-cluster distances */\\nclass DistanceMatrix {\\n    /**\\n     * @arg distance {function} Some notion of distance between 2 given nodes\\n     */\\n    constructor(elements, distance) {\\n        // A sparse adjacency matrix:\\n        // {A => {},\\n        //  B => {A => 4},\\n        //  C => {A => 4, B => 4},\\n        //  D => {A => 4, B => 4, C => 4}\\n        //  E => {A => 4, B => 4, C => 4, D => 4}}\\n        //\\n        // A, B, etc. are arrays of [arrays of arrays of...] nodes, each\\n        // array being a cluster. In this way, they not only accumulate a\\n        // cluster but retain the steps along the way.\\n        //\\n        // This is an efficient data structure in terms of CPU and memory, in\\n        // that we don't have to slide a lot of memory around when we delete a\\n        // row or column from the middle of the matrix while merging. Of\\n        // course, we lose some practical efficiency by using hash tables, and\\n        // maps in particular are slow in their early implementations.\\n        this._matrix = new Map();\\n\\n        // Convert elements to clusters:\\n        const clusters = elements.map(el => [el]);\\n\\n        // Init matrix:\\n        for (let outerCluster of clusters) {\\n            const innerMap = new Map();\\n            for (let innerCluster of this._matrix.keys()) {\\n                innerMap.set(innerCluster, distance(outerCluster[0],\\n                                                    innerCluster[0]));\\n            }\\n            this._matrix.set(outerCluster, innerMap);\\n        }\\n        this._numClusters = clusters.length;\\n    }\\n\\n    // Return (distance, a: clusterA, b: clusterB) of closest-together clusters.\\n    // Replace this to change linkage criterion.\\n    closest() {\\n        const self = this;\\n\\n        if (this._numClusters < 2) {\\n            throw new Error('There must be at least 2 clusters in order to return the closest() ones.');\\n        }\\n\\n        // Return the distances between every pair of clusters.\\n        function clustersAndDistances() {\\n            const ret = [];\\n            for (let [outerKey, row] of self._matrix.entries()) {\\n                for (let [innerKey, storedDistance] of row.entries()) {\\n                    ret.push({a: outerKey, b: innerKey, distance: storedDistance});\\n                }\\n            }\\n            return ret;\\n        }\\n        // Optimizing this by inlining the loop and writing it less\\n        // functionally doesn't help:\\n        return min(clustersAndDistances(), x => x.distance);\\n    }\\n\\n    // Look up the distance between 2 clusters in me. Try the lookup in the\\n    // other direction if the first one falls in the nonexistent half of the\\n    // triangle.\\n    _cachedDistance(clusterA, clusterB) {\\n        let ret = this._matrix.get(clusterA).get(clusterB);\\n        if (ret === undefined) {\\n            ret = this._matrix.get(clusterB).get(clusterA);\\n        }\\n        return ret;\\n    }\\n\\n    // Merge two clusters.\\n    merge(clusterA, clusterB) {\\n        // An example showing how rows merge:\\n        //  A: {}\\n        //  B: {A: 1}\\n        //  C: {A: 4, B: 4},\\n        //  D: {A: 4, B: 4, C: 4}\\n        //  E: {A: 4, B: 4, C: 2, D: 4}}\\n        //\\n        // Step 2:\\n        //  C: {}\\n        //  D: {C: 4}\\n        //  E: {C: 2, D: 4}}\\n        //  AB: {C: 4, D: 4, E: 4}\\n        //\\n        // Step 3:\\n        //  D:  {}\\n        //  AB: {D: 4}\\n        //  CE: {D: 4, AB: 4}\\n\\n        // Construct new row, finding min distances from either subcluster of\\n        // the new cluster to old clusters.\\n        //\\n        // There will be no repetition in the matrix because, after all,\\n        // nothing pointed to this new cluster before it existed.\\n        const newRow = new Map();\\n        for (let outerKey of this._matrix.keys()) {\\n            if (outerKey !== clusterA && outerKey !== clusterB) {\\n                newRow.set(outerKey, Math.min(this._cachedDistance(clusterA, outerKey),\\n                                              this._cachedDistance(clusterB, outerKey)));\\n            }\\n        }\\n\\n        // Delete the rows of the clusters we're merging.\\n        this._matrix.delete(clusterA);\\n        this._matrix.delete(clusterB);\\n\\n        // Remove inner refs to the clusters we're merging.\\n        for (let inner of this._matrix.values()) {\\n            inner.delete(clusterA);\\n            inner.delete(clusterB);\\n        }\\n\\n        // Attach new row.\\n        this._matrix.set([clusterA, clusterB], newRow);\\n\\n        // There is a net decrease of 1 cluster:\\n        this._numClusters -= 1;\\n    }\\n\\n    numClusters() {\\n        return this._numClusters;\\n    }\\n\\n    // Return an Array of nodes for each cluster in me.\\n    clusters() {\\n        // TODO: Can't get map to work here. Don't know why.\\n        return Array.from(this._matrix.keys()).map(e => Array.from(flatten(e)));\\n    }\\n}\\n\\n/**\\n * Partition the given nodes into one or more clusters by position in the DOM\\n * tree.\\n *\\n * This implements an agglomerative clustering. It uses single linkage, since\\n * we're talking about adjacency here more than Euclidean proximity: the\\n * clusters we're talking about in the DOM will tend to be adjacent, not\\n * overlapping. We haven't tried other linkage criteria yet.\\n *\\n * In a later release, we may consider score or notes.\\n *\\n * @arg {Fnode[]|Node[]} fnodes :term:`fnodes<fnode>` or DOM nodes to group\\n *     into clusters\\n * @arg {number} splittingDistance The closest-nodes :func:`distance` beyond\\n *     which we will not attempt to unify 2 clusters. Make this larger to make\\n *     larger clusters.\\n * @arg getDistance {function} A function that returns some notion of numerical\\n *    distance between 2 nodes. Default: :func:`distance`\\n * @return {Array} An Array of Arrays, with each Array containing all the\\n *     nodes in one cluster. Note that neither the clusters nor the nodes are\\n *     in any particular order. You may find :func:`domSort` helpful to remedy\\n *     the latter.\\n */\\nfunction clusters(fnodes, splittingDistance, getDistance = distance) {\\n    const matrix = new DistanceMatrix(fnodes, getDistance);\\n    let closest;\\n\\n    while (matrix.numClusters() > 1 && (closest = matrix.closest()).distance < splittingDistance) {\\n        matrix.merge(closest.a, closest.b);\\n    }\\n\\n    return matrix.clusters();\\n}\\n\\nvar clusters$1 = /*#__PURE__*/Object.freeze({\\n  __proto__: null,\\n  distance: distance,\\n  euclidean: euclidean,\\n  clusters: clusters\\n});\\n\\n// The left-hand side of a rule\\n\\n\\n/**\\n * Take nodes that match a given DOM selector. Example:\\n * ``dom('meta[property=\\\"og:title\\\"]')``\\n *\\n * Every ruleset has at least one ``dom`` or :func:`element` rule, as that is\\n * where nodes begin to flow into the system. If run against a subtree of a\\n * document, the root of the subtree is not considered as a possible match.\\n */\\nfunction dom(selector) {\\n    return new DomLhs(selector);\\n}\\n\\n/**\\n * Take a single given node if it matches a given DOM selector, without looking\\n * through its descendents or ancestors. Otherwise, take no nodes. Example:\\n * ``element('input')``\\n *\\n * This is useful for applications in which you want Fathom to classify an\\n * element the user has selected, rather than scanning the whole page for\\n * candidates.\\n */\\nfunction element(selector) {\\n    return new ElementLhs(selector);\\n}\\n\\n/**\\n * Rules and the LHSs and RHSs that comprise them have no mutable state. This\\n * lets us make BoundRulesets from Rulesets without duplicating the rules. It\\n * also lets us share a common cache among rules: multiple ones might care\\n * about a cached type(), for instance; there isn't a one-to-one relationship\\n * of storing with caring. There would also, because of the interdependencies\\n * of rules in a ruleset, be little use in segmenting the caches: if you do\\n * something that causes one to need to be cleared, you'll need to clear many\\n * more as well.\\n *\\n * Lhses are responsible for maintaining ruleset.maxCache.\\n *\\n * Lhs and its subclasses are private to the Fathom framework.\\n */\\nclass Lhs {\\n    constructor() {\\n        this._predicate = () => true;\\n    }\\n\\n    /** Return a new Lhs of the appropriate kind, given its first call. */\\n    static fromFirstCall(firstCall) {\\n        // firstCall is never 'dom', because dom() directly returns a DomLhs.\\n        if (firstCall.method === 'type') {\\n            return new TypeLhs(...firstCall.args);\\n        } else if (firstCall.method === 'and') {\\n            return new AndLhs(firstCall.args);\\n        } else if (firstCall.method === 'nearest') {\\n            return new NearestLhs(firstCall.args);\\n        } else {\\n            throw new Error('The left-hand side of a rule() must start with dom(), type(), and(), or nearest().');\\n        }\\n    }\\n\\n    /**\\n     * Prune nodes from consideration early in run execution, before scoring is\\n     * done.\\n     *\\n     * Reserve this for where you are sure it is always correct or when\\n     * performance demands it. It is generally preferable to use :func:`score`\\n     * and let the :doc:`trainer<training>` determine the relative significance\\n     * of each rule. Human intuition as to what is important is often wrong:\\n     * for example, one might assume that a music player website would include\\n     * the word \\\"play\\\", but this does not hold once you include sites in other\\n     * languages.\\n     *\\n     * Can be chained after :func:`type` or :func:`dom`.\\n     *\\n     * Example: ``dom('p').when(isVisible)``\\n     *\\n     * @arg {function} predicate Accepts a fnode and returns a boolean\\n     */\\n    when(predicate) {\\n        let lhs = this.clone();\\n        lhs._predicate = predicate;\\n        return lhs;\\n    }\\n\\n    /**\\n     * Of all the dom nodes selected by type() or dom(), return only\\n     * the fnodes that satisfy all the predicates imposed by calls to\\n     * when()\\n     */\\n    fnodesSatisfyingWhen(fnodes) {\\n        return Array.from(fnodes).filter(this._predicate);\\n    }\\n\\n    /**\\n     * Return an iterable of output fnodes selected by this left-hand-side\\n     * expression.\\n     *\\n     * Pre: The rules I depend on have already been run, and their results are\\n     * in ruleset.typeCache.\\n     *\\n     * @arg ruleset {BoundRuleset}\\n     */\\n    // fnodes (ruleset) {}\\n\\n    /**\\n     * Check that a RHS-emitted fact is legal for this kind of LHS, and throw\\n     * an error if it isn't.\\n     */\\n    checkFact(fact) {}\\n\\n    /**\\n     * Return the single type the output of the LHS is guaranteed to have.\\n     * Return undefined if there is no such single type we can ascertain.\\n     */\\n    guaranteedType() {}\\n\\n    /**\\n     * Return the type I aggregate if I am an aggregate LHS; return undefined\\n     * otherwise.\\n     */\\n    aggregatedType() {}\\n\\n    /**\\n     * Return each combination of types my selected nodes could be locally (that\\n     * is, by this rule only) constrained to have.\\n     *\\n     * For example, type(A) would return [A]. and(A, or(B, C)) would return\\n     * [AB, AC, ABC]. More examples:\\n     *\\n     * or(A, B) → typeIn(A, B, C)  # Finalizes A, B.   combos A, B, AB: finalizes AB. Optimization: there's no point in returning the last combo in ors. Compilation into 2 rules with identical RHSs will inherently implement this optimization.\\n     * or(A, B) → typeIn(A, B)  # Finalizes A, B\\n     * or(A, B) → A  # Finalizes B\\n     * and(A) -> A  # Finalizes nothing\\n     * and(A, B) -> A  # Finalizes nothing.   AB: Ø\\n     * and(A) -> typeIn(A, B)  # Finalizes A.   A\\n     * and(A, B) -> typeIn(A, B)  # Finalizes nothing.   AB\\n     * and(A, B) -> typeIn(A, B, C)  # Finalizes A, B.   AB\\n     * and(A, or(B, C)) -> D  # Finalizes A, B, C.   AB, AC, ABC: ABC\\n     * and(A, or(B, C)) -> B  # Finalizes A, C.   AB, AC, ABC: AC\\n     * type(A).not(and(A, B)) ->\\n     *\\n     * @return {NiceSet[]}\\n     */\\n    // possibleTypeCombinations() {}\\n\\n    /**\\n     * Types mentioned in this LHS.\\n     *\\n     * In other words, the types I need to know the assignment status of before\\n     * I can make my selections\\n     *\\n     * @return NiceSet of strings\\n     */\\n    // typesMentioned() {}\\n}\\n\\nclass DomLhs extends Lhs {\\n    constructor(selector) {\\n        super();\\n        if (selector === undefined) {\\n            throw new Error('A querySelector()-style selector is required as the argument to ' + this._callName() + '().');\\n        }\\n        this.selector = selector;\\n    }\\n\\n    /**\\n     * Return the name of this kind of LHS, for use in error messages.\\n     */\\n    _callName() {\\n        return 'dom';\\n    }\\n\\n    clone() {\\n        return new this.constructor(this.selector);\\n    }\\n\\n    fnodes(ruleset) {\\n        return this._domNodesToFilteredFnodes(\\n            ruleset,\\n            ruleset.doc.querySelectorAll(this.selector));\\n    }\\n\\n    /**\\n     * Turn a NodeList of DOM nodes into an array of fnodes, and filter out\\n     * those that don't match the :func:`when()` clause.\\n     */\\n    _domNodesToFilteredFnodes(ruleset, domNodes) {\\n        let ret = [];\\n        for (let i = 0; i < domNodes.length; i++) {\\n            ret.push(ruleset.fnodeForElement(domNodes[i]));\\n        }\\n        return this.fnodesSatisfyingWhen(ret);\\n    }\\n\\n    checkFact(fact) {\\n        if (fact.type === undefined) {\\n            throw new Error(`The right-hand side of a ${this._callName()}() rule failed to specify a type. This means there is no way for its output to be used by later rules. All it specified was ${fact}.`);\\n        }\\n    }\\n\\n    asLhs() {\\n        return this;\\n    }\\n\\n    possibleTypeCombinations() {\\n        return [];\\n    }\\n\\n    typesMentioned() {\\n        return new NiceSet();\\n    }\\n}\\n\\nclass ElementLhs extends DomLhs {\\n    _callName() {\\n        return 'element';\\n    }\\n\\n    fnodes(ruleset) {\\n        return this._domNodesToFilteredFnodes(\\n            ruleset,\\n            ruleset.doc.matches(this.selector) ? [ruleset.doc] : []);\\n    }\\n}\\n\\n/** Internal representation of a LHS constrained by type but not by max() */\\nclass TypeLhs extends Lhs {\\n    constructor(type) {\\n        super();\\n        if (type === undefined) {\\n            throw new Error('A type name is required when calling type().');\\n        }\\n        this._type = type;  // the input type\\n    }\\n\\n    clone() {\\n        return new this.constructor(this._type);\\n    }\\n\\n    fnodes(ruleset) {\\n        const cached = getDefault(ruleset.typeCache, this._type, () => []);\\n        return this.fnodesSatisfyingWhen(cached);\\n    }\\n\\n    /** Override the type previously specified by this constraint. */\\n    type(inputType) {\\n        // Preserve the class in case this is a TypeMaxLhs.\\n        return new this.constructor(inputType);\\n    }\\n\\n    /**\\n     * Of the nodes selected by a ``type`` call to the left, constrain the LHS\\n     * to return only the max-scoring one. If there is a tie, more than 1 node\\n     * will be returned. Example: ``type('titley').max()``\\n     */\\n    max() {\\n        return new TypeMaxLhs(this._type);\\n    }\\n\\n    /**\\n     * Take the nodes selected by a ``type`` call to the left, group them into\\n     * clusters, and return the nodes in the cluster that has the highest total\\n     * score (on the relevant type).\\n     *\\n     * Nodes come out in arbitrary order, so, if you plan to emit them,\\n     * consider using ``.out('whatever').allThrough(domSort)``. See\\n     * :func:`domSort`.\\n     *\\n     * If multiple clusters have equally high scores, return an arbitrary one,\\n     * because Fathom has no way to represent arrays of arrays in rulesets.\\n     *\\n     * @arg options {Object} The same depth costs taken by :func:`distance`,\\n     *     plus ``splittingDistance``, which is the distance beyond which 2\\n     *     clusters will be considered separate. ``splittingDistance``, if\\n     *     omitted, defaults to 3.\\n     */\\n    bestCluster(options) {\\n        return new BestClusterLhs(this._type, options);\\n    }\\n\\n    // Other clustering calls could be called biggestCluster() (having the most\\n    // nodes) and bestAverageCluster() (having the highest average score).\\n\\n    guaranteedType() {\\n        return this._type;\\n    }\\n\\n    possibleTypeCombinations() {\\n        return [this.typesMentioned()];\\n    }\\n\\n    typesMentioned() {\\n        return new NiceSet([this._type]);\\n    }\\n}\\n\\n/**\\n * Abstract LHS that is an aggregate function taken across all fnodes of a type\\n *\\n * The main point here is that any aggregate function over a (typed) set of\\n * nodes depends on first computing all the rules that could emit those nodes\\n * (nodes of that type).\\n */\\nclass AggregateTypeLhs extends TypeLhs {\\n    aggregatedType() {\\n        return this._type;\\n    }\\n}\\n\\n/**\\n * Internal representation of a LHS that has both type and max([NUMBER])\\n * constraints. max(NUMBER != 1) support is not yet implemented.\\n */\\nclass TypeMaxLhs extends AggregateTypeLhs {\\n    /**\\n     * Return the max-scoring node (or nodes if there is a tie) of the given\\n     * type.\\n     */\\n    fnodes(ruleset) {\\n        // TODO: Optimize better. Walk the dependency tree, and run only the\\n        // rules that could possibly lead to a max result. As part of this,\\n        // make RHSs expose their max potential scores.\\n        const self = this;\\n        // Work around V8 bug:\\n        // https://stackoverflow.com/questions/32943776/using-super-within-an-\\n        // arrow-function-within-an-arrow-function-within-a-method\\n        const getSuperFnodes = () => super.fnodes(ruleset);\\n        return setDefault(\\n            ruleset.maxCache,\\n            this._type,\\n            function maxFnodesOfType() {\\n                return maxes(getSuperFnodes(), fnode => ruleset.weightedScore(fnode.scoresSoFarFor(self._type)));\\n            });\\n    }\\n}\\n\\nclass BestClusterLhs extends AggregateTypeLhs {\\n    constructor(type, options) {\\n        super(type);\\n        this._options = options || {splittingDistance: 3};\\n    }\\n\\n    /**\\n     * Group the nodes of my type into clusters, and return the cluster with\\n     * the highest total score for that type.\\n     */\\n    fnodes(ruleset) {\\n        // Get the nodes of the type:\\n        const fnodesOfType = Array.from(super.fnodes(ruleset));\\n        if (fnodesOfType.length === 0) {\\n            return [];\\n        }\\n        // Cluster them:\\n        const clusts = clusters(\\n            fnodesOfType,\\n            this._options.splittingDistance,\\n            (a, b) => distance(a, b, this._options));\\n        // Tag each cluster with the total of its nodes' scores:\\n        const clustsAndSums = clusts.map(\\n            clust => [clust,\\n                      sum(clust.map(fnode => fnode.scoreFor(this._type)))]);\\n        // Return the highest-scoring cluster:\\n        return max(clustsAndSums, clustAndSum => clustAndSum[1])[0];\\n    }\\n}\\n\\nclass AndLhs extends Lhs {\\n    constructor(lhss) {\\n        super();\\n\\n        // For the moment, we accept only type()s as args. TODO: Generalize to\\n        // type().max() and such later.\\n        this._args = lhss.map(sideToTypeLhs);\\n    }\\n\\n    *fnodes(ruleset) {\\n        // Take an arbitrary one for starters. Optimization: we could always\\n        // choose the pickiest one to start with.\\n        const fnodes = this._args[0].fnodes(ruleset);\\n        // Then keep only the fnodes that have the type of every other arg:\\n        fnodeLoop: for (let fnode of fnodes) {\\n            for (let otherLhs of this._args.slice(1)) {\\n                // Optimization: could use a .hasTypeSoFar() below\\n                if (!fnode.hasType(otherLhs.guaranteedType())) {\\n                    // TODO: This is n^2. Why is there no set intersection in JS?!\\n                    continue fnodeLoop;\\n                }\\n            }\\n            yield fnode;\\n        }\\n    }\\n\\n    possibleTypeCombinations() {\\n        return [this.typesMentioned()];\\n    }\\n\\n    typesMentioned() {\\n        return new NiceSet(this._args.map(arg => arg.guaranteedType()));\\n    }\\n}\\n\\nfunction sideToTypeLhs(side) {\\n    const lhs = side.asLhs();\\n    if (!(lhs.constructor === TypeLhs)) {\\n        throw new Error('and() and nearest() support only simple type() calls as arguments for now.');\\n        // TODO: Though we could solve this with a compilation step: and(type(A), type(B).max()) is equivalent to type(B).max() -> type(Bmax); and(type(A), type(Bmax)).\\n        // In fact, we should be able to compile most (any?) arbitrary and()s, including nested ands and and(type(...).max(), ...) constructions into several and(type(A), type(B), ...) rules.\\n    }\\n    return lhs;\\n}\\n\\nclass NearestLhs extends Lhs {\\n    constructor([a, b, distance]) {\\n        super();\\n        this._a = sideToTypeLhs(a);\\n        this._b = sideToTypeLhs(b);\\n        this._distance = distance;\\n    }\\n\\n    /**\\n     * Return an iterable of {fnodes, transformer} pairs.\\n     */\\n    *fnodes(ruleset) {\\n        // Go through all the left arg's nodes. For each one, find the closest\\n        // right-arg's node. O(a * b). Once a right-arg's node is used, we\\n        // don't eliminate it from consideration, because then order of left-\\n        // args' nodes would matter.\\n\\n        // TODO: Still not sure how to get the distance to factor into the\\n        // score unless we hard-code nearest() to do that. It's a\\n        // matter of not being able to bind on the RHS to the output of the\\n        // distance function on the LHS. Perhaps we could at least make\\n        // distance part of the note and read it in a props() callback.\\n\\n        // We're assuming here that simple type() calls return just plain\\n        // fnodes, not {fnode, rhsTransformer} pairs:\\n        const as_ = this._a.fnodes(ruleset);\\n        const bs = Array.from(this._b.fnodes(ruleset));\\n        if (bs.length > 0) {\\n            // If bs is empty, there can be no nearest nodes, so don't emit any.\\n            for (const a of as_) {\\n                const nearest = min(bs, b => this._distance(a, b));\\n                yield {fnode: a,\\n                       rhsTransformer: function setNoteIfEmpty(fact) {\\n                           // If note is explicitly set by the RHS, let it take\\n                           // precedence, even though that makes this entire LHS\\n                           // pointless.\\n                           if (fact.note === undefined) {\\n                               fact.note = nearest;  // TODO: Wrap this in an object to make room to return distance later.\\n                           }\\n                           return fact;\\n                       }};\\n            }\\n        }\\n    }\\n\\n    checkFact(fact) {\\n        // Barf if the fact doesn't set a type at least. It should be a *new* type or at least one that doesn't result in cycles, but we can't deduce that.\\n    }\\n\\n    possibleTypeCombinations() {\\n        return [new NiceSet([this._a.guaranteedType()])];\\n    }\\n\\n    typesMentioned() {\\n        return new NiceSet([this._a.guaranteedType(),\\n                            this._b.guaranteedType()]);\\n    }\\n\\n    guaranteedType() {\\n        return this._a.guaranteedType();\\n    }\\n}\\n\\n// The right-hand side of a rule\\n\\n\\nconst TYPE = 1;\\nconst NOTE = 2;\\nconst SCORE = 4;\\nconst ELEMENT = 8;\\nconst SUBFACTS = {\\n    type: TYPE,\\n    note: NOTE,\\n    score: SCORE,\\n    element: ELEMENT\\n};\\n\\n/**\\n * Expose the output of this rule's LHS as a \\\"final result\\\" to the surrounding\\n * program. It will be available by calling :func:`~BoundRuleset.get` on the\\n * ruleset and passing the key. You can run each node through a callback\\n * function first by adding :func:`through()`, or you can run the entire set of\\n * nodes through a callback function by adding :func:`allThrough()`.\\n */\\nfunction out(key) {\\n    return new OutwardRhs(key);\\n}\\n\\nclass InwardRhs {\\n    constructor(calls = [], max = Infinity, types) {\\n        this._calls = calls.slice();\\n        this._max = max;  // max score\\n        this._types = new NiceSet(types);  // empty set if unconstrained\\n    }\\n\\n    /**\\n     * Declare that the maximum returned subscore is such and such,\\n     * which helps the optimizer plan efficiently. This doesn't force it to be\\n     * true; it merely throws an error at runtime if it isn't. To lift an\\n     * ``atMost`` constraint, call ``atMost()`` (with no args). The reason\\n     * ``atMost`` and ``typeIn`` apply until explicitly cleared is so that, if\\n     * someone used them for safety reasons on a lexically distant rule you are\\n     * extending, you won't stomp on their constraint and break their\\n     * invariants accidentally.\\n     */\\n    atMost(score) {\\n        return new this.constructor(this._calls, score, this._types);\\n    }\\n\\n    _checkAtMost(fact) {\\n        if (fact.score !== undefined && fact.score > this._max) {\\n            throw new Error(`Score of ${fact.score} exceeds the declared atMost(${this._max}).`);\\n        }\\n    }\\n\\n    /**\\n      * Determine any of type, note, score, and element using a callback. This\\n      * overrides any previous call to `props` and, depending on what\\n      * properties of the callback's return value are filled out, may override\\n      * the effects of other previous calls as well.\\n      *\\n      * The callback should return...\\n      *\\n      * * An optional :term:`subscore`\\n      * * A type (required on ``dom(...)`` rules, defaulting to the input one on\\n      *   ``type(...)`` rules)\\n      * * Optional notes\\n      * * An element, defaulting to the input one. Overriding the default\\n      *   enables a callback to walk around the tree and say things about nodes\\n      *   other than the input one.\\n      */\\n    props(callback) {\\n        function getSubfacts(fnode) {\\n            const subfacts = callback(fnode);\\n            // Filter the raw result down to okayed properties so callbacks\\n            // can't insert arbitrary keys (like conserveScore, which might\\n            // mess up the optimizer).\\n            for (let subfact in subfacts) {\\n                if (!SUBFACTS.hasOwnProperty(subfact) || !(SUBFACTS[subfact] & getSubfacts.possibleSubfacts)) {\\n                    // The ES5.1 spec says in 12.6.4 that it's fine to delete\\n                    // as we iterate.\\n                    delete subfacts[subfact];\\n                }\\n            }\\n            return subfacts;\\n        }\\n        // Thse are the subfacts this call could affect:\\n        getSubfacts.possibleSubfacts = TYPE | NOTE | SCORE | ELEMENT;\\n        getSubfacts.kind = 'props';\\n        return new this.constructor(this._calls.concat(getSubfacts),\\n                                    this._max,\\n                                    this._types);\\n    }\\n\\n    /**\\n     * Set the type applied to fnodes processed by this RHS.\\n     */\\n    type(theType) {\\n        // In the future, we might also support providing a callback that receives\\n        // the fnode and returns a type. We couldn't reason based on these, but the\\n        // use would be rather a consise way to to override part of what a previous\\n        // .props() call provides.\\n\\n        // Actually emit a given type.\\n        function getSubfacts() {\\n            return {type: theType};\\n        }\\n        getSubfacts.possibleSubfacts = TYPE;\\n        getSubfacts.type = theType;\\n        getSubfacts.kind = 'type';\\n        return new this.constructor(this._calls.concat(getSubfacts),\\n                                    this._max,\\n                                    this._types);\\n    }\\n\\n    /**\\n     * Constrain this rule to emit 1 of a set of given types. Pass no args to lift\\n     * a previous ``typeIn`` constraint, as you might do when basing a LHS on a\\n     * common value to factor out repetition.\\n     *\\n     * ``typeIn`` is mostly a hint for the query planner when you're emitting types\\n     * dynamically from ``props`` calls—in fact, an error will be raised if\\n     * ``props`` is used without a ``typeIn`` or ``type`` to constrain it—but it\\n     * also checks conformance at runtime to ensure validity.\\n     */\\n    typeIn(...types) {\\n        // Rationale: If we used the spelling \\\"type('a', 'b', ...)\\\" instead of\\n        // this, one might expect type('a', 'b').type(fn) to have the latter\\n        // call override, while expecting type(fn).type('a', 'b') to keep both\\n        // in effect. Then different calls to type() don't consistently\\n        // override each other, and the rules get complicated. Plus you can't\\n        // inherit a type constraint and then sub in another type-returning\\n        // function that still gets the constraint applied.\\n        return new this.constructor(this._calls,\\n                                    this._max,\\n                                    types);\\n    }\\n\\n    /**\\n     * Check a fact for conformance with any typeIn() call.\\n     *\\n     * @arg leftType the type of the LHS, which becomes my emitted type if the\\n     *    fact doesn't specify one\\n     */\\n    _checkTypeIn(result, leftType) {\\n        if (this._types.size > 0) {\\n            if (result.type === undefined) {\\n                if (!this._types.has(leftType)) {\\n                    throw new Error(`A right-hand side claimed, via typeIn(...) to emit one of the types ${this._types} but actually inherited ${leftType} from the left-hand side.`);\\n                }\\n            } else if (!this._types.has(result.type)) {\\n                throw new Error(`A right-hand side claimed, via typeIn(...) to emit one of the types ${this._types} but actually emitted ${result.type}.`);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Whatever the callback returns (even ``undefined``) becomes the note of\\n     * the fact. This overrides any previous call to ``note``.\\n     */\\n    note(callback) {\\n        function getSubfacts(fnode) {\\n            return {note: callback(fnode)};\\n        }\\n        getSubfacts.possibleSubfacts = NOTE;\\n        getSubfacts.kind = 'note';\\n        return new this.constructor(this._calls.concat(getSubfacts),\\n                                    this._max,\\n                                    this._types);\\n    }\\n\\n    /**\\n     * Affect the confidence with which the input node should be considered a\\n     * member of a type.\\n     *\\n     * The parameter is generally between 0 and 1 (inclusive), with 0 meaning\\n     * the node does not have the \\\"smell\\\" this rule checks for and 1 meaning it\\n     * does. The range between 0 and 1 is available to represent \\\"fuzzy\\\"\\n     * confidences. If you have an unbounded range to compress down to [0, 1],\\n     * consider using :func:`sigmoid` or a scaling thereof.\\n     *\\n     * Since every node can have multiple, independent scores (one for each\\n     * type), this applies to the type explicitly set by the RHS or, if none,\\n     * to the type named by the ``type`` call on the LHS. If the LHS has none\\n     * because it's a ``dom(...)`` LHS, an error is raised.\\n     *\\n     * @arg {number|function} scoreOrCallback Can either be a static number,\\n     *     generally 0 to 1 inclusive, or else a callback which takes the fnode\\n     *     and returns such a number. If the callback returns a boolean, it is\\n     *     cast to a number.\\n     */\\n    score(scoreOrCallback) {\\n        let getSubfacts;\\n\\n        function getSubfactsFromNumber(fnode) {\\n            return {score: scoreOrCallback};\\n        }\\n\\n        function getSubfactsFromFunction(fnode) {\\n            let result = scoreOrCallback(fnode);\\n            if (typeof result === 'boolean') {\\n                // Case bools to numbers for convenience. Boolean features are\\n                // common. Don't cast other things, as it frustrates ruleset\\n                // debugging.\\n                result = Number(result);\\n            }\\n            return {score: result};\\n        }\\n\\n        if (typeof scoreOrCallback === 'number') {\\n            getSubfacts = getSubfactsFromNumber;\\n        } else {\\n            getSubfacts = getSubfactsFromFunction;\\n        }\\n        getSubfacts.possibleSubfacts = SCORE;\\n        getSubfacts.kind = 'score';\\n\\n        return new this.constructor(this._calls.concat(getSubfacts),\\n                                    this._max,\\n                                    this._types);\\n    }\\n\\n    // Future: why not have an .element() method for completeness?\\n\\n    // -------- Methods below this point are private to the framework. --------\\n\\n    /**\\n     * Run all my props().type().note().score() stuff across a given fnode,\\n     * enforce my max() stuff, and return a fact ({element, type, score,\\n     * notes}) for incorporation into that fnode (or a different one, if\\n     * element is specified). Any of the 4 fact properties can be missing;\\n     * filling in defaults is a job for the caller.\\n     *\\n     * @arg leftType The type the LHS takes in\\n     */\\n    fact(fnode, leftType) {\\n        const doneKinds = new Set();\\n        const result = {};\\n        let haveSubfacts = 0;\\n        for (let call of reversed(this._calls)) {\\n            // If we've already called a call of this kind, then forget it.\\n            if (!doneKinds.has(call.kind)) {\\n                doneKinds.add(call.kind);\\n\\n                if (~haveSubfacts & call.possibleSubfacts) {\\n                    // This call might provide a subfact we are missing.\\n                    const newSubfacts = call(fnode);\\n\\n                    // We start with an empty object, so we're okay here.\\n                    // eslint-disable-next-line guard-for-in\\n                    for (let subfact in newSubfacts) {\\n                        // A props() callback could insert arbitrary keys into\\n                        // the result, but it shouldn't matter, because nothing\\n                        // pays any attention to them.\\n                        if (!result.hasOwnProperty(subfact)) {\\n                            result[subfact] = newSubfacts[subfact];\\n                        }\\n                        haveSubfacts |= SUBFACTS[subfact];\\n                    }\\n                }\\n            }\\n        }\\n        this._checkAtMost(result);\\n        this._checkTypeIn(result, leftType);\\n        return result;\\n    }\\n\\n    /**\\n     * Return a record describing the types I might emit (which means either to\\n     * add a type to a fnode or to output a fnode that already has that type).\\n     * {couldChangeType: whether I might add a type to the fnode,\\n     *  possibleTypes: If couldChangeType, the types I might emit; empty set if\\n     *      we cannot infer it. If not couldChangeType, undefined.}\\n     */\\n    possibleEmissions() {\\n        // If there is a typeIn() constraint or there is a type() call to the\\n        // right of all props() calls, we have a constraint. We hunt for the\\n        // tightest constraint we can find, favoring a type() call because it\\n        // gives us a single type but then falling back to a typeIn().\\n        let couldChangeType = false;\\n        for (let call of reversed(this._calls)) {\\n            if (call.kind === 'props') {\\n                couldChangeType = true;\\n                break;\\n            } else if (call.kind === 'type') {\\n                return {couldChangeType: true,\\n                        possibleTypes: new Set([call.type])};\\n            }\\n        }\\n        return {couldChangeType,\\n                possibleTypes: this._types};\\n    }\\n}\\n\\nclass OutwardRhs {\\n    constructor(key, through = x => x, allThrough = x => x) {\\n        this.key = key;\\n        this.callback = through;\\n        this.allCallback = allThrough;\\n    }\\n\\n    /**\\n     * Append ``.through`` to :func:`out` to run each :term:`fnode` emitted\\n     * from the LHS through an arbitrary function before returning it to the\\n     * containing program. Example::\\n     *\\n     *     out('titleLengths').through(fnode => fnode.noteFor('title').length)\\n     */\\n    through(callback) {\\n        return new this.constructor(this.key, callback, this.allCallback);\\n    }\\n\\n    /**\\n     * Append ``.allThrough`` to :func:`out` to run the entire iterable of\\n     * emitted :term:`fnodes<fnode>` through an arbitrary function before\\n     * returning them to the containing program. Example::\\n     *\\n     *     out('sortedTitles').allThrough(domSort)\\n     */\\n    allThrough(callback) {\\n        return new this.constructor(this.key, this.callback, callback);\\n    }\\n\\n    asRhs() {\\n        return this;\\n    }\\n}\\n\\nfunction props(callback) {\\n    return new Side({method: 'props', args: [callback]});\\n}\\n\\n/** Constrain to an input type on the LHS, or apply a type on the RHS. */\\nfunction type(theType) {\\n    return new Side({method: 'type', args: [theType]});\\n}\\n\\nfunction note(callback) {\\n    return new Side({method: 'note', args: [callback]});\\n}\\n\\nfunction score(scoreOrCallback) {\\n    return new Side({method: 'score', args: [scoreOrCallback]});\\n}\\n\\nfunction atMost(score) {\\n    return new Side({method: 'atMost', args: [score]});\\n}\\n\\nfunction typeIn(...types) {\\n    return new Side({method: 'typeIn', args: types});\\n}\\n\\n/**\\n * Pull nodes that conform to multiple conditions at once.\\n *\\n * For example: ``and(type('title'), type('english'))``\\n *\\n * Caveats: ``and`` supports only simple ``type`` calls as arguments for now,\\n * and it may fire off more rules as prerequisites than strictly necessary.\\n * ``not`` and ``or`` don't exist yet, but you can express ``or`` the long way\\n * around by having 2 rules with identical RHSs.\\n */\\nfunction and(...lhss) {\\n    return new Side({method: 'and', args: lhss});\\n}\\n\\n/**\\n * Experimental. For each :term:`fnode` from ``typeCallA``, find the closest\\n * node from ``typeCallB``, and attach it as a note. The note is attached to\\n * the type specified by the RHS, defaulting to the type of ``typeCallA``. If\\n * no nodes are emitted from ``typeCallB``, do nothing.\\n *\\n * For example... ::\\n *\\n *     nearest(type('image'), type('price'))\\n *\\n * The score of the ``typeCallA`` can be added to the new type's score by using\\n * :func:`conserveScore` (though this routine has since been removed)::\\n *\\n *     rule(nearest(type('image'), type('price')),\\n *          type('imageWithPrice').score(2).conserveScore())\\n *\\n * Caveats: ``nearest`` supports only simple ``type`` calls as arguments ``a``\\n * and ``b`` for now.\\n *\\n * @arg distance {function} A function that takes 2 fnodes and returns a\\n *     numerical distance between them. Included options are :func:`distance`,\\n *     which is a weighted topological distance, and :func:`euclidean`, which\\n *     is a spatial distance.\\n */\\nfunction nearest(typeCallA, typeCallB, distance = euclidean) {\\n    return new Side({method: 'nearest', args: [typeCallA, typeCallB, distance]});\\n}\\n\\n/**\\n * A chain of calls that can be compiled into a Rhs or Lhs, depending on its\\n * position in a Rule. This lets us use type() as a leading call for both RHSs\\n * and LHSs. I would prefer to do this dynamically, but that wouldn't compile\\n * down to old versions of ES.\\n */\\nclass Side {\\n    constructor(...calls) {\\n        // A \\\"call\\\" is like {method: 'dom', args: ['p.smoo']}.\\n        this._calls = calls;\\n    }\\n\\n    max() {\\n        return this._and('max');\\n    }\\n\\n    bestCluster(options) {\\n        return this._and('bestCluster', options);\\n    }\\n\\n    props(callback) {\\n        return this._and('props', callback);\\n    }\\n\\n    type(...types) {\\n        return this._and('type', ...types);\\n    }\\n\\n    note(callback) {\\n        return this._and('note', callback);\\n    }\\n\\n    score(scoreOrCallback) {\\n        return this._and('score', scoreOrCallback);\\n    }\\n\\n    atMost(score) {\\n        return this._and('atMost', score);\\n    }\\n\\n    typeIn(...types) {\\n        return this._and('typeIn', ...types);\\n    }\\n\\n    and(...lhss) {\\n        return this._and('and', lhss);\\n    }\\n\\n    _and(method, ...args) {\\n        return new this.constructor(...this._calls.concat({method, args}));\\n    }\\n\\n    asLhs() {\\n        return this._asSide(Lhs.fromFirstCall(this._calls[0]), this._calls.slice(1));\\n    }\\n\\n    asRhs() {\\n        return this._asSide(new InwardRhs(), this._calls);\\n    }\\n\\n    _asSide(side, calls) {\\n        for (let call of calls) {\\n            side = side[call.method](...call.args);\\n        }\\n        return side;\\n    }\\n\\n    when(pred) {\\n        return this._and('when', pred);\\n    }\\n}\\n\\n/**\\n * A wrapper around a DOM node, storing :term:`types<type>`,\\n * :term:`scores<score>`, and :term:`notes<note>` that apply to it\\n */\\nclass Fnode {\\n    /**\\n     * @arg element The DOM element described by the fnode.\\n     * @arg ruleset The ruleset which created the fnode.\\n     */\\n    constructor(element, ruleset) {\\n        if (element === undefined) {\\n            throw new Error(\\\"Someone tried to make a fnode without specifying the element they're talking about.\\\");\\n        }\\n        /**\\n         * The raw DOM element this fnode describes\\n         */\\n        this.element = element;\\n        this._ruleset = ruleset;\\n\\n        // A map of type => {score: number, note: anything}. `score` is always\\n        // present and defaults to 1. A note is set iff `note` is present and\\n        // not undefined.\\n        this._types = new Map();\\n\\n        // Note: conserveScore() is temporarily absent in 3.0.\\n        //\\n        // By default, a fnode has an independent score for each of its types.\\n        // However, a RHS can opt to conserve the score of an upstream type,\\n        // carrying it forward into another type. To avoid runaway scores in\\n        // the case that multiple rules choose to do this, we limit the\\n        // contribution of an upstream type's score to being multiplied in a\\n        // single time. In this set, we keep track of which upstream types'\\n        // scores have already been multiplied into each type. LHS fnode => Set\\n        // of types whose score for that node have been multiplied into this\\n        // node's score.\\n        this._conservedScores = new Map();\\n    }\\n\\n    /**\\n     * Return whether the given type is one of the ones attached to the wrapped\\n     * HTML node.\\n     */\\n    hasType(type) {\\n        // Run type(theType) against the ruleset to make sure this doesn't\\n        // return false just because we haven't lazily run certain rules yet.\\n        this._computeType(type);\\n        return this._types.has(type);\\n    }\\n\\n    /**\\n     * Return the confidence, in the range (0, 1), that the fnode belongs to the\\n     * given type, 0 by default.\\n     */\\n    scoreFor(type) {\\n        this._computeType(type);\\n        return sigmoid(this._ruleset.weightedScore(this.scoresSoFarFor(type)) +\\n                       getDefault(this._ruleset.biases, type, () => 0));\\n    }\\n\\n    /**\\n     * Return the fnode's note for the given type, ``undefined`` if none.\\n     */\\n    noteFor(type) {\\n        this._computeType(type);\\n        return this._noteSoFarFor(type);\\n    }\\n\\n    /**\\n     * Return whether this fnode has a note for the given type.\\n     *\\n     * ``undefined`` is not considered a note and may be overwritten with\\n     * impunity.\\n     */\\n    hasNoteFor(type) {\\n        this._computeType(type);\\n        return this._hasNoteSoFarFor(type);\\n    }\\n\\n    // -------- Methods below this point are private to the framework. --------\\n\\n    /**\\n     * Return an iterable of the types tagged onto me by rules that have\\n     * already executed.\\n     */\\n    typesSoFar() {\\n        return this._types.keys();\\n    }\\n\\n    _noteSoFarFor(type) {\\n        return this._typeRecordForGetting(type).note;\\n    }\\n\\n    _hasNoteSoFarFor(type) {\\n        return this._noteSoFarFor(type) !== undefined;\\n    }\\n\\n    /**\\n     * Return the score thus far computed on me for a certain type. Doesn't\\n     * implicitly run any rules. If no score has yet been determined for the\\n     * given type, return undefined.\\n     */\\n    scoresSoFarFor(type) {\\n        return this._typeRecordForGetting(type).score;\\n    }\\n\\n    /**\\n     * Add a given number to one of our per-type scores. Implicitly assign us\\n     * the given type. Keep track of which rule it resulted from so we can\\n     * later mess with the coeffs.\\n     */\\n    addScoreFor(type, score, ruleName) {\\n        this._typeRecordForSetting(type).score.set(ruleName, score);\\n    }\\n\\n    /**\\n     * Set the note attached to one of our types. Implicitly assign us that\\n     * type if we don't have it already.\\n     */\\n    setNoteFor(type, note) {\\n        if (this._hasNoteSoFarFor(type)) {\\n            if (note !== undefined) {\\n                throw new Error(`Someone (likely the right-hand side of a rule) tried to add a note of type ${type} to an element, but one of that type already exists. Overwriting notes is not allowed, since it would make the order of rules matter.`);\\n            }\\n            // else the incoming note is undefined and we already have the\\n            // type, so it's a no-op\\n        } else {\\n            // Apply either a type and note or just a type (which means a note\\n            // that is undefined):\\n            this._typeRecordForSetting(type).note = note;\\n        }\\n    }\\n\\n    /**\\n     * Return a score/note record for a type, creating it if it doesn't exist.\\n     */\\n    _typeRecordForSetting(type) {\\n        return setDefault(this._types, type, () => ({score: new Map()}));\\n    }\\n\\n    /**\\n     * Manifest a temporary type record for reading, working around the lack of\\n     * a .? operator in JS.\\n     */\\n    _typeRecordForGetting(type) {\\n        return getDefault(this._types, type, () => ({score: new Map()}));\\n    }\\n\\n    /**\\n     * Make sure any scores, notes, and type-tagging for the given type are\\n     * computed for my element.\\n     */\\n    _computeType(theType) {\\n        if (!this._types.has(theType)) {  // Prevent infinite recursion when an A->A rule looks at A's note in a callback.\\n            this._ruleset.get(type(theType));\\n        }\\n    }\\n}\\n\\n/**\\n * Construct and return the proper type of rule class based on the\\n * inwardness/outwardness of the RHS.\\n *\\n * @arg lhs {Lhs} The left-hand side of the rule\\n * @arg rhs {Rhs} The right-hand side of the rule\\n * @arg options {object} Other, optional information about the rule.\\n *     Currently, the only recognized option is ``name``, which points to a\\n *     string that uniquely identifies this rule in a ruleset. The name\\n *     correlates this rule with one of the coefficients passed into\\n *     :func:`ruleset`. If no name is given, an identifier is assigned based on\\n *     the index of this rule in the ruleset, but that is, of course, brittle.\\n */\\nfunction rule(lhs, rhs, options) {\\n    // Since out() is a valid call only on the RHS (unlike type()), we can take\\n    // a shortcut here: any outward RHS will already be an OutwardRhs; we don't\\n    // need to sidetrack it through being a Side. And OutwardRhs has an asRhs()\\n    // that just returns itself.\\n    if (typeof rhs === 'string') {\\n        rhs = out(rhs);\\n    }\\n    return new ((rhs instanceof OutwardRhs) ? OutwardRule : InwardRule)(lhs, rhs, options);\\n}\\n\\nlet nextRuleNumber = 0;\\nfunction newInternalRuleName() {\\n    return '_' + nextRuleNumber++;\\n}\\n\\n/**\\n * We place the in/out distinction in Rules because it determines whether the\\n * RHS result is cached, and Rules are responsible for maintaining the rulewise\\n * cache ruleset.ruleCache.\\n */\\nclass Rule {  // abstract\\n    constructor(lhs, rhs, options) {\\n        this.lhs = lhs.asLhs();\\n        this.rhs = rhs.asRhs();\\n        // TODO: Make auto-generated rule names be based on the out types of\\n        // the rules, e.g. _priceish_4. That way, adding rules for one type\\n        // won't make the coeffs misalign for another.\\n        this.name = (options ? options.name : undefined) || newInternalRuleName();\\n    }\\n\\n    /**\\n     * Return a NiceSet of the rules that this one shallowly depends on in the\\n     * given ruleset. In a BoundRuleset, this may include rules that have\\n     * already been executed.\\n     *\\n     * Depend on emitters of any LHS type this rule finalizes. (See\\n     * _typesFinalized for a definition.) Depend on adders of any other LHS\\n     * types (because, after all, we need to know what nodes have that type in\\n     * order to find the set of LHS nodes). This works for simple rules and\\n     * complex ones like and().\\n     *\\n     * Specific examples (where A is a type):\\n     * * A.max->* depends on anything emitting A.\\n     * * Even A.max->A depends on A emitters, because we have to have all the\\n     *   scores factored in first. For example, what if we did\\n     *   max(A)->score(.5)?\\n     * * A->A depends on anything adding A.\\n     * * A->(something other than A) depends on anything emitting A. (For\\n     *   example, we need the A score finalized before we could transfer it to\\n     *   B using conserveScore().)\\n     * * A->out() also depends on anything emitting A. Fnode methods aren't\\n     *   smart enough to lazily run emitter rules as needed. We could make them\\n     *   so if it was shown to be an advantage.\\n     */\\n    prerequisites(ruleset) {\\n        // Optimization: we could cache the result of this when in a compiled (immutable) ruleset.\\n\\n        // Extend prereqs with rules derived from each of the given types. If\\n        // no rules are found, raise an exception, as that indicates a\\n        // malformed ruleset.\\n        function extendOrThrow(prereqs, types, ruleGetter, verb) {\\n            for (let type of types) {\\n                const rules = ruleGetter(type);\\n                if (rules.length > 0) {\\n                    prereqs.extend(rules);\\n                } else {\\n                    throw new Error(`No rule ${verb} the \\\"${type}\\\" type, but another rule needs it as input.`);\\n                }\\n            }\\n        }\\n\\n        const prereqs = new NiceSet();\\n\\n        // Add finalized types:\\n        extendOrThrow(prereqs, this._typesFinalized(), type => ruleset.inwardRulesThatCouldEmit(type), 'emits');\\n\\n        // Add mentioned types:\\n        // We could say this.lhs.typesMentioned().minus(typesFinalized) as an\\n        // optimization. But since types mentioned are a superset of types\\n        // finalized and rules adding are a subset of rules emitting, we get\\n        // the same result without.\\n        extendOrThrow(prereqs, this.lhs.typesMentioned(), type => ruleset.inwardRulesThatCouldAdd(type), 'adds');\\n\\n        return prereqs;\\n    }\\n\\n    /**\\n     * Return the types that this rule finalizes.\\n     *\\n     * To \\\"finalize\\\" a type means to make sure we're finished running all\\n     * possible rules that might change a node's score or notes w.r.t. a given\\n     * type. This is generally done because we're about to use those data for\\n     * something, like computing a new type's score or or an aggregate\\n     * function. Exhaustively, we're about to...\\n     * * change the type of the nodes or\\n     * * aggregate all nodes of a type\\n     *\\n     * This base-class implementation just returns what aggregate functions\\n     * need, since that need spans inward and outward rules.\\n     *\\n     * @return Set of types\\n     */\\n    _typesFinalized() {\\n        // Get the types that are fed to aggregate functions. Aggregate\\n        // functions are more demanding than a simple type() LHS. A type() LHS\\n        // itself does not finalize its nodes because the things it could do to\\n        // them without changing their type (adding notes, adding to score)\\n        // are immutable or commutative (respectively). Thus, we require a RHS\\n        // type change in order to require finalization of a simple type()\\n        // mention. A max(B), OTOH, is not commutative with other B->B rules\\n        // (imagine type(B).max()->score(.5)), so it must depend on B emitters\\n        // and thus finalize B. (This will have to be relaxed or rethought when\\n        // we do the max()/atMost() optimization. Perhaps we can delegate to\\n        // aggregate functions up in Rule.prerequisites() to ask what their\\n        // prereqs are. If they implement such an optimization, they can reply.\\n        // Otherwise, we can assume they are all the nodes of their type.)\\n        //\\n        // TODO: Could arbitrary predicates (once we implement those) matter\\n        // too? Maybe it's not just aggregations.\\n        const type = this.lhs.aggregatedType();\\n        return (type === undefined) ? new NiceSet() : new NiceSet([type]);\\n    }\\n}\\n\\n/**\\n * A normal rule, whose results head back into the Fathom knowledgebase, to be\\n * operated on by further rules.\\n */\\nclass InwardRule extends Rule {\\n    // TODO: On construct, complain about useless rules, like a dom() rule that\\n    // doesn't assign a type.\\n\\n    /**\\n     * Return an iterable of the fnodes emitted by the RHS of this rule.\\n     * Side effect: update ruleset's store of fnodes, its accounting of which\\n     * rules are done executing, and its cache of results per type.\\n     */\\n    results(ruleset) {\\n        if (ruleset.doneRules.has(this)) {  // shouldn't happen\\n            throw new Error('A bug in Fathom caused results() to be called on an inward rule twice. That could cause redundant score contributions, etc.');\\n        }\\n        const self = this;\\n        // For now, we consider most of what a LHS computes to be cheap, aside\\n        // from type() and type().max(), which are cached by their specialized\\n        // LHS subclasses.\\n        const leftResults = this.lhs.fnodes(ruleset);\\n        // Avoid returning a single fnode more than once. LHSs uniquify\\n        // themselves, but the RHS can change the element it's talking\\n        // about and thus end up with dupes.\\n        const returnedFnodes = new Set();\\n\\n        // Merge facts into fnodes:\\n        forEach(\\n            // leftResult can be either a fnode or a {fnode, rhsTransformer} pair.\\n            function updateFnode(leftResult) {\\n                const leftType = self.lhs.guaranteedType();\\n                // Get a fnode and a RHS transformer, whether a plain fnode is\\n                // returned or a {fnode, rhsTransformer} pair:\\n                const {fnode: leftFnode = leftResult, rhsTransformer = identity} = leftResult;\\n                // Grab the fact from the RHS, and run the LHS's optional\\n                // transformer over it to pick up anything special it wants to\\n                // do:\\n                const fact = rhsTransformer(self.rhs.fact(leftFnode, leftType));\\n                self.lhs.checkFact(fact);\\n                const rightFnode = ruleset.fnodeForElement(fact.element || leftFnode.element);\\n                // If the RHS doesn't specify a type, default to the\\n                // type of the LHS, if any:\\n                const rightType = fact.type || self.lhs.guaranteedType();\\n                if (fact.score !== undefined) {\\n                    if (rightType !== undefined) {\\n                        rightFnode.addScoreFor(rightType, fact.score, self.name);\\n                    } else {\\n                        throw new Error(`The right-hand side of a rule specified a score (${fact.score}) with neither an explicit type nor one we could infer from the left-hand side.`);\\n                    }\\n                }\\n                if (fact.type !== undefined || fact.note !== undefined) {\\n                    // There's a reason to call setNoteFor.\\n                    if (rightType === undefined) {\\n                        throw new Error(`The right-hand side of a rule specified a note (${fact.note}) with neither an explicit type nor one we could infer from the left-hand side. Notes are per-type, per-node, so that's a problem.`);\\n                    } else {\\n                        rightFnode.setNoteFor(rightType, fact.note);\\n                    }\\n                }\\n                returnedFnodes.add(rightFnode);\\n            },\\n            leftResults);\\n\\n        // Update ruleset lookup tables.\\n        // First, mark this rule as done:\\n        ruleset.doneRules.add(this);\\n        // Then, stick each fnode in typeCache under all applicable types.\\n        // Optimization: we really only need to loop over the types\\n        // this rule can possibly add.\\n        for (let fnode of returnedFnodes) {\\n            for (let type of fnode.typesSoFar()) {\\n                setDefault(ruleset.typeCache, type, () => new Set()).add(fnode);\\n            }\\n        }\\n        return returnedFnodes.values();\\n    }\\n\\n    /**\\n     * Return a Set of the types that could be emitted back into the system.\\n     * To emit a type means to either to add it to a fnode emitted from the RHS\\n     * or to leave it on such a fnode where it already exists.\\n     */\\n    typesItCouldEmit() {\\n        const rhs = this.rhs.possibleEmissions();\\n        if (!rhs.couldChangeType && this.lhs.guaranteedType() !== undefined) {\\n            // It's a b -> b rule.\\n            return new Set([this.lhs.guaranteedType()]);\\n        } else if (rhs.possibleTypes.size > 0) {\\n            // We can prove the type emission from the RHS alone.\\n            return rhs.possibleTypes;\\n        } else {\\n            throw new Error('Could not determine the emitted type of a rule because its right-hand side calls props() without calling typeIn().');\\n        }\\n    }\\n\\n    /**\\n     * Return a Set of types I could add to fnodes I output (where the fnodes\\n     * did not already have them).\\n     */\\n    typesItCouldAdd() {\\n        const ret = new Set(this.typesItCouldEmit());\\n        ret.delete(this.lhs.guaranteedType());\\n        return ret;\\n    }\\n\\n    /**\\n     * Add the types we could change to the superclass's result.\\n     */\\n    _typesFinalized() {\\n        const self = this;\\n        function typesThatCouldChange() {\\n            const ret = new NiceSet();\\n\\n            // Get types that could change:\\n            const emissions = self.rhs.possibleEmissions();\\n            if (emissions.couldChangeType) {\\n                // Get the possible guaranteed combinations of types on the LHS\\n                // (taking just this LHS into account). For each combo, if the RHS\\n                // adds a type that's not in the combo, the types in the combo get\\n                // unioned into ret.\\n                for (let combo of self.lhs.possibleTypeCombinations()) {\\n                    for (let rhsType of emissions.possibleTypes) {\\n                        if (!combo.has(rhsType)) {\\n                            ret.extend(combo);\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            // Optimization: the possible combos could be later expanded to be\\n            // informed by earlier rules which add the types mentioned in the LHS.\\n            // If the only way for something to get B is to have Q first, then we\\n            // can add Q to each combo and end up with fewer types finalized. Would\\n            // this imply the existence of a Q->B->Q cycle and thus be impossible?\\n            // Think about it. If we do this, we can centralize that logic here,\\n            // rather than repeating it in all the Lhs subclasses).\\n            return ret;\\n        }\\n\\n        return typesThatCouldChange().extend(super._typesFinalized());\\n    }\\n}\\n\\n/**\\n * A rule whose RHS is an out(). This represents a final goal of a ruleset.\\n * Its results go out into the world, not inward back into the Fathom\\n * knowledgebase.\\n */\\nclass OutwardRule extends Rule {\\n    /**\\n     * Compute the whole thing, including any .through() and .allThrough().\\n     * Do not mark me done in ruleset.doneRules; out rules are never marked as\\n     * done so they can be requested many times without having to cache their\\n     * (potentially big, since they aren't necessarily fnodes?) results. (We\\n     * can add caching later if it proves beneficial.)\\n     */\\n    results(ruleset) {\\n        /**\\n         * From a LHS's ``{fnode, rhsTransform}`` object or plain fnode, pick off just\\n         * the fnode and return it.\\n         */\\n        function justFnode(fnodeOrStruct) {\\n            return (fnodeOrStruct instanceof Fnode) ? fnodeOrStruct : fnodeOrStruct.fnode;\\n        }\\n\\n        return this.rhs.allCallback(map(this.rhs.callback, map(justFnode, this.lhs.fnodes(ruleset))));\\n    }\\n\\n    /**\\n     * @return the key under which the output of this rule will be available\\n     */\\n    key() {\\n        return this.rhs.key;\\n    }\\n\\n    /**\\n     * OutwardRules finalize all types mentioned.\\n     */\\n    _typesFinalized() {\\n        return this.lhs.typesMentioned().extend(super._typesFinalized());\\n    }\\n}\\n\\n/**\\n * A shortcut for creating a new :class:`Ruleset`, for symmetry with\\n * :func:`rule`\\n */\\nfunction ruleset(rules, coeffs = [], biases = []) {\\n    return new Ruleset(rules, coeffs, biases);\\n}\\n\\n/**\\n * An unbound ruleset. When you bind it by calling :func:`~Ruleset.against()`,\\n * the resulting :class:`BoundRuleset` will be immutable.\\n */\\nclass Ruleset {\\n    /**\\n     * @arg rules {Array} Rules returned from :func:`rule`\\n     * @arg coeffs {Map} A map of rule names to numerical weights, typically\\n     *     returned by the :doc:`trainer<training>`. Example:\\n     *     ``[['someRuleName', 5.04], ...]``. If not given, coefficients\\n     *     default to 1.\\n     * @arg biases {object} A map of type names to neural-net biases. These\\n     *      enable accurate confidence estimates. Example: ``[['someType',\\n     *      -2.08], ...]``. If absent, biases default to 0.\\n     */\\n    constructor(rules, coeffs = [], biases = []) {\\n        this._inRules = [];\\n        this._outRules = new Map();  // key -> rule\\n        this._rulesThatCouldEmit = new Map();  // type -> [rules]\\n        this._rulesThatCouldAdd = new Map();  // type -> [rules]\\n        // Private to the framework:\\n        this._coeffs = new Map(coeffs);  // rule name => coefficient\\n        this.biases = new Map(biases);  // type name => bias\\n\\n        // Separate rules into out ones and in ones, and sock them away. We do\\n        // this here so mistakes raise errors early.\\n        for (let rule of rules) {\\n            if (rule instanceof InwardRule) {\\n                this._inRules.push(rule);\\n\\n                // Keep track of what inward rules can emit or add:\\n                // TODO: Combine these hashes for space efficiency:\\n                const emittedTypes = rule.typesItCouldEmit();\\n                for (let type of emittedTypes) {\\n                    setDefault(this._rulesThatCouldEmit, type, () => []).push(rule);\\n                }\\n                for (let type of rule.typesItCouldAdd()) {\\n                    setDefault(this._rulesThatCouldAdd, type, () => []).push(rule);\\n                }\\n            } else if (rule instanceof OutwardRule) {\\n                this._outRules.set(rule.key(), rule);\\n            } else {\\n                throw new Error(`This element of ruleset()'s first param wasn't a rule: ${rule}`);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Commit this ruleset to running against a specific DOM tree or subtree.\\n     *\\n     * When run against a subtree, the root of the subtree is not considered as\\n     * a possible match.\\n     *\\n     * This doesn't actually modify the Ruleset but rather returns a fresh\\n     * :class:`BoundRuleset`, which contains caches and other stateful, per-DOM\\n     * bric-a-brac.\\n     */\\n    against(doc) {\\n        return new BoundRuleset(doc,\\n                                this._inRules,\\n                                this._outRules,\\n                                this._rulesThatCouldEmit,\\n                                this._rulesThatCouldAdd,\\n                                this._coeffs,\\n                                this.biases);\\n    }\\n\\n    /**\\n     * Return all the rules (both inward and outward) that make up this ruleset.\\n     *\\n     * From this, you can construct another ruleset like this one but with your\\n     * own rules added.\\n     */\\n    rules() {\\n        return Array.from([...this._inRules, ...this._outRules.values()]);\\n    }\\n}\\n\\n/**\\n * A ruleset that is earmarked to analyze a certain DOM\\n *\\n * Carries a cache of rule results on that DOM. Typically comes from\\n * :meth:`~Ruleset.against`.\\n */\\nclass BoundRuleset {\\n    /**\\n     * @arg inRules {Array} Non-out() rules\\n     * @arg outRules {Map} Output key -> out() rule\\n     */\\n    constructor(doc, inRules, outRules, rulesThatCouldEmit, rulesThatCouldAdd, coeffs, biases) {\\n        this.doc = doc;\\n        this._inRules = inRules;\\n        this._outRules = outRules;\\n        this._rulesThatCouldEmit = rulesThatCouldEmit;\\n        this._rulesThatCouldAdd = rulesThatCouldAdd;\\n        this._coeffs = coeffs;\\n\\n        // Private, for the use of only helper classes:\\n        this.biases = biases;\\n        this._clearCaches();\\n        this.elementCache = new WeakMap();  // DOM element => fnode about it\\n        this.doneRules = new Set();  // InwardRules that have been executed. OutwardRules can be executed more than once because they don't change any fnodes and are thus idempotent.\\n    }\\n\\n    /**\\n     * Change my coefficients and biases after construction.\\n     *\\n     * @arg coeffs See the :class:`Ruleset` constructor.\\n     * @arg biases See the :class:`Ruleset` constructor.\\n     */\\n    setCoeffsAndBiases(coeffs, biases = []) {\\n        // Destructuring assignment doesn't make it through rollup properly\\n        // (https://github.com/rollup/rollup-plugin-commonjs/issues/358):\\n        this._coeffs = new Map(coeffs);\\n        this.biases = new Map(biases);\\n        this._clearCaches();\\n    }\\n\\n    /**\\n     * Clear the typeCache and maxCache, usually in the wake of changing\\n     * ``this._coeffs``, because both of thise depend on weighted scores.\\n     */\\n    _clearCaches() {\\n        this.maxCache = new Map();  // type => Array of max fnode (or fnodes, if tied) of this type\\n        this.typeCache = new Map();  // type => Set of all fnodes of this type found so far. (The dependency resolution during execution ensures that individual types will be comprehensive just in time.)\\n    }\\n\\n    /**\\n     * Return an array of zero or more fnodes.\\n     * @arg thing {string|Lhs|Node} Can be\\n     *\\n     *       (1) A string which matches up with an \\\"out\\\" rule in the ruleset.\\n     *           If the out rule uses through(), the results of through's\\n     *           callback (which might not be fnodes) will be returned.\\n     *       (2) An arbitrary LHS which we calculate and return the results of.\\n     *       (3) A DOM node, for which we will return the corresponding fnode.\\n     *\\n     *     Results are cached for cases (1) and (3).\\n     */\\n    get(thing) {\\n        if (typeof thing === 'string') {\\n            if (this._outRules.has(thing)) {\\n                return Array.from(this._execute(this._outRules.get(thing)));\\n            } else {\\n                throw new Error(`There is no out() rule with key \\\"${thing}\\\".`);\\n            }\\n        } else if (isDomElement(thing)) {\\n            // Return the fnode and let it run type(foo) on demand, as people\\n            // ask it things like scoreFor(foo).\\n            return this.fnodeForElement(thing);\\n        } else if (thing.asLhs !== undefined) {\\n            // Make a temporary out rule, and run it. This may add things to\\n            // the ruleset's cache, but that's fine: it doesn't change any\\n            // future results; it just might make them faster. For example, if\\n            // you ask for .get(type('smoo')) twice, the second time will be a\\n            // cache hit.\\n            const outRule = rule(thing, out(Symbol('outKey')));\\n            return Array.from(this._execute(outRule));\\n        } else {\\n            throw new Error('ruleset.get() expects a string, an expression like on the left-hand side of a rule, or a DOM node.');\\n        }\\n    }\\n\\n    /**\\n     * Return the weighted sum of the per-rule, per-type scores from a fnode.\\n     *\\n     * @arg mapOfScores a Map of rule name to the [0, 1] score it computed for\\n     *      the type in question\\n     */\\n    weightedScore(mapOfScores) {\\n        let total = 0;\\n        for (const [name, score] of mapOfScores) {\\n            total += score * getDefault(this._coeffs, name, () => 1);\\n        }\\n        return total;\\n    }\\n\\n    // Provide an opaque context object to be made available to all ranker\\n    // functions.\\n    // context (object) {\\n    //     self.context = object;\\n    // }\\n\\n    // -------- Methods below this point are private to the framework. --------\\n\\n    /**\\n     * Return all the thus-far-unexecuted rules that will have to run to run\\n     * the requested rule, in the form of Map(prereq: [rulesItIsNeededBy]).\\n     */\\n    _prerequisitesTo(rule, undonePrereqs = new Map()) {\\n        for (let prereq of rule.prerequisites(this)) {\\n            if (!this.doneRules.has(prereq)) {\\n                // prereq is not already run. (If it were, we wouldn't care\\n                // about adding it to the graph.)\\n                const alreadyAdded = undonePrereqs.has(prereq);\\n                setDefault(undonePrereqs, prereq, () => []).push(rule);\\n\\n                // alreadyAdded means we've already computed the prereqs of\\n                // this prereq and added them to undonePrereqs. So, now\\n                // that we've hooked up the rule to this prereq in the\\n                // graph, we can stop. But, if we haven't, then...\\n                if (!alreadyAdded) {\\n                    this._prerequisitesTo(prereq, undonePrereqs);\\n                }\\n            }\\n        }\\n        return undonePrereqs;\\n    }\\n\\n    /**\\n     * Run the given rule (and its dependencies, in the proper order), and\\n     * return its results.\\n     *\\n     * The caller is responsible for ensuring that _execute() is not called\\n     * more than once for a given InwardRule, lest non-idempotent\\n     * transformations, like score contributions, be applied to fnodes more\\n     * than once.\\n     *\\n     * The basic idea is to sort rules in topological order (according to input\\n     * and output types) and then run them. On top of that, we do some\\n     * optimizations. We keep a cache of results by type (whether partial or\\n     * comprehensive--either way, the topology ensures that any\\n     * non-comprehensive typeCache entry is made comprehensive before another\\n     * rule needs it). And we prune our search for prerequisite rules at the\\n     * first encountered already-executed rule.\\n     */\\n    _execute(rule) {\\n        const prereqs = this._prerequisitesTo(rule);\\n        let sorted;\\n        try {\\n            sorted = [rule].concat(toposort(prereqs.keys(),\\n                                            prereq => prereqs.get(prereq)));\\n        } catch (exc) {\\n            if (exc instanceof CycleError) {\\n                throw new CycleError('There is a cyclic dependency in the ruleset.');\\n            } else {\\n                throw exc;\\n            }\\n        }\\n        let fnodes;\\n        for (let eachRule of reversed(sorted)) {\\n            // Sock each set of results away in this.typeCache:\\n            fnodes = eachRule.results(this);\\n        }\\n        return Array.from(fnodes);\\n    }\\n\\n    /** @return {Rule[]} */\\n    inwardRulesThatCouldEmit(type) {\\n        return getDefault(this._rulesThatCouldEmit, type, () => []);\\n    }\\n\\n    /** @return {Rule[]} */\\n    inwardRulesThatCouldAdd(type) {\\n        return getDefault(this._rulesThatCouldAdd, type, () => []);\\n    }\\n\\n    /**\\n     * @return the Fathom node that describes the given DOM element. This does\\n     *     not trigger any execution, so the result may be incomplete.\\n     */\\n    fnodeForElement(element) {\\n        return setDefault(this.elementCache,\\n                          element,\\n                          () => new Fnode(element, this));\\n    }\\n}\\n\\n/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nconst version = '3.7.3';\\n\\nexport { and, atMost, clusters$1 as clusters, dom, element, exceptions, nearest, note, out, props, rule, ruleset, score, type, typeIn, utilsForFrontend as utils, version };\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/fathom.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-document.sys.mjs":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-document.sys.mjs ***!
  \**************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\nimport { AppConstants } from \\\"resource://gre/modules/AppConstants.sys.mjs\\\";\\n\\n/**\\n * @typedef {object} Lazy\\n * @property {typeof setTimeout} setTimeout\\n * @property {typeof clearTimeout} clearTimeout\\n * @property {typeof console} console\\n * @property {typeof import(\\\"chrome://global/content/translations/TranslationsUtils.mjs\\\").TranslationsUtils} TranslationsUtils\\n */\\n\\n/** @type {Lazy} */\\nconst lazy = /** @type {any} */ ({});\\n\\nChromeUtils.defineESModuleGetters(lazy, {\\n  setTimeout: \\\"resource://gre/modules/Timer.sys.mjs\\\",\\n  clearTimeout: \\\"resource://gre/modules/Timer.sys.mjs\\\",\\n  TranslationsUtils:\\n    \\\"chrome://global/content/translations/TranslationsUtils.mjs\\\",\\n});\\n\\nChromeUtils.defineLazyGetter(lazy, \\\"console\\\", () => {\\n  return console.createInstance({\\n    maxLogLevelPref: \\\"browser.translations.logLevel\\\",\\n    prefix: \\\"Translations\\\",\\n  });\\n});\\n\\n/**\\n * Map the NodeFilter enums that are used by the TreeWalker into enums that make\\n * sense for determining the status of the nodes for the TranslationsDocument process.\\n * This aligns the meanings of the filtering for the translations process.\\n */\\nconst NodeStatus = {\\n  // This node is ready to translate as is.\\n  READY_TO_TRANSLATE: NodeFilter.FILTER_ACCEPT,\\n\\n  // This node is a shadow host and needs to be subdivided further.\\n  SHADOW_HOST: NodeFilter.FILTER_ACCEPT,\\n\\n  // This node contains too many block elements and needs to be subdivided further.\\n  SUBDIVIDE_FURTHER: NodeFilter.FILTER_SKIP,\\n\\n  // This node should not be considered for translation.\\n  NOT_TRANSLATABLE: NodeFilter.FILTER_REJECT,\\n};\\n\\n/**\\n * @typedef {import(\\\"../translations\\\").NodeVisibility} NodeVisibility\\n * @typedef {import(\\\"../translations\\\").LanguagePair} LanguagePair\\n * @typedef {import(\\\"../translations\\\").PortToPage} PortToPage\\n * @typedef {import(\\\"../translations\\\").EngineStatus} EngineStatus\\n * @typedef {import(\\\"../translations\\\").TranslationsMode} TranslationsMode\\n * @typedef {import(\\\"../translations\\\").ScrollDirection} ScrollDirection\\n * @typedef {import(\\\"../translations\\\").NodeViewportContext} NodeViewportContext\\n * @typedef {import(\\\"../translations\\\").NodeSpatialContext} NodeSpatialContext\\n * @typedef {import(\\\"../translations\\\").UpdateEligibility} UpdateEligibility\\n * @typedef {import(\\\"../translations\\\").SortableContentElement} SortableContentElement\\n * @typedef {import(\\\"../translations\\\").PrioritizedContentElements} PrioritizedContentElements\\n * @typedef {import(\\\"../translations\\\").SortableAttributeElement} SortableAttributeElement\\n * @typedef {import(\\\"../translations\\\").PrioritizedAttributeElements} PrioritizedAttributeElements\\n * @typedef {import(\\\"../translations\\\").TranslationPriorityKinds} TranslationPriorityKinds\\n * @typedef {import(\\\"../translations\\\").TranslationRequest} TranslationRequest\\n * @typedef {import(\\\"../translations\\\").TranslationFunction} TranslationFunction\\n */\\n\\n/**\\n * Create a translation cache with a limit. It implements a \\\"least recently used\\\" strategy\\n * to remove old translations. After `#cacheExpirationMS` the cache will be emptied.\\n * This cache is owned statically by the TranslationsChild. This means that it will be\\n * re-used on page reloads if the origin of the site does not change.\\n */\\nexport class LRUCache {\\n  /**\\n   * A Map from input HTML strings to their translated HTML strings.\\n   *\\n   * This cache is used to check if we already have a translated response for the given\\n   * input HTML, to help avoid spending CPU cycles translating HTML for which we already\\n   * know the translated output.\\n   *\\n   * @type {Map<string, string>}\\n   */\\n  #htmlCacheMap = new Map();\\n\\n  /**\\n   * A Map from input text strings to their translated text strings.\\n   *\\n   * This cache is used to check if we already have a translated response for the given\\n   * input text, to help avoid spending CPU cycles translating text for which we already\\n   * know the translated output.\\n   *\\n   * @type {Map<string, string>}\\n   */\\n  #textCacheMap = new Map();\\n\\n  /**\\n   * A Set containing strings of translated HTML output.\\n   *\\n   * This cache is used to check if the HTML has already been translated,\\n   * to help avoid sending already-translated HTML to be translated a second time.\\n   *\\n   * Ideally, a translation model that receives source text that is already in the\\n   * target translation language should just pass it through, but this is not always\\n   * the case in practice. Depending on the model, sending already-translated text to\\n   * be translated again may change the translation or even produce garbage as a response.\\n   *\\n   * Best to avoid this situation altogether if we can.\\n   *\\n   * @type {Set<string>}\\n   */\\n  #htmlCacheSet = new Set();\\n\\n  /**\\n   * A Set containing strings of translated plain text output.\\n   *\\n   * This cache is used to check if the text has already been translated,\\n   * to help avoid sending already-translated text to be translated a second time.\\n   *\\n   * Ideally, a translation model that receives source text that is already in the\\n   * target translation language should just pass it through, but this is not always\\n   * the case in practice. Depending on the model, sending already-translated text to\\n   * be translated again may change the translation or even produce garbage as a response.\\n   *\\n   * Best to avoid this situation altogether if we can.\\n   *\\n   * @type {Set<string>}\\n   */\\n  #textCacheSet = new Set();\\n\\n  /**\\n   * The language pair for this cache. All cached translations will be for the given pair.\\n   *\\n   * @type {LanguagePair}\\n   */\\n  #languagePair;\\n\\n  /**\\n   * The limit of entries that can be held in each underlying cache before old entries\\n   * will start being replaced by new entries.\\n   *\\n   * @type {number}\\n   */\\n  #cacheLimit = 5_000;\\n\\n  /**\\n   * This cache will self-destruct after 10 minutes.\\n   *\\n   * @type {number}\\n   */\\n  #cacheExpirationMS = 10 * 60_000;\\n\\n  /**\\n   * The source and target langue pair for the content in this cache.\\n   *\\n   * @param {LanguagePair} languagePair\\n   */\\n  constructor(languagePair) {\\n    this.#languagePair = languagePair;\\n  }\\n\\n  /**\\n   * Retrieves the corresponding Map from source text to translated text.\\n   *\\n   * This is used to determine if a cached translation already exists for\\n   * the given source text, preventing us from having to spend CPU time by\\n   * recomputing the translation.\\n   *\\n   * @param {boolean} isHTML\\n   *\\n   * @returns {Map<string, string>}\\n   */\\n  #getCacheMap(isHTML) {\\n    return isHTML ? this.#htmlCacheMap : this.#textCacheMap;\\n  }\\n\\n  /**\\n   * Retrieves the corresponding Set of translated text responses\\n   *\\n   * This is used to determine if the text being sent to translate\\n   * has already been translated. In such a situation we want to\\n   * avoid sending it to the translator a second time.\\n   *\\n   * @param {boolean} isHTML\\n   * @returns {Set<string>}\\n   */\\n  #getCacheSet(isHTML) {\\n    return isHTML ? this.#htmlCacheSet : this.#textCacheSet;\\n  }\\n\\n  /**\\n   * Get a translation if it exists from the cache, and move it to the end of the cache\\n   * to keep it alive longer.\\n   *\\n   * @param {string} sourceString\\n   * @param {boolean} isHTML\\n   *\\n   * @returns {string | undefined}\\n   */\\n  get(sourceString, isHTML) {\\n    const cacheMap = this.#getCacheMap(isHTML);\\n    const targetString = cacheMap.get(sourceString);\\n\\n    if (targetString === undefined) {\\n      return undefined;\\n    }\\n\\n    // Maps are ordered, move this item to the end of the list so it will stay\\n    // alive longer.\\n    cacheMap.delete(sourceString);\\n    cacheMap.set(sourceString, targetString);\\n\\n    this.keepAlive();\\n\\n    return targetString;\\n  }\\n\\n  /**\\n   * Adds a new translation to the cache, a mapping from the source text to the target text.\\n   *\\n   * @param {string} sourceString\\n   * @param {string} targetString\\n   * @param {boolean} isHTML\\n   */\\n  set(sourceString, targetString, isHTML) {\\n    const cacheMap = this.#getCacheMap(isHTML);\\n    if (cacheMap.has(sourceString)) {\\n      // The Map already has this value, so we must delete it to\\n      // re-insert it at the most-recently-used position of the Map.\\n      cacheMap.delete(sourceString);\\n    } else if (cacheMap.size === this.#cacheLimit) {\\n      // The Map is at capacity, so we must evict the least-recently-used value.\\n      const oldestKey = cacheMap.keys().next().value;\\n      // @ts-ignore: We can ensure that oldestKey is not undefined.\\n      cacheMap.delete(oldestKey);\\n    }\\n    cacheMap.set(sourceString, targetString);\\n\\n    const cacheSet = this.#getCacheSet(isHTML);\\n    if (cacheSet.has(targetString)) {\\n      // The Set already has this value, so we must delete it to\\n      // re-insert it at the most-recently-used position of the Set.\\n      cacheSet.delete(targetString);\\n    } else if (cacheSet.size === this.#cacheLimit) {\\n      // The Set is at capacity, so we must evict the least-recently-used value.\\n      const oldestKey = cacheSet.keys().next().value;\\n      // @ts-ignore: We can ensure that oldestKey is not undefined.\\n      cacheSet.delete(oldestKey);\\n    }\\n    cacheSet.add(targetString);\\n\\n    this.keepAlive();\\n  }\\n\\n  /**\\n   * Returns true if the source text is text that has already been translated\\n   * into the target language, otherwise false. If so, we want to avoid sending\\n   * this text to be translated a second time. Depending on the model, retranslating\\n   * text that is already in the target language may produce garbage output.\\n   *\\n   * @param {string} sourceText\\n   * @param {boolean} isHTML\\n   *\\n   * @returns {boolean}\\n   */\\n  isAlreadyTranslated(sourceText, isHTML) {\\n    return this.#getCacheSet(isHTML).has(sourceText);\\n  }\\n\\n  /**\\n   * Returns true if the given pair matches the language pair for this cache, otherwise false.\\n   *\\n   * @param {LanguagePair} languagePair\\n   *\\n   * @returns {boolean}\\n   */\\n  matches(languagePair) {\\n    return (\\n      lazy.TranslationsUtils.langTagsMatch(\\n        this.#languagePair.sourceLanguage,\\n        languagePair.sourceLanguage\\n      ) &&\\n      lazy.TranslationsUtils.langTagsMatch(\\n        this.#languagePair.targetLanguage,\\n        languagePair.targetLanguage\\n      )\\n    );\\n  }\\n\\n  /**\\n   * The id for the cache's keep-alive timeout, at which point it will destroy itself.\\n   *\\n   * @type {number}\\n   */\\n  #keepAliveTimeoutId = 0;\\n\\n  /**\\n   * Used to ensure that only one callback is added to the event loop to set keep-alive timeout.\\n   *\\n   * @type {boolean}\\n   */\\n  #hasPendingKeepAliveCallback = false;\\n\\n  /**\\n   * Resets the timer for the cache's keep-alive timeout, extending the time the cache will live.\\n   */\\n  keepAlive() {\\n    if (this.#hasPendingKeepAliveCallback) {\\n      // There is already a pending callback to extend the timeout.\\n      return;\\n    }\\n\\n    if (this.#keepAliveTimeoutId) {\\n      lazy.clearTimeout(this.#keepAliveTimeoutId);\\n      this.#keepAliveTimeoutId = 0;\\n    }\\n\\n    this.#hasPendingKeepAliveCallback = true;\\n    lazy.setTimeout(() => {\\n      this.#hasPendingKeepAliveCallback = false;\\n      this.#keepAliveTimeoutId = lazy.setTimeout(() => {\\n        this.#htmlCacheMap = new Map();\\n        this.#textCacheMap = new Map();\\n        this.#htmlCacheSet = new Set();\\n        this.#textCacheSet = new Set();\\n      }, this.#cacheExpirationMS);\\n    }, 0);\\n  }\\n}\\n\\n/**\\n * How often the DOM is updated with translations, in milliseconds.\\n *\\n * Each time the DOM is updated, we must pause the mutation observer.\\n *\\n *  - Stopping the observer takes about 5 micro seconds based on profiling.\\n *\\n *  - Starting the observer takes about 30 micro seconds based on profiling.\\n *\\n * We want to choose a DOM update interval that is fast enough to feel instantaneously\\n * reactive when completed translation requests come in, while also allowing multiple\\n * nodes to be updated within a single pause of the observer.\\n *\\n * @type {number}\\n */\\nconst DOM_UPDATE_INTERVAL_MS = 25;\\n\\n/**\\n * Tags excluded from content translation.\\n */\\nconst CONTENT_EXCLUDED_TAGS = new Set([\\n  // The following are elements that semantically should not be translated.\\n  \\\"CODE\\\",\\n  \\\"KBD\\\",\\n  \\\"SAMP\\\",\\n  \\\"VAR\\\",\\n  \\\"ACRONYM\\\",\\n\\n  // The following are deprecated tags.\\n  \\\"DIR\\\",\\n  \\\"APPLET\\\",\\n\\n  // The following are embedded elements, and are not supported (yet).\\n  \\\"MATH\\\",\\n  \\\"EMBED\\\",\\n  \\\"OBJECT\\\",\\n  \\\"IFRAME\\\",\\n\\n  // This is an SVG tag that can contain arbitrary XML, ignore it.\\n  \\\"METADATA\\\",\\n\\n  // These are elements that are treated as opaque by Firefox which causes their\\n  // innerHTML property to be just the raw text node behind it. Any text that is sent as\\n  // HTML must be valid, and there is no guarantee that the innerHTML is valid.\\n  \\\"NOSCRIPT\\\",\\n  \\\"NOEMBED\\\",\\n  \\\"NOFRAMES\\\",\\n\\n  // The title is handled separately, and a HEAD tag should not be considered.\\n  \\\"HEAD\\\",\\n\\n  // These are not user-visible tags.\\n  \\\"STYLE\\\",\\n  \\\"SCRIPT\\\",\\n  \\\"TEMPLATE\\\",\\n\\n  // Textarea elements contain user content, which should not be translated.\\n  \\\"TEXTAREA\\\",\\n]);\\n\\n/**\\n * Tags excluded from attribute translation.\\n */\\nconst ATTRIBUTE_EXCLUDED_TAGS = (() => {\\n  const attributeTags = new Set(CONTENT_EXCLUDED_TAGS);\\n\\n  // The <head> element may contain <meta> elements that may have translatable attributes.\\n  // So we will allow <head> for attribute translations, but not for content translations.\\n  attributeTags.delete(\\\"HEAD\\\");\\n\\n  // <textarea> elements are excluded from content translation, because we do not want to\\n  // translate text that the user types, but the \\\"placeholder\\\"attribute should be translated.\\n  attributeTags.delete(\\\"TEXTAREA\\\");\\n\\n  return attributeTags;\\n})();\\n\\n/**\\n * A map of criteria to determine if an attribute is translatable for a given element.\\n * Each key in the map represents an attribute name, while the value can be either `null` or an array of further criteria.\\n *\\n * - If the criteria value is `null`, the attribute is considered translatable for any element.\\n *\\n * - If the criteria array is specified, then at least one criterion must match a given element in order for the attribute to be translatable.\\n *   Each object in the array defines a tagName and optional conditions to match against an element in question.\\n *\\n *   - If none of the tagNames match the element, then the attribute is not translatable for that element.\\n *\\n *   - If a tagName matches and no further conditions are specified, then the attribute is always translatable for elements of that type.\\n *\\n *   - If a tagName matches and further conditions are specified, then at least one of the conditions must match for the attribute to be translatable for that element.\\n *\\n * Example:\\n *\\n * - \\\"title\\\" is translatable for all elements.\\n *\\n * - \\\"label\\\" is translatable only for \\\"TRACK\\\" elements.\\n *\\n * - \\\"value\\\" is translatable only for \\\"INPUT\\\" elements whose \\\"type\\\" attribute is \\\"button\\\", \\\"reset\\\".\\n *\\n * @type {Map<string, Array<{ tagName: string, conditions?: Record<string, Array<string>> }> | null>}\\n */\\nconst TRANSLATABLE_ATTRIBUTES = new Map([\\n  [\\\"abbr\\\", [{ tagName: \\\"TH\\\" }]],\\n  [\\n    \\\"alt\\\",\\n    [\\n      { tagName: \\\"AREA\\\" },\\n      { tagName: \\\"IMAGE\\\" },\\n      { tagName: \\\"IMG\\\" },\\n      { tagName: \\\"INPUT\\\" },\\n    ],\\n  ],\\n  [\\\"aria-braillelabel\\\", null],\\n  [\\\"aria-brailleroledescription\\\", null],\\n  [\\\"aria-colindextext\\\", null],\\n  [\\\"aria-description\\\", null],\\n  [\\\"aria-label\\\", null],\\n  [\\\"aria-placeholder\\\", null],\\n  [\\\"aria-roledescription\\\", null],\\n  [\\\"aria-rowindextext\\\", null],\\n  [\\\"aria-valuetext\\\", null],\\n  [\\n    \\\"content\\\",\\n    [{ tagName: \\\"META\\\", conditions: { name: [\\\"description\\\", \\\"keywords\\\"] } }],\\n  ],\\n  [\\\"download\\\", [{ tagName: \\\"A\\\" }, { tagName: \\\"AREA\\\" }]],\\n  [\\n    \\\"label\\\",\\n    [{ tagName: \\\"TRACK\\\" }, { tagName: \\\"OPTGROUP\\\" }, { tagName: \\\"OPTION\\\" }],\\n  ],\\n  [\\\"placeholder\\\", [{ tagName: \\\"INPUT\\\" }, { tagName: \\\"TEXTAREA\\\" }]],\\n  [\\\"title\\\", null],\\n  [\\n    // We only want to translate value attributes for button-like <input> elements.\\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=1919230#c10\\n    // type: submit is not translated because it may affect form submission, depending on how the server is configured.\\n    // See https://github.com/whatwg/html/issues/3396#issue-291182587\\n    \\\"value\\\",\\n    [{ tagName: \\\"INPUT\\\", conditions: { type: [\\\"button\\\", \\\"reset\\\"] } }],\\n  ],\\n]);\\n\\n/**\\n * A single CSS selector string that matches elements with the criteria defined in TRANSLATABLE_ATTRIBUTES.\\n *\\n * @see TRANSLATABLE_ATTRIBUTES\\n *\\n * @type {string}\\n */\\nconst TRANSLATABLE_ATTRIBUTES_SELECTOR = (() => {\\n  const selectors = [];\\n\\n  for (const [attribute, criteria] of TRANSLATABLE_ATTRIBUTES) {\\n    if (!criteria) {\\n      // There are no further criteria: we translate this attribute for all elements.\\n      // Example: [title]\\n      selectors.push(`[${attribute}]`);\\n      continue;\\n    }\\n\\n    for (const { tagName, conditions } of criteria) {\\n      if (!conditions) {\\n        // There are no further conditions: we translate this attribute for all elements with this tagName.\\n        // Example: TRACK[label]\\n        selectors.push(`${tagName}[${attribute}]`);\\n        continue;\\n      }\\n\\n      // Further conditions are specified, so we must add a selector for each condition.\\n      for (const [key, values] of Object.entries(conditions)) {\\n        for (const value of values) {\\n          // Example: INPUT[value][type=\\\"button\\\"]\\n          selectors.push(`${tagName}[${attribute}][${key}=\\\"${value}\\\"]`);\\n        }\\n      }\\n    }\\n  }\\n\\n  return selectors.join(\\\",\\\");\\n})();\\n\\n/**\\n * Options used by the mutation observer\\n */\\nconst MUTATION_OBSERVER_OPTIONS = {\\n  characterData: true,\\n  childList: true,\\n  subtree: true,\\n  attributes: true,\\n  attributeOldValue: true,\\n  attributeFilter: [...TRANSLATABLE_ATTRIBUTES.keys()],\\n};\\n\\n/**\\n * This class manages the process of translating the DOM from one language to another.\\n *\\n * The logic within this class is generally separated into two types of translations:\\n * Content Translations and Attribute Translations.\\n *\\n *  - For Content Translations, the DOM is traversed, filtered, and subdivided into smaller\\n *    groups of Nodes that have translatable text content.\\n *\\n *  - For Attribute Translations, a series of query selectors are used to filter all of\\n *    the Nodes that have translatable attributes within the DOM.\\n *\\n * Once nodes have been identified for both Content Translations and Attribute Translations,\\n * they are then registered for intersection observation and mutation observation.\\n *\\n * The mutation observer notifies us when a Node's content has changed, when a Node's translatable\\n * attributes have changed, as well as when new nodes are added into the DOM tree, and need to be\\n * further filtered, subdivided, and registered for intersection observation.\\n *\\n * In total, four intersection observers are used to prioritize which nodes should be translated: two to\\n * handle content-translation observations, and the other two to handle attribute-translation observations.\\n *\\n * Once intersections have been observed, the relevant nodes are sent into a queue where they will\\n * wait to be assigned a priority, based on both the type of translation, as well as the Node's location\\n * relative to the viewport of the screen.\\n *\\n * Prioritized nodes are then sent to the translation scheduler @see {TranslationScheduler}, which\\n * will attempt to optimally send requests to the TranslationsEngine worker to be translated, based\\n * both on the engine's throughput as well as on how many new translation requests are coming in.\\n *\\n * Once a request has come back from the TranslationsEngine worker, its response is validated, then\\n * the relevant node's content or attribute is scheduled to be updated in the DOM with the corresponding\\n * result of the translation.\\n *\\n * Note that a pending translation request may be cancelled at any stage in this process, up until the point\\n * where the request has come back from the TranslationsEngine worker, and the Node's content or attribute\\n * has been replaced in the DOM. Cancellations may happen for one of several reasons:\\n *\\n *  1) The page has been hidden (such as switching tabs), and we are pausing all execution until it is shown again.\\n *  2) The user has scrolled to a new location on the page entirely, and prior requests are no longer relevant.\\n *  3) A Node's location with respect to the viewport has changed and it needs a new translation priority.\\n *  4) A Node's content has mutated within the DOM, and the pending translation request is no longer relevant.\\n *\\n * The following diagram shows the flow of translations throughout the entire lifecycle of the TranslationsDocument.\\n *\\n *                             ┌────────────────────────┐    ┌──────────┐\\n *                             │ Register DOM roots for │    │ Mutation │\\n *                             │ mutation observation   │    │ Observer │\\n *                             └────────────────────────┘    └──────────┘\\n *                                         │                      │\\n *                                         │                      │ New nodes\\n *                                         │                      │ observed\\n *                                         v                      │\\n *                                ┌─────────────────┐             │\\n *                                │ Subdivide nodes │ <───────────┘\\n *                                │ within the DOM  │\\n *                                └─────────────────┘\\n *                                         │\\n *                                         │\\n *                                         │\\n *                                         v\\n *                                ┌──────────────────┐\\n *                                │ Register nodes   │\\n * ┌────────────────────────────> │ for intersection │\\n * │                              │ observation      │\\n * │                              └──────────────────┘\\n * │                                       │\\n * │                                       │\\n * │                                       │\\n * │                                       v\\n * │                              ┌───────────────────┐\\n * │                              │ Wait for observed │\\n * │  ┌─────────────────────────> │ intersection      │\\n * │  │                           └───────────────────┘\\n * │  │                                    │\\n * │  │                                    │ Node intersection with\\n * │  │                                    │ viewport is observed\\n * │  │                                    │\\n * │  │                                    v\\n * │  │  ┌────────┐ Node mutated  ┌──────────────────┐\\n * │  ├─ │ Cancel │ <──────────── │ Enqueue node for │ Node's intersection context with\\n * │  │  └────────┘               │ prioritization   │ respect to the viewport has changed   ┌────────┐\\n * │  │                           │                  │ ────────────────────────────────────> │ Cancel │\\n * │  │                           └──────────────────┘                                       └────────┘\\n * │  │                                    │   ^   ^                                              │ Node's new intersection context is\\n * │  │           Send prioritized node    │   │   │                                              │ still relevant to be translated\\n * │  │           to translation scheduler │   │   └──────────────────────────────────────────────┘\\n * │  │                                    │   │\\n * │  │                                    v   └───────────────────────────────────────────────────┐\\n * │  │                           ┌───────────────────┐                                            │ Node's new intersection context is\\n * │  │                           │ Scheduler creates │ Node's intersection context with           │ still relevant to be translated\\n * │  │  ┌────────┐ Node mutated  │ a request promise │ respect to the viewport has changed    ┌────────┐\\n * │  ├─ │ Cancel │ <──────────── │ for the node      │ ─────────────────────────────────────> │ Cancel │\\n * │  │  └────────┘               └───────────────────┘                                        └────────┘\\n * │  │                                    │\\n * │  │                                    │ Send translation request\\n * │  │                                    │ to TranslationsEngine\\n * │  │                                    │\\n * │  │                                    v\\n * │  │                           ┌───────────────────┐\\n * │  │                           │ Wait for response │\\n * │  │  ┌────────┐ Node mutated  │ from translations │\\n * │  ├─ │ Cancel │ <──────────── │ engine            │\\n * │  │  └────────┘               └───────────────────┘\\n * │  │                                    │\\n * │  │                                    │ Receive response with\\n * │  │                                    │ translated text for node\\n * │  │                                    │\\n * │  │                                    v\\n * │  │                           ┌───────────────┐\\n * │  │                           │ Schedule node │\\n * │  │  ┌────────┐  Node mutated │ to be updated │\\n * │  └─ │ Cancel │ <──────────── │               │\\n * │     └────────┘               └───────────────┘\\n * │                                       │\\n * │                                       │ Update node content\\n * │                                       │ or attribute with\\n * │                                       │ translated text\\n * │                                       v\\n * │                              ┌───────────────────┐\\n * │                              │ Unregister node   │\\n * │                 Node mutated │ from intersection │\\n * └───────────────────────────── │ observation       │\\n *                                └───────────────────┘\\n */\\nexport class TranslationsDocument {\\n  /**\\n   * The BCP 47 language tag that matches the page's source language.\\n   *\\n   * If elements are found that do not match this language, then they are skipped,\\n   * because our translation models only operate between the exact language pair.\\n   *\\n   * @type {string}\\n   */\\n  #documentLanguage;\\n\\n  /**\\n   * Marks when we have a pending callback for updating all nodes whose content translation\\n   * requests have completed. This ensures that we won't redundantly request to update nodes.\\n   *\\n   * @type {boolean}\\n   */\\n  #hasPendingUpdateContentCallback = false;\\n\\n  /**\\n   * Marks when we have a pending callback for updating all elements whose attribute\\n   * translation requests have completed. This ensures that we won't redundantly request\\n   * to update nodes.\\n   *\\n   * @type {boolean}\\n   */\\n  #hasPendingUpdateAttributesCallback = false;\\n\\n  /**\\n   * A map of elements with translatable text content that may be prevented and removed\\n   * by the intersection observers before they are prioritized and sent to the scheduler.\\n   *\\n   * @type {Map<Element, Set<Node>>}\\n   */\\n  #queuedIntersectionPrunableContentElements = new Map();\\n\\n  /**\\n   * A map of elements with translatable text content that are unaffected by intersection\\n   * observation. An example of this would be the <title> element, which will never intersect\\n   * with the viewport.\\n   *\\n   * @type {Map<Element, Set<Node>>}\\n   */\\n  #queuedIntersectionExemptContentElements = new Map();\\n\\n  /**\\n   * A map of elements with translatable attributes that may be prevented and removed\\n   * by the intersection observers before they are prioritized and sent to the scheduler.\\n   *\\n   * @type {Map<Element, Set<string>>}\\n   */\\n  #queuedIntersectionPrunableAttributeElements = new Map();\\n\\n  /**\\n   * A map of elements with translatable attributes that are unaffected by intersection\\n   * observation. An example of this would be the <head> element, which may have translatable\\n   * attributes, but will never intersect with the viewport.\\n   *\\n   * @type {Map<Element, Set<string>>}\\n   */\\n  #queuedIntersectionExemptAttributeElements = new Map();\\n\\n  /**\\n   * The list of nodes that need updating with the translated content. These are batched into an update.\\n   * The translationId is a monotonically increasing number that represents a unique id for a translation.\\n   * It guards against races where a node is mutated before the translation is returned. The translation is\\n   * asynchronously cancelled during a mutation, but it can still return a translation before it is\\n   * cancelled.\\n   *\\n   * @type {Set<{ element: Element, targetNode: Node, translatedContent: string, translationId: number }>}\\n   */\\n  #elementsThatNeedContentUpdates = new Set();\\n\\n  /**\\n   * The list of nodes that need updating with the translated attributes. These are batched into an update.\\n   * The translationId is a monotonically increasing number that represents a unique id for a translation.\\n   * It guards against races where a node is mutated before the translation is returned. The translation is\\n   * asynchronously cancelled during a mutation, but it can still return a translation before it is\\n   * cancelled.\\n   *\\n   * @type {Set<{ element: Element, translation: string, attribute: string, translationId: number }>}\\n   */\\n  #elementsThatNeedAttributeUpdates = new Set();\\n\\n  /**\\n   * This is the set of nodes (both elements and text nodes) whose translation requests\\n   * have fully completed, and the node's content has been updated with the translated\\n   * value.\\n   *\\n   * Nodes will be removed from this set when they are observed for mutations.\\n   *\\n   * @type {WeakSet<Node>}\\n   */\\n  #processedContentNodes = new WeakSet();\\n\\n  /**\\n   * All root elements we're trying to translate. This should be the `document.body`\\n   * the `head` (for attributes only), and the `title` element.\\n   *\\n   * @type {Set<Node>}\\n   */\\n  #rootNodes = new Set();\\n\\n  /**\\n   * A collection of nodes whose text content has mutated, which will be batched\\n   * together and sent to be re-translated once every requestAnimationFrame.\\n   *\\n   * @type {Set<Node>}\\n   */\\n  #nodesWithMutatedContent = new Set();\\n\\n  /**\\n   * A collection of elements whose attributes have mutated, which will be batched\\n   * together and sent to be re-translated once every requestAnimationFrame.\\n   *\\n   * @type {Map<Element, Set<string>>}\\n   */\\n  #elementsWithMutatedAttributes = new Map();\\n\\n  /**\\n   * Marks when we have a pending callback for updating the mutated nodes.\\n   * This ensures that we won't redundantly request for nodes to be updated.\\n   *\\n   * @type {boolean}\\n   */\\n  #hasPendingMutatedNodesCallback = false;\\n\\n  /**\\n   * Marks when we have a pending callback for sending prioritizing translation\\n   * requests and submitting them to the TranslationScheduler. This ensures that\\n   * we won't redundantly request prioritization.\\n   *\\n   * @type {boolean}\\n   */\\n  #hasPendingPrioritizationCallback = false;\\n\\n  /**\\n   * This boolean indicates whether the first visible DOM translation change is about to occur.\\n   *\\n   * @type {boolean}\\n   */\\n  #hasFirstVisibleChange = false;\\n\\n  /**\\n   * A unique ID that guards against races between translations and mutations.\\n   *\\n   * @type {Map<Element, Map<Node, number>>}\\n   */\\n  #pendingContentTranslations = new Map();\\n\\n  /**\\n   * A unique ID that guards against races between translations and mutations. The\\n   * Map<string, number> is a mapping of the node's attribute to the translation id.\\n   *\\n   * @type {Map<Element, Map<string, number>>}\\n   */\\n  #pendingAttributeTranslations = new Map();\\n\\n  /**\\n   * Cache a map of all child nodes to their pending parents. This lookup was slow\\n   * from profiling sites like YouTube with lots of mutations. Caching the relationship\\n   * speeds it up.\\n   *\\n   * @type {WeakMap<Node, Node>}\\n   */\\n  #nodeToPendingParent = new WeakMap();\\n\\n  /**\\n   * The y-axis location of the viewport the previous time a scroll event was fired.\\n   *\\n   * @type {number}\\n   */\\n  #previousScrollY = 0;\\n\\n  /**\\n   * A hint at the most recent direction in which the user scrolled since requesting translations.\\n   * This helps with the prioritization of translation requests for outside-of-viewport nodes.\\n   *\\n   * @type {ScrollDirection?}\\n   */\\n  #mostRecentScrollDirection = null;\\n\\n  /**\\n   * The most recent timestamp from a \\\"scroll\\\" event.\\n   *\\n   * @type {number}\\n   */\\n  #mostRecentScrollTimestamp = 0;\\n\\n  /**\\n   * Start with 1 so that it will never be falsey.\\n   *\\n   * @type {number}\\n   */\\n  #lastTranslationId = 1;\\n\\n  /**\\n   * A cache of recent translations, used to avoid wasting CPU time translating text\\n   * for which we already have a translated response.\\n   *\\n   * @type {LRUCache}\\n   */\\n  #translationsCache;\\n\\n  /**\\n   * The DOMParser is used when updating elements with translated text.\\n   *\\n   * @type {DOMParser}\\n   */\\n  #domParser;\\n\\n  /**\\n   * The mutation observer that watches for both new and mutated nodes.\\n   *\\n   * @type {MutationObserver}\\n   */\\n  #mutationObserver;\\n\\n  /**\\n   * The inner-window ID is used for better profiler marker reporting.\\n   *\\n   * @type {number}\\n   */\\n  #innerWindowId;\\n\\n  /**\\n   * The original document of the page that we will be updating with translated text.\\n   *\\n   * @type {Document}\\n   */\\n  #sourceDocument;\\n\\n  /**\\n   * A callback that will report that the first visible change has been made to the page.\\n   * This is a key performance metric when considering the time to initialize translations.\\n   *\\n   * @type {() => void}\\n   */\\n  #actorReportFirstVisibleChange;\\n\\n  /**\\n   * The scheduler that is responsible for sending translation requests to the TranslationsEngine.\\n   *\\n   * @type {TranslationScheduler}\\n   */\\n  #scheduler;\\n\\n  /**\\n   * The script direction of the target language.\\n   *\\n   * @type {(\\\"ltr\\\"|\\\"rtl\\\")}\\n   */\\n  #targetScriptDirection;\\n\\n  /**\\n   * The mode of translation, either \\\"content-eager\\\" or \\\"lazy\\\".\\n   *\\n   * When the find bar is closed, the mode will be \\\"lazy\\\", translating only content near the viewport.\\n   * This is better for power consumption, conserves battery on mobile, etc., and is the default behavior.\\n   *\\n   * When the find bar is open, the mode will change to \\\"content-eager\\\", eventually translating the entire page,\\n   * regardless of proximity to the viewport. This way the find-in-page functionality will work as intended.\\n   *\\n   * @type {TranslationsMode}\\n   */\\n  #translationsMode;\\n\\n  /**\\n   * A map containing all elements that are being observed for content translations,\\n   * and the set of translatable nodes for that element.\\n   *\\n   * Only Element type nodes are observable for intersection, so in order to observe\\n   * a Text Node for intersection, it must be linked to its parent element.\\n   *\\n   * Note that the set of translatable nodes may contain the element itself.\\n   *\\n   * @type {Map<Element, Set<Node>>}\\n   */\\n  #intersectionObservedContentElements = new Map();\\n\\n  /**\\n   * A map containing all elements that are being observed for attribute translations,\\n   * and the set of translatable attribute names for each element.\\n   *\\n   * @type {Map<Element, Set<string>>}\\n   */\\n  #intersectionObservedAttributeElements = new Map();\\n\\n  // The following four intersection observers are responsible for detecting when nodes are within close enough range of the viewport\\n  // to have their content and/or attributes scheduled to be translated. Two observers are dedicated to observing nodes with translatable\\n  // text content, and two observers are dedicated to observing nodes with translatable attributes.\\n  //\\n  // Each pair has one In-Viewport Observer and one Beyond-Viewport Observer. The priority at which a node's translations are scheduled is\\n  // determined by its location within these observer pairs. Translations for nodes that are observed by the In-Viewport observers are scheduled\\n  // at the highest priority. Translations for nodes that are observed by the Beyond-Viewport observers are scheduled at lower priorities.\\n  //\\n  // As the location of the viewport changes with respect to the page, translations for nodes may be reprioritized or cancelled altogether.\\n  // The following diagram shows a few examples of how translation priorities for nodes may change as the viewport moves:\\n  //\\n  //\\n  //                                    Page                                                             Page\\n  //                   ┌─────────────────────────────────────┐                          ┌─────────────────────────────────────┐\\n  //                   │ ~~~                    ~ ~ ~ ~ ~    │                          │ ~~~                    ~ ~ ~ ~ ~    │\\n  //                   │                                     │                          │                                     │\\n  //                   │         ~~~~~~~~~~~~~~~~~~          │                          │         ~~~~~~~~~~~~~~~~~~          │\\n  // Beyond-Viewport ══╪═> ┌─────────────────────────────┐   │   v                      │ ╔═══════════════════════════════════╪════╦═══ Translations for these nodes\\n  // Observer          │   │ ~~  ~~~~~~~~~~~~~~~~~~      │   │   v                      │ ╠═> ~~  ~~~~~~~~~~~~~~~~~~  <═══════╪════╣    will be cancelled if their\\n  //                   │   │ ~~  ~~~~~~~~~~~~~~~~~~~     │   │   v                      │ ╚═> ~~  ~~~~~~~~~~~~~~~~~~~ <═══════╪════╣    requests did not yet complete.\\n  //                   │   │                             │   │   v                      │                                     │    ║\\n  //     In-Viewport ══╪═══╪══> ┌───────────────────┐    │   │   v                      │                                     │    ║\\n  //     Observer      │   │    │~~~~~~~~~~~~~~~~~  │    │   │   v                      │         ~~~~~~~~~~~~~~~~~   <═══════╪════╝\\n  //                   │   │    │                   │    │   │   v    Beyond-Viewport ══╪═> ┌─────────────────────────────┐   │\\n  //                   │   │    │~~~~~~~~~~~~~~~~~~ │    │   │   v    Observer          │   │     ~~~~~~~~~~~~~~~~~~~ <═══╪═══╪════╦═══ Translations for these nodes\\n  //                   │   │    │                   │    │   │                          │   │                             │   │    ║    will be moved to a lower priority\\n  //                   │   │    └───────────────────┘    │   │ Scroll                   │   │     ~~~~~~~~~~~~~~~~~~ <════╪═══╪════╝    if their requests did not yet complete.\\n  //                   │   │                             │   │  down      In-Viewport ══╪═══╪══> ┌───────────────────┐    │   │\\n  //                   │   │ ~~                          │   │            Observer      │   │ ~~ │                   │    │   │\\n  //                   │   │ ~~  ~~~~~~~~~~~~~~~         │   │   v                      │   │ ~~ │~~~~~~~~~~~~~~~ <══╪════╪═══╪════════ Translations for this node will\\n  //                   │   └─────────────────────────────┘   │   v                      │   │    │                   │    │   │         be moved to a higher priority if\\n  //                   │                                     │   v                      │   │    │                   │    │   │         its requests did not yet complete.\\n  //                   │                                     │   v                      │   │    └───────────────────┘    │   │\\n  //                   │                                     │   v                      │   │                             │   │\\n  //                   │         ~~~~~~~~~~~~~~~~~~          │   v                      │   │     ~~~~~~~~~~~~~~~~~~ <════╪═══╪════╦═══ Translations for these nodes will\\n  //                   │         ~~~~~~~~~~~~~~~~~           │   v                      │   │     ~~~~~~~~~~~~~~~~~ <═════╪═══╪════╝    be newly requested at a lower priority.\\n  //                   │                                     │                          │   └─────────────────────────────┘   │\\n  //                   │     ~~  ~~~~~~~~~~~~~~~~~~~         │                          │     ~~  ~~~~~~~~~~~~~~~~~~~         │\\n  //                   │         ~~~~~~~~~~~~~~~~            │                          │         ~~~~~~~~~~~~~~~~            │\\n  //                   │ ~~~                            ~~~~ │                          │ ~~~                            ~~~~ │\\n  //                   └─────────────────────────────────────┘                          └─────────────────────────────────────┘\\n\\n  /**\\n   * An intersection observer bound to the exact dimensions of the viewport\\n   * that watches for nodes whose text content is translatable.\\n   *\\n   * Nodes observed by this observer lead to the highest-priority translation requests\\n   * since they are the nodes that are immediately within the viewport.\\n   *\\n   * @type {IntersectionObserver}\\n   */\\n  #intersectionObserverForContentTranslationsWithinViewport;\\n\\n  /**\\n   * A promise that is resolved once the in-viewport content intersection observer's\\n   * first observation has completed.\\n   *\\n   * @type {PromiseWithResolvers<void>}\\n   */\\n  #contentWithinViewportInitialObservation = Promise.withResolvers();\\n\\n  /**\\n   * An intersection observer whose borders extend beyond the viewport\\n   * that watches for nodes whose text content is translatable.\\n   *\\n   * Nodes observed by this observer lead to lower-priority translation requests\\n   * since they lie just beyond the viewport of what the user can see.\\n   *\\n   * @type {IntersectionObserver}\\n   */\\n  #intersectionObserverForContentTranslationsBeyondViewport;\\n\\n  /**\\n   * A promise that is resolved once the beyond-viewport content intersection observer's\\n   * first observation has completed.\\n   *\\n   * @type {PromiseWithResolvers<void>}\\n   */\\n  #contentBeyondViewportInitialObservation = Promise.withResolvers();\\n\\n  /**\\n   * An intersection observer bound to the exact dimensions of the viewport\\n   * that watches for nodes with attributes that are translatable.\\n   *\\n   * Nodes observed by this observer lead to the highest-priority translation requests\\n   * since they are the nodes that are immediately within the viewport.\\n   *\\n   * @type {IntersectionObserver}\\n   */\\n  #intersectionObserverForAttributeTranslationsWithinViewport;\\n\\n  /**\\n   * A promise that is resolved once the in-viewport attribute intersection observer's\\n   * first observation has completed.\\n   *\\n   * @type {PromiseWithResolvers<void>}\\n   */\\n  #attributesWithinViewportInitialObservation = Promise.withResolvers();\\n\\n  /**\\n   * An intersection observer whose borders extend beyond the viewport\\n   * that watches for nodes with attributes that are translatable.\\n   *\\n   * Nodes observed by this observer lead to lower-priority translation requests\\n   * since they lie just beyond the viewport of what the user can see.\\n   *\\n   * @type {IntersectionObserver}\\n   */\\n  #intersectionObserverForAttributeTranslationsBeyondViewport;\\n\\n  /**\\n   * A promise that is resolved once the beyond-viewport attribute intersection observer's\\n   * first observation has completed.\\n   *\\n   * @type {PromiseWithResolvers<void>}\\n   */\\n  #attributesBeyondViewportInitialObservation = Promise.withResolvers();\\n\\n  /**\\n   * Construct a new TranslationsDocument. It is tied to a specific Document and cannot\\n   * be re-used. The translation functions are injected since this class shouldn't\\n   * manage the life cycle of the translations engines.\\n   *\\n   * @param {Document} document\\n   * @param {string} documentLanguage - The BCP 47 tag of the source language.\\n   * @param {string} targetLanguage - The BCP 47 tag of the destination language.\\n   * @param {number} innerWindowId - This is used for better profiler marker reporting.\\n   * @param {MessagePort} port - The port to the translations engine.\\n   * @param {() => void} requestNewPort - Used when an engine times out and a new\\n   *                                      translation request comes in.\\n   * @param {() => void} reportVisibleChange - Used to report to the actor that the first visible change\\n   *                                           for a translation is about to occur.\\n   * @param {LRUCache} translationsCache - A cache in which to store translated text.\\n   * @param {boolean} isFindBarOpen - Whether the find bar was open in the current tab upon construction.\\n   */\\n  constructor(\\n    document,\\n    documentLanguage,\\n    targetLanguage,\\n    innerWindowId,\\n    port,\\n    requestNewPort,\\n    reportVisibleChange,\\n    translationsCache,\\n    isFindBarOpen\\n  ) {\\n    /** @type {WindowProxy} */\\n    const ownerGlobal = ensureExists(document.ownerGlobal);\\n    ownerGlobal.addEventListener(\\\"scroll\\\", this.#handleScrollEvent);\\n\\n    this.#domParser = new ownerGlobal.DOMParser();\\n    this.#innerWindowId = innerWindowId;\\n    this.#sourceDocument = document;\\n    this.#documentLanguage = documentLanguage;\\n    this.#translationsCache = translationsCache;\\n    this.#actorReportFirstVisibleChange = reportVisibleChange;\\n    this.#targetScriptDirection =\\n      Services.intl.getScriptDirection(targetLanguage);\\n    this.#translationsMode = isFindBarOpen ? \\\"content-eager\\\" : \\\"lazy\\\";\\n\\n    this.#scheduler = new TranslationScheduler(\\n      port,\\n      this.#innerWindowId,\\n      translationsCache,\\n      requestNewPort\\n    );\\n\\n    /**\\n     * This selector runs to find child nodes that should be excluded. It should be\\n     * basically the same implementation of `isExcludedNode`, but as a selector.\\n     *\\n     * @type {string}\\n     */\\n    this.contentExcludedNodeSelector = [\\n      // Use: [lang|=value] to match language codes.\\n      //\\n      // Per: https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\\n      //\\n      // The elements with an attribute name of attr whose value can be exactly\\n      // value or can begin with value immediately followed by a hyphen, - (U+002D).\\n      // It is often used for language subcode matches.\\n      `[lang]:not([lang|=\\\"${this.#documentLanguage}\\\"])`,\\n      `[translate=no]`,\\n      `.notranslate`,\\n      `[contenteditable=\\\"true\\\"]`,\\n      `[contenteditable=\\\"\\\"]`,\\n      [...CONTENT_EXCLUDED_TAGS].join(\\\",\\\"),\\n    ].join(\\\",\\\");\\n\\n    /**\\n     * This selector runs to find elements that should be excluded from attribute translation.\\n     *\\n     * @type {string}\\n     */\\n    this.attributeExcludedNodeSelector = [\\n      // Exclude any element with translate=\\\"no\\\", as it explicitly opts out of translation.\\n      `[translate=\\\"no\\\"]`,\\n\\n      // Exclude any element that is a descendant of a container marked with \\\"notranslate\\\" class.\\n      `.notranslate`,\\n      [...ATTRIBUTE_EXCLUDED_TAGS].join(\\\",\\\"),\\n    ].join(\\\",\\\");\\n\\n    /**\\n     * Define the type of IntersectionObserver for lazily prioritizing translations.\\n     *\\n     * @type {typeof IntersectionObserver}\\n     */\\n    const DocumentIntersectionObserver = ownerGlobal.IntersectionObserver;\\n\\n    this.#intersectionObserverForContentTranslationsWithinViewport =\\n      new DocumentIntersectionObserver(\\n        entries => {\\n          // The count of requests that we prevent from being sent to the TranslationsEngine.\\n          let preventedCount = 0;\\n\\n          // The count of requests that we had to cancel from the TranslationScheduler.\\n          // This is a subset of preventedCount.\\n          let cancelledCount = 0;\\n\\n          // The count of nodes that entered this observer's proximity.\\n          let enteredCount = 0;\\n\\n          // The count of nodes that exited this observer's proximity.\\n          let exitedCount = 0;\\n\\n          const startTime = ChromeUtils.now();\\n          for (const { target, isIntersecting } of entries) {\\n            isIntersecting ? enteredCount++ : exitedCount++;\\n\\n            // The logic here does not care about `isIntersecting`, because it doesn't matter\\n            // whether the target entered the boundary or exited the boundary. If the target\\n            // entered, then it may need to be reprioritized to a higher priority. If it exited\\n            // then the target may need to be reprioritized to a lower priority. In either case, we\\n            // need to try to cancel any unscheduled requests, and resubmit them with a new priority.\\n            const { preventedNodeSet, cancelledFromSchedulerCount } =\\n              this.#preventUnscheduledContentTranslations(target);\\n\\n            if (preventedNodeSet) {\\n              preventedCount += preventedNodeSet.size;\\n              cancelledCount += cancelledFromSchedulerCount;\\n\\n              this.#queuedIntersectionPrunableContentElements.set(\\n                target,\\n                preventedNodeSet\\n              );\\n            }\\n          }\\n\\n          ChromeUtils.addProfilerMarker(\\n            \\\"TranslationsDocument IntersectionObserver (Content)\\\",\\n            { startTime, innerWindowId },\\n            `Within Viewport: ${enteredCount} elements entered, ${exitedCount} exited, ` +\\n              `prevented ${preventedCount} requests: ` +\\n              `${preventedCount - cancelledCount} requests were never sent to the scheduler, ` +\\n              `${cancelledCount} requests were cancelled from the scheduler.`\\n          );\\n\\n          this.#contentWithinViewportInitialObservation.resolve();\\n          this.#maybePrioritizeRequestsAndSubmitToScheduler();\\n        },\\n        {\\n          root: null,\\n          rootMargin: \\\"0% 0% 0% 0%\\\",\\n        }\\n      );\\n\\n    this.#intersectionObserverForContentTranslationsBeyondViewport =\\n      new DocumentIntersectionObserver(\\n        entries => {\\n          // The count of requests that we prevent from being sent to the TranslationsEngine.\\n          let preventedCount = 0;\\n\\n          // The count of requests that we had to cancel from the TranslationScheduler.\\n          // This is a subset of preventedCount.\\n          let cancelledCount = 0;\\n\\n          // The count of nodes that entered this observer's proximity.\\n          let enteredCount = 0;\\n\\n          // The count of nodes that exited this observer's proximity.\\n          let exitedCount = 0;\\n\\n          const startTime = ChromeUtils.now();\\n          for (const { target, isIntersecting } of entries) {\\n            if (isIntersecting) {\\n              // The target has entered the boundary, so we will enqueue it for translation.\\n              // Even if the target is also within the boundary of the in-viewport observer\\n              // this call is idempotent and the target will be enqueued only one time.\\n              enteredCount++;\\n              this.#enqueueForIntersectionPrunableContentPrioritization(target);\\n            } else {\\n              // The target has exited the boundary of the beyond-viewport observer,\\n              // which means that is certainly not within range of the in-viewport observer.\\n              // We should simply cancel the translation at this point until a time when the\\n              // user moves the viewport near to this target again.\\n              exitedCount++;\\n\\n              if (this.#translationsMode === \\\"lazy\\\") {\\n                // We only want to prevent content translations after they exit beyond-viewport\\n                // proximity in \\\"lazy\\\" translations mode. In \\\"content-eager\\\" translation mode,\\n                // we must ensure that all content is still translated regardless of spatial context.\\n                const { preventedNodeSet, cancelledFromSchedulerCount } =\\n                  this.#preventUnscheduledContentTranslations(target);\\n\\n                if (preventedNodeSet) {\\n                  preventedCount += preventedNodeSet.size;\\n                  cancelledCount += cancelledFromSchedulerCount;\\n                }\\n              }\\n            }\\n          }\\n\\n          ChromeUtils.addProfilerMarker(\\n            \\\"TranslationsDocument IntersectionObserver (Content)\\\",\\n            { startTime, innerWindowId },\\n            `Extended Viewport: ${enteredCount} elements entered, ${exitedCount} exited, ` +\\n              `prevented ${preventedCount} requests: ` +\\n              `${preventedCount - cancelledCount} requests were never sent to the scheduler, ` +\\n              `${cancelledCount} requests were cancelled from the scheduler.`\\n          );\\n\\n          this.#contentBeyondViewportInitialObservation.resolve();\\n          this.#maybePrioritizeRequestsAndSubmitToScheduler();\\n        },\\n        {\\n          root: null,\\n          rootMargin: \\\"150% 50% 150% 50%\\\",\\n        }\\n      );\\n\\n    this.#intersectionObserverForAttributeTranslationsWithinViewport =\\n      new DocumentIntersectionObserver(\\n        entries => {\\n          // The count of requests that we prevent from being sent to the TranslationsEngine.\\n          let preventedCount = 0;\\n\\n          // The count of requests that we had to cancel from the TranslationScheduler.\\n          // This is a subset of preventedCount.\\n          let cancelledCount = 0;\\n\\n          // The count of nodes that entered this observer's proximity.\\n          let enteredCount = 0;\\n\\n          // The count of nodes that exited this observer's proximity.\\n          let exitedCount = 0;\\n\\n          const startTime = ChromeUtils.now();\\n          for (const { target, isIntersecting } of entries) {\\n            isIntersecting ? enteredCount++ : exitedCount++;\\n\\n            // The logic here does not care about `isIntersecting`, because it doesn't matter\\n            // whether the target entered the boundary or exited the boundary. If the target\\n            // entered, then it may need to be reprioritized to a higher priority. If it exited\\n            // then the target may need to be reprioritized to a lower priority. In either case, we\\n            // need to try to cancel any unscheduled requests, and resubmit them with a new priority.\\n            const { preventedAttributeSet, cancelledFromSchedulerCount } =\\n              this.#preventUnscheduledAttributeTranslations(target);\\n            if (preventedAttributeSet) {\\n              preventedCount += preventedAttributeSet.size;\\n              cancelledCount += cancelledFromSchedulerCount;\\n              this.#queuedIntersectionPrunableAttributeElements.set(\\n                target,\\n                preventedAttributeSet\\n              );\\n            }\\n          }\\n\\n          ChromeUtils.addProfilerMarker(\\n            \\\"TranslationsDocument IntersectionObserver (Attributes)\\\",\\n            { startTime, innerWindowId },\\n            `Within Viewport: ${enteredCount} elements entered, ${exitedCount} exited, ` +\\n              `prevented ${preventedCount} requests: ` +\\n              `${preventedCount - cancelledCount} requests were never sent to the scheduler, ` +\\n              `${cancelledCount} requests were cancelled from the scheduler.`\\n          );\\n\\n          this.#attributesWithinViewportInitialObservation.resolve();\\n          this.#maybePrioritizeRequestsAndSubmitToScheduler();\\n        },\\n        {\\n          root: null,\\n          rootMargin: \\\"0% 0% 0% 0%\\\",\\n        }\\n      );\\n\\n    this.#intersectionObserverForAttributeTranslationsBeyondViewport =\\n      new DocumentIntersectionObserver(\\n        entries => {\\n          // The count of requests that we prevent from being sent to the TranslationsEngine.\\n          let preventedCount = 0;\\n\\n          // The count of requests that we had to cancel from the TranslationScheduler.\\n          // This is a subset of preventedCount.\\n          let cancelledCount = 0;\\n\\n          // The count of nodes that entered this observer's proximity.\\n          let enteredCount = 0;\\n\\n          // The count of nodes that exited this observer's proximity.\\n          let exitedCount = 0;\\n\\n          const startTime = ChromeUtils.now();\\n          for (const { target, isIntersecting } of entries) {\\n            if (isIntersecting) {\\n              // The target has entered the boundary, so we will enqueue it for translation.\\n              // Even if the target is also within the boundary of the in-viewport observer\\n              // this call is idempotent and the target will be enqueued only one time.\\n              enteredCount++;\\n              this.#enqueueForIntersectionPrunableAttributePrioritization(\\n                target\\n              );\\n            } else {\\n              // The target has exited the boundary of the beyond-viewport observer,\\n              // which means that is certainly not within range of the in-viewport observer.\\n              // We should simply cancel the translation at this point until a time when the\\n              // user moves the viewport near to this target again.\\n              exitedCount++;\\n\\n              const { preventedAttributeSet, cancelledFromSchedulerCount } =\\n                this.#preventUnscheduledAttributeTranslations(target);\\n\\n              if (preventedAttributeSet) {\\n                preventedCount += preventedAttributeSet.size;\\n                cancelledCount += cancelledFromSchedulerCount;\\n              }\\n            }\\n          }\\n\\n          ChromeUtils.addProfilerMarker(\\n            \\\"TranslationsDocument IntersectionObserver (Attributes)\\\",\\n            { startTime, innerWindowId },\\n            `Extended Viewport: ${enteredCount} elements entered, ${exitedCount} exited, ` +\\n              `prevented ${preventedCount} requests: ` +\\n              `${preventedCount - cancelledCount} were never sent to the scheduler, ` +\\n              `${cancelledCount} requests were cancelled from the scheduler.`\\n          );\\n\\n          this.#attributesBeyondViewportInitialObservation.resolve();\\n          this.#maybePrioritizeRequestsAndSubmitToScheduler();\\n        },\\n        {\\n          root: null,\\n          rootMargin: \\\"100% 50% 100% 50%\\\",\\n        }\\n      );\\n\\n    /**\\n     * Define the type of the MutationObserver for editor type hinting.\\n     *\\n     * @type {typeof MutationObserver}\\n     */\\n    const DocumentMutationObserver = ownerGlobal.MutationObserver;\\n\\n    this.#mutationObserver = new DocumentMutationObserver(\\n      async mutationsList => {\\n        await this.#waitForFirstIntersectionObservations();\\n\\n        const startTime = ChromeUtils.now();\\n\\n        // The count of attribute mutations in this observation.\\n        let attributeCount = 0;\\n\\n        // The count of child-list mutations in this observation.\\n        let childListCount = 0;\\n\\n        // The count of character-data mutations in this observation.\\n        let characterDataCount = 0;\\n\\n        // The count of requests that we prevent from being sent to the TranslationsEngine.\\n        let preventedCount = 0;\\n\\n        // The count of translation requests that had to be cancelled from the TranslationScheduler.\\n        // This is a subset of preventedCount.\\n        let cancelledFromSchedulerCount = 0;\\n\\n        // The count of translation requests that had to be cancelled from the TranslationsEngine.\\n        // This is a subset of cancelledFromSchedulerCount.\\n        let cancelledFromEngineCount = 0;\\n\\n        for (const mutation of mutationsList) {\\n          if (!mutation.target) {\\n            continue;\\n          }\\n\\n          const pendingParentElement = this.#getPendingParentElementFromTarget(\\n            mutation.target\\n          );\\n\\n          if (pendingParentElement && mutation.type === \\\"childList\\\") {\\n            const preventionResult =\\n              this.#preventContentTranslation(pendingParentElement);\\n\\n            if (preventionResult.preventedCount) {\\n              preventedCount += preventionResult.preventedCount;\\n              cancelledFromSchedulerCount +=\\n                preventionResult.cancelledFromSchedulerCount;\\n              cancelledFromEngineCount +=\\n                preventionResult.cancelledFromEngineCount;\\n\\n              // The node was still pending to be translated, and we cancelled it.\\n              // Make sure it gets marked as mutated so it will be resubmitted.\\n              this.#markNodeContentMutated(pendingParentElement);\\n\\n              // New nodes could have been added, make sure we can follow their shadow roots.\\n              ensureExists(\\n                this.#sourceDocument.ownerGlobal\\n              ).requestAnimationFrame(() => {\\n                this.#addShadowRootsToObserver(pendingParentElement);\\n              });\\n            }\\n          }\\n\\n          switch (mutation.type) {\\n            case \\\"childList\\\": {\\n              childListCount++;\\n\\n              for (const addedNode of mutation.addedNodes) {\\n                if (!addedNode) {\\n                  continue;\\n                }\\n                this.#subdivideNodeForAttributeTranslations(addedNode);\\n                this.#addShadowRootsToObserver(addedNode);\\n                this.#markNodeContentMutated(addedNode);\\n              }\\n              for (const removedNode of mutation.removedNodes) {\\n                if (!removedNode) {\\n                  continue;\\n                }\\n\\n                const contentPreventionResult =\\n                  this.#preventContentTranslation(removedNode);\\n\\n                preventedCount += contentPreventionResult.preventedCount;\\n                cancelledFromSchedulerCount +=\\n                  contentPreventionResult.cancelledFromSchedulerCount;\\n                cancelledFromEngineCount +=\\n                  contentPreventionResult.cancelledFromEngineCount;\\n\\n                const selfOrParentElement =\\n                  asElement(removedNode) ?? asElement(removedNode.parentNode);\\n\\n                if (selfOrParentElement) {\\n                  deleteFromNestedMap(\\n                    this.#pendingContentTranslations,\\n                    selfOrParentElement,\\n                    removedNode\\n                  );\\n                  this.#removeFromContentIntersectionObservation(\\n                    selfOrParentElement,\\n                    removedNode\\n                  );\\n                }\\n\\n                const element = asElement(removedNode);\\n\\n                if (element) {\\n                  const attributePreventionResult =\\n                    this.#preventAttributeTranslations(element);\\n\\n                  preventedCount += attributePreventionResult.preventedCount;\\n\\n                  cancelledFromSchedulerCount +=\\n                    attributePreventionResult.cancelledFromSchedulerCount;\\n\\n                  cancelledFromEngineCount +=\\n                    attributePreventionResult.cancelledFromEngineCount;\\n\\n                  this.#pendingAttributeTranslations.delete(element);\\n                  this.#removeFromAttributeIntersectionObservation(element);\\n                }\\n              }\\n              break;\\n            }\\n            case \\\"characterData\\\": {\\n              characterDataCount++;\\n\\n              const node = mutation.target;\\n              if (node) {\\n                // The mutated node will implement the CharacterData interface. The only\\n                // node of this type that contains user-visible text is the `Text` node.\\n                // Ignore others such as the comment node.\\n                // https://developer.mozilla.org/en-US/docs/Web/API/CharacterData\\n                if (node.nodeType === Node.TEXT_NODE) {\\n                  const preventionResult =\\n                    this.#preventContentTranslation(node);\\n\\n                  preventedCount += preventionResult.preventedCount;\\n                  cancelledFromSchedulerCount +=\\n                    preventionResult.cancelledFromSchedulerCount;\\n                  cancelledFromEngineCount +=\\n                    preventionResult.cancelledFromEngineCount;\\n\\n                  this.#markNodeContentMutated(node);\\n                }\\n              }\\n              break;\\n            }\\n            case \\\"attributes\\\": {\\n              attributeCount++;\\n\\n              const element = asElement(mutation.target);\\n              if (element && mutation.attributeName) {\\n                const { oldValue, attributeName } = mutation;\\n                this.#maybeMarkElementAttributeMutated(\\n                  element,\\n                  attributeName,\\n                  oldValue\\n                );\\n              }\\n              break;\\n            }\\n            default: {\\n              break;\\n            }\\n          }\\n        }\\n\\n        ChromeUtils.addProfilerMarker(\\n          \\\"TranslationsDocument MutationObserver\\\",\\n          { startTime, innerWindowId },\\n          `Observed ${childListCount + characterDataCount + attributeCount} mutations: ` +\\n            `childList(${childListCount}), characterData(${characterDataCount}), attribute(${attributeCount}), ` +\\n            `prevented ${preventedCount} requests: ` +\\n            `${preventedCount - cancelledFromSchedulerCount - cancelledFromEngineCount} requests were never sent to the scheduler, ` +\\n            `${cancelledFromSchedulerCount - cancelledFromEngineCount} requests were cancelled from the scheduler before being sent to the engine, ` +\\n            `${cancelledFromEngineCount} requests were cancelled from the engine.`\\n        );\\n\\n        this.#maybePrioritizeRequestsAndSubmitToScheduler();\\n      }\\n    );\\n\\n    this.#sourceDocument.addEventListener(\\n      \\\"visibilitychange\\\",\\n      this.#handleVisibilityChange\\n    );\\n\\n    const addRootElements = () => {\\n      const startTime = ChromeUtils.now();\\n\\n      this.#addRootElement(document.body);\\n      this.#addRootElement(document.head);\\n      this.#addRootElement(document.querySelector(\\\"title\\\"));\\n\\n      ChromeUtils.addProfilerMarker(\\n        \\\"TranslationsDocument Initialize\\\",\\n        { startTime, innerWindowId: this.#innerWindowId },\\n        \\\"Added initial root elements for translation\\\"\\n      );\\n\\n      if (this.#intersectionObservedContentElements.size === 0) {\\n        // After the initial parse of the page, there are no intersection-observable\\n        // content elements, so we must vacuously consider the first observation complete.\\n        this.#contentWithinViewportInitialObservation.resolve();\\n        this.#contentBeyondViewportInitialObservation.resolve();\\n      }\\n\\n      if (this.#intersectionObservedAttributeElements.size === 0) {\\n        // After the initial parse of the page, there are no intersection-observable\\n        // attribute elements, so we must vacuously consider the first observation complete.\\n        this.#attributesWithinViewportInitialObservation.resolve();\\n        this.#attributesBeyondViewportInitialObservation.resolve();\\n      }\\n\\n      if (\\n        // The page may have content nodes that cannot be observed for intersection.\\n        this.#queuedIntersectionExemptContentElements.size > 0 ||\\n        // The page may have attribute elements that cannot be observed for intersection.\\n        this.#queuedIntersectionExemptAttributeElements.size > 0\\n      ) {\\n        // These are either elements such as <title> that will never intersect with the\\n        // observers, or the find bar was open when Full-Page Translations was invoked,\\n        // causing us to start in \\\"content-eager\\\" translations mode.\\n        this.#maybePrioritizeRequestsAndSubmitToScheduler();\\n      }\\n    };\\n\\n    if (document.body) {\\n      addRootElements();\\n    } else {\\n      // The TranslationsDocument was invoked before the DOM was ready, wait for\\n      // it to be loaded.\\n      document.addEventListener(\\\"DOMContentLoaded\\\", addRootElements, {\\n        once: true,\\n      });\\n    }\\n\\n    /** @type {HTMLElement} */ (document.documentElement).lang = targetLanguage;\\n\\n    lazy.console.log(\\n      \\\"Beginning to translate.\\\",\\n      // The defaultView may not be there on tests.\\n      document.defaultView?.location.href\\n    );\\n  }\\n\\n  /**\\n   * Enters content-eager translations mode, where all elements with translatable\\n   * text content will be sent to the scheduler, but attribute translations will\\n   * continue to be handled lazily based on viewport intersection proximity.\\n   */\\n  async enterContentEagerTranslationsMode() {\\n    lazy.console.info(\\\"Entering Content-Eager translations mode.\\\");\\n    this.#translationsMode = \\\"content-eager\\\";\\n\\n    await this.#waitForFirstIntersectionObservations();\\n\\n    if (this.#translationsMode !== \\\"content-eager\\\") {\\n      // The translations mode changed while we were waiting for the\\n      // first intersection observations: do not continue.\\n      return;\\n    }\\n\\n    for (const element of this.#intersectionObservedContentElements.keys()) {\\n      this.#enqueueForIntersectionPrunableContentPrioritization(element);\\n    }\\n\\n    // Most attributes are not searchable within the find bar, so we will not eagerly\\n    // enqueue them to be sent to the scheduler. They will still be translated based\\n    // on their proximity to the viewport.\\n    this.#maybePrioritizeRequestsAndSubmitToScheduler();\\n  }\\n\\n  /**\\n   * Enters lazy translations mode, where all translations will be scheduled lazily\\n   * based on viewport intersection proximity. Any pending requests that are not\\n   * within viewport proximity will be cancelled.\\n   */\\n  async enterLazyTranslationsMode() {\\n    lazy.console.info(\\\"Entering Lazy translations mode.\\\");\\n    this.#translationsMode = \\\"lazy\\\";\\n\\n    await this.#waitForFirstIntersectionObservations();\\n\\n    if (this.#translationsMode !== \\\"lazy\\\") {\\n      // The translations mode changed while we were waiting for the\\n      // first intersection observations: do not continue.\\n      return;\\n    }\\n\\n    for (const element of this.#pendingContentTranslations.keys()) {\\n      if (getNodeSpatialContext(element).viewportContext !== \\\"within\\\") {\\n        this.#preventUnscheduledContentTranslations(element);\\n      }\\n    }\\n\\n    this.#maybePrioritizeRequestsAndSubmitToScheduler();\\n  }\\n\\n  /**\\n   * This is a test-only function that simulates intersection observation\\n   * by running through all of the observed nodes and enqueuing them for\\n   * prioritization if they are not already associated with a pending\\n   * translation request.\\n   *\\n   * This function may only be used in testing contexts where the viewport\\n   * is effectively non-existent, such that the intersection observers will\\n   * not observe nodes as intended.\\n   *\\n   * @throws If this function is called outside of automated testing.\\n   * @throws If the viewport is not zero-width or zero-height.\\n   */\\n  simulateIntersectionObservationForNonPendingNodes() {\\n    lazy.console.debug(\\\"Simulating intersection observations for test.\\\");\\n\\n    if (!Cu.isInAutomation) {\\n      // There is no scenario in which we should call this function outside of an\\n      // automated test that requires it.\\n      throw new Error(\\n        \\\"Attempt to manually simulate intersection observation outside of test.\\\"\\n      );\\n    }\\n\\n    const window = ensureExists(this.#sourceDocument.ownerGlobal);\\n    const { visualViewport } = window;\\n    if (visualViewport.width > 0 && visualViewport.height > 0) {\\n      // The only time we should call this function is in test cases where the\\n      // intersection observers will not function because a viewport dimension is zero.\\n      // If a viewport dimension is not actually zero, then this was called in error.\\n      throw new Error(\\n        \\\"Attempt to manually simulate intersection observation with a valid viewport.\\\"\\n      );\\n    }\\n\\n    // This should never be called as the first intersection observation.\\n    // See #waitForFirstIntersectionObservation for an explanation why.\\n    //\\n    // The code is written so that the first intersection observation is\\n    // guaranteed to be fulfilled when adding the initial root elements.\\n    //\\n    // If you are modifying this code, and this promise hangs, then the\\n    // code has been modified incorrectly such that the first observation\\n    // guarantee is no longer upheld.\\n    /** @type {PromiseWithResolvers<void>} */\\n    const firstIntersectionObservationsTimeout = Promise.withResolvers();\\n    lazy.setTimeout(\\n      () =>\\n        firstIntersectionObservationsTimeout.reject(\\n          new Error(\\n            \\\"The TranslationDocument's first intersection observations failed to resolve.\\\"\\n          )\\n        ),\\n      2000\\n    );\\n\\n    Promise.race([\\n      firstIntersectionObservationsTimeout.promise,\\n      this.#waitForFirstIntersectionObservations(),\\n    ]).then(() => {\\n      firstIntersectionObservationsTimeout.resolve();\\n\\n      for (const element of this.#intersectionObservedContentElements.keys()) {\\n        if (!this.#pendingContentTranslations.has(element)) {\\n          this.#enqueueForIntersectionPrunableContentPrioritization(element);\\n        }\\n      }\\n\\n      for (const element of this.#intersectionObservedAttributeElements.keys()) {\\n        if (!this.#pendingAttributeTranslations.has(element)) {\\n          this.#enqueueForIntersectionPrunableAttributePrioritization(element);\\n        }\\n      }\\n\\n      this.#maybePrioritizeRequestsAndSubmitToScheduler();\\n    });\\n  }\\n\\n  /**\\n   * The first intersection observation is critical to the flow of the TranslationsDocument.\\n   *\\n   * When we add the root elements within the constructor, the entire DOM is parsed, and each\\n   * translatable element on the page is registered with the intersection observers. As such,\\n   * each observer's first observation will mostly contain nodes that are \\\"exiting\\\" proximity,\\n   * since most of the element on the page will likely lie well beyond the viewport.\\n   *\\n   * To prevent unnecessary cancellations, race conditions, etc. many of the asynchronous\\n   * callbacks within this file such as submitting nodes to the scheduler or handling mutated\\n   * nodes must wait until the first intersection observation has occurred.\\n   */\\n  async #waitForFirstIntersectionObservations() {\\n    await Promise.all([\\n      this.#contentWithinViewportInitialObservation.promise,\\n      this.#contentBeyondViewportInitialObservation.promise,\\n      this.#attributesWithinViewportInitialObservation.promise,\\n      this.#attributesBeyondViewportInitialObservation.promise,\\n    ]);\\n  }\\n\\n  /**\\n   * Marks that the text content of the given node has mutated, both allowing and\\n   * ensuring that the node will be rescheduled for translation, even if it had\\n   * previously been translated.\\n   *\\n   * @param {Node} node\\n   */\\n  #markNodeContentMutated(node) {\\n    this.#processedContentNodes.delete(node);\\n    this.#nodesWithMutatedContent.add(node);\\n\\n    const selfOrParentElement = asElement(node) ?? asElement(node.parentNode);\\n\\n    if (selfOrParentElement) {\\n      deleteFromNestedMap(\\n        this.#pendingContentTranslations,\\n        selfOrParentElement,\\n        node\\n      );\\n\\n      if (this.#intersectionObservedContentElements.has(selfOrParentElement)) {\\n        // If the mutated content belongs to an element that we are already observing\\n        // for intersection, we must re-register it with the Beyond-Viewport intersection\\n        // observer, which will ensure that any mutated elements within extended-viewport\\n        // proximity will be re-enqueued for prioritization when the next observer cycle runs.\\n        this.#intersectionObserverForContentTranslationsBeyondViewport.unobserve(\\n          selfOrParentElement\\n        );\\n        this.#intersectionObserverForContentTranslationsBeyondViewport.observe(\\n          selfOrParentElement\\n        );\\n      }\\n    }\\n\\n    this.#ensureMutationUpdateCallbackIsRegistered();\\n  }\\n\\n  /**\\n   * Marks that the given element's attribute has been mutated, only if that attribute\\n   * is translatable for that element, both allowing and ensuring that the attribute will\\n   * be rescheduled for translation, even if it had previously been translated.\\n   *\\n   * @param {Element} element\\n   * @param {string} attributeName\\n   * @param {string?} oldValue\\n   */\\n  #maybeMarkElementAttributeMutated(element, attributeName, oldValue) {\\n    const newValue = element.getAttribute(attributeName);\\n\\n    if (!newValue) {\\n      // The element no longer has a value for this attribute.\\n      return;\\n    }\\n\\n    if (oldValue === newValue) {\\n      // The new attribute value is exactly the same as the old value.\\n      return;\\n    }\\n\\n    if (\\n      this.#translationsCache.isAlreadyTranslated(newValue, /* isHTML */ false)\\n    ) {\\n      // We know that the new attribute value is already text in the target language.\\n      return;\\n    }\\n\\n    if (!isAttributeTranslatable(element, attributeName)) {\\n      // The given attribute is not translatable for this element.\\n      return;\\n    }\\n\\n    let mutatedAttributes = this.#elementsWithMutatedAttributes.get(element);\\n    if (!mutatedAttributes) {\\n      mutatedAttributes = new Set();\\n      this.#elementsWithMutatedAttributes.set(element, mutatedAttributes);\\n    }\\n    mutatedAttributes.add(attributeName);\\n\\n    deleteFromNestedMap(\\n      this.#pendingAttributeTranslations,\\n      element,\\n      attributeName\\n    );\\n\\n    if (this.#intersectionObservedAttributeElements.has(element)) {\\n      // If the mutated attribute belongs to an element that we are already observing\\n      // for intersection, we must re-register it with the Beyond-Viewport intersection\\n      // observer, which will ensure that any mutated elements within extended-viewport\\n      // proximity will be re-enqueued for prioritization when the next observer cycle runs.\\n      this.#intersectionObserverForAttributeTranslationsBeyondViewport.unobserve(\\n        element\\n      );\\n      this.#intersectionObserverForAttributeTranslationsBeyondViewport.observe(\\n        element\\n      );\\n    }\\n\\n    this.#ensureMutationUpdateCallbackIsRegistered();\\n  }\\n\\n  /**\\n   * Ensures that all nodes that have been picked up by the mutation observer\\n   * are processed, prioritized and sent to the scheduler to re translated.\\n   */\\n  #ensureMutationUpdateCallbackIsRegistered() {\\n    if (this.#hasPendingMutatedNodesCallback) {\\n      // A callback has already been registered to update mutated nodes.\\n      return;\\n    }\\n\\n    if (\\n      this.#nodesWithMutatedContent.size === 0 &&\\n      this.#elementsWithMutatedAttributes.size === 0\\n    ) {\\n      // There are no mutated nodes to update.\\n      return;\\n    }\\n\\n    this.#hasPendingMutatedNodesCallback = true;\\n    const ownerGlobal = ensureExists(this.#sourceDocument.ownerGlobal);\\n\\n    // Nodes can be mutated in a tight loop. To guard against the performance of re-translating nodes too frequently,\\n    // we will batch the processing of mutated nodes into a double requestAnimationFrame.\\n    ownerGlobal.requestAnimationFrame(() => {\\n      ownerGlobal.requestAnimationFrame(async () => {\\n        // We should not handle any mutations until the intersection observers have completed their first observations.\\n        await this.#waitForFirstIntersectionObservations();\\n\\n        this.#hasPendingMutatedNodesCallback = false;\\n\\n        // The count of content translation requests will be 1:1 with the count of content-translation nodes.\\n        const contentNodeCount = this.#nodesWithMutatedContent.size;\\n\\n        // Attribute translation requests have a 1:many relationship with their element, so we must increment manually.\\n        const attributeElementCount = this.#elementsWithMutatedAttributes.size;\\n        let attributeRequestCount = 0;\\n\\n        const startTime = ChromeUtils.now();\\n\\n        // Ensure the nodes are still alive.\\n        const liveNodes = [];\\n        for (const node of this.#nodesWithMutatedContent) {\\n          if (isNodeDetached(node)) {\\n            this.#nodesWithMutatedContent.delete(node);\\n          } else {\\n            liveNodes.push(node);\\n          }\\n        }\\n\\n        // Remove any nodes that are contained in another node.\\n        for (let i = 0; i < liveNodes.length; i++) {\\n          const node = liveNodes[i];\\n          if (!this.#nodesWithMutatedContent.has(node)) {\\n            continue;\\n          }\\n          for (let j = i + 1; j < liveNodes.length; j++) {\\n            const otherNode = liveNodes[j];\\n\\n            if (!this.#nodesWithMutatedContent.has(otherNode)) {\\n              continue;\\n            }\\n\\n            if (node.contains(otherNode)) {\\n              this.#nodesWithMutatedContent.delete(otherNode);\\n            } else if (otherNode.contains(node)) {\\n              this.#nodesWithMutatedContent.delete(node);\\n              break;\\n            }\\n          }\\n        }\\n\\n        for (const node of this.#nodesWithMutatedContent) {\\n          this.#addShadowRootsToObserver(node);\\n          this.#subdivideNodeForContentTranslations(node);\\n        }\\n        this.#nodesWithMutatedContent.clear();\\n\\n        for (const [\\n          element,\\n          attributes,\\n        ] of this.#elementsWithMutatedAttributes.entries()) {\\n          attributeRequestCount += attributes.size;\\n          this.#maybeObserveElementForAttributePrioritization(\\n            element,\\n            attributes\\n          );\\n        }\\n        this.#elementsWithMutatedAttributes.clear();\\n\\n        ChromeUtils.addProfilerMarker(\\n          \\\"TranslationsDocument MutationObserver\\\",\\n          { startTime, innerWindowId: this.#innerWindowId },\\n          `Handled content mutations for ${contentNodeCount} nodes, and ` +\\n            `${attributeRequestCount} attribute mutations among ${attributeElementCount} elements.`\\n        );\\n\\n        this.#maybePrioritizeRequestsAndSubmitToScheduler();\\n      });\\n    });\\n  }\\n\\n  /**\\n   * If a pending node contains or is the target node, return that pending node.\\n   *\\n   * @param {Node} target\\n   *\\n   * @returns {Element | undefined}\\n   */\\n  #getPendingParentElementFromTarget(target) {\\n    const pendingParent = this.#nodeToPendingParent.get(target);\\n    const pendingParentElement = asElement(pendingParent);\\n\\n    if (\\n      pendingParentElement &&\\n      this.#pendingContentTranslations.has(pendingParentElement)\\n    ) {\\n      return pendingParentElement;\\n    }\\n\\n    return undefined;\\n  }\\n\\n  /**\\n   * Attempts to cancel a translation for the given node, even if the relevant\\n   * translation request has already been sent to the TranslationsEngine.\\n   *\\n   * This function is primarily used by the mutation observer, when we are certain\\n   * that content has changed, and the previous translation is no longer valid.\\n   *\\n   * For a more conservative cancellation that will only cancel a translation\\n   * request before it has been sent to the TranslationsEngine, use the\\n   * `#maybePreventUnscheduledContentTranslation` function.\\n   *\\n   * @param {Node} node\\n   *\\n   * @returns {{\\n   *  preventedCount: number,\\n   *  cancelledFromSchedulerCount: number,\\n   *  cancelledFromEngineCount: number,\\n   * }}\\n   */\\n  #preventContentTranslation(node) {\\n    const textNode = asTextNode(node);\\n    const parentElement = asElement(node.parentNode);\\n\\n    if (textNode && parentElement) {\\n      const pendingNodes = this.#pendingContentTranslations.get(parentElement);\\n      const translationId = pendingNodes?.get(textNode);\\n\\n      if (translationId) {\\n        const { didPrevent, didCancelFromScheduler, didCancelFromEngine } =\\n          this.#scheduler.preventSingleTranslation(translationId);\\n\\n        if (didPrevent) {\\n          return {\\n            preventedCount: Number(didPrevent),\\n            cancelledFromSchedulerCount: Number(didCancelFromScheduler),\\n            cancelledFromEngineCount: Number(didCancelFromEngine),\\n          };\\n        }\\n      }\\n    }\\n\\n    const element = asElement(node);\\n    if (!element) {\\n      return {\\n        preventedCount: 0,\\n        cancelledFromSchedulerCount: 0,\\n        cancelledFromEngineCount: 0,\\n      };\\n    }\\n\\n    let preventedCount = 0;\\n    let cancelledFromSchedulerCount = 0;\\n    let cancelledFromEngineCount = 0;\\n\\n    const preventionResult =\\n      this.#preventUnscheduledContentTranslations(element);\\n\\n    if (preventionResult.preventedNodeSet) {\\n      // We were able to prevent these content translations before\\n      // they were sent to the TranslationsEngine.\\n      preventedCount += preventionResult.preventedNodeSet.size;\\n      cancelledFromSchedulerCount +=\\n        preventionResult.cancelledFromSchedulerCount;\\n    }\\n\\n    const pendingNodes = this.#pendingContentTranslations.get(element);\\n    if (!pendingNodes) {\\n      // No pending content translations were found for this element.\\n      // They either already completed, or never existed.\\n      return {\\n        preventedCount,\\n        cancelledFromSchedulerCount,\\n        cancelledFromEngineCount: 0,\\n      };\\n    }\\n\\n    for (const [pendingNode, translationId] of pendingNodes) {\\n      // eslint-disable-next-line no-shadow\\n      const { didPrevent, didCancelFromScheduler, didCancelFromEngine } =\\n        this.#scheduler.preventSingleTranslation(translationId);\\n\\n      if (didPrevent) {\\n        pendingNodes.delete(pendingNode);\\n      }\\n\\n      preventedCount += Number(didPrevent);\\n      cancelledFromSchedulerCount += Number(didCancelFromScheduler);\\n      cancelledFromEngineCount += Number(didCancelFromEngine);\\n    }\\n\\n    if (pendingNodes.size === 0) {\\n      removeMozTranslationsIds(element);\\n      this.#pendingContentTranslations.delete(element);\\n    }\\n\\n    return {\\n      preventedCount,\\n      cancelledFromSchedulerCount,\\n      cancelledFromEngineCount,\\n    };\\n  }\\n\\n  /**\\n   * Attempts to cancel all attribute translations for the given node, even if the\\n   * relevant translation requests have already been sent to the TranslationsEngine.\\n   *\\n   * This function is primarily used by the mutation observer, when we are certain\\n   * that content has changed, and the previous translation is no longer valid.\\n   *\\n   * For a more conservative cancellation that will only cancel translation requests\\n   * before they have been sent to the TranslationsEngine, use the\\n   * `#maybePreventUnscheduledAttributeTranslations` function.\\n   *\\n   * @param {Element} element\\n   *\\n   * @returns {{\\n   *  preventedCount: number,\\n   *  cancelledFromSchedulerCount: number,\\n   *  cancelledFromEngineCount: number,\\n   * }}\\n   */\\n  #preventAttributeTranslations(element) {\\n    const preventionResult =\\n      this.#preventUnscheduledAttributeTranslations(element);\\n\\n    let preventedCount = 0;\\n    let cancelledFromSchedulerCount = 0;\\n    let cancelledFromEngineCount = 0;\\n\\n    if (preventionResult.preventedAttributeSet) {\\n      // We were able to prevent these attributes translations before\\n      // they were send to the TranslationsEngine.\\n      preventedCount += preventionResult.preventedAttributeSet.size;\\n      cancelledFromSchedulerCount +=\\n        preventionResult.cancelledFromSchedulerCount;\\n    }\\n\\n    const pendingAttributes = this.#pendingAttributeTranslations.get(element);\\n    if (!pendingAttributes) {\\n      // No pending attribute translations were found for this element.\\n      // They either already completed, or never existed.\\n      return {\\n        preventedCount,\\n        cancelledFromSchedulerCount,\\n        cancelledFromEngineCount: 0,\\n      };\\n    }\\n\\n    for (const [attributeName, translationId] of pendingAttributes) {\\n      // eslint-disable-next-line no-shadow\\n      const { didPrevent, didCancelFromScheduler, didCancelFromEngine } =\\n        this.#scheduler.preventSingleTranslation(translationId);\\n\\n      if (didPrevent) {\\n        pendingAttributes.delete(attributeName);\\n      }\\n\\n      preventedCount += Number(didPrevent);\\n      cancelledFromSchedulerCount += Number(didCancelFromScheduler);\\n      cancelledFromEngineCount += Number(didCancelFromEngine);\\n    }\\n\\n    if (pendingAttributes.size === 0) {\\n      this.#pendingAttributeTranslations.delete(element);\\n    }\\n\\n    return {\\n      preventedCount,\\n      cancelledFromSchedulerCount,\\n      cancelledFromEngineCount,\\n    };\\n  }\\n\\n  /**\\n   * Adds an element to a queue from which it will eventually be prioritized\\n   * and submitted to the scheduler for attribute translation.\\n   *\\n   * The queue is intersection-exempt, meaning that the intersection observers\\n   * will not be able to remove this element from the queue before it is prioritized\\n   * and submitted to the scheduler.\\n   *\\n   * @param {Element} element\\n   */\\n  #enqueueForIntersectionPrunableAttributePrioritization(element) {\\n    if (this.#queuedIntersectionPrunableAttributeElements.has(element)) {\\n      return;\\n    }\\n\\n    const translatableAttributes =\\n      this.#intersectionObservedAttributeElements.get(element);\\n\\n    if (!translatableAttributes) {\\n      lazy.console.warn(`\\n        Attempted to enqueue an element for attribute translation,\\n        but no translatable attributes were registered with the element.\\n      `);\\n      return;\\n    }\\n\\n    let queuedAttributes =\\n      this.#queuedIntersectionPrunableAttributeElements.get(element);\\n\\n    if (queuedAttributes) {\\n      for (const attributeName of translatableAttributes) {\\n        queuedAttributes.add(attributeName);\\n      }\\n    } else {\\n      queuedAttributes = translatableAttributes;\\n      this.#queuedIntersectionPrunableAttributeElements.set(\\n        element,\\n        translatableAttributes\\n      );\\n    }\\n  }\\n\\n  /**\\n   * Adds an element to a queue from which it will eventually be prioritized\\n   * and submitted to the scheduler for attribute translation.\\n   *\\n   * The queue is intersection-exempt, meaning that the intersection observers\\n   * will not be able to remove this element from the queue before it is prioritized\\n   * and submitted to the scheduler.\\n   *\\n   * @param {Element} element\\n   */\\n  #maybeEnqueueForIntersectionExemptAttributePrioritization(element) {\\n    if (this.#queuedIntersectionExemptAttributeElements.has(element)) {\\n      return;\\n    }\\n\\n    const translatableAttributes =\\n      this.#intersectionObservedAttributeElements.get(element) ??\\n      this.#getTranslatableAttributes(element);\\n\\n    if (!translatableAttributes) {\\n      return;\\n    }\\n\\n    let queuedAttributes =\\n      this.#queuedIntersectionExemptAttributeElements.get(element);\\n\\n    if (queuedAttributes) {\\n      for (const attributeName of translatableAttributes) {\\n        queuedAttributes.add(attributeName);\\n      }\\n    } else {\\n      queuedAttributes = translatableAttributes;\\n      this.#queuedIntersectionExemptAttributeElements.set(\\n        element,\\n        translatableAttributes\\n      );\\n    }\\n  }\\n\\n  /**\\n   * Retrieves an array of translatable attributes within the given node.\\n   *\\n   * If the node is deemed to be excluded from translation, no attributes\\n   * will be returned even if they are otherwise translatable.\\n   *\\n   * @see TRANSLATABLE_ATTRIBUTES\\n   * @see TranslationsDocument.contentExcludedNodeSelector\\n   *\\n   * @param {Node} node - The node from which to retrieve translatable attributes.\\n   *\\n   * @returns {null | Set<string>} - The translatable attribute names from the given node.\\n   */\\n  #getTranslatableAttributes(node) {\\n    const element = asHTMLElement(node);\\n    if (!element) {\\n      // We only translate attributes on element node types.\\n      return null;\\n    }\\n\\n    if (element.closest(this.attributeExcludedNodeSelector)) {\\n      // Either this node or an ancestor is explicitly excluded from translations, so we should not translate.\\n      return null;\\n    }\\n\\n    let attributes = null;\\n\\n    for (const attribute of TRANSLATABLE_ATTRIBUTES.keys()) {\\n      if (isAttributeTranslatable(node, attribute)) {\\n        if (!attributes) {\\n          attributes = new Set();\\n        }\\n        attributes.add(attribute);\\n      }\\n    }\\n\\n    return attributes;\\n  }\\n\\n  /**\\n   * Start and stop translation as the page is shown. For instance, this will\\n   * transition into \\\"hidden\\\" when the user tabs away from a document.\\n   */\\n  #handleVisibilityChange = () => {\\n    if (this.#sourceDocument.visibilityState === \\\"visible\\\") {\\n      this.#scheduler.onShowPage();\\n    } else {\\n      ChromeUtils.addProfilerMarker(\\n        \\\"TranslationsDocument Pause\\\",\\n        { innerWindowId: this.#innerWindowId },\\n        \\\"Pausing translations and discarding the port\\\"\\n      );\\n      this.#scheduler.onHidePage();\\n    }\\n  };\\n\\n  /**\\n   * Remove any dangling event handlers.\\n   */\\n  destroy() {\\n    this.#scheduler.destroy();\\n    this.#stopAllObservers();\\n\\n    if (!Cu.isDeadWrapper(this.#sourceDocument)) {\\n      this.#sourceDocument.removeEventListener(\\n        \\\"visibilitychange\\\",\\n        this.#handleVisibilityChange\\n      );\\n\\n      const window = this.#sourceDocument.ownerGlobal;\\n      if (window) {\\n        window.removeEventListener(\\\"scroll\\\", this.#handleScrollEvent);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Helper function for adding a new root to the mutation\\n   * observer.\\n   *\\n   * @param {Node} root\\n   */\\n  #observeNewRoot(root) {\\n    this.#rootNodes.add(root);\\n    this.#mutationObserver.observe(root, MUTATION_OBSERVER_OPTIONS);\\n  }\\n\\n  /**\\n   * Shadow roots are used in custom elements, and are a method for encapsulating\\n   * markup. Normally only \\\"open\\\" shadow roots can be accessed, but in privileged\\n   * contexts, they can be traversed using the ChromeOnly property openOrClosedShadowRoot.\\n   *\\n   * @param {Node} node\\n   */\\n  #addShadowRootsToObserver(node) {\\n    const { ownerDocument } = node;\\n    if (!ownerDocument) {\\n      return;\\n    }\\n    const nodeIterator = ownerDocument.createTreeWalker(\\n      node,\\n      NodeFilter.SHOW_ELEMENT,\\n      currentNode =>\\n        getShadowRoot(currentNode)\\n          ? NodeFilter.FILTER_ACCEPT\\n          : NodeFilter.FILTER_SKIP\\n    );\\n\\n    /** @type {Node | null} */\\n    let currentNode;\\n    while ((currentNode = nodeIterator.nextNode())) {\\n      // Only shadow hosts are accepted nodes\\n      const shadowRoot = ensureExists(getShadowRoot(currentNode));\\n      if (!this.#rootNodes.has(shadowRoot)) {\\n        this.#observeNewRoot(shadowRoot);\\n      }\\n      // A shadow root may contain other shadow roots, recurse into them.\\n      this.#addShadowRootsToObserver(shadowRoot);\\n    }\\n  }\\n\\n  /**\\n   * Add a new element to start translating. This root is tracked for mutations and\\n   * kept up to date with translations. This will be the body element and title tag\\n   * for the document.\\n   *\\n   * @param {Node | null | undefined} node\\n   */\\n  #addRootElement(node) {\\n    if (!node) {\\n      return;\\n    }\\n\\n    const element = asHTMLElement(node);\\n    if (!element) {\\n      return;\\n    }\\n\\n    if (this.#rootNodes.has(element)) {\\n      // Exclude nodes that are already targeted.\\n      return;\\n    }\\n\\n    this.#rootNodes.add(element);\\n\\n    if (element.nodeName === \\\"TITLE\\\") {\\n      // The <title> node is special, in that it will never intersect with the viewport,\\n      // so we must explicitly enqueue it for translation here.\\n      this.#enqueueForIntersectionExemptContentPrioritization(element);\\n      this.#maybeEnqueueForIntersectionExemptAttributePrioritization(element);\\n      this.#mutationObserver.observe(element, MUTATION_OBSERVER_OPTIONS);\\n      return;\\n    }\\n\\n    if (element.nodeName === \\\"HEAD\\\") {\\n      // The <head> element is not considered for content translations, but it may contain <meta>\\n      // elements that may have translatable attributes. This is a special case where we should\\n      // explicitly check for <meta> elements within the <head> and eagerly enqueue them, since\\n      // they will not intersect with the intersection observers.\\n      for (const metaElement of element.querySelectorAll(\\\"meta\\\")) {\\n        this.#maybeEnqueueForIntersectionExemptAttributePrioritization(\\n          metaElement\\n        );\\n      }\\n      this.#mutationObserver.observe(element, MUTATION_OBSERVER_OPTIONS);\\n      return;\\n    }\\n\\n    const contentStartTime = ChromeUtils.now();\\n    this.#subdivideNodeForContentTranslations(element);\\n    ChromeUtils.addProfilerMarker(\\n      \\\"TranslationsDocument Add Root\\\",\\n      { startTime: contentStartTime, innerWindowId: this.#innerWindowId },\\n      `Subdivided new root \\\"${node.nodeName}\\\" for content translations`\\n    );\\n\\n    const attributeStartTime = ChromeUtils.now();\\n    this.#subdivideNodeForAttributeTranslations(element);\\n    ChromeUtils.addProfilerMarker(\\n      \\\"TranslationsDocument Add Root\\\",\\n      { startTime: attributeStartTime, innerWindowId: this.#innerWindowId },\\n      `Subdivided new root \\\"${node.nodeName}\\\" for attribute translations`\\n    );\\n\\n    this.#mutationObserver.observe(element, MUTATION_OBSERVER_OPTIONS);\\n    this.#addShadowRootsToObserver(element);\\n  }\\n\\n  /**\\n   * Add qualified nodes to be observed for intersection or enqueued for\\n   * translation by recursively walking through the DOM tree of nodes,\\n   * including elements in the Shadow DOM.\\n   *\\n   * @param {Node} node\\n   */\\n  #processSubdivide(node) {\\n    const { ownerDocument } = node;\\n    if (!ownerDocument) {\\n      return;\\n    }\\n\\n    // This iterator will contain each node that has been subdivided enough to be translated.\\n    const nodeIterator = ownerDocument.createTreeWalker(\\n      node,\\n      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,\\n      this.#determineTranslationStatusForUnprocessedNodes\\n    );\\n\\n    let currentNode;\\n    while ((currentNode = nodeIterator.nextNode())) {\\n      const shadowRoot = getShadowRoot(currentNode);\\n      if (shadowRoot) {\\n        this.#processSubdivide(shadowRoot);\\n      } else {\\n        this.#observeOrEnqueueNodeForContentPrioritization(currentNode);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Start walking down through a node's subtree and decide which nodes to queue for\\n   * content translation. This first node could be the root nodes of the DOM, such as\\n   * the document body, or the title element, or it could be a mutation target.\\n   *\\n   * The nodes go through a process of subdivision until an appropriate sized chunk\\n   * of inline text can be found.\\n   *\\n   * @param {Node} node\\n   */\\n  #subdivideNodeForContentTranslations(node) {\\n    if (!this.#rootNodes.has(node)) {\\n      // This is a non-root node, which means it came from a mutation observer.\\n      // This new node could be a host element for shadow tree\\n      const shadowRoot = getShadowRoot(node);\\n      if (shadowRoot && !this.#rootNodes.has(shadowRoot)) {\\n        this.#observeNewRoot(shadowRoot);\\n      } else {\\n        // Ensure that it is a valid node to translate by checking all of its ancestors.\\n        for (let parent of getAncestorsIterator(node)) {\\n          // Parent is ShadowRoot. We can stop here since this is\\n          // the top ancestor of the shadow tree.\\n          if (parent.containingShadowRoot == parent) {\\n            break;\\n          }\\n          if (\\n            this.#determineTranslationStatus(parent) ===\\n            NodeStatus.NOT_TRANSLATABLE\\n          ) {\\n            return;\\n          }\\n        }\\n      }\\n    }\\n\\n    switch (this.#determineTranslationStatusForUnprocessedNodes(node)) {\\n      case NodeStatus.NOT_TRANSLATABLE: {\\n        // This node is rejected as it shouldn't be translated.\\n        return;\\n      }\\n\\n      // SHADOW_HOST and READY_TO_TRANSLATE both map to FILTER_ACCEPT\\n      case NodeStatus.SHADOW_HOST:\\n      case NodeStatus.READY_TO_TRANSLATE: {\\n        const shadowRoot = getShadowRoot(node);\\n        if (shadowRoot) {\\n          this.#processSubdivide(shadowRoot);\\n        } else {\\n          // This node is ready for translating, and doesn't need to be subdivided. There\\n          // is no reason to run the TreeWalker, it can be directly submitted for\\n          // translation.\\n          this.#observeOrEnqueueNodeForContentPrioritization(node);\\n        }\\n        break;\\n      }\\n\\n      case NodeStatus.SUBDIVIDE_FURTHER: {\\n        // This node may be translatable, but it needs to be subdivided into smaller\\n        // pieces. Create a TreeWalker to walk the subtree, and find the subtrees/nodes\\n        // that contain enough inline elements to send to be translated.\\n        this.#processSubdivide(node);\\n        break;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Uses query selectors to locate all of the elements that have translatable attributes,\\n   * then registers those elements with the intersection observers for their attributes\\n   * to be translated when observed.\\n   *\\n   * @param {Node} node\\n   */\\n  #subdivideNodeForAttributeTranslations(node) {\\n    const element = asElement(node);\\n    if (!element) {\\n      // We only translate attributes on Element type nodes.\\n      return;\\n    }\\n\\n    this.#maybeObserveElementForAttributePrioritization(element);\\n\\n    const childElementsWithTranslatableAttributes = element.querySelectorAll(\\n      TRANSLATABLE_ATTRIBUTES_SELECTOR\\n    );\\n\\n    for (const childElement of childElementsWithTranslatableAttributes) {\\n      this.#maybeObserveElementForAttributePrioritization(childElement);\\n    }\\n  }\\n\\n  /**\\n   * Test whether this is an element we do not want to translate. These are things like\\n   * <code> elements, elements with a different \\\"lang\\\" attribute, and elements that\\n   * have a `translate=no` attribute.\\n   *\\n   * @param {Node} node\\n   */\\n  #isExcludedNode(node) {\\n    // Property access be expensive, so destructure required properties so they are\\n    // not accessed multiple times.\\n    const { nodeType } = node;\\n\\n    if (nodeType === Node.TEXT_NODE) {\\n      // Text nodes are never excluded.\\n      return false;\\n    }\\n    const element = asElement(node);\\n    if (!element) {\\n      // Only elements and and text nodes should be considered.\\n      return true;\\n    }\\n\\n    const { nodeName } = element;\\n\\n    if (CONTENT_EXCLUDED_TAGS.has(nodeName.toUpperCase())) {\\n      // SVG tags can be lowercased, so ensure everything is uppercased.\\n      // This is an excluded tag.\\n      return true;\\n    }\\n\\n    if (!this.#matchesDocumentLanguage(element)) {\\n      // Exclude nodes that don't match the sourceLanguage.\\n      return true;\\n    }\\n\\n    if (element.getAttribute(\\\"translate\\\") === \\\"no\\\") {\\n      // This element has a translate=\\\"no\\\" attribute.\\n      // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/translate\\n      return true;\\n    }\\n\\n    if (element.classList.contains(\\\"notranslate\\\")) {\\n      // Google Translate skips translations if the classList contains \\\"notranslate\\\"\\n      // https://cloud.google.com/translate/troubleshooting\\n      return true;\\n    }\\n\\n    if (asHTMLElement(element)?.isContentEditable) {\\n      // This field is editable, and so exclude it similar to the way that form input\\n      // fields are excluded.\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  /**\\n   * Runs `determineTranslationStatus`, but only on unprocessed nodes.\\n   *\\n   * @param {Node} node\\n   *\\n   * @returns {number} - One of the NodeStatus values.\\n   */\\n  #determineTranslationStatusForUnprocessedNodes = node => {\\n    if (this.#processedContentNodes.has(node)) {\\n      // Skip nodes that have already been processed.\\n      return NodeStatus.NOT_TRANSLATABLE;\\n    }\\n\\n    return this.#determineTranslationStatus(node);\\n  };\\n\\n  /**\\n   * Determines if a node should be submitted for translation, not translatable, or if\\n   * it should be subdivided further. It doesn't check if the node has already been\\n   * processed.\\n   *\\n   * The return result works as a TreeWalker NodeFilter as well.\\n   *\\n   * @param {Node} node\\n   *\\n   * @returns {number} - One of the `NodeStatus` values. See that object\\n   *   for documentation. These values match the filters for the TreeWalker.\\n   *   These values also work as a `NodeFilter` value.\\n   */\\n  #determineTranslationStatus(node) {\\n    if (getShadowRoot(node)) {\\n      return NodeStatus.SHADOW_HOST;\\n    }\\n\\n    if (this.#isExcludedNode(node)) {\\n      // This is an explicitly excluded node.\\n      return NodeStatus.NOT_TRANSLATABLE;\\n    }\\n\\n    if (\\n      nodeOrParentIncludesItself(\\n        node,\\n        this.#intersectionObservedContentElements\\n      )\\n    ) {\\n      // This node or its parent is already being observed for translation: reject it.\\n      return NodeStatus.NOT_TRANSLATABLE;\\n    }\\n\\n    if (\\n      containsExcludedNode(node, this.contentExcludedNodeSelector) &&\\n      !hasNonWhitespaceTextNodes(node)\\n    ) {\\n      // Skip this node, and dig deeper into its tree to cut off smaller pieces to translate.\\n      return NodeStatus.SUBDIVIDE_FURTHER;\\n    }\\n\\n    if (nodeNeedsSubdividing(node)) {\\n      // Skip this node, and dig deeper into its tree to cut off smaller pieces\\n      // to translate. It is presumed to be a wrapper of block elements.\\n      return NodeStatus.SUBDIVIDE_FURTHER;\\n    }\\n\\n    if (!node.textContent?.trim().length) {\\n      // Do not use subtrees that are empty of text. This textContent call is fairly expensive.\\n      return !node.hasChildNodes()\\n        ? NodeStatus.NOT_TRANSLATABLE\\n        : NodeStatus.SUBDIVIDE_FURTHER;\\n    }\\n\\n    // This node can be treated as entire block to submit for translation.\\n    return NodeStatus.READY_TO_TRANSLATE;\\n  }\\n\\n  /**\\n   * Adds an element to a queue from which it will eventually be prioritized\\n   * and submitted to the scheduler for content translation.\\n   *\\n   * The queue is intersection-exempt, meaning that the intersection observers\\n   * will not be able to remove this element from the queue before it is prioritized\\n   * and submitted to the scheduler.\\n   *\\n   * @param {Element} element\\n   */\\n  #enqueueForIntersectionPrunableContentPrioritization(element) {\\n    if (this.#queuedIntersectionPrunableContentElements.has(element)) {\\n      return;\\n    }\\n\\n    const nodeSet =\\n      this.#intersectionObservedContentElements.get(element) ??\\n      new Set([element]);\\n\\n    let queuedNodes =\\n      this.#queuedIntersectionPrunableContentElements.get(element);\\n\\n    if (queuedNodes) {\\n      for (const node of nodeSet) {\\n        queuedNodes.add(node);\\n      }\\n    } else {\\n      queuedNodes = nodeSet;\\n      this.#queuedIntersectionPrunableContentElements.set(element, queuedNodes);\\n    }\\n  }\\n\\n  /**\\n   * Adds an element to a queue from which it will eventually be prioritized\\n   * and submitted to the scheduler for attribute translation.\\n   *\\n   * The queue is intersection-exempt, meaning that the intersection observers\\n   * will not be able to remove this element from the queue before it is prioritized\\n   * and submitted to the scheduler.\\n   *\\n   * @param {Element} element\\n   */\\n  #enqueueForIntersectionExemptContentPrioritization(element) {\\n    if (this.#queuedIntersectionExemptContentElements.has(element)) {\\n      return;\\n    }\\n\\n    const nodeSet =\\n      this.#intersectionObservedContentElements.get(element) ??\\n      new Set([element]);\\n\\n    let queuedNodes =\\n      this.#queuedIntersectionExemptContentElements.get(element);\\n\\n    if (queuedNodes) {\\n      for (const node of nodeSet) {\\n        queuedNodes.add(node);\\n      }\\n    } else {\\n      queuedNodes = nodeSet;\\n      this.#queuedIntersectionExemptContentElements.set(element, queuedNodes);\\n    }\\n  }\\n\\n  /**\\n   * Submit each translatable attribute for the given element to the TranslationScheduler\\n   * to have the attribute text translated.\\n   *\\n   * @param {number} priority\\n   * @param {Element} element\\n   * @param {Set<string>} attributeSet\\n   */\\n  #submitForAttributeTranslation(priority, element, attributeSet) {\\n    for (const attribute of attributeSet) {\\n      const sourceText = element.getAttribute(attribute);\\n\\n      if (!sourceText?.trim().length) {\\n        continue;\\n      }\\n      const translationId = this.#lastTranslationId++;\\n\\n      let pendingAttributes = this.#pendingAttributeTranslations.get(element);\\n      if (!pendingAttributes) {\\n        pendingAttributes = new Map();\\n        this.#pendingAttributeTranslations.set(element, pendingAttributes);\\n      }\\n      pendingAttributes.set(attribute, translationId);\\n\\n      this.#tryTranslate(\\n        element,\\n        sourceText,\\n        false /*isHTML*/,\\n        translationId,\\n        priority\\n      )\\n        .then(translation => {\\n          if (translation) {\\n            this.#registerElementForAttributeTranslationUpdate(\\n              element,\\n              translation,\\n              attribute,\\n              translationId\\n            );\\n          } else if (\\n            pendingAttributes.get(attribute) === translationId &&\\n            this.#pendingAttributeTranslations.get(element) ===\\n              pendingAttributes\\n          ) {\\n            // There is nothing to update for this translation request.\\n            pendingAttributes.delete(attribute);\\n            if (pendingAttributes.size === 0) {\\n              this.#pendingAttributeTranslations.delete(element);\\n              this.#removeFromAttributeIntersectionObservation(\\n                element,\\n                attribute\\n              );\\n            }\\n          }\\n        })\\n        .catch(error => {\\n          lazy.console.error(error);\\n          if (\\n            pendingAttributes.get(attribute) === translationId &&\\n            this.#pendingAttributeTranslations.get(element) ===\\n              pendingAttributes\\n          ) {\\n            // There is nothing to update for this translation request.\\n            pendingAttributes.delete(attribute);\\n            if (pendingAttributes.size === 0) {\\n              this.#pendingAttributeTranslations.delete(element);\\n              this.#removeFromAttributeIntersectionObservation(\\n                element,\\n                attribute\\n              );\\n            }\\n          }\\n        });\\n    }\\n  }\\n\\n  /**\\n   * Ensures that elements with completed attribute translation requests will be updated.\\n   *\\n   * This may happen immediately if there are very few active translation requests.\\n   *\\n   * If there are many active translation requests, we will register a callback to the\\n   * event loop to update a batch of elements all at once.\\n   *\\n   * This distinction is made because updating any content within the DOM requires\\n   * pausing the mutation observer, and that cost adds up if you do it individually\\n   * for every translation request that completes.\\n   *\\n   * @param {Element} element\\n   * @param {string} translation\\n   * @param {string} attribute\\n   * @param {number} translationId\\n   */\\n  #registerElementForAttributeTranslationUpdate(\\n    element,\\n    translation,\\n    attribute,\\n    translationId\\n  ) {\\n    // Add the nodes to be populated with the next translation update.\\n    this.#elementsThatNeedAttributeUpdates.add({\\n      element,\\n      translation,\\n      attribute,\\n      translationId,\\n    });\\n\\n    if (this.#scheduler.isWithinFinalBatches()) {\\n      // The scheduler is within the final batches of requests that it will send, so we will eagerly update\\n      // instead of registering a callback to update several nodes in a batch. This is particularly important\\n      // for cases such as translating a YouTube video with closed captions. When the rest of the viewport\\n      // is already translated, and a new request for a caption comes in, that will be the only request that\\n      // the scheduler is reacting to, and we want to update the caption text as soon as we possibly can.\\n      this.#updateElementsWithAttributeTranslations();\\n    } else if (!this.#hasPendingUpdateAttributesCallback) {\\n      // Schedule a callback on the event loop to update a batch elements with completed attribute translations.\\n      this.#hasPendingUpdateAttributesCallback = true;\\n      lazy.setTimeout(\\n        this.#updateElementsWithAttributeTranslations,\\n        DOM_UPDATE_INTERVAL_MS\\n      );\\n    } else {\\n      // An update has been previously scheduled, do nothing here.\\n    }\\n  }\\n\\n  /**\\n   * Updates all elements that have completed attribute translation requests.\\n   *\\n   * This function is intentionally written as a lambda so that it can be passed as a callback without the\\n   * need to explicitly bind `this` to the function object.\\n   */\\n  #updateElementsWithAttributeTranslations = () => {\\n    this.#hasPendingUpdateAttributesCallback = false;\\n\\n    let staleRequestCount = 0;\\n    let detachedElementCount = 0;\\n    let updatedAttributeCount = 0;\\n\\n    const startTime = ChromeUtils.now();\\n\\n    // Stop the mutations so that the updates won't trigger observations.\\n    this.#pauseMutationObserverAndThen(() => {\\n      for (const entry of this.#elementsThatNeedAttributeUpdates) {\\n        const { element, translation, attribute, translationId } = entry;\\n\\n        const eligibility = this.#determineElementAttributeUpdateEligibility(\\n          element,\\n          attribute,\\n          translationId\\n        );\\n\\n        if (eligibility === \\\"stale\\\") {\\n          // A new request has been submitted for this node. This one is no longer relevant.\\n          staleRequestCount++;\\n          continue;\\n        } else if (eligibility === \\\"detached\\\") {\\n          // This element is detached from the DOM: there is no point in updating it.\\n          detachedElementCount++;\\n        } else {\\n          updatedAttributeCount++;\\n          element.setAttribute(attribute, translation);\\n        }\\n\\n        deleteFromNestedMap(\\n          this.#queuedIntersectionPrunableAttributeElements,\\n          element,\\n          attribute\\n        );\\n\\n        deleteFromNestedMap(\\n          this.#queuedIntersectionExemptAttributeElements,\\n          element,\\n          attribute\\n        );\\n\\n        deleteFromNestedMap(\\n          this.#pendingAttributeTranslations,\\n          element,\\n          attribute\\n        );\\n\\n        this.#removeFromAttributeIntersectionObservation(element, attribute);\\n      }\\n\\n      this.#elementsThatNeedAttributeUpdates.clear();\\n    });\\n\\n    ChromeUtils.addProfilerMarker(\\n      \\\"TranslationsDocument Update (Attributes)\\\",\\n      { startTime, innerWindowId: this.#innerWindowId },\\n      \\\"Attribute Update Request: \\\" +\\n        `${staleRequestCount} stale requests, ${detachedElementCount} detached elements, ` +\\n        `${updatedAttributeCount} attributes updated.`\\n    );\\n  };\\n\\n  /**\\n   * Submit a node to the TranslationScheduler to have its text content translated.\\n   *\\n   * @param {number} priority\\n   * @param {Element} observableElement\\n   * @param {Set<Node>} nodeSet\\n   */\\n  #submitForContentTranslation(priority, observableElement, nodeSet) {\\n    for (const targetNode of nodeSet) {\\n      // Give each element an id that gets passed through the translation so it can be reunited later on.\\n      if (observableElement === targetNode) {\\n        /** @type {Array<Element>} */\\n        const elements = observableElement.querySelectorAll(\\\"*\\\");\\n\\n        elements.forEach((el, i) => {\\n          const dataset = getDataset(el);\\n          if (dataset) {\\n            dataset.mozTranslationsId = String(i);\\n          }\\n        });\\n      }\\n\\n      /** @type {string} */\\n      let sourceText;\\n      /** @type {boolean} */\\n      let isHTML;\\n\\n      if (\\n        // This node is a text node, therefore it cannot be an HTML translation.\\n        asTextNode(targetNode) ||\\n        // When an element has no child elements and its textContent is exactly\\n        // equal to its innerHTML, then it is safe to treat as a text translation.\\n        (observableElement.childElementCount === 0 &&\\n          observableElement.textContent === observableElement.innerHTML)\\n      ) {\\n        sourceText = targetNode.textContent ?? \\\"\\\";\\n        isHTML = false;\\n      } else {\\n        sourceText = /** @type {string} */ (observableElement.innerHTML);\\n        isHTML = true;\\n      }\\n\\n      if (sourceText.trim().length === 0) {\\n        return;\\n      }\\n      const translationId = this.#lastTranslationId++;\\n\\n      let pendingNodes =\\n        this.#pendingContentTranslations.get(observableElement);\\n      if (!pendingNodes) {\\n        pendingNodes = new Map();\\n        this.#pendingContentTranslations.set(observableElement, pendingNodes);\\n      }\\n      pendingNodes.set(targetNode, translationId);\\n\\n      this.#walkNodeToPendingParent(targetNode);\\n      this.#tryTranslate(\\n        targetNode,\\n        sourceText,\\n        isHTML,\\n        translationId,\\n        priority\\n      )\\n        .then(translation => {\\n          if (translation) {\\n            this.#registerElementForContentTranslationUpdate(\\n              observableElement,\\n              targetNode,\\n              translation,\\n              translationId\\n            );\\n          } else if (\\n            pendingNodes.get(targetNode) === translationId &&\\n            this.#pendingContentTranslations.get(observableElement) ===\\n              pendingNodes\\n          ) {\\n            // There is nothing to update for this translation request.\\n            pendingNodes.delete(targetNode);\\n            if (pendingNodes.size === 0) {\\n              this.#pendingContentTranslations.delete(observableElement);\\n              this.#removeFromContentIntersectionObservation(\\n                observableElement,\\n                targetNode\\n              );\\n            }\\n          }\\n        })\\n        .catch(error => {\\n          lazy.console.error(error);\\n          if (\\n            pendingNodes.get(targetNode) === translationId &&\\n            this.#pendingContentTranslations.get(observableElement) ===\\n              pendingNodes\\n          ) {\\n            pendingNodes.delete(targetNode);\\n            if (pendingNodes.size === 0) {\\n              this.#pendingContentTranslations.delete(observableElement);\\n              this.#removeFromContentIntersectionObservation(\\n                observableElement,\\n                targetNode\\n              );\\n            }\\n          }\\n        });\\n    }\\n  }\\n\\n  /**\\n   * Walks the nodes to set the relationship between the node to the pending parent node.\\n   * This solves a performance problem with pages with large subtrees and lots of mutation.\\n   * For instance on YouTube it took 838ms to `getPendingParentElementFromTarget` by going\\n   * through all pending translations. Caching this relationship reduced it to 26ms to walk\\n   * it while adding the pending translation.\\n   *\\n   * On a page like the Wikipedia \\\"Cat\\\" entry, there are not many mutations, and this\\n   * adds 4ms of additional wasted work.\\n   *\\n   * @param {Node} pendingParent\\n   */\\n  #walkNodeToPendingParent(pendingParent) {\\n    this.#nodeToPendingParent.set(pendingParent, pendingParent);\\n    const { ownerDocument } = pendingParent;\\n    if (!ownerDocument) {\\n      return;\\n    }\\n    const nodeIterator = ownerDocument.createTreeWalker(\\n      pendingParent,\\n      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT\\n    );\\n    /** @type {Node | null} */\\n    let node;\\n    while ((node = nodeIterator.nextNode())) {\\n      this.#nodeToPendingParent.set(node, pendingParent);\\n    }\\n  }\\n\\n  /**\\n   * Attempts to translate the given text for the given node.\\n   *\\n   * If we already have a cached result for this translation,\\n   * then we will resolve immediately and never send the request\\n   * to the TranslationsEngine.\\n   *\\n   * The request may also fail or be cancelled before it completes.\\n   *\\n   * @param {Node} node\\n   * @param {string} sourceText\\n   * @param {boolean} isHTML\\n   * @param {number} translationId\\n   * @param {number} priority\\n   *\\n   * @returns {Promise<string | null>}\\n   */\\n  async #tryTranslate(node, sourceText, isHTML, translationId, priority) {\\n    if (this.#translationsCache.isAlreadyTranslated(sourceText, isHTML)) {\\n      // The cache indicates that the text being sent to translate is already\\n      // translated into the target language. Don't try to re-translate it.\\n      return null;\\n    }\\n\\n    /** @type {string | null | undefined} */\\n    let translation = this.#translationsCache.get(sourceText, isHTML);\\n\\n    if (translation !== undefined) {\\n      // We already have a cached translation for this source text.\\n      return translation;\\n    }\\n\\n    translation = await this.#scheduler\\n      .createTranslationRequestPromise(\\n        node,\\n        sourceText,\\n        isHTML,\\n        translationId,\\n        priority\\n      )\\n      .finally(() => {\\n        // Any time a request resolves or rejects, we need to inform the scheduler\\n        // so that it can determine if it needs to schedule a new batch of requests.\\n        this.#scheduler.maybeScheduleMoreTranslationRequests();\\n      });\\n\\n    if (translation !== null) {\\n      this.#translationsCache.set(sourceText, translation, isHTML);\\n      if (!this.#hasFirstVisibleChange) {\\n        this.#hasFirstVisibleChange = true;\\n        this.#actorReportFirstVisibleChange();\\n      }\\n    }\\n\\n    return translation;\\n  }\\n\\n  /**\\n   * Start the mutation observer, for instance after applying the translations to the DOM.\\n   */\\n  #startMutationObserver() {\\n    if (Cu.isDeadWrapper(this.#mutationObserver)) {\\n      // This observer is no longer alive.\\n      return;\\n    }\\n\\n    for (const node of this.#rootNodes) {\\n      if (Cu.isDeadWrapper(node)) {\\n        // This node is no longer alive.\\n        continue;\\n      }\\n      this.#mutationObserver.observe(node, MUTATION_OBSERVER_OPTIONS);\\n    }\\n  }\\n\\n  /**\\n   * Stop the mutation observer, for instance to apply the translations to the DOM.\\n   */\\n  #stopMutationObserver() {\\n    // Was the window already destroyed?\\n    if (!Cu.isDeadWrapper(this.#mutationObserver)) {\\n      this.#mutationObserver.disconnect();\\n    }\\n  }\\n\\n  /**\\n   * Stops the mutation observer and all intersection observers.\\n   */\\n  #stopAllObservers() {\\n    const observers = [\\n      this.#mutationObserver,\\n      this.#intersectionObserverForContentTranslationsWithinViewport,\\n      this.#intersectionObserverForContentTranslationsBeyondViewport,\\n      this.#intersectionObserverForAttributeTranslationsWithinViewport,\\n      this.#intersectionObserverForAttributeTranslationsBeyondViewport,\\n    ];\\n\\n    for (const observer of observers) {\\n      if (!Cu.isDeadWrapper(observer)) {\\n        observer.disconnect();\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Updates all nodes that have completed attribute translation requests.\\n   *\\n   * This function is called asynchronously, so nodes may already be dead. Before\\n   * accessing a node make sure and run `Cu.isDeadWrapper` to check that it is alive.\\n   */\\n  #updateNodesWithContentTranslations = () => {\\n    this.#hasPendingUpdateContentCallback = false;\\n\\n    let staleRequestCount = 0;\\n    let detachedNodeCount = 0;\\n    let textNodeCount = 0;\\n    let elementCount = 0;\\n\\n    const startTime = ChromeUtils.now();\\n\\n    // Stop the mutations so that the updates won't trigger observations.\\n    this.#pauseMutationObserverAndThen(() => {\\n      const entries = this.#elementsThatNeedContentUpdates;\\n      for (const {\\n        element,\\n        targetNode,\\n        translatedContent,\\n        translationId,\\n      } of entries) {\\n        const eligibility = this.#determineNodeContentUpdateEligibility(\\n          element,\\n          targetNode,\\n          translationId\\n        );\\n\\n        if (eligibility === \\\"stale\\\") {\\n          // A new request has been submitted for this node. This one is no longer relevant.\\n          staleRequestCount++;\\n          continue;\\n        } else if (eligibility === \\\"detached\\\") {\\n          // This node is detached from the DOM: there is no point in updating it.\\n          detachedNodeCount++;\\n        } else if (element === targetNode) {\\n          elementCount++;\\n\\n          const translationsDocument = this.#domParser.parseFromSafeString(\\n            `<!DOCTYPE html><div>${translatedContent}</div>`,\\n            \\\"text/html\\\"\\n          );\\n\\n          updateElement(translationsDocument, element);\\n          this.#processedContentNodes.add(targetNode);\\n        } else {\\n          textNodeCount++;\\n          targetNode.textContent = translatedContent;\\n          this.#processedContentNodes.add(targetNode);\\n        }\\n\\n        deleteFromNestedMap(\\n          this.#queuedIntersectionPrunableContentElements,\\n          element,\\n          targetNode\\n        );\\n\\n        deleteFromNestedMap(\\n          this.#queuedIntersectionExemptContentElements,\\n          element,\\n          targetNode\\n        );\\n\\n        deleteFromNestedMap(\\n          this.#pendingContentTranslations,\\n          element,\\n          targetNode\\n        );\\n\\n        this.#removeFromContentIntersectionObservation(element, targetNode);\\n      }\\n\\n      this.#elementsThatNeedContentUpdates.clear();\\n    });\\n\\n    ChromeUtils.addProfilerMarker(\\n      \\\"TranslationsDocument Update (Content)\\\",\\n      { startTime, innerWindowId: this.#innerWindowId },\\n      \\\"Content Update Request: \\\" +\\n        `${staleRequestCount} stale requests, ${detachedNodeCount} detached nodes, ` +\\n        `${textNodeCount} text nodes, and ${elementCount} elements.`\\n    );\\n  };\\n\\n  /**\\n   * Stops the mutation observer while running the given callback,\\n   * then restarts the mutation observer once the callback has finished.\\n   *\\n   * This is used to update nodes with translated content when their\\n   * translation requests have completed, ensuring that we will always\\n   * stop and restart the observer.\\n   *\\n   * @param {Function} callback - A callback to run while the mutation observer is paused.\\n   */\\n  #pauseMutationObserverAndThen(callback) {\\n    this.#stopMutationObserver();\\n    try {\\n      callback();\\n    } finally {\\n      this.#startMutationObserver();\\n    }\\n  }\\n\\n  /**\\n   * Ensures that nodes with completed content translation requests will be updated.\\n   *\\n   * This may happen immediately if there are very few active translation requests.\\n   *\\n   * If there are many active translation requests, we will register a callback to the\\n   * event loop to update a batch of nodes all at once.\\n   *\\n   * This distinction is made because updating any content within the DOM requires\\n   * pausing the mutation observer, and that cost adds up if you do it individually\\n   * for every translation request that completes.\\n   *\\n   * @param {Element} element\\n   * @param {Node} targetNode\\n   * @param {string} translatedContent\\n   * @param {number} translationId - A unique id to identify this translation request.\\n   */\\n  #registerElementForContentTranslationUpdate(\\n    element,\\n    targetNode,\\n    translatedContent,\\n    translationId\\n  ) {\\n    // Add the nodes to be populated with the next translation update.\\n    this.#elementsThatNeedContentUpdates.add({\\n      element,\\n      targetNode,\\n      translatedContent,\\n      translationId,\\n    });\\n\\n    if (this.#scheduler.isWithinFinalBatches()) {\\n      // The scheduler is within the final batches of requests that it will send, so we will eagerly update\\n      // instead of registering a callback to update several nodes in a batch. This is particularly important\\n      // for cases such as translating a YouTube video with closed captions. When the rest of the viewport\\n      // is already translated, and a new request for a caption comes in, that will be the only request that\\n      // the scheduler is reacting to, and we want to update the caption text as soon as we possibly can.\\n      this.#updateNodesWithContentTranslations();\\n    } else if (!this.#hasPendingUpdateContentCallback) {\\n      // Schedule a callback on the event loop to update all nodes with completed translations.\\n      this.#hasPendingUpdateContentCallback = true;\\n      lazy.setTimeout(\\n        this.#updateNodesWithContentTranslations,\\n        DOM_UPDATE_INTERVAL_MS\\n      );\\n    } else {\\n      // An update has been previously scheduled, do nothing here.\\n    }\\n  }\\n\\n  /**\\n   * Check to see if a language matches the document's source language.\\n   *\\n   * @param {Node} node\\n   */\\n  #matchesDocumentLanguage(node) {\\n    const lang = asHTMLElement(node)?.lang;\\n    if (!lang) {\\n      // No `lang` was present, so assume it matches the language.\\n      return true;\\n    }\\n\\n    // First, cheaply check if language tags match, without canonicalizing.\\n    if (lazy.TranslationsUtils.langTagsMatch(this.#documentLanguage, lang)) {\\n      return true;\\n    }\\n\\n    try {\\n      // Make sure the local is in the canonical form, and check again. This function\\n      // throws, so don't trust that the language tags are formatting correctly.\\n      const [language] = Intl.getCanonicalLocales(lang);\\n\\n      return lazy.TranslationsUtils.langTagsMatch(\\n        this.#documentLanguage,\\n        language\\n      );\\n    } catch (_error) {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * Called by external code (the actor) once a new MessagePort has been established.\\n   * We pass this along to the scheduler, since this is the port that will be used\\n   * to send translation requests to the TranslationsEngine.\\n   *\\n   * @param {MessagePort} port\\n   */\\n  acquirePort(port) {\\n    this.#scheduler.acquirePort(port);\\n  }\\n\\n  /**\\n   * Retrieves the current status of the TranslationsEngine that is handling translations\\n   * for this TranslationsDocument instance.\\n   *\\n   * @returns {EngineStatus}\\n   */\\n  get engineStatus() {\\n    return this.#scheduler.engineStatus;\\n  }\\n\\n  /**\\n   * Returns true if the TranslationsDocument has any pending translation requests\\n   * that are actively being handled by the TranslationScheduler, otherwise false.\\n   *\\n   * @returns {boolean}\\n   */\\n  hasPendingTranslationRequests() {\\n    return (\\n      this.#pendingContentTranslations.size > 0 ||\\n      this.#pendingAttributeTranslations.size > 0\\n    );\\n  }\\n\\n  /**\\n   * Returns true if the TranslationsDocument has any pending callback on the event loop\\n   * that has not yet completed, otherwise false.\\n   *\\n   * @returns {boolean}\\n   */\\n  hasPendingCallbackOnEventLoop() {\\n    return (\\n      this.#hasPendingMutatedNodesCallback ||\\n      this.#hasPendingPrioritizationCallback ||\\n      this.#hasPendingUpdateAttributesCallback ||\\n      this.#hasPendingUpdateContentCallback ||\\n      this.#scheduler.hasPendingScheduleRequestsCallback()\\n    );\\n  }\\n\\n  /**\\n   * Returns true if the TranslationsDocument is observing at least one\\n   * element for intersection to translate its content, otherwise false.\\n   *\\n   * @returns {boolean}\\n   */\\n  isObservingAnyElementForContentIntersection() {\\n    return this.#intersectionObservedContentElements.size > 0;\\n  }\\n\\n  /**\\n   * Returns true if the TranslationsDocument is observing at least one\\n   * element for intersection to translate its attributes, otherwise false.\\n   *\\n   * @returns {boolean}\\n   */\\n  isObservingAnyElementForAttributeIntersection() {\\n    return this.#intersectionObservedAttributeElements.size > 0;\\n  }\\n\\n  /**\\n   * An event handler for when the user scrolls around the page.\\n   * Uses the scrollY position to determine if the user is scrolling up or down.\\n   * This scroll hint is used to help optimally prioritize translation requests.\\n   *\\n   * This function is intentionally written as a lambda so that it can be passed as a\\n   * callback without the need to explicitly bind `this` to the function object.\\n   */\\n  #handleScrollEvent = () => {\\n    if (ChromeUtils.now() - this.#mostRecentScrollTimestamp < 100) {\\n      // Scrolling can fire a lot of events in rapid succession, and computing the scrollY value can\\n      // trigger reflow, so we will limit how often we take the time to compute the scrollY value.\\n      // Scroll hints are critical to providing a smooth translation experience, but it's not the\\n      // end of the world if we happen to miss one.\\n      return;\\n    }\\n\\n    const scrollY = ensureExists(this.#sourceDocument.ownerGlobal).scrollY;\\n\\n    this.#mostRecentScrollDirection =\\n      scrollY >= this.#previousScrollY ? \\\"down\\\" : \\\"up\\\";\\n\\n    this.#previousScrollY = scrollY;\\n    this.#mostRecentScrollTimestamp = ChromeUtils.now();\\n  };\\n\\n  /**\\n   * Returns true if the user has scrolled recently, otherwise false.\\n   *\\n   * @returns {boolean}\\n   */\\n  #hasUserScrolledRecently() {\\n    return ChromeUtils.now() - this.#mostRecentScrollTimestamp < 200;\\n  }\\n\\n  /**\\n   * Attempts to determine an optimal set of translation priorities considering the location\\n   * of nodes with respect to the viewport, the type of translation request (content or attribute),\\n   * as well as the user's recent scroll activity.\\n   *\\n   * For example, if the user is actively scrolling up, we will do our best to prioritize visible\\n   * content translations that are just above the user's viewport, in hopes that their translation\\n   * requests will complete before the user even sees them.\\n   *\\n   * @returns {TranslationPriorityKinds}\\n   */\\n  #determinePrioritiesForTranslations() {\\n    // The following priorities are always the same, regardless of recent scroll activity.\\n    // Translating in-viewport content will always be of the highest priority.\\n    const inViewportContentPriority = TranslationScheduler.P0;\\n\\n    // The priority of translating content nodes whose viewport context was indeterminate.\\n    const otherContentPriority = TranslationScheduler.P6;\\n\\n    // The priority of translating attributes whose viewport context was indeterminate.\\n    const otherAttributePriority = TranslationScheduler.P7;\\n\\n    // The following priorities are all dependent on the user's recent scroll activity.\\n    // The priority of translating attributes within the viewport.\\n    let inViewportAttributePriority;\\n\\n    // The priority of translating content above the viewport.\\n    let aboveViewportContentPriority;\\n\\n    // The priority of translating attributes above the viewport.\\n    let aboveViewportAttributePriority;\\n\\n    // The priority of translating content below the viewport.\\n    let belowViewportContentPriority;\\n\\n    // The priority of translating attributes below the viewport.\\n    let belowViewportAttributePriority;\\n\\n    switch (this.#mostRecentScrollDirection) {\\n      case \\\"up\\\": {\\n        // The user has recently scrolled up, so we will prioritize content above the viewport.\\n        aboveViewportContentPriority = TranslationScheduler.P1;\\n\\n        // Since the user is scrolling up, it is likely that the content below the viewport\\n        // has already been translated, which means that we can skip over this priority in most\\n        // cases, but in the event that there are leftover, untranslated nodes, we still want to\\n        // get all of the visible content around the viewport translated at the highest priorities.\\n        belowViewportContentPriority = TranslationScheduler.P2;\\n\\n        // Attributes within and above the viewport are the next most important.\\n        inViewportAttributePriority = TranslationScheduler.P3;\\n        aboveViewportAttributePriority = TranslationScheduler.P4;\\n\\n        // Attributes below the viewport are the next most important.\\n        belowViewportAttributePriority = TranslationScheduler.P5;\\n        break;\\n      }\\n      case \\\"down\\\": {\\n        // The user has recently scrolled down, so we will prioritize content below the viewport.\\n        belowViewportContentPriority = TranslationScheduler.P1;\\n\\n        // Since the user is scrolling down, it is likely that the content above the viewport\\n        // has already been translated, which means that we can skip over this priority in most\\n        // cases, but in the event that there are leftover, untranslated nodes, we still want to\\n        // get all of the visible content around the viewport translated at the highest priorities.\\n        aboveViewportContentPriority = TranslationScheduler.P2;\\n\\n        // Attributes within and above the viewport are the next most important.\\n        inViewportAttributePriority = TranslationScheduler.P3;\\n        belowViewportAttributePriority = TranslationScheduler.P4;\\n\\n        // Attributes above the viewport are the next most important.\\n        aboveViewportAttributePriority = TranslationScheduler.P5;\\n        break;\\n      }\\n      default: {\\n        // The user has not scrolled at all since activating Full-Page Translations.\\n        if (AppConstants.platform === \\\"android\\\") {\\n          // Attributes, e.g. \\\"title\\\" are less accessible on Android, so even if the user has not\\n          // scrolled yet, we are going to do our best to prioritize visible content beyond the viewport.\\n          // Mobile viewports are also pretty small, so we should quickly get through to the attributes.\\n          belowViewportContentPriority = TranslationScheduler.P1;\\n          aboveViewportContentPriority = TranslationScheduler.P2;\\n          inViewportAttributePriority = TranslationScheduler.P3;\\n        } else {\\n          // On Desktop, however, if the user has not scrolled yet, we have no indication that they\\n          // are going to scroll, so we should prioritize the entire viewport, including attributes.\\n          inViewportAttributePriority = TranslationScheduler.P1;\\n          belowViewportContentPriority = TranslationScheduler.P2;\\n          aboveViewportContentPriority = TranslationScheduler.P3;\\n        }\\n\\n        belowViewportAttributePriority = TranslationScheduler.P4;\\n        aboveViewportAttributePriority = TranslationScheduler.P5;\\n      }\\n    }\\n\\n    return {\\n      inViewportContentPriority,\\n      inViewportAttributePriority,\\n      aboveViewportContentPriority,\\n      aboveViewportAttributePriority,\\n      belowViewportContentPriority,\\n      belowViewportAttributePriority,\\n      otherContentPriority,\\n      otherAttributePriority,\\n    };\\n  }\\n\\n  /**\\n   * Registers a callback on the event loop to drain the queued content-translation nodes and the\\n   * queued attribute-translation elements, prioritizing them and sending their translation requests\\n   * to the TranslationScheduler.\\n   *\\n   * Does nothing if a callback is already pending.\\n   *\\n   * The callback registered by this function uses a dynamic rate limit, where the time between sending\\n   * a batch of requests to the scheduler is much longer if the user is actively scrolling around the page.\\n   *\\n   * The intersection observers are constantly monitoring the locations of nodes within the page,\\n   * enqueuing them to be scheduled when they get near to the viewport, cancelling their requests\\n   * when they exit the viewport, etc.\\n   *\\n   * When an intersection observer needs to cancel a translation request, it is much cheaper to\\n   * remove the node from the queue before it gets assigned a priority submitted to the scheduler.\\n   * If we submit a translation request for every node that gets close to the viewport immediately\\n   * then we will waste a lot of resources cancelling all of those requests if the viewport moves.\\n   *\\n   * So we want to have some mechanism to throttle how frequently nodes are submitted to the scheduler,\\n   * allowing the intersection observers to rapidly resolve the ideal state by adding and removing nodes\\n   * from the queues before we pause to schedule translations for all of the nodes currently in the queues.\\n   *\\n   * However, if we wait too long between each time we send requests to the scheduler, the user experience\\n   * will no longer feel fluid and reactive.\\n   *\\n   * When the user is scrolling, the observers are going to be adding and cancelling many nodes in rapid\\n   * succession as their spatial contexts relative to the viewport change. We need to allow extra time\\n   * to cheaply resolve the state of the queues before sending requests to the scheduler.\\n   *\\n   * When the user is not scrolling, new nodes may still be entering or exiting proximity with te viewport,\\n   * but in this case it is often due to closed caption text updates on a video, or a chat section for a live\\n   * stream being flooded with new comments. Here we want to prioritize and submit much more quickly so that\\n   * we can react fluidly to dynamic changes on the page.\\n   */\\n  async #maybePrioritizeRequestsAndSubmitToScheduler() {\\n    // Ensure that we've completed the first intersection observation before we submit any requests\\n    // to the scheduler. Otherwise, the observers may end up cancelling the requests, because every observed\\n    // element that is not within the observer's proximity will be seen the first time as leaving proximity.\\n    await this.#waitForFirstIntersectionObservations();\\n\\n    if (this.#hasPendingPrioritizationCallback) {\\n      // A callback has already been registered to submit to the scheduler.\\n      return;\\n    }\\n\\n    if (\\n      this.#queuedIntersectionExemptContentElements.size === 0 &&\\n      this.#queuedIntersectionPrunableContentElements.size === 0 &&\\n      this.#queuedIntersectionExemptAttributeElements.size === 0 &&\\n      this.#queuedIntersectionPrunableAttributeElements.size === 0\\n    ) {\\n      // There are no nodes to submit to the scheduler.\\n      return;\\n    }\\n\\n    this.#hasPendingPrioritizationCallback = true;\\n\\n    lazy.setTimeout(\\n      async () => {\\n        const contentElementCount =\\n          this.#queuedIntersectionPrunableContentElements.size;\\n        const attributeElementCount =\\n          this.#queuedIntersectionPrunableAttributeElements.size;\\n\\n        let contentRequestCount = 0;\\n        let attributeRequestCount = 0;\\n\\n        const startTime = ChromeUtils.now();\\n\\n        const {\\n          inViewportContentPriority,\\n          inViewportAttributePriority,\\n          aboveViewportContentPriority,\\n          aboveViewportAttributePriority,\\n          belowViewportContentPriority,\\n          belowViewportAttributePriority,\\n          otherContentPriority,\\n          otherAttributePriority,\\n        } = this.#determinePrioritiesForTranslations();\\n\\n        const {\\n          titleElement,\\n          inViewportContent,\\n          aboveViewportContent,\\n          belowViewportContent,\\n          otherContent,\\n        } = this.#prioritizeQueuedContentElements();\\n\\n        const {\\n          inViewportAttributes,\\n          aboveViewportAttributes,\\n          belowViewportAttributes,\\n          otherAttributes,\\n        } = this.#prioritizeQueuedAttributeElements();\\n\\n        for (const { element, nodeSet } of inViewportContent) {\\n          contentRequestCount += nodeSet.size;\\n          this.#submitForContentTranslation(\\n            inViewportContentPriority,\\n            element,\\n            nodeSet\\n          );\\n        }\\n\\n        if (titleElement) {\\n          // The translator pops nodes off in LIFO order, so if the <title> element is present\\n          // in this group, we want to push it on as the final top-priority node, to ensure\\n          // that it is the very first element to be translated.\\n          contentRequestCount++;\\n          this.#submitForContentTranslation(\\n            inViewportContentPriority,\\n            titleElement,\\n            new Set([titleElement])\\n          );\\n        }\\n\\n        for (const { element, attributeSet } of inViewportAttributes) {\\n          attributeRequestCount += attributeSet.size;\\n          this.#submitForAttributeTranslation(\\n            inViewportAttributePriority,\\n            element,\\n            attributeSet\\n          );\\n        }\\n\\n        for (const { element, nodeSet } of aboveViewportContent) {\\n          contentRequestCount += nodeSet.size;\\n          this.#submitForContentTranslation(\\n            aboveViewportContentPriority,\\n            element,\\n            nodeSet\\n          );\\n        }\\n\\n        for (const { element, attributeSet } of aboveViewportAttributes) {\\n          attributeRequestCount += attributeSet.size;\\n          this.#submitForAttributeTranslation(\\n            aboveViewportAttributePriority,\\n            element,\\n            attributeSet\\n          );\\n        }\\n\\n        for (const { element, nodeSet } of belowViewportContent) {\\n          contentRequestCount += nodeSet.size;\\n          this.#submitForContentTranslation(\\n            belowViewportContentPriority,\\n            element,\\n            nodeSet\\n          );\\n        }\\n\\n        for (const { element, attributeSet } of belowViewportAttributes) {\\n          attributeRequestCount += attributeSet.size;\\n          this.#submitForAttributeTranslation(\\n            belowViewportAttributePriority,\\n            element,\\n            attributeSet\\n          );\\n        }\\n\\n        for (const { element, nodeSet } of otherContent) {\\n          contentRequestCount += nodeSet.size;\\n          this.#submitForContentTranslation(\\n            otherContentPriority,\\n            element,\\n            nodeSet\\n          );\\n        }\\n\\n        for (const { element, attributeSet } of otherAttributes) {\\n          attributeRequestCount += attributeSet.size;\\n          this.#submitForAttributeTranslation(\\n            otherAttributePriority,\\n            element,\\n            attributeSet\\n          );\\n        }\\n\\n        this.#hasPendingPrioritizationCallback = false;\\n\\n        ChromeUtils.addProfilerMarker(\\n          \\\"TranslationsDocument Prioritize\\\",\\n          { startTime, innerWindowId: this.#innerWindowId },\\n          `Prioritized ${contentRequestCount} content translation requests among ${contentElementCount} elements, ` +\\n            `${attributeRequestCount} attribute translation requests among ${attributeElementCount} elements.`\\n        );\\n      },\\n      this.#hasUserScrolledRecently() ? 250 : 25\\n    );\\n  }\\n\\n  /**\\n   * Iterates through all of the nodes that the observers have queued to be sent\\n   * to the TranslationScheduler for attribute translations, groups them based on their\\n   * spatial context with respect to the viewport, then sorts them such that the nodes\\n   * most likely to be encountered next will be scheduled for translation first.\\n   *\\n   * If the <title> is contained within this batch, it specially returns the title node\\n   * as a distinct field so that we can specially ensure that it is the very first translation.\\n   *\\n   * @returns {PrioritizedContentElements}\\n   */\\n  #prioritizeQueuedContentElements() {\\n    /**\\n     * Nodes that lie at least partially within the viewport.\\n     *\\n     * @type {Array<SortableContentElement>}\\n     */\\n    const inViewportContent = [];\\n\\n    /**\\n     * Nodes that lie entirely above the viewport.\\n     *\\n     * @type {Array<SortableContentElement>}\\n     */\\n    const aboveViewportContent = [];\\n\\n    /**\\n     * Nodes that lie entirely below the viewport.\\n     *\\n     * @type {Array<SortableContentElement>}\\n     */\\n    const belowViewportContent = [];\\n\\n    /**\\n     * Nodes that lie entirely to either side of the viewport,\\n     * or whose position could not be determined.\\n     *\\n     * @type {Array<SortableContentElement>}\\n     */\\n    const otherContent = [];\\n\\n    // The <title> will be specially returned in this variable if it is present\\n    // in this batch of nodes.\\n    let titleElement;\\n\\n    const queuedContentElements =\\n      this.#queuedIntersectionPrunableContentElements;\\n\\n    for (const [element, nodeSet] of this\\n      .#queuedIntersectionExemptContentElements) {\\n      const existingSet = queuedContentElements.get(element);\\n\\n      if (existingSet) {\\n        for (const node of nodeSet) {\\n          existingSet.add(node);\\n        }\\n      } else {\\n        queuedContentElements.set(element, nodeSet);\\n      }\\n    }\\n\\n    for (const [element, nodeSet] of queuedContentElements) {\\n      // We will cache the location values so that they don't have to be recomputed\\n      // for every comparison when we sort. Based on my profiles, this all but removes\\n      // samples captured with `Array.prototype.sort`, and cuts the number of samples\\n      // from submitting nodes to the scheduler roughly in half.\\n      const { top, left, right, viewportContext } =\\n        getNodeSpatialContext(element);\\n\\n      switch (viewportContext) {\\n        case \\\"within\\\": {\\n          inViewportContent.push({ element, nodeSet, top, left, right });\\n          break;\\n        }\\n        case \\\"above\\\": {\\n          aboveViewportContent.push({ element, nodeSet, top, left, right });\\n          break;\\n        }\\n        case \\\"below\\\": {\\n          belowViewportContent.push({ element, nodeSet, top, left, right });\\n          break;\\n        }\\n        default: {\\n          if (element.nodeName === \\\"TITLE\\\") {\\n            titleElement = element;\\n          } else {\\n            otherContent.push({ element, nodeSet, top, left, right });\\n          }\\n        }\\n      }\\n    }\\n\\n    // These node groups will be iterated over and sent to the TranslationScheduler in a regular loop,\\n    // but the scheduler processes new requests in a stack-based LIFO ordering, so the following\\n    // sorting semantics will sort nodes in the REVERSE order of how we want them to be scheduled.\\n\\n    // Sort nodes below the viewport such that the top-most nodes will be scheduled first.\\n    this.#orderFromBottomToTop(belowViewportContent);\\n\\n    // Sort nodes above the viewport such that the bottom-most nodes will be scheduled first.\\n    this.#orderFromTopToBottom(aboveViewportContent);\\n\\n    if (\\n      this.#mostRecentScrollDirection === \\\"up\\\" &&\\n      this.#hasUserScrolledRecently()\\n    ) {\\n      // If the user is scrolling up, we should sort nodes that come into intersection proximity\\n      // such that the bottom-most nodes will be scheduled first.\\n      this.#orderFromTopToBottom(inViewportContent);\\n    } else {\\n      // If the user is scrolling down, or by default if they have not scrolled recently, we should\\n      // sort such that the top-most nodes will be scheduled first.\\n      this.#orderFromBottomToTop(inViewportContent);\\n    }\\n\\n    this.#queuedIntersectionPrunableContentElements.clear();\\n    this.#queuedIntersectionExemptContentElements.clear();\\n\\n    return {\\n      titleElement,\\n      inViewportContent,\\n      aboveViewportContent,\\n      belowViewportContent,\\n      otherContent,\\n    };\\n  }\\n\\n  /**\\n   * Iterates through all of the elements that the observers have queued to be sent\\n   * to the TranslationScheduler for attribute translations, groups them based on their\\n   * spatial context with respect to the viewport, then sorts them such that the elements\\n   * most likely to be encountered next will be scheduled for translation first.\\n   *\\n   * @returns {PrioritizedAttributeElements}\\n   */\\n  #prioritizeQueuedAttributeElements() {\\n    /**\\n     * Elements that lie at least partially within the viewport.\\n     *\\n     * @type {Array<SortableAttributeElement>}\\n     */\\n    const inViewportAttributes = [];\\n\\n    /**\\n     * Elements that lie entirely above the viewport.\\n     *\\n     * @type {Array<SortableAttributeElement>}\\n     */\\n    const aboveViewportAttributes = [];\\n\\n    /**\\n     * Elements that lie entirely below the viewport.\\n     *\\n     * @type {Array<SortableAttributeElement>}\\n     */\\n    const belowViewportAttributes = [];\\n\\n    /**\\n     * Elements that lie to either side of the viewport,\\n     * or whose position could not be determined.\\n     *\\n     * @type {Array<SortableAttributeElement>}\\n     */\\n    const otherAttributes = [];\\n\\n    const queuedAttributeElements =\\n      this.#queuedIntersectionPrunableAttributeElements;\\n\\n    for (const [element, attributeSet] of this\\n      .#queuedIntersectionExemptAttributeElements) {\\n      const existingSet = queuedAttributeElements.get(element);\\n\\n      if (!existingSet) {\\n        queuedAttributeElements.set(element, attributeSet);\\n        continue;\\n      }\\n\\n      for (const attributeName of attributeSet) {\\n        existingSet.add(attributeName);\\n      }\\n    }\\n\\n    for (const [element, attributeSet] of queuedAttributeElements) {\\n      // We will cache the location values so that they don't have to be recomputed\\n      // for every comparison when we sort. Based on my profiles, this all but removes\\n      // samples captured with `Array.prototype.sort`, and cuts the time to submit requests\\n      // to the scheduler roughly in half.\\n      const { top, left, right, viewportContext } =\\n        getNodeSpatialContext(element);\\n\\n      switch (viewportContext) {\\n        case \\\"within\\\": {\\n          inViewportAttributes.push({\\n            element,\\n            attributeSet,\\n            top,\\n            left,\\n            right,\\n          });\\n          break;\\n        }\\n        case \\\"above\\\": {\\n          aboveViewportAttributes.push({\\n            element,\\n            attributeSet,\\n            top,\\n            left,\\n            right,\\n          });\\n          break;\\n        }\\n        case \\\"below\\\": {\\n          belowViewportAttributes.push({\\n            element,\\n            attributeSet,\\n            top,\\n            left,\\n            right,\\n          });\\n          break;\\n        }\\n        default: {\\n          otherAttributes.push({ element, attributeSet, top, left, right });\\n        }\\n      }\\n    }\\n\\n    // These element groups will be iterated over and sent to the TranslationScheduler in a regular loop,\\n    // but the scheduler processes new requests in a stack-based LIFO ordering, so the following\\n    // sorting semantics will sort elements in the REVERSE order of how we want them to be scheduled.\\n\\n    // Sort elements below the viewport such that the top-most elements will be scheduled first.\\n    this.#orderFromBottomToTop(belowViewportAttributes);\\n\\n    // Sort elements above the viewport such that the bottom-most elements will be scheduled first.\\n    this.#orderFromTopToBottom(aboveViewportAttributes);\\n\\n    if (this.#mostRecentScrollDirection === \\\"up\\\") {\\n      // If we are scrolling up, we should sort new elements that come into the viewport\\n      // such that the bottom-most elements will be scheduled first.\\n      this.#orderFromTopToBottom(inViewportAttributes);\\n    } else {\\n      // If we are scrolling down, we should sort new elements that come into the viewport\\n      // such that the top-most elements will be scheduled first.\\n      this.#orderFromBottomToTop(inViewportAttributes);\\n    }\\n\\n    this.#queuedIntersectionPrunableAttributeElements.clear();\\n    this.#queuedIntersectionExemptAttributeElements.clear();\\n\\n    return {\\n      inViewportAttributes,\\n      aboveViewportAttributes,\\n      belowViewportAttributes,\\n      otherAttributes,\\n    };\\n  }\\n\\n  /**\\n   * Sorts such that nodes closer to the top of the page are first,\\n   * and nodes closer to the bottom of the page are last.\\n   *\\n   * @param {Array<SortableContentElement> | Array<SortableAttributeElement>} nodes\\n   */\\n  #orderFromTopToBottom(nodes) {\\n    nodes.sort((lhs, rhs) => {\\n      const verticalDifference =\\n        (lhs.top ?? -Infinity) - (rhs.top ?? -Infinity);\\n\\n      if (Math.abs(verticalDifference) > 1) {\\n        // The vertical difference is greater than one pixel: this takes full precedence.\\n        return verticalDifference;\\n      }\\n\\n      if (this.#targetScriptDirection === \\\"ltr\\\") {\\n        // Secondarily sort such that the LIFO scheduler will process from left to right.\\n        return (rhs.right ?? Infinity) - (lhs.right ?? Infinity);\\n      }\\n\\n      // Secondarily sort such that the LIFO scheduler will process from right to left.\\n      return (lhs.left ?? -Infinity) - (rhs.left ?? -Infinity);\\n    });\\n  }\\n\\n  /**\\n   * Sorts such that nodes closer to the bottom of the page are first,\\n   * and nodes closer to the bottom of the page are last.\\n   *\\n   * @param {Array<SortableContentElement> | Array<SortableAttributeElement>} nodes\\n   */\\n  #orderFromBottomToTop(nodes) {\\n    nodes.sort((lhs, rhs) => {\\n      const verticalDifference = (rhs.top ?? Infinity) - (lhs.top ?? Infinity);\\n\\n      if (verticalDifference) {\\n        // The vertical difference is greater than one pixel: this takes full precedence.\\n        return verticalDifference;\\n      }\\n\\n      if (this.#targetScriptDirection === \\\"ltr\\\") {\\n        // Secondarily sort such that the LIFO scheduler will process from left to right.\\n        return (rhs.right ?? Infinity) - (lhs.right ?? Infinity);\\n      }\\n\\n      // Secondarily sort such that the LIFO scheduler will process from right to left.\\n      return (lhs.left ?? -Infinity) - (rhs.left ?? -Infinity);\\n    });\\n  }\\n\\n  /**\\n   * Attempts to register a node with the content-translation intersection observers.\\n   *\\n   * If the node is a text node that was determined to be translatable, then it will\\n   * be immediately enqueued for translation because only element type nodes can be\\n   * observed for intersection.\\n   *\\n   * @param {Node} node\\n   */\\n  #observeOrEnqueueNodeForContentPrioritization(node) {\\n    let observableElement;\\n    let translatableNode;\\n\\n    const element = asElement(node);\\n    if (element) {\\n      observableElement = element;\\n      translatableNode = element;\\n    } else if ((translatableNode = asTextNode(node))) {\\n      observableElement = asElement(node.parentNode);\\n    }\\n\\n    if (!translatableNode) {\\n      // This node is not translatable, and it should have been filtered earlier.\\n      lazy.console.warn(\\n        `A non-translatable ${node.nodeName} node was not filtered correctly.`\\n      );\\n      return;\\n    }\\n\\n    if (!observableElement) {\\n      // This node is translatable, but its immediate parent is not observable for intersection.\\n      lazy.console.warn(\\n        `Found a translatable ${node.nodeName} node is not a direct child of an element.`\\n      );\\n      return;\\n    }\\n\\n    let nodeSet =\\n      this.#intersectionObservedContentElements.get(observableElement);\\n\\n    if (!nodeSet) {\\n      nodeSet = new Set([translatableNode]);\\n      this.#intersectionObservedContentElements.set(observableElement, nodeSet);\\n    }\\n\\n    nodeSet.add(translatableNode);\\n\\n    if (this.#translationsMode === \\\"content-eager\\\") {\\n      this.#enqueueForIntersectionPrunableContentPrioritization(\\n        observableElement\\n      );\\n    }\\n\\n    // It is very important that we register the element with the In-Viewport\\n    // observer before the Beyond-Viewport observer, to ensure that the In-Viewport\\n    // observer callback is triggered first, otherwise we will be sending unnecessary\\n    // cancellations for any nodes that lie within the bounds of both observers.\\n    this.#intersectionObserverForContentTranslationsWithinViewport.observe(\\n      observableElement\\n    );\\n    this.#intersectionObserverForContentTranslationsBeyondViewport.observe(\\n      observableElement\\n    );\\n  }\\n\\n  /**\\n   * Ensures that an element is removed from content intersection observation.\\n   * If the element was not already being observed, has no effect.\\n   *\\n   * @param {Element} observableElement\\n   * @param {Node} targetNode\\n   */\\n  #removeFromContentIntersectionObservation(observableElement, targetNode) {\\n    const { didDeleteOuterEntry } = deleteFromNestedMap(\\n      this.#intersectionObservedContentElements,\\n      observableElement,\\n      targetNode\\n    );\\n\\n    if (didDeleteOuterEntry) {\\n      this.#intersectionObserverForContentTranslationsWithinViewport.unobserve(\\n        observableElement\\n      );\\n      this.#intersectionObserverForContentTranslationsBeyondViewport.unobserve(\\n        observableElement\\n      );\\n    }\\n  }\\n\\n  /**\\n   * Ensures that an element is removed from attribute intersection observation.\\n   * If the element was not already being observed, has no effect.\\n   *\\n   * @param {Element} observableElement\\n   * @param {string} [attributeName]\\n   */\\n  #removeFromAttributeIntersectionObservation(\\n    observableElement,\\n    attributeName\\n  ) {\\n    let didDeleteOuterEntry = false;\\n\\n    if (!attributeName) {\\n      didDeleteOuterEntry = true;\\n      this.#intersectionObservedAttributeElements.delete(observableElement);\\n    } else {\\n      const deletionResult = deleteFromNestedMap(\\n        this.#intersectionObservedAttributeElements,\\n        observableElement,\\n        attributeName\\n      );\\n      didDeleteOuterEntry = deletionResult.didDeleteOuterEntry;\\n    }\\n\\n    if (didDeleteOuterEntry) {\\n      this.#intersectionObserverForAttributeTranslationsWithinViewport.unobserve(\\n        observableElement\\n      );\\n      this.#intersectionObserverForAttributeTranslationsBeyondViewport.unobserve(\\n        observableElement\\n      );\\n    }\\n  }\\n\\n  /**\\n   * Attempts to register an element with the attribute-translation intersection observers.\\n   * If the element has no translatable attributes, it will not be registered for observation.\\n   *\\n   * @param {Element} element\\n   * @param {Set<string> | null} [attributes]\\n   */\\n  #maybeObserveElementForAttributePrioritization(element, attributes) {\\n    attributes = attributes ?? this.#getTranslatableAttributes(element);\\n    if (!attributes) {\\n      return;\\n    }\\n\\n    // It is very important that we register the element with the In-Viewport\\n    // observer before the Beyond-Viewport observer, to ensure that the In-Viewport\\n    // observer callback is triggered first, otherwise we will be sending unnecessary\\n    // cancellations for any nodes that lie within the bounds of both observers.\\n    this.#intersectionObservedAttributeElements.set(element, attributes);\\n    this.#intersectionObserverForAttributeTranslationsWithinViewport.observe(\\n      element\\n    );\\n    this.#intersectionObserverForAttributeTranslationsBeyondViewport.observe(\\n      element\\n    );\\n  }\\n\\n  /**\\n   * Attempts to cancel a content translation request for the given node,\\n   * only if the request has not already been sent to the TranslationsEngine.\\n   *\\n   * This function is intended to be used by the intersection observers to\\n   * re-prioritize a translation. If a translation request has already been\\n   * sent to the TranslationsEngine, in this case, it will soon be complete\\n   * so it would be wasteful to fully cancel it solely to re-prioritize.\\n   *\\n   * In order to fully cancel a translation request, even if it has already been\\n   * sent to the TranslationsEngine, as such is the use case for the mutation\\n   * observer, then the `#maybePreventContentTranslation` function should be used instead.\\n   *\\n   * @param {Element} element\\n   * @returns {{\\n   *  preventedNodeSet?: Set<Node>,\\n   *  cancelledFromSchedulerCount: number\\n   * }}\\n   */\\n  #preventUnscheduledContentTranslations(element) {\\n    /** @type {Set<Node> | undefined} */\\n    let preventedNodeSet =\\n      this.#queuedIntersectionPrunableContentElements.get(element);\\n\\n    if (preventedNodeSet) {\\n      this.#queuedIntersectionPrunableContentElements.delete(element);\\n    }\\n\\n    const pendingNodes = this.#pendingContentTranslations.get(element);\\n    let cancelledFromSchedulerCount = 0;\\n\\n    if (!pendingNodes) {\\n      return {\\n        preventedNodeSet,\\n        cancelledFromSchedulerCount,\\n      };\\n    }\\n\\n    /** @param {Node} node */\\n    const addNodeToSet = node => {\\n      if (!preventedNodeSet) {\\n        preventedNodeSet = new Set();\\n      }\\n      preventedNodeSet.add(node);\\n    };\\n\\n    for (const [node, translationId] of pendingNodes) {\\n      if (this.#scheduler.preventUnscheduledTranslation(translationId)) {\\n        addNodeToSet(node);\\n      }\\n    }\\n\\n    if (preventedNodeSet) {\\n      for (const node of preventedNodeSet.keys()) {\\n        pendingNodes.delete(node);\\n        cancelledFromSchedulerCount++;\\n      }\\n    }\\n\\n    if (pendingNodes.size === 0) {\\n      this.#pendingContentTranslations.delete(element);\\n    }\\n\\n    return {\\n      preventedNodeSet,\\n      cancelledFromSchedulerCount,\\n    };\\n  }\\n\\n  /**\\n   * Attempts to cancel all attribute translation requests for the given element,\\n   * only if the requests have not already been sent to the TranslationsEngine.\\n   *\\n   * This function is intended to be used by the intersection observers to\\n   * re-prioritize translations. If the translation requests have already been\\n   * sent to the TranslationsEngine, in this case, they will soon be complete\\n   * so it would be wasteful to fully cancel them solely to re-prioritize.\\n   *\\n   * In order to fully cancel an element's attribute translation requests, even\\n   * if they have already been sent to the TranslationsEngine, as such is the use\\n   * case for the mutation observer, then the `#maybePreventAttributeTranslations`\\n   * function should be used instead.\\n   *\\n   * @param {Element} element\\n   * @returns {{\\n   *   preventedAttributeSet?: Set<string>,\\n   *   cancelledFromSchedulerCount: number,\\n   * }}\\n   */\\n  #preventUnscheduledAttributeTranslations(element) {\\n    /** @type {Set<string> | undefined} */\\n    let preventedAttributeSet =\\n      this.#queuedIntersectionPrunableAttributeElements.get(element);\\n\\n    if (preventedAttributeSet) {\\n      this.#queuedIntersectionPrunableAttributeElements.delete(element);\\n    }\\n\\n    const pendingAttributes = this.#pendingAttributeTranslations.get(element);\\n    let cancelledFromSchedulerCount = 0;\\n\\n    if (!pendingAttributes) {\\n      return {\\n        preventedAttributeSet,\\n        cancelledFromSchedulerCount,\\n      };\\n    }\\n\\n    /** @param {string} attribute */\\n    const addAttributeToSet = attribute => {\\n      if (!preventedAttributeSet) {\\n        preventedAttributeSet = new Set();\\n      }\\n      preventedAttributeSet.add(attribute);\\n    };\\n\\n    for (const [attribute, translationId] of pendingAttributes) {\\n      if (this.#scheduler.preventUnscheduledTranslation(translationId)) {\\n        addAttributeToSet(attribute);\\n      }\\n    }\\n\\n    if (preventedAttributeSet) {\\n      for (const attribute of preventedAttributeSet.keys()) {\\n        pendingAttributes.delete(attribute);\\n        cancelledFromSchedulerCount++;\\n      }\\n    }\\n\\n    if (pendingAttributes.size === 0) {\\n      this.#pendingAttributeTranslations.delete(element);\\n    }\\n\\n    return {\\n      preventedAttributeSet,\\n      cancelledFromSchedulerCount,\\n    };\\n  }\\n\\n  /**\\n   * Determines whether the given node is eligible to have its text content updated.\\n   *\\n   * Updates to nodes within the DOM may happen asynchronously, so by the time that we are\\n   * ready to update the content we need to check two conditions:\\n   *\\n   * 1) Has the fulfilled request that we have gone stale due to a newer, more-relevant request\\n   *    that was scheduled for this same node?\\n   *\\n   * 2) Has this node already detached from the DOM before we updated its content, in which case\\n   *    there is no point in moving forward with the update?\\n   *\\n   * @param {Element} element\\n   * @param {Node} targetNode\\n   * @param {number} translationId\\n   *\\n   * @returns {UpdateEligibility}\\n   */\\n  #determineNodeContentUpdateEligibility(element, targetNode, translationId) {\\n    const pendingNodes = this.#pendingContentTranslations.get(element);\\n\\n    if (!pendingNodes || pendingNodes.get(targetNode) !== translationId) {\\n      // This translation lost a race, and was deleted or re-submitted under a different id.\\n      return \\\"stale\\\";\\n    }\\n\\n    if (this.#nodesWithMutatedContent.has(targetNode)) {\\n      // The target node has been mutated since the time we requested translation.\\n      // The translated value that we have is no longer relevant.\\n      return \\\"stale\\\";\\n    }\\n\\n    if (isNodeDetached(targetNode)) {\\n      // The node is detached from the DOM, there is no use in updating its content.\\n      return \\\"detached\\\";\\n    }\\n\\n    return \\\"valid\\\";\\n  }\\n\\n  /**\\n   * Determines whether the given element is eligible to have its attributes updated.\\n   *\\n   * Updates to elements within the DOM may happen asynchronously, so by the time that we are\\n   * ready to update the attributes we need to check two conditions:\\n   *\\n   * 1) Has the fulfilled request that we have gone stale due to a newer, more-relevant request\\n   *    that was scheduled for this same attribute on this element?\\n   *\\n   * 2) Has this element already detached from the DOM before we updated its attribute, in which\\n   *    case there is no point moving forward with the update?\\n   *\\n   * @param {Element} element\\n   * @param {string} attribute\\n   * @param {number} translationId\\n   *\\n   * @returns {UpdateEligibility}\\n   */\\n  #determineElementAttributeUpdateEligibility(\\n    element,\\n    attribute,\\n    translationId\\n  ) {\\n    const pendingAttributes = this.#pendingAttributeTranslations.get(element);\\n\\n    if (\\n      !pendingAttributes ||\\n      pendingAttributes.get(attribute) !== translationId\\n    ) {\\n      // A new request has been submitted for this attribute. This one is no longer relevant.\\n      return \\\"stale\\\";\\n    }\\n\\n    if (this.#elementsWithMutatedAttributes.get(element)?.has(attribute)) {\\n      // This attribute has been mutated since the time we requested translation.\\n      // The translated value that we have is no longer relevant.\\n      return \\\"stale\\\";\\n    }\\n\\n    if (isNodeDetached(element)) {\\n      // This element is detached from the DOM: there is no point in updating it.\\n      return \\\"detached\\\";\\n    }\\n\\n    return \\\"valid\\\";\\n  }\\n}\\n\\n/**\\n * The AntiStarvationStack is a stack-like data structure with a predefined batch size.\\n * Requests are pushed to the stack one at a time, but they may only be popped in a batch.\\n *\\n * The stack keeps track of whether the net count of requests has increased or decreased\\n * between each time it pops a batch of request. If the size of the stack has not decreased\\n * since the previous time a batch was popped, then it means that more requests are being\\n * pushed to the stack than are being popped from the stack, and the stack is considered\\n * to have starving requests.\\n *\\n * This terminology is derived from the idea that if the stack is growing faster than it is\\n * processing, then requests at the bottom of the stack will never be popped, and they will starve,\\n * i.e. they will never have a chance to be processed.\\n *\\n *  - https://en.wikipedia.org/wiki/Starvation_(computer_science)\\n *\\n * In order to ensure fairness in processing, when the stack has starving requests it will pull\\n * a predefined portion of the batch from the bottom of the stack, instead of only from the top.\\n * This ensures that if the stack is growing faster than it can be processed, we are guaranteed\\n * to eventually process the oldest requests in the stack, given enough time, and no request will\\n * ever starve entirely.\\n *\\n * It is recommended that the starvation batch portion is less than or equal half of the batch size.\\n * This ensures that priority is still given to newer requests, as is the intent of the stack, while\\n * still ensuring fairness in scheduling.\\n *\\n * The following is a diagram of several calls to popBatch(), demonstrating both normal calls to\\n * popBatch() as well as calls to popBatch() under starvation conditions:\\n *\\n * AntiStarvationStack: size == 9, #batchSize == 5, #starvationBatchPortion == 2\\n *\\n *             ┌─┬─┬─┬─┬─┬─┬─┬─┬─┐\\n *             └─┴─┴─┴─┴─┴─┴─┴─┴─┘\\n * popBatch():         └────┬────┘\\n *                          5\\n *\\n *             ┌─┬─┬─┬─┐\\n *             └─┴─┴─┴─┘\\n * push() x 7:         └──────┬──────┘\\n *                            7\\n *\\n *             ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐\\n *             └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘\\n * popBatch(): └─┬─┘           └──┬──┘\\n *               2                3\\n *\\n *                 ┌─┬─┬─┬─┬─┬─┐\\n *                 └─┴─┴─┴─┴─┴─┘\\n * push() x 4:                 └───┬───┘\\n *                                 4\\n *\\n *                 ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐\\n *                 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘\\n * popBatch():               └────┬────┘\\n *                                5\\n *\\n *                 ┌─┬─┬─┬─┬─┐\\n *                 └─┴─┴─┴─┴─┘\\n */\\nclass AntiStarvationStack {\\n  /**\\n   * The array that represents the internal stack.\\n   *\\n   * @type {Array<TranslationRequest>}\\n   */\\n  #stack = [];\\n\\n  /**\\n   * Keeps track of the size of the stack the previous time a batch was popped.\\n   * This is used to determine if the stack contains any starving requests,\\n   * i.e. more requests are being pushed to the stack than are being popped.\\n   *\\n   * @type {number}\\n   */\\n  #sizeBeforePreviousPop = 0;\\n\\n  /**\\n   * The size of the batch that will be popped from the top of stack when no\\n   * starvation is occurring, i.e. more requests are being popped than pushed.\\n   *\\n   * @type {number}\\n   */\\n  #batchSize = 2;\\n\\n  /**\\n   * Returns the count of requests that are popped from this stack when calling popBatch().\\n   *\\n   * @see {AntiStarvationStack.popBatch}\\n   *\\n   * @returns {number}\\n   */\\n  get batchSize() {\\n    return this.#batchSize;\\n  }\\n\\n  /**\\n   * The size of the batch that will be popped from the bottom of stack when the\\n   * stack has starving requests, i.e. more requests are being pushed than popped.\\n   *\\n   * When the stack is starving, then (#batchSize - #starvationBatchPortion)\\n   * nodes will still be removed from the top of the stack, but #starvationBatchPortion\\n   * nodes will also be removed from the bottom of the stack to ensure fairness for\\n   * continuing to process old requests in addition to new requests.\\n   *\\n   * @type {number}\\n   */\\n  #starvationBatchPortion = 1;\\n\\n  /**\\n   * Constructs a new AntiStarvationStack.\\n   *\\n   * The given batchSize must be larger than the starvationBatchPortion.\\n   *\\n   * @param {number} batchSize\\n   * @param {number} starvationBatchPortion\\n   */\\n  constructor(batchSize, starvationBatchPortion) {\\n    this.#batchSize = batchSize;\\n    this.#starvationBatchPortion = starvationBatchPortion;\\n\\n    if (this.#batchSize < 2) {\\n      throw new Error(\\\"Batch size must be at least 2.\\\");\\n    }\\n\\n    if (this.#starvationBatchPortion <= 0) {\\n      throw new Error(\\\"Starvation batch portion must be greater than zero.\\\");\\n    }\\n\\n    if (this.#batchSize < this.#starvationBatchPortion) {\\n      throw new Error(\\n        \\\"Batch size must not be smaller than starvation batch portion.\\\"\\n      );\\n    }\\n  }\\n\\n  /**\\n   * Returns the current count of requests in the stack.\\n   *\\n   * @returns {number}\\n   */\\n  get size() {\\n    return this.#stack.length;\\n  }\\n\\n  /**\\n   * Pushes a translation request to the top of the stack.\\n   *\\n   * @param {TranslationRequest} request\\n   */\\n  push(request) {\\n    this.#stack.push(request);\\n  }\\n\\n  /**\\n   * Pops at most #batchSize requests from the stack.\\n   *\\n   * If the stack is starving (i.e. the net count of requests in the stack has\\n   * increased since the previous call to popBatch(), rather than decreased),\\n   * then a portion of requests will be removed from the bottom of the stack\\n   * to ensure fairness in scheduling.\\n   *\\n   * @returns {{ starvationDetected: boolean, requests: Array<TranslationRequest>}}\\n   */\\n  popBatch() {\\n    const currentSize = this.size;\\n    const starvationDetected =\\n      // The stack was not empty the last time we popped.\\n      this.#sizeBeforePreviousPop > 0 &&\\n      // The net requests have not decreased since the last time we popped.\\n      currentSize >= this.#sizeBeforePreviousPop &&\\n      // The stack currently has more than one batch worth of requests.\\n      currentSize > this.#batchSize;\\n\\n    this.#sizeBeforePreviousPop = currentSize;\\n\\n    if (currentSize === 0) {\\n      return { starvationDetected, requests: [] };\\n    }\\n\\n    let topBatchSize = this.#batchSize;\\n    let bottomBatchSize = 0;\\n\\n    if (starvationDetected && currentSize > this.#batchSize) {\\n      // The stack is growing faster than it is being processed,\\n      // the stack contains more than one batch worth of requests.\\n      // We will pull some from the bottom and the top to prevent starvation.\\n      topBatchSize -= this.#starvationBatchPortion;\\n      bottomBatchSize = this.#starvationBatchPortion;\\n    }\\n\\n    /** @type {Array<TranslationRequest>} */\\n    const requests = [];\\n\\n    for (let i = 0; i < topBatchSize && this.size > 0; i++) {\\n      // @ts-ignore: this.#stack.pop() cannot return undefined here.\\n      requests.push(this.#stack.pop());\\n    }\\n\\n    // Removing requests from the front of an array like this has O(n) performance characteristics.\\n    // An ideal solution here would utilize a deque with amortized O(1) popBack() and popFront()\\n    // guarantees. Unfortunately, JavaScript lacks a standard deque implementation at this time.\\n    //\\n    // We are operating on small arrays, usually single or double digits in size, low hundreds at most.\\n    // I have not found the performance characteristics here to be any sort of bottleneck; I rarely\\n    // see this function show up in performance profiles, even when translating high-activity live\\n    // stream comment sections, which is a prime scenario for starvation conditions.\\n    //\\n    // Until such a time that a deque is readily available in JavaScript, I do not feel the complexity\\n    // of writing a custom deque implementation is justified for our use case here.\\n    if (bottomBatchSize > 0) {\\n      const bottomPortion = this.#stack.slice(0, bottomBatchSize);\\n      requests.push(...bottomPortion);\\n\\n      // Retain the rest of the stack without the bottom portion.\\n      this.#stack = this.#stack.slice(bottomBatchSize, this.size);\\n    }\\n\\n    return { starvationDetected, requests };\\n  }\\n\\n  /**\\n   * Removes a request from the stack if it matches the given translationId.\\n   *\\n   * @param {number} translationId\\n   * @returns {TranslationRequest | undefined}\\n   */\\n  remove(translationId) {\\n    const index = this.#stack.findIndex(\\n      request => translationId === request.translationId\\n    );\\n\\n    if (index < 0) {\\n      // No request was found matching this translationId.\\n      // It may have already been sent to the TranslationsEngine.\\n      return undefined;\\n    }\\n\\n    const request = this.#stack[index];\\n\\n    // Removing requests from the middle of an array like this has O(n) performance characteristics.\\n    // An ideal solution here would utilize a table-based strategy with amortized O(1) removal guarantees.\\n    //\\n    // Unfortunately, using a table structure such as Map would make every call to popBatch() have O(n),\\n    // characteristics, even under non-starvation conditions, due to Map not having any double-ended\\n    // iteration capabilities at this time.\\n    //\\n    // We are operating on small arrays, usually single or double digits in size, low hundreds at most.\\n    // I have not found the performance characteristics here to be any sort of bottleneck; I rarely\\n    // see this function show up in performance profiles, even when scrolling rapidly through pages,\\n    // which is a prime scenario for cancelling requests and therefore removing them by their translationIds.\\n    this.#stack.splice(index, 1);\\n\\n    return request;\\n  }\\n\\n  /**\\n   * Clears all entries from the stack.\\n   */\\n  clear() {\\n    this.#stack = [];\\n  }\\n}\\n\\n/**\\n * The TranslationScheduler orchestrates when translation requests are sent to the TranslationsEngine.\\n *\\n * The scheduler implements a stack-based, newest-first priority-scheduling algorithm, which ensures\\n * that the most recent content that enters proximity to the viewport, whether due to user scrolling,\\n * or due to dynamic content entering the page, is translated at the highest priority.\\n *\\n * Although the scheduler ensures that the highest-priority requests are translated first, it also\\n * ensures scheduling fairness with guarantees that every request will eventually be scheduled,\\n * regardless of age or priority, even if more requests are coming in than can be processed.\\n *\\n * Fairness is guaranteed by the use of an anti-starvation stack @see {AntiStarvationStack}.\\n *\\n * Requests may be cancelled from the scheduler at any time, even after they are sent to the\\n * TranslationsEngine, though the earlier a request is cancelled, the cheaper it is to do so.\\n */\\nclass TranslationScheduler {\\n  /**\\n   * The priorities of the translation requests, where P0 is the highest and P7 is the lowest.\\n   *\\n   * The priorities are determined by the TranslationsDocument, and are dynamically assigned\\n   * based on several factors including whether the request is for a content or an attribute\\n   * translation, the location of the element with respect to the viewport, and the user's\\n   * recent scrolling activity on the page.\\n   */\\n  static get P0() {\\n    return 0;\\n  }\\n  static get P1() {\\n    return 1;\\n  }\\n  static get P2() {\\n    return 2;\\n  }\\n  static get P3() {\\n    return 3;\\n  }\\n  static get P4() {\\n    return 4;\\n  }\\n  static get P5() {\\n    return 5;\\n  }\\n  static get P6() {\\n    return 6;\\n  }\\n  static get P7() {\\n    return 7;\\n  }\\n\\n  /**\\n   * The count of active requests must be lower than this threshold before we will allow\\n   * sending any more requests to the TranslationsEngine.\\n   *\\n   * We want to strike a balance between being optimally reactive to changes that may\\n   * change request priorities, such as the user scrolling, while also sending a constant\\n   * flow of requests to the TranslationsEngine, minimizing CPU downtime in the worker between\\n   * finishing the current batch of requests and beginning to process the next batch of requests.\\n   *\\n   * This number may need to be increased if the performance of the TranslationsEngine worker\\n   * improves considerably, or if we ever have more than one worker translating in parallel.\\n   *\\n   * @type {number}\\n   */\\n  static get ACTIVE_REQUEST_THRESHOLD() {\\n    return 1;\\n  }\\n\\n  /**\\n   * The port that sends translation requests to the TranslationsEngine.\\n   *\\n   * @type {MessagePort | null}\\n   */\\n  #port = null;\\n\\n  /**\\n   * If a new port is needed, this callback will be invoked to request one\\n   * from the actor. After the actor obtains it, it calls `acquirePort`.\\n   *\\n   * @type {() => void}\\n   */\\n  #actorRequestNewPort;\\n\\n  /**\\n   * A map from the translationId to its corresponding TranslationRequest.\\n   *\\n   * This map contains only the requests that have been sent to the TranslationsEngine.\\n   * Once the engine sends a translation response, we will match the translationId here\\n   * to resolve or reject the request's promise, then remove it from the map.\\n   *\\n   * This map is mutually exclusive to the #unscheduledRequestsPriorityMap.\\n   *\\n   * @type {Map<number, TranslationRequest>}\\n   */\\n  #activeRequests = new Map();\\n\\n  /**\\n   * A map from the translationId to the corresponding request's priority.\\n   *\\n   * This map contains only the requests that have not yet been sent to the TranslationsEngine.\\n   * We use this map to look up which priority stack a request should be removed from if the\\n   * request needs to be cancelled.\\n   *\\n   * Once the scheduler send the request to the TranslationsEngine, the entry for the translationId\\n   * will be removed from this map, and an entry for the same id will be added to #activeRequests.\\n   *\\n   * @type {Map<number, number>}\\n   */\\n  #unscheduledRequestPriorities = new Map();\\n\\n  /**\\n   * The stacks that correspond to the eight priorities a translation request can be assigned.\\n   * The lower the number, the higher the priority. Each priority corresponds to an index in this array.\\n   *\\n   * @see {TranslationScheduler.P0}\\n   * @see {TranslationScheduler.P1}\\n   * @see {TranslationScheduler.P2}\\n   * @see {TranslationScheduler.P3}\\n   * @see {TranslationScheduler.P4}\\n   * @see {TranslationScheduler.P5}\\n   * @see {TranslationScheduler.P6}\\n   * @see {TranslationScheduler.P7}\\n   */\\n  #priorityStacks = [\\n    new AntiStarvationStack(2, 1), // p0 stack\\n    new AntiStarvationStack(2, 1), // p1 stack\\n    new AntiStarvationStack(2, 1), // p2 stack\\n    new AntiStarvationStack(2, 1), // p3 stack\\n    new AntiStarvationStack(2, 1), // p4 stack\\n    new AntiStarvationStack(2, 1), // p5 stack\\n    new AntiStarvationStack(2, 1), // p6 stack\\n    new AntiStarvationStack(2, 1), // p7 stack\\n  ];\\n\\n  #maxRequestsPerScheduleEvent = (() => {\\n    let requestCount = 0;\\n\\n    for (const stack of this.#priorityStacks) {\\n      requestCount += stack.batchSize;\\n    }\\n\\n    return requestCount;\\n  })();\\n\\n  /**\\n   * Tracks the status of the translation engine.\\n   *\\n   * @type {EngineStatus}\\n   */\\n  #engineStatus = \\\"uninitialized\\\";\\n\\n  /**\\n   * Read-only getter to retrieve the engine status.\\n   *\\n   * @returns {EngineStatus}\\n   */\\n  get engineStatus() {\\n    return this.#engineStatus;\\n  }\\n\\n  /**\\n   * Whether the page is currently shown or not. If hidden, we pause processing\\n   * and do not attempt to send new translation requests to the engine.\\n   */\\n  #isPageShown = true;\\n\\n  /**\\n   * If a port is being requested, we store a reference to that promise\\n   * (plus its resolve/reject) so that repeated requests are not re-sent.\\n   *\\n   * @type {{ promise: Promise<void>, resolve: Function, reject: Function } | null}\\n   */\\n  #portRequest = null;\\n\\n  /**\\n   * Marks when we have a pending callback for scheduling more requests\\n   * This ensures that we won't over-schedule requests from multiple calls.\\n   *\\n   * @type {boolean}\\n   */\\n  #hasPendingScheduleRequestsCallback = false;\\n\\n  /**\\n   * The InnerWindowID value to report to profiler markers.\\n   *\\n   * @type {number}\\n   */\\n  #innerWindowId;\\n\\n  /**\\n   * A cache of translations that have already been computed.\\n   * This is cache is shared with the TranslationsDocument.\\n   *\\n   * @type {LRUCache}\\n   */\\n  #translationsCache;\\n\\n  /**\\n   * Constructs a new TranslationScheduler.\\n   *\\n   * @param {MessagePort?} port - A port to send translation requests to the TranslationsEngine.\\n   * @param {number} innerWindowId - The innerWindowId for profiler markers.\\n   * @param {LRUCache} translationsCache - A cache of completed translations, shared with the TranslationsDocument.\\n   * @param {() => void} actorRequestNewPort - The function to call to ask the actor for a new port.\\n   */\\n  constructor(port, innerWindowId, translationsCache, actorRequestNewPort) {\\n    this.#innerWindowId = innerWindowId;\\n    this.#translationsCache = translationsCache;\\n    this.#actorRequestNewPort = actorRequestNewPort;\\n\\n    if (port) {\\n      this.acquirePort(port);\\n    }\\n  }\\n\\n  /**\\n   * @returns {boolean}\\n   */\\n  hasPendingScheduleRequestsCallback() {\\n    return this.#hasPendingScheduleRequestsCallback;\\n  }\\n\\n  /**\\n   * Attaches an onmessage handler to manage any communication with the TranslationsEngine.\\n   * If we were waiting for a port (#portRequest), we resolve that once the engine indicates\\n   * \\\"ready\\\" or reject if it indicates failure.\\n   *\\n   * @see {TranslationsDocument.acquirePort}\\n   *\\n   * @param {MessagePort} port\\n   */\\n  acquirePort(port) {\\n    if (this.#port) {\\n      // If we already have a port open but we somehow got a new one,\\n      // discard the old and use the new. Typically not expected unless the engine\\n      // had an error or the page re-requested a new port forcibly.\\n      if (this.#engineStatus === \\\"ready\\\") {\\n        lazy.console.error(\\n          \\\"Received a new translation port while one already existed.\\\"\\n        );\\n      }\\n      this.#discardPort();\\n    }\\n\\n    this.#port = port;\\n\\n    const portRequest = this.#portRequest;\\n\\n    // Wire up message handling\\n    port.onmessage = event => {\\n      /** @type {{data: PortToPage}} */\\n      const { data } = /** @type {any} */ (event);\\n\\n      switch (data.type) {\\n        case \\\"TranslationsPort:TranslationResponse\\\": {\\n          const { translationId, targetText } = data;\\n          const request = this.#activeRequests.get(translationId);\\n\\n          if (request) {\\n            this.#activeRequests.delete(translationId);\\n            request.resolve(targetText);\\n          }\\n\\n          break;\\n        }\\n        case \\\"TranslationsPort:GetEngineStatusResponse\\\": {\\n          if (portRequest) {\\n            const { resolve, reject } = portRequest;\\n            if (data.status === \\\"ready\\\") {\\n              resolve();\\n            } else {\\n              reject(new Error(\\\"The engine failed to load.\\\"));\\n            }\\n          }\\n\\n          this.#engineStatus = data.status;\\n\\n          if (data.status === \\\"ready\\\") {\\n            this.maybeScheduleMoreTranslationRequests();\\n          } else {\\n            for (const translationId of this.#activeRequests.keys()) {\\n              this.preventSingleTranslation(translationId);\\n            }\\n\\n            for (const translationId of this.#unscheduledRequestPriorities.keys()) {\\n              this.preventUnscheduledTranslation(translationId);\\n            }\\n          }\\n\\n          break;\\n        }\\n        case \\\"TranslationsPort:EngineTerminated\\\": {\\n          this.#discardPort();\\n          this.maybeScheduleMoreTranslationRequests();\\n          break;\\n        }\\n        default: {\\n          lazy.console.error(\\\"Unknown translations port message:\\\", data);\\n          break;\\n        }\\n      }\\n    };\\n\\n    // Ask for the engine status\\n    port.postMessage({ type: \\\"TranslationsPort:GetEngineStatusRequest\\\" });\\n  }\\n\\n  /**\\n   * Returns a promise that will resolve when we have acquired a valid port.\\n   *\\n   * @returns {Promise<void>}\\n   */\\n  #getPortRequestPromise() {\\n    if (this.#portRequest) {\\n      // We already have a pending request to acquire a port.\\n      return this.#portRequest.promise;\\n    }\\n\\n    if (this.#engineStatus === \\\"ready\\\") {\\n      // The engine is already ready for translating.\\n      return Promise.resolve();\\n    }\\n\\n    if (this.#port) {\\n      // We already have a port: we don't need another one.\\n      return Promise.resolve();\\n    }\\n\\n    const portRequest = Promise.withResolvers();\\n    this.#portRequest = portRequest;\\n\\n    // Ask the actor for a new port (which eventually calls `acquirePort`).\\n    this.#actorRequestNewPort();\\n\\n    this.#portRequest.promise\\n      .catch(error => {\\n        lazy.console.error(error);\\n      })\\n      .finally(() => {\\n        // If we haven't replaced #portRequest with another request,\\n        // clear it out now that it succeeded.\\n        if (portRequest === this.#portRequest) {\\n          this.#portRequest = null;\\n        }\\n      });\\n\\n    return this.#portRequest.promise;\\n  }\\n\\n  /**\\n   * Close the port and remove any chance of further messages to the TranslationsEngine.\\n   * Any active requests are moved back to the priority stacks from which they were scheduled.\\n   */\\n  #discardPort() {\\n    this.#preserveActiveRequests();\\n\\n    if (this.#port) {\\n      this.#port.close();\\n      this.#port = null;\\n      this.#portRequest = null;\\n    }\\n\\n    this.#engineStatus = \\\"uninitialized\\\";\\n  }\\n\\n  /**\\n   * Called when the page becomes visible again, e.g. the user was on another tab\\n   * and switched back to this page as the active tab. Any requests that were left\\n   * in the stacks will resume to be scheduled.\\n   */\\n  async onShowPage() {\\n    this.#isPageShown = true;\\n    this.maybeScheduleMoreTranslationRequests();\\n  }\\n\\n  /**\\n   * Called when the page is hidden, e.g. the user moved to a different tab.\\n   * Any active requests that had been sent to the TranslationsEngine will\\n   * be Cancelled and moved back to the corresponding priority stacks that\\n   * they came from.\\n   */\\n  async onHidePage() {\\n    this.#isPageShown = false;\\n\\n    if (this.#portRequest) {\\n      //this.#portRequest.reject();\\n      // If the page is hidden while a port request is pending,\\n      // wait for that request to finish so we can move any in-flight\\n      // requests to the temp queue properly.\\n      try {\\n        await this.#portRequest.promise;\\n      } catch {\\n        // If the port request fails while hidden, not much to do.\\n      }\\n\\n      if (this.#isPageShown) {\\n        // The page was re-shown while we were awaiting the pending port request.\\n        return;\\n      }\\n    }\\n\\n    // Discard the port to avoid engine usage while hidden.\\n    this.#discardPort();\\n  }\\n\\n  /**\\n   * Creates a new TranslationRequest, adds it to the stack that corresponds to its priority,\\n   * and returns a promise for the resolution or rejection of the request.\\n   *\\n   * @see {TranslationRequest}\\n   *\\n   * @param {Node} node - The node that corresponds to this translation request.\\n   * @param {string} sourceText - The source text to translate for this request.\\n   * @param {boolean} isHTML - True if the source text is HTML markup, false if it is plain text.\\n   * @param {number} translationId - The translationId that corresponds to this request.\\n   * @param {number} priority - The priority at which this request should be scheduled.\\n   * @returns {Promise<string | null>}\\n   *   The translated text, or null if the text is already translated, the request becomes stale, the translation fails.\\n   */\\n  createTranslationRequestPromise(\\n    node,\\n    sourceText,\\n    isHTML,\\n    translationId,\\n    priority\\n  ) {\\n    const { promise, resolve, reject } = Promise.withResolvers();\\n    this.#unscheduledRequestPriorities.set(translationId, priority);\\n\\n    this.#priorityStacks[priority].push({\\n      node,\\n      sourceText,\\n      isHTML,\\n      translationId,\\n      priority,\\n      resolve,\\n      reject,\\n    });\\n\\n    this.maybeScheduleMoreTranslationRequests();\\n\\n    return promise;\\n  }\\n\\n  /**\\n   * Attempts to cancel a translation request if it has not been sent to the TranslationsEngine.\\n   *\\n   * To fully cancel a request regardless of whether it has been scheduled or not,\\n   * use the `cancelSingleTranslation` method.\\n   *\\n   * @see {TranslationScheduler.preventSingleTranslation}\\n   *\\n   * @param {number} translationId - The translationId of the request to cancel.\\n   * @returns {boolean} - True if the request was Cancelled, otherwise false.\\n   */\\n  preventUnscheduledTranslation(translationId) {\\n    const priority = this.#unscheduledRequestPriorities.get(translationId);\\n\\n    if (priority === undefined) {\\n      // We were unable to retrieve an unscheduled priority for the given translationId.\\n      // This request has likely already been sent to the TranslationsEngine.\\n      return false;\\n    }\\n\\n    const request = this.#priorityStacks[priority].remove(translationId);\\n\\n    if (request) {\\n      request.resolve(null);\\n    }\\n\\n    this.#unscheduledRequestPriorities.delete(translationId);\\n\\n    ChromeUtils.addProfilerMarker(\\n      `TranslationScheduler Cancel P${priority}`,\\n      { innerWindowId: this.#innerWindowId },\\n      `Cancelled one unscheduled P${priority} translation.`\\n    );\\n\\n    return true;\\n  }\\n\\n  /**\\n   * Cancel a translation request regardless of whether it has been sent to the TranslationsEngine.\\n   *\\n   * For a more conservative method to only cancel a request that has not yet been scheduled,\\n   * use the `maybePreventUnscheduledTranslation` method.\\n   *\\n   * @see {TranslationScheduler.preventUnscheduledTranslation}\\n   *\\n   * @param {number} translationId - The translationId of the request to cancel.\\n   * @returns {{\\n   *  didPrevent: boolean,\\n   *  didCancelFromScheduler: boolean,\\n   *  didCancelFromEngine: boolean,\\n   * }}\\n   */\\n  preventSingleTranslation(translationId) {\\n    if (this.preventUnscheduledTranslation(translationId)) {\\n      // We successfully canceled this request before it was scheduled: nothing more to do.\\n      return {\\n        didPrevent: true,\\n        didCancelFromScheduler: true,\\n        didCancelFromEngine: false,\\n      };\\n    }\\n\\n    const request = this.#activeRequests.get(translationId);\\n\\n    if (!request) {\\n      // This translation completed before we got a chance to cancel it.\\n      return {\\n        didPrevent: false,\\n        didCancelFromScheduler: false,\\n        didCancelFromEngine: false,\\n      };\\n    }\\n\\n    // If the request is active, then it has been sent to the TranslationsEngine,\\n    // so we must attempt to send a cancel request to the engine as well.\\n    this.#port?.postMessage({\\n      type: \\\"TranslationsPort:CancelSingleTranslation\\\",\\n      translationId,\\n    });\\n\\n    request.resolve(null);\\n    this.#activeRequests.delete(translationId);\\n\\n    ChromeUtils.addProfilerMarker(\\n      `TranslationScheduler Cancel P${request.priority}`,\\n      { innerWindowId: this.#innerWindowId },\\n      `Cancelled one active P${request.priority} translation.`\\n    );\\n\\n    // We may have cancelled the only active request, which may not receive a response now.\\n    // If so, we need to ensure that we continue to schedule more requests.\\n    this.maybeScheduleMoreTranslationRequests();\\n\\n    return {\\n      didPrevent: true,\\n      didCancelFromScheduler: true,\\n      didCancelFromEngine: true,\\n    };\\n  }\\n\\n  /**\\n   * Returns any active translation request back to the priority stack from which they came.\\n   * Whenever the scheduler resumes scheduling, these requests may be already fulfilled,\\n   * resulting in a no-op, or they will be picked back up where they were left off.\\n   */\\n  #preserveActiveRequests() {\\n    lazy.console.log(\\n      `Pausing translations with ${this.#activeRequests.size} active translation requests.`\\n    );\\n\\n    if (!this.#hasActiveTranslationRequests()) {\\n      // There are no active requests to unschedule: nothing more to do.\\n      return;\\n    }\\n\\n    for (const request of this.#activeRequests.values()) {\\n      const { translationId, priority } = request;\\n\\n      this.#priorityStacks[priority].push(request);\\n      this.#unscheduledRequestPriorities.set(translationId, priority);\\n    }\\n\\n    this.#activeRequests.clear();\\n  }\\n\\n  /**\\n   * Returns true if the scheduler has few enough quests that it is within the\\n   * final batches that it will schedule until more requests come in.\\n   *\\n   * @returns {boolean}\\n   */\\n  isWithinFinalBatches() {\\n    return (\\n      this.#maxRequestsPerScheduleEvent >=\\n      this.#pendingTranslationRequestCount()\\n    );\\n  }\\n\\n  /**\\n   * Returns the count of pending translation requests, both active and unscheduled.\\n   *\\n   * @returns {number}\\n   */\\n  #pendingTranslationRequestCount() {\\n    return this.#activeRequests.size + this.#unscheduledRequestPriorities.size;\\n  }\\n\\n  /**\\n   * Returns true if the scheduler has any requests have been sent to the TranslationsEngine,\\n   * and have not yet received a response, otherwise false.\\n   *\\n   * @returns {boolean}\\n   */\\n  #hasActiveTranslationRequests() {\\n    return this.#activeRequests.size > 0;\\n  }\\n\\n  /**\\n   * Returns true if the scheduler has any requests that have not yet been sent to the TranslationsEngine,\\n   * and are waiting in a corresponding priority stack to be scheduled, otherwise false.\\n   *\\n   * @returns {boolean}\\n   */\\n  #hasUnscheduledTranslationRequests() {\\n    return this.#unscheduledRequestPriorities.size > 0;\\n  }\\n\\n  /**\\n   * Returns true if the conditions are met to schedule more requests by sending them to the TranslationsEngine,\\n   * otherwise false if the scheduler should wait longer before sending more requests over the port.\\n   *\\n   * @returns {boolean}\\n   */\\n  #shouldScheduleMoreTranslationRequests() {\\n    if (!this.#isPageShown) {\\n      // We should not spend CPU time if the page is hidden.\\n      return false;\\n    }\\n\\n    if (this.#portRequest) {\\n      // We are still waiting for a port: we will try again if a port is acquired.\\n      return false;\\n    }\\n\\n    if (this.#port && this.#engineStatus === \\\"uninitialized\\\") {\\n      // We have acquired a port, but we are still waiting for an engine status message.\\n      // We will try again if the engine becomes ready.\\n      return false;\\n    }\\n\\n    if (this.#hasPendingScheduleRequestsCallback) {\\n      // There is already a pending callback to schedule more requests.\\n      return false;\\n    }\\n\\n    if (\\n      this.#activeRequests.size > TranslationScheduler.ACTIVE_REQUEST_THRESHOLD\\n    ) {\\n      // There are too many active requests to schedule any more right now.\\n      return false;\\n    }\\n\\n    if (!this.#hasUnscheduledTranslationRequests()) {\\n      // There are no unscheduled requests to be sent to the TranslationsEngine.\\n      return false;\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * Schedules another batch of requests by sending them to the TranslationsEngine,\\n   * only if it makes sense to do so.\\n   */\\n  maybeScheduleMoreTranslationRequests() {\\n    if (!this.#shouldScheduleMoreTranslationRequests()) {\\n      // The conditions are not currently right to schedule more requests.\\n      return;\\n    }\\n\\n    this.#hasPendingScheduleRequestsCallback = true;\\n\\n    lazy.setTimeout(() => {\\n      this.#getPortRequestPromise()\\n        .then(this.#scheduleMoreTranslationRequests)\\n        .catch(error => {\\n          lazy.console.error(error);\\n          this.#hasPendingScheduleRequestsCallback = false;\\n        });\\n    }, 0);\\n  }\\n\\n  /**\\n   * Schedules a batch of requests from the given stack by sending them to the TranslationsEngine.\\n   *\\n   * @param {AntiStarvationStack} stack - The stack from which to schedule the batch of requests.\\n   * @returns {boolean} - Returns true if starvation was detected in this stack, otherwise false.\\n   */\\n  #scheduleBatchFromStack(stack) {\\n    const { starvationDetected, requests } = stack.popBatch();\\n\\n    for (const request of requests) {\\n      this.#maybeScheduleTranslationRequest(request);\\n    }\\n\\n    return starvationDetected;\\n  }\\n\\n  /**\\n   * Schedules another batch of requests from the priority stacks by sending them to the TranslationsEngine.\\n   * How many requests are scheduled, and from which stacks, will depend on the current state of the stacks.\\n   *\\n   * This function is intentionally written as a lambda so that it can be passed as a\\n   * callback without the need to explicitly bind `this` to the function object.\\n   */\\n  #scheduleMoreTranslationRequests = () => {\\n    if (!this.#port) {\\n      // We lost our port between when this function was registered on the event loop, and when it was invoked.\\n      // The best we can do is possibly try again, if the conditions are still right.\\n      this.#hasPendingScheduleRequestsCallback = false;\\n      this.maybeScheduleMoreTranslationRequests();\\n      return;\\n    }\\n\\n    let stackSizesAtStart = null;\\n    const activeRequestsAtStart = this.#activeRequests.size;\\n    const unscheduledRequestsAtStart = this.#unscheduledRequestPriorities.size;\\n    if (Services.profiler?.IsActive() || lazy.console.shouldLog(\\\"Debug\\\")) {\\n      // We need to preserve the sizes prior to scheduling only if we are adding profiler markers,\\n      // or if we are logging to console debug. Otherwise we shouldn't bother with these computations.\\n      stackSizesAtStart = this.#priorityStacks.map(stack => stack.size);\\n    }\\n\\n    // Schedule only as many requests as we are required to in order to achieve starvation fairness,\\n    // starting with the highest-priority stack and moving toward the lower-priority stacks.\\n    for (const stack of this.#priorityStacks) {\\n      const starvationDetected = this.#scheduleBatchFromStack(stack);\\n\\n      if (stack.size === 0) {\\n        // This stack is now empty, so we are clear to schedule more lower-priority requests.\\n        continue;\\n      }\\n\\n      if (starvationDetected) {\\n        // This stack is starving (i.e. more requests are being added than are being scheduled),\\n        // so we must process a batch of lower-priority requests on this cycle in order to keep\\n        // the priority-scheduling algorithm fair, otherwise we could, in theory, only ever process\\n        // the current-level stack if new requests of the same priority continue to come in at a high rate.\\n        continue;\\n      }\\n\\n      // We just scheduled a batch of requests from the highest-relevant-priority stack, and the count of requests\\n      // in that stack is decreasing. We should break here so as not to schedule any lower-priority requests before\\n      // we absolutely need to. The lower-priority requests may be justifiably cancelled before we get to them,\\n      // such as being re-prioritized or removed if the user scrolls around the page. In the event that they are\\n      // not cancelled, then they are guaranteed to be scheduled eventually, either due to starvation fairness,\\n      // or simply when it is their turn after processing all of the higher-priority requests first.\\n      break;\\n    }\\n\\n    this.#maybeAddProfilerMarkersForStacks(stackSizesAtStart);\\n    this.#maybeLogStackDataToConsoleDebug(\\n      stackSizesAtStart,\\n      activeRequestsAtStart,\\n      unscheduledRequestsAtStart\\n    );\\n\\n    this.#hasPendingScheduleRequestsCallback = false;\\n  };\\n\\n  /**\\n   * If actively profiling, adds a marker for how many requests wre scheduled from each stack, if any.\\n   *\\n   * Normally, we would rely on `ChromeUtils.addProfilerMarker()` itself to no-op if not profiling,\\n   * however there are calculations and conditions for whether or not to post a marker, and scheduling\\n   * happens quite frequently, so it is best to not waste time with these calculations if not profiling.\\n   *\\n   * @param {Array<number>?} stackSizesAtStart – The size of each stack prior to the slice of scheduling that just occurred.\\n   */\\n  #maybeAddProfilerMarkersForStacks(stackSizesAtStart) {\\n    if (!stackSizesAtStart || !Services.profiler.IsActive()) {\\n      return;\\n    }\\n\\n    for (let priority = 0; priority < stackSizesAtStart.length; ++priority) {\\n      const scheduledCount =\\n        stackSizesAtStart[priority] - this.#priorityStacks[priority].size;\\n\\n      if (scheduledCount > 0) {\\n        ChromeUtils.addProfilerMarker(\\n          `TranslationScheduler Send P${priority}`,\\n          { innerWindowId: this.#innerWindowId },\\n          `Posted ${scheduledCount} P${priority} translation requests.`\\n        );\\n      }\\n    }\\n  }\\n\\n  /**\\n   * If \\\"Debug\\\" is available, logs how many requests were scheduled from each stack on this scheduling pass, starting\\n   * with the highest-priority stack and logging through to the lowest-priority stack that scheduled any request.\\n   *\\n   * Normally, we would rely on `lazy.console.debug()` itself to no-op if \\\"Debug\\\" does not lie within the max log level,\\n   * however there are calculations and conditions related to formatting this log nicely in the console, and scheduling\\n   * happens quite frequently, so it is best to not waste time with these calculations if we will not log them at all.\\n   *\\n   * Example:\\n   *\\n   * \\\"Scheduler(_1 | 422) [ __1, 165, 132, __1, 106, __1, __8, __8 ] => P0(__1), P1(__2)\\\"\\n   *             ╻    ╻      ╻    ╻    ╻    ╻    ╻    ╻    ╻    ╻       ╻        ╻\\n   *             │    │      │    │    │    │    │    │    │    │       │        │\\n   *             │    │      │    │    │    │    │    │    │    │       │        2 P1 requests were scheduled in this batch.\\n   *             │    │      │    │    │    │    │    │    │    │       │\\n   *             │    │      │    │    │    │    │    │    │    │       1 P0 request was scheduled in this batch.\\n   *             │    │      │    │    │    │    │    │    │    │\\n   *             │    │      │    │    │    │    │    │    │    There are 8 P7 requests\\n   *             │    │      │    │    │    │    │    │    │\\n   *             │    │      │    │    │    │    │    │    There are 8 P6 requests.\\n   *             │    │      │    │    │    │    │    │\\n   *             │    │      │    │    │    │    │    There is 1 P5 request.\\n   *             │    │      │    │    │    │    │\\n   *             │    │      │    │    │    │    There are 106 P4 requests.\\n   *             │    │      │    │    │    │\\n   *             │    │      │    │    │    There is 1 P3 request.\\n   *             │    │      │    │    │\\n   *             │    │      │    │    There are 132 P2 requests.\\n   *             │    │      │    │\\n   *             │    │      │    There are 165 P1 requests.\\n   *             │    │      │\\n   *             │    │      There is 1 P0 request.\\n   *             │    │\\n   *             │    There are 422 pending requests.\\n   *             │\\n   *             There is 1 active request.\\n   *\\n   * @param {Array<number>?} stackSizesAtStart – The size of each stack prior to the slice of scheduling that just occurred.\\n   * @param {number} activeRequestsAtStart - The number of active requests that the TranslationsEngine was processing at the\\n   *                                         moment we scheduled more requests from the stacks.\\n   * @param {number} unscheduledRequestsAtStart - The number of unscheduled requests that the TranslationsEngine was processing\\n   *                                         at the moment we scheduled more requests from the stacks.\\n   */\\n  #maybeLogStackDataToConsoleDebug(\\n    stackSizesAtStart,\\n    activeRequestsAtStart,\\n    unscheduledRequestsAtStart\\n  ) {\\n    if (!stackSizesAtStart || !lazy.console.shouldLog(\\\"Debug\\\")) {\\n      return;\\n    }\\n\\n    // Find the deepest priority stack that scheduled any requests.\\n    let maxStackDepth;\\n    for (let depth = stackSizesAtStart.length - 1; depth >= 0; --depth) {\\n      if (this.#priorityStacks[depth].size < stackSizesAtStart[depth]) {\\n        maxStackDepth = depth;\\n        break;\\n      }\\n    }\\n\\n    if (maxStackDepth === undefined) {\\n      // No requests were scheduled on this pass.\\n      return;\\n    }\\n\\n    const padLength = Math.max(\\n      3,\\n      ...stackSizesAtStart.map(n => String(n).length)\\n    );\\n\\n    const segments = [];\\n    for (let priority = 0; priority <= maxStackDepth; ++priority) {\\n      const sizeAtStart = stackSizesAtStart[priority];\\n      const currentSize = this.#priorityStacks[priority].size;\\n      const scheduledCount = sizeAtStart - currentSize;\\n\\n      const formatted =\\n        scheduledCount === 0\\n          ? \\\"_\\\".repeat(padLength)\\n          : String(scheduledCount).padStart(padLength, \\\"_\\\");\\n\\n      segments.push(`P${priority}(${formatted})`);\\n    }\\n\\n    const activeRequestsPadLength = String(\\n      this.#maxRequestsPerScheduleEvent\\n    ).length;\\n    const activeRequestsString =\\n      activeRequestsAtStart === 0\\n        ? \\\"_\\\".repeat(activeRequestsPadLength)\\n        : String(activeRequestsAtStart).padStart(activeRequestsPadLength, \\\"_\\\");\\n\\n    const unscheduledRequestsString = String(\\n      unscheduledRequestsAtStart\\n    ).padStart(3, \\\"_\\\");\\n\\n    lazy.console.debug(\\n      `Scheduler(${activeRequestsString} | ${unscheduledRequestsString}) ` +\\n        TranslationScheduler.#formatSizesAtStart(stackSizesAtStart) +\\n        ` => ${segments.join(\\\", \\\")}`\\n    );\\n  }\\n\\n  /**\\n   * Formats the sizes of each priority stack into a string that is nice to look\\n   * at in the JS console.\\n   *\\n   * Example:\\n   *\\n   * \\\"[ __1, 165, 132, __1, 106, __1, __8, __8 ]\\\"\\n   * //  P0   P1   P2   P3   P4   P5   P6   P7\\n   *\\n   * @param {Array<number>} stackSizesAtStart\\n   */\\n  static #formatSizesAtStart(stackSizesAtStart) {\\n    const padLength = Math.max(\\n      3,\\n      ...stackSizesAtStart.map(n => String(Math.abs(n)).length)\\n    );\\n\\n    const segments = stackSizesAtStart.map(n =>\\n      n === 0 ? \\\"_\\\".repeat(padLength) : String(n).padStart(padLength, \\\"_\\\")\\n    );\\n\\n    return `[ ${segments.join(\\\", \\\")} ]`;\\n  }\\n\\n  /**\\n   * Schedules the translation request by sending it to the TranslationsEngine only\\n   * if the node that is relevant to the request is not detached.\\n   *\\n   * @param {TranslationRequest} request\\n   */\\n  #maybeScheduleTranslationRequest(request) {\\n    const { node } = request;\\n\\n    if (isNodeDetached(node)) {\\n      // If the node is dead, there is no need to schedule it.\\n      const { translationId, resolve } = request;\\n\\n      this.#unscheduledRequestPriorities.delete(translationId);\\n      resolve(null);\\n\\n      return;\\n    }\\n\\n    this.#scheduleTranslationRequest(request);\\n  }\\n\\n  /**\\n   * Schedules a translation request by sending it to the TranslationsEngine,\\n   * marking the request as active.\\n   *\\n   * @param {TranslationRequest} request\\n   */\\n  #scheduleTranslationRequest(request) {\\n    if (!this.#port) {\\n      // This should never happen, since we should only be scheduling requests under\\n      // circumstances in which we are certain that we have a valid port.\\n      lazy.console.error(\\n        \\\"Attempt to schedule a translation request without a port.\\\"\\n      );\\n\\n      // If this should ever happen, the best thing we can do to recover is to put\\n      // the request back onto its corresponding priority stack to be scheduled again.\\n      const { priority } = request;\\n      this.#priorityStacks[priority].push(request);\\n\\n      return;\\n    }\\n\\n    const { translationId, sourceText, isHTML } = request;\\n\\n    this.#activeRequests.set(translationId, request);\\n    this.#unscheduledRequestPriorities.delete(translationId);\\n    if (this.#translationsCache.isAlreadyTranslated(sourceText, isHTML)) {\\n      // Our cache indicates that the text that is being sent to translate is an exact\\n      // match to the translated output text of a previous request. When this happens\\n      // we should simply signal to the engine that this is a no-op, rather than\\n      // attempting to re-translate text that is already in the target language.\\n      //\\n      // This can happen in cases where a website removes already-translated content,\\n      // and then puts it back in the same spot, triggering our mutation observers.\\n      //\\n      // Wikipedia does this, for example, with the \\\"title\\\" attributes on hyperlinks\\n      // nearly every time they are moused over.\\n      this.#port.postMessage({\\n        type: \\\"TranslationsPort:Passthrough\\\",\\n        translationId,\\n      });\\n      return;\\n    }\\n\\n    const cachedTranslation = this.#translationsCache.get(sourceText, isHTML);\\n    if (cachedTranslation) {\\n      // We already have a matching translated output for this source text, but\\n      // it was not hot in the cache when this request was sent to the translator,\\n      // otherwise the TranslationsDocument would have handled it directly.\\n      //\\n      // This may happen when several nodes with identical text get queued for translation\\n      // all at the same time, while the cache was still cold, such as translating a nested\\n      // comment section with multiple collapsed expandable threads that say \\\"2 replies\\\".\\n      //\\n      // We will signal to the engine to simply pass the cached translation along as\\n      // the response instead of wasting CPU time trying to recompute the translation.\\n      this.#port.postMessage({\\n        type: \\\"TranslationsPort:CachedTranslation\\\",\\n        translationId,\\n        cachedTranslation,\\n      });\\n      return;\\n    }\\n\\n    this.#port.postMessage({\\n      type: \\\"TranslationsPort:TranslationRequest\\\",\\n      translationId,\\n      sourceText,\\n      isHTML,\\n    });\\n  }\\n\\n  /**\\n   * Cleans up everything, closing the port and removing all translation request data.\\n   */\\n  destroy() {\\n    this.#port?.close();\\n    this.#port = null;\\n    this.#portRequest?.reject();\\n    this.#portRequest = null;\\n    this.#engineStatus = \\\"uninitialized\\\";\\n\\n    this.#activeRequests.clear();\\n    this.#unscheduledRequestPriorities.clear();\\n\\n    for (const stack of this.#priorityStacks) {\\n      stack.clear();\\n    }\\n  }\\n}\\n\\n/**\\n * Returns true if an HTML element is hidden based on factors such as collapsed state and\\n * computed style, otherwise false.\\n *\\n * @param {HTMLElement} element\\n * @returns {boolean}\\n */\\nfunction isHTMLElementHidden(element) {\\n  // This is a cheap and easy check that will not compute style or force reflow.\\n  if (element.hidden) {\\n    // The element is explicitly hidden.\\n    return true;\\n  }\\n\\n  // Handle open/closed <details> elements. This will also not compute style or force reflow.\\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/details\\n  if (\\n    // The element is within a closed <details>\\n    element.closest(\\\"details:not([open])\\\") &&\\n    // The element is not part of the <summary> of the <details>, which is always visible, even when closed.\\n    !element.closest(\\\"summary\\\")\\n  ) {\\n    // The element is within a closed <details> and is not part of the <summary>, therefore it is not visible.\\n    return true;\\n  }\\n\\n  // This forces reflow, which has a performance cost, but this is also what JQuery uses for its :hidden and :visible.\\n  // https://github.com/jquery/jquery/blob/bd6b453b7effa78b292812dbe218491624994526/src/css/hiddenVisibleSelectors.js#L1-L10\\n  if (\\n    !(\\n      element.offsetWidth ||\\n      element.offsetHeight ||\\n      element.getClientRects().length\\n    )\\n  ) {\\n    return true;\\n  }\\n\\n  const { ownerGlobal } = element;\\n  if (!ownerGlobal) {\\n    // We cannot compute the style without ownerGlobal, so we will assume it is not visible.\\n    return true;\\n  }\\n\\n  // This flushes the style, which is a performance cost.\\n  const style = ownerGlobal.getComputedStyle(element);\\n  if (!style) {\\n    // We were unable to compute the style, so we will assume it is not visible.\\n    return true;\\n  }\\n\\n  // This is an issue with the DOM library generation.\\n  // @ts-expect-error Property 'display' does not exist on type 'CSSStyleDeclaration'.ts(2339)\\n  const { display, visibility, opacity } = style;\\n\\n  return (\\n    display === \\\"none\\\" ||\\n    visibility === \\\"hidden\\\" ||\\n    visibility === \\\"collapse\\\" ||\\n    opacity === \\\"0\\\"\\n  );\\n}\\n\\n/**\\n * This function returns the correct element to determine the\\n * style of node.\\n *\\n * @param {Node} node\\n *\\n * @returns {HTMLElement | null}\\n */\\nfunction getHTMLElementForStyle(node) {\\n  const element = asHTMLElement(node);\\n  if (element) {\\n    return element;\\n  }\\n\\n  if (node.parentElement) {\\n    return asHTMLElement(node.parentElement);\\n  }\\n\\n  // For cases like text node where its parent is ShadowRoot,\\n  // we'd like to use flattenedTreeParentNode\\n  if (node.flattenedTreeParentNode) {\\n    return asHTMLElement(node.flattenedTreeParentNode);\\n  }\\n\\n  // If the text node is not connected or doesn't have a frame.\\n  return null;\\n}\\n\\n/**\\n * Gets the spatial context of the node with respect to the viewport.\\n *\\n * If the node lies entirely to the left or entirely to the right of the viewport,\\n * this takes precedence over whether the node is entirely above or below the viewport.\\n *\\n * For example, if a node is both entirely above, and entirely to the right of the\\n * viewport, then the returned context will be \\\"right\\\".\\n *\\n * If any part of a node's bounding box lies within the viewport then the context\\n * is considered \\\"within\\\".\\n *\\n * @param {Node} node\\n *\\n * @returns {NodeSpatialContext}\\n */\\nfunction getNodeSpatialContext(node) {\\n  const window = node.ownerGlobal;\\n  const document = node.ownerDocument;\\n  if (!window || !document || !document.documentElement) {\\n    // We won't be able to calculate the spatial context for this node.\\n    return {};\\n  }\\n\\n  const element = getHTMLElementForStyle(node);\\n  if (!element) {\\n    // We only calculate the spatial context for HTML elements.\\n    return {};\\n  }\\n\\n  if (isHTMLElementHidden(element)) {\\n    // If the element is hidden, then the spatial context is not important.\\n    return {};\\n  }\\n\\n  const { top, right, bottom, left } = element.getBoundingClientRect();\\n\\n  const viewportHeight =\\n    window.innerHeight || document.documentElement.clientHeight;\\n  const viewportWidth =\\n    window.innerWidth || document.documentElement.clientWidth;\\n\\n  /** @type {NodeSpatialContext} */\\n  let spatialContext = { top, left, right, viewportContext: undefined };\\n\\n  if (right < 0) {\\n    // The node is entirely to the left of the viewport.\\n    spatialContext.viewportContext = \\\"left\\\";\\n    return spatialContext;\\n  }\\n\\n  if (left > viewportWidth) {\\n    // The node is entirely to the right of the viewport.\\n    spatialContext.viewportContext = \\\"right\\\";\\n    return spatialContext;\\n  }\\n\\n  if (bottom < 0) {\\n    // The node is entirely above the viewport.\\n    spatialContext.viewportContext = \\\"above\\\";\\n    return spatialContext;\\n  }\\n\\n  if (top > viewportHeight) {\\n    // The node is entirely below the viewport.\\n    spatialContext.viewportContext = \\\"below\\\";\\n    return spatialContext;\\n  }\\n\\n  // The node must be within the viewport.\\n  spatialContext.viewportContext = \\\"within\\\";\\n  return spatialContext;\\n}\\n\\n/**\\n * Actually perform the update of the element with the translated node. This step\\n * will detach all of the \\\"live\\\" nodes, and match them up in the correct order as provided\\n * by the translations engine.\\n *\\n * @param {Document} translationsDocument\\n * @param {Element} element\\n *\\n * @returns {void}\\n */\\nfunction updateElement(translationsDocument, element) {\\n  // This text should have the same layout as the target, but it's not completely\\n  // guaranteed since the content page could change at any time, and the translation process is async.\\n  //\\n  // The document has the following structure:\\n  //\\n  // <html>\\n  //   <head>\\n  //   <body>{translated content}</body>\\n  // </html>\\n\\n  const originalHTML = element.innerHTML;\\n\\n  /**\\n   * The Set of translation IDs for nodes that have been cloned.\\n   *\\n   * @type {Set<string>}\\n   */\\n  const clonedNodes = new Set();\\n\\n  // Guard against unintended changes to the \\\"value\\\" of <option> elements during\\n  // translation. This issue occurs because if an <option> element lacks an explicitly\\n  // set \\\"value\\\" attribute, then the default \\\"value\\\" will be taken from the text content\\n  // when requested.\\n  //\\n  // For example, <option>dog</option> might be translated to <option>perro</option>.\\n  // Without an explicit \\\"value\\\", the implicit \\\"value\\\" would change from \\\"dog\\\" to \\\"perro\\\",\\n  // and this can cause problems for submissions to queries etc.\\n  //\\n  // To prevent this, we ensure every translated <option> has an explicit \\\"value\\\"\\n  // attribute, either preserving the original \\\"value\\\" or assigning it from the original\\n  // text content. This results in <option>dog</option> being translated to\\n  // <option value=\\\"dog\\\">perro</option>\\n  //\\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option#value\\n  if (element.tagName === \\\"OPTION\\\") {\\n    element.setAttribute(\\n      \\\"value\\\",\\n      /** @type {HTMLOptionElement} */ (element).value\\n    );\\n  }\\n  for (const option of element.querySelectorAll(\\\"option\\\")) {\\n    option.setAttribute(\\\"value\\\", option.value);\\n  }\\n\\n  /**\\n   * Build up a mapping of any element that has a \\\"value\\\" field that may change based\\n   * on translations. In the recursive \\\"merge\\\" function below, we can remove <option>\\n   * elements from <select> elements, which could cause the value attribute to change\\n   * as the option is removed. This will need to be restored.\\n   *\\n   * @type {Map<Node, string>}\\n   */\\n  const nodeValues = new Map();\\n  for (const select of element.querySelectorAll(\\\"select\\\")) {\\n    nodeValues.set(select, select.value);\\n  }\\n\\n  const firstChild = translationsDocument.body?.firstChild;\\n  if (firstChild) {\\n    merge(element, firstChild);\\n  }\\n\\n  // Restore the <select> values.\\n  if (element.tagName === \\\"SELECT\\\") {\\n    /** @type {HTMLSelectElement} */ (element).value =\\n      nodeValues.get(element) ?? \\\"\\\";\\n  }\\n  for (const select of element.querySelectorAll(\\\"select\\\")) {\\n    select.value = nodeValues.get(select);\\n  }\\n\\n  /**\\n   * Merge the live tree with the translated tree by re-using elements from the live tree.\\n   *\\n   * @param {Element} liveTree\\n   * @param {Node} translatedTree\\n   */\\n  function merge(liveTree, translatedTree) {\\n    /** @type {Map<string, Element>} */\\n    const liveElementsById = new Map();\\n\\n    /** @type {Array<Text>} */\\n    const liveTextNodes = [];\\n\\n    // Remove all the nodes from the liveTree, and categorize them by Text node or\\n    // Element node.\\n    /** @type {Node | null} */\\n    let node;\\n    while ((node = liveTree.firstChild)) {\\n      // This is a ChildNode with the `remove` method.\\n      const childNode = /** @type {ChildNode} */ (\\n        /** @type {unknown} */ (node)\\n      );\\n      childNode.remove();\\n\\n      const childElement = asElement(node);\\n      const childTextNode = asTextNode(node);\\n      const dataset = getDataset(childElement);\\n      if (childElement && dataset) {\\n        liveElementsById.set(dataset.mozTranslationsId, childElement);\\n      } else if (childTextNode) {\\n        liveTextNodes.push(childTextNode);\\n      }\\n    }\\n\\n    // The translated tree dictates the order.\\n\\n    /** @type {Node[]} */\\n    const translatedNodes = [];\\n    for (const childNode of translatedTree.childNodes) {\\n      if (childNode) {\\n        translatedNodes.push(childNode);\\n      }\\n    }\\n\\n    for (\\n      let translatedIndex = 0;\\n      translatedIndex < translatedNodes.length;\\n      translatedIndex++\\n    ) {\\n      const translatedNode = ensureExists(translatedNodes[translatedIndex]);\\n      const translatedTextNode = asTextNode(translatedNode);\\n      const translatedElement = asElement(translatedNode);\\n      const dataset = getDataset(translatedElement);\\n\\n      if (translatedTextNode) {\\n        // Copy the translated text to the original Text node and re-append it.\\n        let liveTextNode = liveTextNodes.shift();\\n\\n        if (liveTextNode) {\\n          liveTextNode.data = translatedTextNode.data;\\n        } else {\\n          liveTextNode = translatedTextNode;\\n        }\\n\\n        liveTree.appendChild(liveTextNode);\\n      } else if (dataset) {\\n        const liveElementId = dataset.mozTranslationsId;\\n        // Element nodes try to use the already existing DOM nodes.\\n\\n        // Find the element in the live tree that matches the one in the translated tree.\\n        let liveElement = liveElementsById.get(liveElementId);\\n\\n        if (!liveElement) {\\n          lazy.console.warn(\\\"Could not find a corresponding live element\\\", {\\n            path: createNodePath(translatedNode, translationsDocument.body),\\n            liveElementId,\\n            liveElementsById,\\n            translatedNode,\\n          });\\n          continue;\\n        }\\n\\n        // Has this element already been added to the list? Then duplicate it and re-add\\n        // it as a clone. The Translations Engine can sometimes duplicate HTML.\\n        if (liveElement.parentNode) {\\n          liveElement = ensureExists(\\n            asElement(liveElement.cloneNode(true /* deep clone */))\\n          );\\n          clonedNodes.add(liveElementId);\\n          lazy.console.warn(\\n            \\\"Cloning a node because it was already inserted earlier\\\",\\n            {\\n              path: createNodePath(translatedNode, translationsDocument.body),\\n              translatedNode,\\n              liveElement,\\n            }\\n          );\\n        }\\n\\n        if (isNodeTextEmpty(translatedNode) && !isNodeTextEmpty(liveElement)) {\\n          // The translated node has no text, but the original node does have text, so we should investigate.\\n          //\\n          // Note that it is perfectly fine if both the translated node and original node do not have text.\\n          // This occurs when attributes are translated on the node, but no text content was translated.\\n          //\\n          // However, since we have a case where the original node has text and the translated node does not,\\n          // this scenario may be caused by one of two situations:\\n          //\\n          //   1) The element was duplicated by translation but then not given text\\n          //      content. This happens on Wikipedia articles for example.\\n          //\\n          //   2) The translator messed up and could not translate the text. This\\n          //      happens on YouTube in the language selector. In that case, having the\\n          //      original text is much better than no text at all.\\n          //\\n          // To make sure it is case 1) and not case 2), check whether this is the only occurrence.\\n          for (let i = 0; i < translatedNodes.length; i++) {\\n            if (translatedIndex === i) {\\n              // This is the current node, not a sibling.\\n              continue;\\n            }\\n            const sibling = translatedNodes[i];\\n            const siblingDataset = getDataset(asElement(sibling));\\n            if (\\n              // Only consider other element nodes.\\n              sibling.nodeType === Node.ELEMENT_NODE &&\\n              // If the sibling's mozTranslationsId matches, then use the sibling's\\n              // node instead.\\n              liveElementId === siblingDataset?.mozTranslationsId\\n            ) {\\n              // This is case 1 from above. Remove this element's original text nodes,\\n              // since a sibling text node now has all of the text nodes.\\n              removeTextNodes(liveElement);\\n            }\\n          }\\n\\n          // Report this issue to the console.\\n          lazy.console.warn(\\n            \\\"The translated element has no text even though the original did.\\\",\\n            {\\n              path: createNodePath(translatedNode, translationsDocument.body),\\n              translatedNode,\\n              liveElement,\\n            }\\n          );\\n        } else if (!isNodeTextEmpty(liveElement)) {\\n          // There are still text nodes to find and update, recursively merge.\\n          merge(liveElement, translatedNode);\\n        }\\n\\n        // Put the live node back in the live branch. But now t has been synced with the\\n        // translated text and order.\\n        liveTree.appendChild(liveElement);\\n      }\\n    }\\n\\n    const unhandledElements = [...liveElementsById].filter(\\n      ([, liveElement]) => !liveElement.parentNode\\n    );\\n\\n    for (node of liveTree.querySelectorAll(\\\"*\\\")) {\\n      const dataset = getDataset(asElement(node));\\n      if (dataset) {\\n        // Clean-up the live element ids.\\n        delete dataset.mozTranslationsId;\\n      }\\n    }\\n\\n    if (unhandledElements.length) {\\n      lazy.console.warn(\\n        `${createNodePath(\\n          translatedTree,\\n          translationsDocument.body\\n        )} Not all nodes unified`,\\n        {\\n          unhandledElements,\\n          clonedNodes,\\n          originalHTML,\\n          translatedContent: translationsDocument.body?.innerHTML,\\n          liveTree: liveTree.outerHTML,\\n          translatedTree: asElement(translatedTree)?.outerHTML,\\n        }\\n      );\\n    }\\n  }\\n}\\n\\n/**\\n * For debug purposes, compute a string path to an element.\\n *\\n * e.g. \\\"div/div#header/p.bold.string/a\\\"\\n *\\n * @param {Node} node\\n * @param {HTMLElement | null} [root]\\n *\\n * @returns {string}\\n */\\nfunction createNodePath(node, root) {\\n  let path = \\\"\\\";\\n  if (!node.ownerDocument) {\\n    return path;\\n  }\\n  if (root === null) {\\n    root = node.ownerDocument.body;\\n  }\\n  if (node.parentNode && node.parentNode !== root) {\\n    path = createNodePath(node.parentNode, root);\\n  }\\n  path += `/${node.nodeName}`;\\n\\n  const element = asElement(node);\\n  if (element) {\\n    if (element.id) {\\n      path += `#${element.id}`;\\n    } else if (element.className) {\\n      for (const className of element.classList) {\\n        path += \\\".\\\" + className;\\n      }\\n    }\\n  }\\n  return path;\\n}\\n\\n/**\\n * Returns true if the content of this node's text is empty, otherwise false.\\n *\\n * @param {Node} node\\n *\\n * @returns {boolean}\\n */\\nfunction isNodeTextEmpty(node) {\\n  const htmlElement = asHTMLElement(node);\\n  if (htmlElement) {\\n    return htmlElement.innerText.trim().length === 0;\\n  }\\n  if (node.nodeType === Node.TEXT_NODE && node.nodeValue) {\\n    return node.nodeValue.trim().length === 0;\\n  }\\n  return true;\\n}\\n\\n/**\\n * Recursively removes text nodes from the given element and all of its children.\\n *\\n * @param {Node} node\\n */\\nfunction removeTextNodes(node) {\\n  for (const child of node.childNodes) {\\n    switch (child?.nodeType) {\\n      case Node.TEXT_NODE: {\\n        node.removeChild(child);\\n        break;\\n      }\\n      case Node.ELEMENT_NODE: {\\n        removeTextNodes(child);\\n        break;\\n      }\\n      default: {\\n        break;\\n      }\\n    }\\n  }\\n}\\n\\n/**\\n * Test whether any of the direct child text nodes of are non-whitespace text nodes.\\n *\\n * For example:\\n *   - `<p>test</p>`: yes\\n *   - `<p> </p>`: no\\n *   - `<p><b>test</b></p>`: no\\n *\\n * @param {Node} node\\n *\\n * @returns {boolean}\\n */\\nfunction hasNonWhitespaceTextNodes(node) {\\n  if (node.nodeType !== Node.ELEMENT_NODE) {\\n    // Only check element nodes.\\n    return false;\\n  }\\n\\n  for (const child of node.childNodes) {\\n    const textNode = asTextNode(child);\\n    if (textNode) {\\n      if (!textNode.textContent?.trim()) {\\n        // This is just whitespace.\\n        continue;\\n      }\\n      // A text node with content was found.\\n      return true;\\n    }\\n  }\\n\\n  // No text nodes were found.\\n  return false;\\n}\\n\\n/**\\n * Like `#isExcludedNode` but looks at the full subtree. Used to see whether\\n * we can submit a subtree, or whether we should split it into smaller\\n * branches first to try to exclude more of the non-translatable content.\\n *\\n * @param {Node} node\\n * @param {string} excludedNodeSelector\\n *\\n * @returns {boolean}\\n */\\nfunction containsExcludedNode(node, excludedNodeSelector) {\\n  return Boolean(asElement(node)?.querySelector(excludedNodeSelector));\\n}\\n\\n/**\\n *\\n * Check if this node or its parent's node is already included in the given Map or Set.\\n *\\n * @param {Node} node\\n * @param { Map<Node, Set<Node>> } map\\n *\\n * @returns {boolean}\\n */\\nfunction nodeOrParentIncludesItself(node, map) {\\n  if (map.size === 0) {\\n    return false;\\n  }\\n\\n  if (map.get(node)?.has(node)) {\\n    return true;\\n  }\\n\\n  // If the immediate parent is the body, it is allowed.\\n  if (node.parentNode === node.ownerDocument?.body) {\\n    return false;\\n  }\\n\\n  // Accessing the parentNode is expensive here according to performance profiling. This\\n  // is due to XrayWrappers. Minimize reading attributes by storing a reference to the\\n  // `parentNode` in a named variable, rather than re-accessing it.\\n\\n  /** @type {Node | null} */\\n  let parentNode;\\n  let lastNode = node;\\n  while ((parentNode = lastNode.parentNode)) {\\n    if (map.get(parentNode)?.has(parentNode)) {\\n      return true;\\n    }\\n    lastNode = parentNode;\\n  }\\n\\n  return false;\\n}\\n\\n/**\\n * Reads the elements computed style and determines if the element is a block-like\\n * element or not. Every element that lays out like a block should be sent in as one\\n * cohesive unit to be translated.\\n *\\n * @param {Node} node\\n *\\n * @returns {boolean}\\n */\\nfunction getIsBlockLike(node) {\\n  const element = asElement(node);\\n  if (!element) {\\n    return false;\\n  }\\n\\n  const { ownerGlobal } = element;\\n  if (!ownerGlobal) {\\n    return false;\\n  }\\n\\n  if (element.namespaceURI === \\\"http://www.w3.org/2000/svg\\\") {\\n    // SVG elements will report as inline, but there is no block layout in SVG.\\n    // Treat every SVG element as being block so that every node will be subdivided.\\n    return true;\\n  }\\n\\n  /** @type {Record<string, string>} */\\n  // @ts-expect-error - This is a workaround for the CSSStyleDeclaration not being indexable.\\n  const style = ownerGlobal.getComputedStyle(element) ?? { display: null };\\n\\n  return style.display !== \\\"inline\\\" && style.display !== \\\"none\\\";\\n}\\n\\n/**\\n * Determine if this element is an inline element or a block element. Inline elements\\n * should be sent as a contiguous chunk of text, while block elements should be further\\n * subdivided before sending them in for translation.\\n *\\n * @param {Node} node\\n *\\n * @returns {boolean}\\n */\\nfunction nodeNeedsSubdividing(node) {\\n  const element = asElement(node);\\n  if (!element) {\\n    // Only elements need to be further subdivided.\\n    return false;\\n  }\\n\\n  for (let childNode of element.childNodes) {\\n    if (!childNode) {\\n      continue;\\n    }\\n    switch (childNode.nodeType) {\\n      case Node.TEXT_NODE: {\\n        // Keep checking for more inline or text nodes.\\n        continue;\\n      }\\n      case Node.ELEMENT_NODE: {\\n        if (getIsBlockLike(childNode)) {\\n          // This node is a block node, so it needs further subdividing.\\n          return true;\\n        } else if (nodeNeedsSubdividing(childNode)) {\\n          // This non-block-like node may contain other block-like nodes.\\n          return true;\\n        }\\n\\n        // Keep checking for more inline or text nodes.\\n        continue;\\n      }\\n      default: {\\n        return true;\\n      }\\n    }\\n  }\\n  return false;\\n}\\n\\n/**\\n * Returns an iterator of a node's ancestors.\\n *\\n * @param {Node} node\\n *\\n * @returns {Generator<Node>}\\n */\\nfunction* getAncestorsIterator(node) {\\n  const document = node.ownerDocument;\\n  if (!document) {\\n    return;\\n  }\\n  for (\\n    let parent = node.parentNode;\\n    parent && parent !== document.documentElement;\\n    parent = parent.parentNode\\n  ) {\\n    yield parent;\\n  }\\n}\\n\\n/**\\n * Determines whether an attribute on a given element is translatable based on the specified\\n * criteria for TRANSLATABLE_ATTRIBUTES.\\n *\\n * @see TRANSLATABLE_ATTRIBUTES\\n *\\n * @param {Node} node - The DOM node on which the attribute is being checked.\\n * @param {string} attribute - The attribute name to check for translatability.\\n *\\n * @returns {boolean}\\n */\\nfunction isAttributeTranslatable(node, attribute) {\\n  const element = asHTMLElement(node);\\n  if (!element) {\\n    return false;\\n  }\\n\\n  if (!element.hasAttribute(attribute)) {\\n    // The element does not have this attribute, so there is nothing to translate.\\n    return false;\\n  }\\n\\n  if (!TRANSLATABLE_ATTRIBUTES.has(attribute)) {\\n    // The attribute is not listed in our translatable attributes, so we will not translate it.\\n    return false;\\n  }\\n\\n  const criteria = TRANSLATABLE_ATTRIBUTES.get(attribute);\\n\\n  if (!criteria) {\\n    // There are no further criteria specified for this attribute, so we translate this attribute for all elements.\\n    return true;\\n  }\\n\\n  // There are further criteria specified, so attempt to find a matching criterion for the given element.\\n  return criteria.some(({ tagName, conditions }) => {\\n    if (tagName !== element.tagName) {\\n      // The tagName does not match the given element. Try the next criterion.\\n      return false;\\n    }\\n\\n    if (!conditions) {\\n      // The tagName matches and there are no further conditions, so we always translate this attribute for this element.\\n      return true;\\n    }\\n\\n    // The tagName matches, but further conditions are specified. Attempt to find a matching condition.\\n    return Object.entries(conditions).some(([key, values]) =>\\n      values.some(value => element.getAttribute(key) === value)\\n    );\\n  });\\n}\\n\\n/**\\n * Returns true if the node is dead or detached from the DOM, otherwise false if the nod is still live.\\n *\\n * @param {Node} node\\n *\\n * @returns {boolean}\\n */\\nfunction isNodeDetached(node) {\\n  return (\\n    // This node is out of the DOM and already garbage collected.\\n    Cu.isDeadWrapper(node) ||\\n    // The node is detached, but not yet garbage collected,\\n    // or it has been re-parented to a parent that itself is not connected.\\n    !node.isConnected ||\\n    // Normally you could just check `node.parentElement` to see if an element is\\n    // part of the DOM, but the Chrome-only flattenedTreeParentNode is used to include\\n    // Shadow DOM elements, which have a null parentElement.\\n    !node.flattenedTreeParentNode\\n  );\\n}\\n\\n/**\\n * Use TypeScript to determine if the Node is an Element.\\n *\\n * @param {Node | null | undefined} node\\n *\\n * @returns {Element | null}\\n */\\nfunction asElement(node) {\\n  if (node?.nodeType === Node.ELEMENT_NODE) {\\n    return /** @type {HTMLElement} */ (node);\\n  }\\n  return null;\\n}\\n\\n/**\\n * Use TypeScript to determine if the Node is an Element.\\n *\\n * @param {Node | null} node\\n *\\n * @returns {Text | null}\\n */\\nfunction asTextNode(node) {\\n  if (node?.nodeType === Node.TEXT_NODE) {\\n    return /** @type {Text} */ (node);\\n  }\\n  return null;\\n}\\n\\n/**\\n * Use TypeScript to determine if the Node is an HTMLElement.\\n *\\n * @param {Node | null} node\\n *\\n * @returns {HTMLElement | null}\\n */\\nfunction asHTMLElement(node) {\\n  // This is a chrome-only function, and is the recommended function for chrome\\n  // contexts. The TranslationsDocument could be used in non-chrome contexts in the\\n  // future, so ensure that this doesn't break future implementations.\\n  //\\n  // See - https://firefox-source-docs.mozilla.org/code-quality/lint/linters/eslint-plugin-mozilla/rules/use-isInstance.html\\n  if (HTMLElement.isInstance) {\\n    if (HTMLElement.isInstance(node)) {\\n      return /** @type {HTMLElement} */ (node);\\n    }\\n  } else if (\\n    // eslint-disable-next-line mozilla/use-isInstance\\n    node instanceof HTMLElement\\n  ) {\\n    return /** @type {HTMLElement} */ (node);\\n  }\\n  return null;\\n}\\n\\n/**\\n * @template T\\n * @param {T | null | undefined} item\\n *\\n * @returns {T}\\n */\\nfunction ensureExists(item, message = \\\"Item did not exist\\\") {\\n  if (item === null || item === undefined) {\\n    throw new Error(message);\\n  }\\n  return item;\\n}\\n\\n/**\\n * Get the ShadowRoot from the chrome-only openOrClosedShadowRoot API.\\n *\\n * @param {Node} node\\n *\\n * @returns {ShadowRoot | null}\\n */\\nfunction getShadowRoot(node) {\\n  return asElement(node)?.openOrClosedShadowRoot ?? null;\\n}\\n\\n/**\\n * Workaround the Gecko DOM TypeScript definition for dataset.\\n *\\n * @param {Element | null | undefined} element\\n *\\n * @returns {Record<string, string> | null}\\n */\\nfunction getDataset(element) {\\n  // @ts-expect-error Type 'DOMStringMap' is not assignable to type 'Record<string, string>'.\\n  return element?.dataset ?? null;\\n}\\n\\n/**\\n * Removes any data-moz-translations-id values from a node and its children.\\n *\\n * @param {Node} node\\n */\\nfunction removeMozTranslationsIds(node) {\\n  const element = asHTMLElement(node);\\n\\n  if (!element) {\\n    return;\\n  }\\n\\n  if (isNodeDetached(element)) {\\n    return;\\n  }\\n\\n  const dataset = getDataset(element);\\n\\n  if (dataset) {\\n    delete dataset.mozTranslationsId;\\n  }\\n\\n  for (const childNode of element.querySelectorAll(\\n    \\\"[data-moz-translations-id]\\\"\\n  )) {\\n    delete childNode.dataset.mozTranslationsId;\\n  }\\n}\\n\\n/**\\n * Removes the entry pertaining to the inner key of a nested map structure,\\n * ensuring that if the inner structure becomes empty, then the outer key\\n * will also be removed from the outer structure.\\n *\\n * @typedef {Element} OuterKey\\n * @typedef {Node | string} InnerKey\\n * @typedef {number} Value\\n *\\n * @param {Map<OuterKey, (Set<InnerKey> | Map<InnerKey, Value>)>} outerMap\\n * @param {OuterKey} outerKey\\n * @param {InnerKey} innerKey\\n *\\n * @returns {{ didDeleteOuterEntry: boolean, didDeleteInnerEntry: boolean }}\\n */\\nfunction deleteFromNestedMap(outerMap, outerKey, innerKey) {\\n  const innerStructure = outerMap.get(outerKey);\\n\\n  const didDeleteInnerEntry =\\n    !!innerStructure && innerStructure.delete(innerKey);\\n\\n  const didDeleteOuterEntry = !innerStructure || innerStructure.size === 0;\\n\\n  if (didDeleteOuterEntry) {\\n    // The inner structure is now empty after removing the inner-key entry.\\n    // Ensure that the inner structure itself is removed from the outer map.\\n    outerMap.delete(outerKey);\\n  }\\n\\n  return { didDeleteOuterEntry, didDeleteInnerEntry };\\n}\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/translations-document.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-engine.sys.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-engine.sys.mjs ***!
  \************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"/* This Source Code Form is subject to the terms of the Mozilla Public\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\n\\n/**\\n * This file lives in the translation engine's process and is in charge of managing the\\n * lifecycle of the translations engines. This process is a singleton Web Content\\n * process that can be created and destroyed as needed.\\n *\\n * The goal of the code in this file is to be as unprivileged as possible, which should\\n * unlock Bug 1813789, which will make this file fully unprivileged.\\n *\\n * Each translation needs an engine for that specific language pair. This engine is\\n * kept around as long as the CACHE_TIMEOUT_MS, after this if some keepAlive event does\\n * not happen, the engine is destroyed. An engine may be destroyed even when a page is\\n * still open and may need translations in the future. This is handled gracefully by\\n * creating new engines and MessagePorts on the fly.\\n *\\n * The engine communicates directly with the content page via a MessagePort. Each end\\n * of the port is transferred from the parent process to the content process, and this\\n * engine process. This port is transitory, and may be closed at any time. Only when a\\n * translation has been requested once (which is initiated by the parent process) can\\n * the content process re-request translation ports. This ensures a rogue content process\\n * only has the capabilities to perform tasks that the parent process has given it.\\n *\\n * The messaging flow can get a little convoluted to handle all of the correctness cases,\\n * but ideally communication passes through the message port as much as possible. There\\n * are many scenarios such as:\\n *\\n *  - Translation pages becoming idle\\n *  - Tab changing causing \\\"pageshow\\\" and \\\"pagehide\\\" visibility changes\\n *  - Translation actor destruction (this can happen long after the page has been\\n *                                   navigated away from, but is still alive in the\\n *                                   page history)\\n *  - Error states\\n *  - Engine Process being graceful shut down (no engines left)\\n *  - Engine Process being killed by the OS.\\n *\\n * The following is a diagram that attempts to illustrate the structure of the processes\\n * and the communication channels that exist between them.\\n *\\n * ┌─────────────────────────────────────────────────────────────┐\\n * │ PARENT PROCESS                                              │\\n * │                                                             │\\n * │  [TranslationsParent]  ←────→  [TranslationsEngineParent]   │\\n * │                  ↑                                    ↑     │\\n * └──────────────────│────────────────────────────────────│─────┘\\n *                    │ JSWindowActor IPC calls            │ JSProcessActor IPC calls\\n *                    │                                    │\\n * ┌──────────────────│────────┐                     ┌─────│─────────────────────────────┐\\n * │ CONTENT PROCESS  │        │                     │     │    ENGINE PROCESS           │\\n * │                  │        │                     │     ↓                             │\\n * │  [french.html]   │        │                     │ [TranslationsEngineChild]         │\\n * │        ↕         ↓        │                     │            ↕                      │\\n * │  [TranslationsChild]      │                     │ [translations-engine.sys.mjs]     │\\n * │  └──TranslationsDocument  │                     │    ├── \\\"fr to en\\\" engine          │\\n * │     └──port1     « ═══════════ MessageChannel ════ » │   └── port2                  │\\n * │                           │                     │    └── \\\"de to en\\\" engine (idle)   │\\n * └───────────────────────────┘                     └───────────────────────────────────┘\\n */\\n\\n// FIXME: Currently, `translations-engine.sys.mjs` is loaded with the system\\n// principal within the sys.mjs context.\\n//\\n// There is some existing code which exported these methods in a global scope\\n// from when this file was being loaded within a chrome .html document within\\n// the content process, however this code no longer exists.\\n//\\n// This block re-exports various methods from the singleton TranslationsEngine\\n// actor into this scope so they can be called as they were called before the\\n// change to use a ProcessActor.\\n//\\n// In the future, this code could perhaps be modified to run within an\\n// unprivileged Cu.Sandbox, with these specific methods re-exported into the\\n// sandbox scope.\\n\\nconst engineActor = ChromeUtils.domProcessChild.getActor(\\\"TranslationsEngine\\\");\\n\\nconst TE_addProfilerMarker = engineActor.TE_addProfilerMarker.bind(engineActor);\\nconst TE_getLogLevel = engineActor.TE_getLogLevel.bind(engineActor);\\nconst TE_log = engineActor.TE_log.bind(engineActor);\\nconst TE_logError = engineActor.TE_logError.bind(engineActor);\\nconst TE_requestEnginePayload =\\n  engineActor.TE_requestEnginePayload.bind(engineActor);\\nconst TE_reportEnginePerformance =\\n  engineActor.TE_reportEnginePerformance.bind(engineActor);\\nconst TE_reportEngineStatus =\\n  engineActor.TE_reportEngineStatus.bind(engineActor);\\nconst TE_resolveForceShutdown =\\n  engineActor.TE_resolveForceShutdown.bind(engineActor);\\nconst TE_destroyEngineProcess =\\n  engineActor.TE_destroyEngineProcess.bind(engineActor);\\n\\n// How long the cache remains alive between uses, in milliseconds. In automation the\\n// engine is manually created and destroyed to avoid timing issues.\\nconst CACHE_TIMEOUT_MS = 15_000;\\n\\n/**\\n * @typedef {import(\\\"./translations-document.sys.mjs\\\").TranslationsDocument} TranslationsDocument\\n * @typedef {import(\\\"../translations.js\\\").TranslationsEnginePayload} TranslationsEnginePayload\\n * @typedef {import(\\\"../translations.js\\\").LanguagePair} LanguagePair\\n */\\n\\nconst lazy = {};\\nChromeUtils.defineESModuleGetters(lazy, {\\n  clearTimeout: \\\"resource://gre/modules/Timer.sys.mjs\\\",\\n  setTimeout: \\\"resource://gre/modules/Timer.sys.mjs\\\",\\n  TranslationsUtils:\\n    \\\"chrome://global/content/translations/TranslationsUtils.mjs\\\",\\n});\\n\\n/**\\n * The TranslationsEngine encapsulates the logic for translating messages. It can\\n * only be set up for a single language pair. In order to change languages\\n * a new engine should be constructed.\\n *\\n * The actual work for the translations happens in a worker. This class manages\\n * instantiating and messaging the worker.\\n *\\n * Keep unused engines around in the TranslationsEngine.#cachedEngine cache in case\\n * page navigation happens and we can re-use previous engines. The engines are very\\n * heavy-weight, so get rid of them after a timeout. Once all are destroyed the\\n * TranslationsEngineParent is notified that it can be destroyed.\\n */\\nexport class TranslationsEngine {\\n  /**\\n   * Maps a language pair key to a cached engine. Engines are kept around for a timeout\\n   * before they are removed so that they can be re-used during navigation.\\n   *\\n   * @type {Map<string, Promise<TranslationsEngine>>}\\n   */\\n  static #cachedEngines = new Map();\\n\\n  /**\\n   * A DOMParser instance used for parsing HTML strings into DOM objects.\\n   *\\n   * @type {DOMParser}\\n   */\\n  static #domParser = new DOMParser();\\n\\n  /**\\n   * The ID of a timer that keeps the engine alive in the cache.\\n   *\\n   * @see {#cachedEngines}\\n   *\\n   * @type {TimeoutID | null}\\n   */\\n  #keepAliveTimeout = null;\\n\\n  /**\\n   * The Web Worker instance used to handle translation requests.\\n   *\\n   * @type {Worker}\\n   */\\n  #worker;\\n\\n  /**\\n   * Multiple messages can be sent before a response is received. This ID is used to keep\\n   * track of the messages. It is incremented on every use.\\n   *\\n   * @type {number}\\n   */\\n  #messageId = 0;\\n\\n  /**\\n   * The total count of completed translation requests.\\n   *\\n   * @type {number}\\n   */\\n  #totalCompletedRequests = 0;\\n\\n  /**\\n   * The total count of words translated across all requests.\\n   *\\n   * @type {number}\\n   */\\n  #totalTranslatedWords = 0;\\n\\n  /**\\n   * The total milliseconds spent in active translation inference.\\n   *\\n   * @type {number}\\n   */\\n  #totalInferenceMilliseconds = 0;\\n\\n  /**\\n   * A word segmenter instance corresponding to the language of the source text.\\n   *\\n   * @type {Intl.Segmenter | null}\\n   */\\n  #wordSegmenter = null;\\n\\n  /**\\n   * Returns a getter function that will create a translations engine on the first\\n   * call, and then return the cached one. After a timeout when the engine hasn't\\n   * been used, it is destroyed.\\n   *\\n   * @param {LanguagePair} languagePair\\n   * @param {number} innerWindowId\\n   * @returns {Promise<TranslationsEngine>}\\n   */\\n  static getOrCreate(languagePair, innerWindowId) {\\n    const languagePairKey =\\n      lazy.TranslationsUtils.serializeLanguagePair(languagePair);\\n    let enginePromise = TranslationsEngine.#cachedEngines.get(languagePairKey);\\n\\n    if (enginePromise) {\\n      return enginePromise;\\n    }\\n\\n    TE_log(`Creating a new engine for \\\"${languagePairKey}\\\".`);\\n\\n    // A new engine needs to be created.\\n    enginePromise = TranslationsEngine.create(languagePair, innerWindowId);\\n\\n    TranslationsEngine.#cachedEngines.set(languagePairKey, enginePromise);\\n\\n    enginePromise.catch(error => {\\n      TE_logError(\\n        `The engine failed to load for translating \\\"${languagePairKey}\\\". Removing it from the cache.`,\\n        error\\n      );\\n      // Remove the engine if it fails to initialize.\\n      TranslationsEngine.#removeEngineFromCache(languagePairKey);\\n    });\\n\\n    return enginePromise;\\n  }\\n\\n  /**\\n   * Removes the engine, and if it's the last, call the process to destroy itself.\\n   *\\n   * @param {string} languagePairKey\\n   * @param {boolean} force - On forced shutdowns, it's not necessary to notify the\\n   *                          parent process.\\n   */\\n  static #removeEngineFromCache(languagePairKey, force) {\\n    TranslationsEngine.#cachedEngines.delete(languagePairKey);\\n    if (TranslationsEngine.#cachedEngines.size === 0 && !force) {\\n      TE_log(\\\"The last engine was removed, destroying this process.\\\");\\n      TE_destroyEngineProcess();\\n    }\\n  }\\n\\n  /**\\n   * Create a TranslationsEngine and bypass the cache.\\n   *\\n   * @param {LanguagePair} languagePair\\n   * @param {number} innerWindowId\\n   * @returns {Promise<TranslationsEngine>}\\n   */\\n  static async create(languagePair, innerWindowId) {\\n    const startTime = ChromeUtils.now();\\n    if (!languagePair.sourceLanguage || !languagePair.targetLanguage) {\\n      throw new Error(\\n        \\\"Attempt to create Translator with missing language tags.\\\"\\n      );\\n    }\\n\\n    const engine = new TranslationsEngine(\\n      languagePair,\\n      await TE_requestEnginePayload(languagePair)\\n    );\\n\\n    await engine.isReady;\\n\\n    TE_addProfilerMarker({\\n      startTime,\\n      message: `Translations engine loaded for \\\"${lazy.TranslationsUtils.serializeLanguagePair(languagePair)}\\\"`,\\n      innerWindowId,\\n    });\\n\\n    return engine;\\n  }\\n\\n  /**\\n   * Signal to the engines that they are being forced to shutdown.\\n   */\\n  static forceShutdown() {\\n    return Promise.allSettled(\\n      [...TranslationsEngine.#cachedEngines].map(\\n        async ([langPair, enginePromise]) => {\\n          TE_log(`Force shutdown of the engine \\\"${langPair}\\\"`);\\n          const engine = await enginePromise;\\n          engine.terminate(true /* force */);\\n        }\\n      )\\n    );\\n  }\\n\\n  /**\\n   * Terminates the engine and its worker after a timeout.\\n   *\\n   * @param {boolean} force\\n   */\\n  terminate = (force = false) => {\\n    const message = `Terminating translations engine \\\"${this.languagePairKey}\\\".`;\\n\\n    this.#maybeReportEnginePerformance();\\n    TE_addProfilerMarker({ message });\\n    TE_log(message);\\n    this.#worker.terminate();\\n    this.#worker = null;\\n    if (this.#keepAliveTimeout) {\\n      lazy.clearTimeout(this.#keepAliveTimeout);\\n    }\\n    for (const [innerWindowId, data] of ports) {\\n      const { sourceLanguage, targetLanguage, port } = data;\\n      if (\\n        sourceLanguage === this.sourceLanguage &&\\n        targetLanguage === this.targetLanguage\\n      ) {\\n        // This port is still active but being closed.\\n        ports.delete(innerWindowId);\\n        port.postMessage({ type: \\\"TranslationsPort:EngineTerminated\\\" });\\n        port.close();\\n      }\\n    }\\n    TranslationsEngine.#removeEngineFromCache(this.languagePairKey, force);\\n  };\\n\\n  /**\\n   * The worker needs to be shutdown after some amount of time of not being used.\\n   */\\n  keepAlive() {\\n    if (this.#keepAliveTimeout) {\\n      // Clear any previous timeout.\\n      lazy.clearTimeout(this.#keepAliveTimeout);\\n    }\\n    // In automated tests, the engine is manually destroyed.\\n    if (!Cu.isInAutomation) {\\n      this.#keepAliveTimeout = lazy.setTimeout(\\n        this.terminate,\\n        CACHE_TIMEOUT_MS\\n      );\\n    }\\n  }\\n\\n  /**\\n   * Reports this engine's performance metrics to telemetry if it\\n   * has completed at least one successful translation request.\\n   */\\n  #maybeReportEnginePerformance() {\\n    if (!this.#totalCompletedRequests) {\\n      // This engine did not translate any requests to completion.\\n      // There is nothing to report.\\n      return;\\n    }\\n\\n    const { sourceLanguage, targetLanguage } = this.languagePair;\\n\\n    TE_reportEnginePerformance({\\n      sourceLanguage,\\n      targetLanguage,\\n      totalInferenceSeconds: this.#totalInferenceMilliseconds / 1000,\\n      totalTranslatedWords: this.#totalTranslatedWords,\\n      totalCompletedRequests: this.#totalCompletedRequests,\\n    });\\n  }\\n\\n  /**\\n   * Construct and initialize the worker.\\n   *\\n   * @param {LanguagePair} languagePair\\n   * @param {TranslationsEnginePayload} enginePayload - If there is no engine payload\\n   *   then the engine will be mocked. This allows this class to be used in tests.\\n   */\\n  constructor(languagePair, enginePayload) {\\n    /** @type {LanguagePair} */\\n    this.languagePair = languagePair;\\n    this.languagePairKey =\\n      lazy.TranslationsUtils.serializeLanguagePair(languagePair);\\n\\n    this.#worker = new Worker(\\n      \\\"chrome://global/content/translations/translations-engine.worker.js\\\"\\n    );\\n\\n    /** @type {Promise<void>} */\\n    this.isReady = new Promise((resolve, reject) => {\\n      const onMessage = ({ data }) => {\\n        TE_log(\\\"Received initialization message\\\", data);\\n        if (data.type === \\\"initialization-success\\\") {\\n          resolve();\\n        } else if (data.type === \\\"initialization-error\\\") {\\n          reject(data.error);\\n        }\\n        this.#worker.removeEventListener(\\\"message\\\", onMessage);\\n      };\\n      this.#worker.addEventListener(\\\"message\\\", onMessage);\\n\\n      try {\\n        this.#wordSegmenter = new Intl.Segmenter(this.sourceLanguage, {\\n          granularity: \\\"word\\\",\\n        });\\n      } catch (error) {\\n        reject(error);\\n      }\\n\\n      // Schedule the first timeout for keeping the engine alive.\\n      this.keepAlive();\\n    });\\n\\n    // Make sure the ArrayBuffers are transferred, not cloned.\\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects\\n    const transferables = [];\\n    if (enginePayload) {\\n      transferables.push(enginePayload.bergamotWasmArrayBuffer);\\n\\n      for (const translationModelPayload of enginePayload.translationModelPayloads) {\\n        const { languageModelFiles } = translationModelPayload;\\n        for (const { buffer } of Object.values(languageModelFiles)) {\\n          transferables.push(buffer);\\n        }\\n      }\\n    }\\n\\n    const { sourceLanguage, targetLanguage } = languagePair;\\n    this.#worker.postMessage(\\n      {\\n        type: \\\"initialize\\\",\\n        sourceLanguage,\\n        targetLanguage,\\n        enginePayload,\\n        messageId: this.#messageId++,\\n        logLevel: TE_getLogLevel(),\\n      },\\n      transferables\\n    );\\n  }\\n\\n  /**\\n   * Counts the number of words in the given source text.\\n   *\\n   * @param {string} sourceText - The text to be counted.\\n   * @param {boolean} isHTML - Whether to parse the text as HTML.\\n   * @returns {number} - The total count of word-like segments in the text.\\n   */\\n  #countWords(sourceText, isHTML) {\\n    if (isHTML) {\\n      sourceText = TranslationsEngine.#domParser.parseFromString(\\n        sourceText,\\n        \\\"text/html\\\"\\n      ).documentElement.textContent;\\n    }\\n\\n    let wordCount = 0;\\n    for (const { isWordLike } of this.#wordSegmenter.segment(sourceText)) {\\n      if (isWordLike) {\\n        wordCount += 1;\\n      }\\n    }\\n\\n    return wordCount;\\n  }\\n\\n  /**\\n   * The implementation for translation. Use translateText or translateHTML for the\\n   * public API.\\n   *\\n   * @param {string} sourceText\\n   * @param {boolean} isHTML\\n   * @param {number} innerWindowId\\n   * @param {number} translationId\\n   * @returns {Promise<string>}\\n   *   A promise that resolves with the translated text.\\n   */\\n  translate(sourceText, isHTML, innerWindowId, translationId) {\\n    this.keepAlive();\\n\\n    const messageId = this.#messageId++;\\n\\n    return new Promise((resolve, reject) => {\\n      const onMessage = ({ data }) => {\\n        if (\\n          data.type === \\\"translations-discarded\\\" &&\\n          data.innerWindowId === innerWindowId\\n        ) {\\n          // The page was unloaded, and we no longer need to listen for a response.\\n          this.#worker.removeEventListener(\\\"message\\\", onMessage);\\n          return;\\n        }\\n\\n        if (data.messageId !== messageId) {\\n          // Multiple translation requests can be sent before a response is received.\\n          // Ensure that the response received here is the correct one.\\n          return;\\n        }\\n\\n        if (data.type === \\\"translation-response\\\") {\\n          // Also keep the translation alive after getting a result, as many translations\\n          // can queue up at once, and then it can take minutes to resolve them all.\\n          this.keepAlive();\\n\\n          const { targetText, inferenceMilliseconds } = data;\\n\\n          resolve(targetText);\\n\\n          const sourceTextWordCount = this.#countWords(sourceText, isHTML);\\n          this.#totalInferenceMilliseconds += inferenceMilliseconds;\\n          this.#totalTranslatedWords += sourceTextWordCount;\\n          this.#totalCompletedRequests += 1;\\n        }\\n        if (data.type === \\\"translation-error\\\") {\\n          reject(data.error);\\n        }\\n        this.#worker.removeEventListener(\\\"message\\\", onMessage);\\n      };\\n\\n      this.#worker.addEventListener(\\\"message\\\", onMessage);\\n\\n      this.#worker.postMessage({\\n        type: \\\"translation-request\\\",\\n        isHTML,\\n        sourceText,\\n        messageId,\\n        translationId,\\n        innerWindowId,\\n      });\\n    });\\n  }\\n\\n  /**\\n   * Applies a function only if a cached engine exists.\\n   *\\n   * @param {LanguagePair} languagePair\\n   * @param {(engine: TranslationsEngine) => void} fn\\n   */\\n  static withCachedEngine(languagePair, fn) {\\n    const engine = TranslationsEngine.#cachedEngines.get(\\n      lazy.TranslationsUtils.serializeLanguagePair(languagePair)\\n    );\\n\\n    if (engine) {\\n      engine.then(fn).catch(() => {});\\n    }\\n  }\\n\\n  /**\\n   * Stop processing the translation queue. All in-progress messages will be discarded.\\n   *\\n   * @param {number} innerWindowId\\n   */\\n  discardTranslationQueue(innerWindowId) {\\n    this.#worker.postMessage({\\n      type: \\\"discard-translation-queue\\\",\\n      innerWindowId,\\n    });\\n  }\\n\\n  /**\\n   * Cancel a single translation.\\n   *\\n   * @param {number} innerWindowId\\n   * @param {id} translationId\\n   */\\n  cancelSingleTranslation(innerWindowId, translationId) {\\n    this.#worker.postMessage({\\n      type: \\\"cancel-single-translation\\\",\\n      innerWindowId,\\n      translationId,\\n    });\\n  }\\n}\\n\\n/**\\n * Maps the innerWindowId to the port.\\n *\\n * @type {Map<number, {\\n *  languagePair: LanguagePair,\\n *  port: MessagePort\\n * }>}\\n */\\nconst ports = new Map();\\n\\n/**\\n * Listen to the port to the content process for incoming messages, and pass\\n * them to the TranslationsEngine manager. The other end of the port is held\\n * in the content process by the TranslationsDocument.\\n *\\n * @param {LanguagePair} languagePair\\n * @param {number} innerWindowId\\n * @param {MessagePort} port\\n */\\nfunction listenForPortMessages(languagePair, innerWindowId, port) {\\n    console.log(\\\"[dbg][issam][translations-engine.sys.mjs] ---- listenForPortMessages\\\", { languagePair, innerWindowId, port });\\n  async function handleMessage({ data }) {\\n    console.log(\\\"[dbg][issam][translations-engine.sys.mjs] ---- listenForPortMessages\\\", data);\\n\\n    switch (data.type) {\\n      case \\\"TranslationsPort:GetEngineStatusRequest\\\": {\\n        // This message gets sent first before the translation queue is processed.\\n        // The engine is most likely to fail on the initial invocation. Any failure\\n        // past the first one is not reported to the UI.\\n        TranslationsEngine.getOrCreate(languagePair, innerWindowId).then(\\n          () => {\\n            TE_log(\\\"The engine is ready for translations.\\\", {\\n              innerWindowId,\\n            });\\n            TE_reportEngineStatus(innerWindowId, \\\"ready\\\");\\n            port.postMessage({\\n              type: \\\"TranslationsPort:GetEngineStatusResponse\\\",\\n              status: \\\"ready\\\",\\n            });\\n          },\\n          error => {\\n            console.error(error);\\n            TE_reportEngineStatus(innerWindowId, \\\"error\\\");\\n            port.postMessage({\\n              type: \\\"TranslationsPort:GetEngineStatusResponse\\\",\\n              status: \\\"error\\\",\\n              error: String(error),\\n            });\\n            // After an error no more translation requests will be sent. Go ahead\\n            // and close the port.\\n            port.close();\\n            ports.delete(innerWindowId);\\n          }\\n        );\\n        break;\\n      }\\n      case \\\"TranslationsPort:Passthrough\\\": {\\n        const { translationId } = data;\\n\\n        port.postMessage({\\n          type: \\\"TranslationsPort:TranslationResponse\\\",\\n          translationId,\\n          targetText: null,\\n        });\\n\\n        TE_addProfilerMarker({\\n          innerWindowId,\\n          type: \\\"Passthrough\\\",\\n          message: `Handled passthrough translation`,\\n        });\\n\\n        break;\\n      }\\n      case \\\"TranslationsPort:CachedTranslation\\\": {\\n        const { cachedTranslation, translationId } = data;\\n        port.postMessage({\\n          type: \\\"TranslationsPort:TranslationResponse\\\",\\n          translationId,\\n          targetText: cachedTranslation,\\n        });\\n\\n        TE_addProfilerMarker({\\n          innerWindowId,\\n          type: \\\"Cached\\\",\\n          message: `Handled cached translation of ${cachedTranslation.length} code units`,\\n        });\\n\\n        break;\\n      }\\n      case \\\"TranslationsPort:TranslationRequest\\\": {\\n        const { sourceText, isHTML, translationId } = data;\\n\\n        const engine = await TranslationsEngine.getOrCreate(\\n          languagePair,\\n          innerWindowId\\n        );\\n\\n        TE_addProfilerMarker({\\n          innerWindowId,\\n          type: \\\"Request\\\",\\n          message: `Handled translation request of ${sourceText.length} code units`,\\n        });\\n\\n        const targetText = await engine.translate(\\n          sourceText,\\n          isHTML,\\n          innerWindowId,\\n          translationId\\n        );\\n\\n        port.postMessage({\\n          type: \\\"TranslationsPort:TranslationResponse\\\",\\n          translationId,\\n          targetText,\\n        });\\n\\n        break;\\n      }\\n      case \\\"TranslationsPort:CancelSingleTranslation\\\": {\\n        const { translationId } = data;\\n        TranslationsEngine.withCachedEngine(languagePair, engine => {\\n          engine.cancelSingleTranslation(innerWindowId, translationId);\\n        });\\n\\n        TE_addProfilerMarker({\\n          innerWindowId,\\n          type: \\\"Cancel\\\",\\n          message: `Cancelled request for translationId ${translationId}`,\\n        });\\n        break;\\n      }\\n      case \\\"TranslationsPort:DiscardTranslations\\\": {\\n        discardTranslations(innerWindowId);\\n        TE_addProfilerMarker({\\n          innerWindowId,\\n          type: \\\"Discard\\\",\\n          message: `Discarded all active translation requests`,\\n        });\\n        break;\\n      }\\n      default:\\n        TE_logError(\\\"Unknown translations port message: \\\" + data.type);\\n        break;\\n    }\\n  }\\n\\n  if (port.onmessage) {\\n    TE_logError(\\n      new Error(\\\"The MessagePort onmessage handler was already present.\\\")\\n    );\\n  }\\n\\n  port.onmessage = event => {\\n    handleMessage(event).catch(error => TE_logError(error));\\n  };\\n}\\n\\n/**\\n * Discards the queue and removes the port.\\n *\\n * @param {number} innerWindowId\\n */\\nfunction discardTranslations(innerWindowId) {\\n  TE_log(\\\"Discarding translations, innerWindowId:\\\", innerWindowId);\\n\\n  const portData = ports.get(innerWindowId);\\n  if (portData) {\\n    const { port, languagePair } = portData;\\n    port.close();\\n    ports.delete(innerWindowId);\\n\\n    TranslationsEngine.withCachedEngine(languagePair, engine => {\\n      engine.discardTranslationQueue(innerWindowId);\\n    });\\n  }\\n}\\n\\n/**\\n * Listen for events coming from the TranslationsEngine actor.\\n */\\nexport function handleActorMessage(data) {\\n  switch (data.type) {\\n    case \\\"StartTranslation\\\": {\\n      const { languagePair, innerWindowId, port } = data;\\n\\n      TE_log(\\n        \\\"Starting translation\\\",\\n        lazy.TranslationsUtils.serializeLanguagePair(languagePair),\\n        innerWindowId\\n      );\\n      listenForPortMessages(languagePair, innerWindowId, port);\\n      console.log(\\\"[dbg][issam][translations-engine.sys.mjs] ---- handleActorMessage StartTranslation\\\");\\n      console.log(\\\"[dbg][issam][translations-engine.sys.mjs] ---- handleActorMessage StartTranslation\\\", innerWindowId);\\n      ports.set(innerWindowId, { port, languagePair });\\n      console.log(\\\"[dbg][issam][translations-engine.sys.mjs] ---- handleActorMessage StartTranslation\\\", [...ports]);\\n      break;\\n    }\\n    case \\\"DiscardTranslations\\\": {\\n      const { innerWindowId } = data;\\n      discardTranslations(innerWindowId);\\n      break;\\n    }\\n    case \\\"ForceShutdown\\\": {\\n      TranslationsEngine.forceShutdown().then(() => {\\n        TE_resolveForceShutdown();\\n      });\\n      break;\\n    }\\n    default:\\n      throw new Error(\\\"Unknown TranslationsEngineChromeToContent event.\\\");\\n  }\\n}\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/translations-engine.sys.mjs?./node_modules/raw-loader/index.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/worker-loader/dist/cjs.js??ruleSet[1].rules[1].use[0]!./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[1].use[1]!./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js":
/*!********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./node_modules/worker-loader/dist/cjs.js??ruleSet[1].rules[1].use[0]!./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[1].use[1]!./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js ***!
  \********************************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = \"\\nvar worker = require(\\\"!!../../../../node_modules/worker-loader/dist/runtime/inline.js\\\");\\n\\nmodule.exports = function Worker_fn() {\\n  return worker(\\\"/*\\\\n * ATTENTION: The \\\\\\\"eval\\\\\\\" devtool has been used (maybe by default in mode: \\\\\\\"development\\\\\\\").\\\\n * This devtool is neither made for production nor for readable output files.\\\\n * It uses \\\\\\\"eval()\\\\\\\" calls to create a separate source file in the browser devtools.\\\\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\\\\n * or disable the default devtool with \\\\\\\"devtool: false\\\\\\\".\\\\n * If you are looking for production-ready output files, see mode: \\\\\\\"production\\\\\\\" (https://webpack.js.org/configuration/mode/).\\\\n */\\\\n/******/ (() => { // webpackBootstrap\\\\n/******/ \\\\tvar __webpack_modules__ = ({\\\\n\\\\n/***/ \\\\\\\"./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[1].use[1]!./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js\\\\\\\":\\\\n/*!************************************************************************************************************************************************!*\\\\\\\\\\\\n  !*** ./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[1].use[1]!./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js ***!\\\\n  \\\\\\\\************************************************************************************************************************************************/\\\\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {\\\\n\\\\n\\\\\\\"use strict\\\\\\\";\\\\neval(\\\\\\\"/* This Source Code Form is subject to the terms of the Mozilla Public\\\\\\\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\\\\\\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\\\\\\\n\\\\\\\\n\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * @typedef {import(\\\\\\\\\\\\\\\"../translations\\\\\\\\\\\\\\\").Bergamot} Bergamot\\\\\\\\n * @typedef {import(\\\\\\\\\\\\\\\"../translations\\\\\\\\\\\\\\\").TranslationModelPayload} TranslationModelPayload\\\\\\\\n * @typedef {import(\\\\\\\\\\\\\\\"../translations\\\\\\\\\\\\\\\").LanguageTranslationModelFiles} LanguageTranslationModelFiles\\\\\\\\n */\\\\\\\\n\\\\\\\\n/* global loadBergamot */\\\\\\\\n__webpack_require__(/*! script-loader!./bergamot-translator.js */ \\\\\\\\\\\\\\\"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n// TODO(Issam): tmp fix should be in shims file.\\\\\\\\nconst ChromeUtils = {\\\\\\\\n  addProfilerMarker: () => {},\\\\\\\\n  now: () => performance.now()\\\\\\\\n};\\\\\\\\n\\\\\\\\n// Respect the preference \\\\\\\\\\\\\\\"browser.translations.logLevel\\\\\\\\\\\\\\\".\\\\\\\\nlet _loggingLevel = \\\\\\\\\\\\\\\"Error\\\\\\\\\\\\\\\";\\\\\\\\nfunction log(...args) {\\\\\\\\n  if (_loggingLevel !== \\\\\\\\\\\\\\\"Error\\\\\\\\\\\\\\\" && _loggingLevel !== \\\\\\\\\\\\\\\"Warn\\\\\\\\\\\\\\\") {\\\\\\\\n    console.log(\\\\\\\\\\\\\\\"Translations:\\\\\\\\\\\\\\\", ...args);\\\\\\\\n  }\\\\\\\\n}\\\\\\\\nfunction trace(...args) {\\\\\\\\n  if (_loggingLevel === \\\\\\\\\\\\\\\"Trace\\\\\\\\\\\\\\\" || _loggingLevel === \\\\\\\\\\\\\\\"All\\\\\\\\\\\\\\\") {\\\\\\\\n    console.log(\\\\\\\\\\\\\\\"Translations:\\\\\\\\\\\\\\\", ...args);\\\\\\\\n  }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Throw Promise rejection errors so that they are visible in the console.\\\\\\\\nself.addEventListener(\\\\\\\\\\\\\\\"unhandledrejection\\\\\\\\\\\\\\\", event => {\\\\\\\\n  throw event.reason;\\\\\\\\n});\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * The alignment for each file type, file type strings should be same as in the\\\\\\\\n * model registry.\\\\\\\\n */\\\\\\\\nconst MODEL_FILE_ALIGNMENTS = {\\\\\\\\n  model: 256,\\\\\\\\n  lex: 64,\\\\\\\\n  vocab: 64,\\\\\\\\n  qualityModel: 64,\\\\\\\\n  srcvocab: 64,\\\\\\\\n  trgvocab: 64\\\\\\\\n};\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * This regex matches the whitespace before and after a text, so that it is preserved.\\\\\\\\n */\\\\\\\\nconst WHITESPACE_REGEX = /^(\\\\\\\\\\\\\\\\s*)(.*?)(\\\\\\\\\\\\\\\\s*)$/s;\\\\\\\\n//                                         /s  Include newlines in .*\\\\\\\\n//                         (^^^)     (^^^)     Match the whitespace at the beginning and end.\\\\\\\\n//                              (^^^)          Non-greedily match the text (including newlines).\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * At the time of writing, the Intl.Segmenter has a less-than-ideal segmentation pattern when\\\\\\\\n * a Left Double Quotation Mark (U+201C) is preceded by a full-width punctuation mark, in which\\\\\\\\n * it fails to segment the quotation mark with the sentence it logically belongs to.\\\\\\\\n *\\\\\\\\n * Example Source Text:\\\\\\\\n *   - 这是第一句话。“这是第二句话。”\\\\\\\\n *\\\\\\\\n * Expected Segmentation:\\\\\\\\n *   - Object { index: 0, segment: 这是第一句话。 }\\\\\\\\n *   - Object { index: 7, segment: “这是第二句话。” }\\\\\\\\n *\\\\\\\\n * Actual Segmentation:\\\\\\\\n *   - Object { index: 0, segment: 这是第一句话。“ }\\\\\\\\n *   - Object { index: 8, segment: 这是第二句话。” }\\\\\\\\n *\\\\\\\\n * By inserting a space between the full-width punctuation and the Left Double Quotation Mark,\\\\\\\\n * we can trick the segmenter into breaking the sentence at the correct location.\\\\\\\\n *\\\\\\\\n * This code may be able to be removed with further upstream improvements to Intl.Segmenter.\\\\\\\\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter\\\\\\\\n */\\\\\\\\nconst FULL_WIDTH_PUNCTUATION_REGEX = /([。！？])“/g;\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * A list of languages that utilize full-width punctuation as described by the regex above.\\\\\\\\n * https://www.unicode.org/charts/PDF/U3000.pdf\\\\\\\\n *\\\\\\\\n * @see {FULL_WIDTH_PUNCTUATION_REGEX}\\\\\\\\n */\\\\\\\\nconst FULL_WIDTH_PUNCTUATION_LANGUAGE_TAGS = [\\\\\\\\\\\\\\\"ja\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ko\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"zh\\\\\\\\\\\\\\\"];\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Do any cleaning steps for the text that are required before sending it into\\\\\\\\n * the translation engine.\\\\\\\\n *\\\\\\\\n * @param {string} sourceLanguage - The BCP-47 language tag for the source language.\\\\\\\\n * @param {string} sourceText - The source text to be cleaned.\\\\\\\\n * @returns {{ whitespaceBefore: string, whitespaceAfter: string, cleanedSourceText: string }}\\\\\\\\n */\\\\\\\\nfunction cleanText(sourceLanguage, sourceText) {\\\\\\\\n  // Whitespace at the beginning or end can confuse translations, but can affect the\\\\\\\\n  // presentation of the final result.\\\\\\\\n  const result = WHITESPACE_REGEX.exec(sourceText);\\\\\\\\n  if (!result) {\\\\\\\\n    throw new Error(\\\\\\\\\\\\\\\"The whitespace regex should always return a result.\\\\\\\\\\\\\\\");\\\\\\\\n  }\\\\\\\\n  const whitespaceBefore = result[1];\\\\\\\\n  const whitespaceAfter = result[3];\\\\\\\\n  let cleanedSourceText = result[2];\\\\\\\\n\\\\\\\\n  // Remove any soft hyphens, as they will break tokenization.\\\\\\\\n  cleanedSourceText = cleanedSourceText.replaceAll(\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\u00AD\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\");\\\\\\\\n  if (FULL_WIDTH_PUNCTUATION_LANGUAGE_TAGS.includes(sourceLanguage)) {\\\\\\\\n    // Add a space to full-width punctuation when it precedes a Left Double Quotation Mark\\\\\\\\n    // (U+201C) to trick the Intl.Segmenter algorithm into breaking a sentence there.\\\\\\\\n    /** @see {FULL_WIDTH_PUNCTUATION_REGEX} for a detailed description. */\\\\\\\\n    cleanedSourceText = cleanedSourceText.replaceAll(FULL_WIDTH_PUNCTUATION_REGEX, \\\\\\\\\\\\\\\"$1 “\\\\\\\\\\\\\\\");\\\\\\\\n  }\\\\\\\\n  return {\\\\\\\\n    whitespaceBefore,\\\\\\\\n    whitespaceAfter,\\\\\\\\n    cleanedSourceText\\\\\\\\n  };\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Initialize the engine, and get it ready to handle translation requests.\\\\\\\\n * The \\\\\\\\\\\\\\\"initialize\\\\\\\\\\\\\\\" message must be received before any other message handling\\\\\\\\n * requests will be processed.\\\\\\\\n */\\\\\\\\naddEventListener(\\\\\\\\\\\\\\\"message\\\\\\\\\\\\\\\", handleInitializationMessage);\\\\\\\\nasync function handleInitializationMessage({\\\\\\\\n  data\\\\\\\\n}) {\\\\\\\\n  const startTime = ChromeUtils.now();\\\\\\\\n  if (data.type !== \\\\\\\\\\\\\\\"initialize\\\\\\\\\\\\\\\") {\\\\\\\\n    console.error(\\\\\\\\\\\\\\\"The TranslationEngine worker received a message before it was initialized.\\\\\\\\\\\\\\\");\\\\\\\\n    return;\\\\\\\\n  }\\\\\\\\n  try {\\\\\\\\n    const {\\\\\\\\n      sourceLanguage,\\\\\\\\n      targetLanguage,\\\\\\\\n      enginePayload,\\\\\\\\n      logLevel,\\\\\\\\n      innerWindowId\\\\\\\\n    } = data;\\\\\\\\n    if (!sourceLanguage) {\\\\\\\\n      throw new Error('Worker initialization missing \\\\\\\\\\\\\\\"sourceLanguage\\\\\\\\\\\\\\\"');\\\\\\\\n    }\\\\\\\\n    if (!targetLanguage) {\\\\\\\\n      throw new Error('Worker initialization missing \\\\\\\\\\\\\\\"targetLanguage\\\\\\\\\\\\\\\"');\\\\\\\\n    }\\\\\\\\n    if (logLevel) {\\\\\\\\n      // Respect the \\\\\\\\\\\\\\\"browser.translations.logLevel\\\\\\\\\\\\\\\" preference.\\\\\\\\n      _loggingLevel = logLevel;\\\\\\\\n    }\\\\\\\\n    let engine;\\\\\\\\n    if (enginePayload.isMocked) {\\\\\\\\n      // The engine is testing mode, and no Bergamot wasm is available.\\\\\\\\n      engine = new MockedEngine(sourceLanguage, targetLanguage);\\\\\\\\n    } else {\\\\\\\\n      const {\\\\\\\\n        bergamotWasmArrayBuffer,\\\\\\\\n        translationModelPayloads\\\\\\\\n      } = enginePayload;\\\\\\\\n      const bergamot = await BergamotUtils.initializeWasm(bergamotWasmArrayBuffer);\\\\\\\\n      engine = new Engine(sourceLanguage, targetLanguage, bergamot, translationModelPayloads);\\\\\\\\n\\\\\\\\n      // Ensure that no memory is leaked by transfering the ArrayBuffers. They should\\\\\\\\n      // all be loaded into Wasm memory at this time. The emscripten generated code\\\\\\\\n      // appears to retain the Wasm ArrayBuffer. The transfer creates a new JS object\\\\\\\\n      // that gains ownership of the original buffer, allowing it to be GCed even\\\\\\\\n      // if the original ArrayBuffer object is retained.\\\\\\\\n      //\\\\\\\\n      // There is no evidence the language model files are retained, but this will\\\\\\\\n      // absolutely ensure we don't leak this large files.\\\\\\\\n      bergamotWasmArrayBuffer.transfer();\\\\\\\\n      for (const {\\\\\\\\n        languageModelFiles\\\\\\\\n      } of translationModelPayloads) {\\\\\\\\n        for (const file of Object.values(languageModelFiles)) {\\\\\\\\n          file.buffer.transfer();\\\\\\\\n        }\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    ChromeUtils.addProfilerMarker(\\\\\\\\\\\\\\\"TranslationsWorker\\\\\\\\\\\\\\\", {\\\\\\\\n      startTime,\\\\\\\\n      innerWindowId\\\\\\\\n    }, \\\\\\\\\\\\\\\"Translations engine loaded.\\\\\\\\\\\\\\\");\\\\\\\\n    handleMessages(engine);\\\\\\\\n    postMessage({\\\\\\\\n      type: \\\\\\\\\\\\\\\"initialization-success\\\\\\\\\\\\\\\"\\\\\\\\n    });\\\\\\\\n  } catch (error) {\\\\\\\\n    console.error(error);\\\\\\\\n    postMessage({\\\\\\\\n      type: \\\\\\\\\\\\\\\"initialization-error\\\\\\\\\\\\\\\",\\\\\\\\n      error: error?.message\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n  removeEventListener(\\\\\\\\\\\\\\\"message\\\\\\\\\\\\\\\", handleInitializationMessage);\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Sets up the message handling for the worker.\\\\\\\\n *\\\\\\\\n * @param {Engine | MockedEngine} engine\\\\\\\\n */\\\\\\\\nfunction handleMessages(engine) {\\\\\\\\n  let discardPromise;\\\\\\\\n  addEventListener(\\\\\\\\\\\\\\\"message\\\\\\\\\\\\\\\", async ({\\\\\\\\n    data\\\\\\\\n  }) => {\\\\\\\\n    try {\\\\\\\\n      if (data.type === \\\\\\\\\\\\\\\"initialize\\\\\\\\\\\\\\\") {\\\\\\\\n        throw new Error(\\\\\\\\\\\\\\\"The Translations engine must not be re-initialized.\\\\\\\\\\\\\\\");\\\\\\\\n      }\\\\\\\\n      if (data.type === \\\\\\\\\\\\\\\"translation-request\\\\\\\\\\\\\\\") {\\\\\\\\n        // Only show these messages when \\\\\\\\\\\\\\\"All\\\\\\\\\\\\\\\" logging is on, since there are so many\\\\\\\\n        // of them.\\\\\\\\n        trace(\\\\\\\\\\\\\\\"Received message\\\\\\\\\\\\\\\", data);\\\\\\\\n      } else {\\\\\\\\n        log(\\\\\\\\\\\\\\\"Received message\\\\\\\\\\\\\\\", data);\\\\\\\\n      }\\\\\\\\n      switch (data.type) {\\\\\\\\n        case \\\\\\\\\\\\\\\"translation-request\\\\\\\\\\\\\\\":\\\\\\\\n          {\\\\\\\\n            const {\\\\\\\\n              sourceText,\\\\\\\\n              messageId,\\\\\\\\n              translationId,\\\\\\\\n              isHTML,\\\\\\\\n              innerWindowId\\\\\\\\n            } = data;\\\\\\\\n            if (discardPromise) {\\\\\\\\n              // Wait for messages to be discarded if there are any.\\\\\\\\n              await discardPromise;\\\\\\\\n            }\\\\\\\\n            try {\\\\\\\\n              const {\\\\\\\\n                whitespaceBefore,\\\\\\\\n                whitespaceAfter,\\\\\\\\n                cleanedSourceText\\\\\\\\n              } = cleanText(engine.sourceLanguage, sourceText);\\\\\\\\n\\\\\\\\n              // Add a translation to the work queue, and when it returns, post the message\\\\\\\\n              // back. The translation may never return if the translations are discarded\\\\\\\\n              // before it have time to be run. In this case this await is just never\\\\\\\\n              // resolved, and the postMessage is never run.\\\\\\\\n              let {\\\\\\\\n                targetText,\\\\\\\\n                inferenceMilliseconds\\\\\\\\n              } = await engine.translate(cleanedSourceText, isHTML, innerWindowId, translationId);\\\\\\\\n\\\\\\\\n              // Ensure the whitespace is retained.\\\\\\\\n              targetText = whitespaceBefore + targetText + whitespaceAfter;\\\\\\\\n\\\\\\\\n              // This logging level can be very verbose and slow, so only do it under the\\\\\\\\n              // \\\\\\\\\\\\\\\"Trace\\\\\\\\\\\\\\\" level, which is the most verbose. Set the logging level to \\\\\\\\\\\\\\\"Info\\\\\\\\\\\\\\\" to avoid\\\\\\\\n              // these, and get all of the other logs.\\\\\\\\n              trace(\\\\\\\\\\\\\\\"Translation complete\\\\\\\\\\\\\\\", {\\\\\\\\n                sourceText,\\\\\\\\n                targetText,\\\\\\\\n                isHTML,\\\\\\\\n                innerWindowId\\\\\\\\n              });\\\\\\\\n              postMessage({\\\\\\\\n                type: \\\\\\\\\\\\\\\"translation-response\\\\\\\\\\\\\\\",\\\\\\\\n                targetText,\\\\\\\\n                inferenceMilliseconds,\\\\\\\\n                translationId,\\\\\\\\n                messageId\\\\\\\\n              });\\\\\\\\n            } catch (error) {\\\\\\\\n              console.error(error);\\\\\\\\n              let message = \\\\\\\\\\\\\\\"An error occurred in the engine worker.\\\\\\\\\\\\\\\";\\\\\\\\n              if (typeof error?.message === \\\\\\\\\\\\\\\"string\\\\\\\\\\\\\\\") {\\\\\\\\n                message = error.message;\\\\\\\\n              }\\\\\\\\n              let stack = \\\\\\\\\\\\\\\"(no stack)\\\\\\\\\\\\\\\";\\\\\\\\n              if (typeof error?.stack === \\\\\\\\\\\\\\\"string\\\\\\\\\\\\\\\") {\\\\\\\\n                stack = error.stack;\\\\\\\\n              }\\\\\\\\n              postMessage({\\\\\\\\n                type: \\\\\\\\\\\\\\\"translation-error\\\\\\\\\\\\\\\",\\\\\\\\n                error: {\\\\\\\\n                  message,\\\\\\\\n                  stack\\\\\\\\n                },\\\\\\\\n                messageId,\\\\\\\\n                innerWindowId\\\\\\\\n              });\\\\\\\\n            }\\\\\\\\n            break;\\\\\\\\n          }\\\\\\\\n        case \\\\\\\\\\\\\\\"discard-translation-queue\\\\\\\\\\\\\\\":\\\\\\\\n          {\\\\\\\\n            ChromeUtils.addProfilerMarker(\\\\\\\\\\\\\\\"TranslationsWorker\\\\\\\\\\\\\\\", {\\\\\\\\n              innerWindowId: data.innerWindowId\\\\\\\\n            }, \\\\\\\\\\\\\\\"Translations discard requested\\\\\\\\\\\\\\\");\\\\\\\\n            discardPromise = engine.discardTranslations(data.innerWindowId);\\\\\\\\n            await discardPromise;\\\\\\\\n            discardPromise = null;\\\\\\\\n\\\\\\\\n            // Signal to the \\\\\\\\\\\\\\\"message\\\\\\\\\\\\\\\" listeners in the main thread to stop listening.\\\\\\\\n            postMessage({\\\\\\\\n              type: \\\\\\\\\\\\\\\"translations-discarded\\\\\\\\\\\\\\\"\\\\\\\\n            });\\\\\\\\n            break;\\\\\\\\n          }\\\\\\\\n        case \\\\\\\\\\\\\\\"cancel-single-translation\\\\\\\\\\\\\\\":\\\\\\\\n          {\\\\\\\\n            engine.discardSingleTranslation(data.innerWindowId, data.translationId);\\\\\\\\n            break;\\\\\\\\n          }\\\\\\\\n        default:\\\\\\\\n          console.warn(\\\\\\\\\\\\\\\"Unknown message type:\\\\\\\\\\\\\\\", data.type);\\\\\\\\n      }\\\\\\\\n    } catch (error) {\\\\\\\\n      // Ensure the unexpected errors are surfaced in the console.\\\\\\\\n      console.error(error);\\\\\\\\n    }\\\\\\\\n  });\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * The Engine is created once for a language pair. The initialization process copies the\\\\\\\\n * ArrayBuffers for the language buffers from JS-managed ArrayBuffers, to aligned\\\\\\\\n * internal memory for the wasm heap.\\\\\\\\n *\\\\\\\\n * After this the ArrayBuffers are discarded and GC'd. This file should be managed\\\\\\\\n * from the TranslationsEngine class on the main thread.\\\\\\\\n *\\\\\\\\n * This class starts listening for messages only after the Bergamot engine has been\\\\\\\\n * fully initialized.\\\\\\\\n */\\\\\\\\nclass Engine {\\\\\\\\n  /**\\\\\\\\n   * @param {string} sourceLanguage\\\\\\\\n   * @param {string} targetLanguage\\\\\\\\n   * @param {Bergamot} bergamot\\\\\\\\n   * @param {Array<TranslationModelPayload>} translationModelPayloads\\\\\\\\n   */\\\\\\\\n  constructor(sourceLanguage, targetLanguage, bergamot, translationModelPayloads) {\\\\\\\\n    /** @type {string} */\\\\\\\\n    this.sourceLanguage = sourceLanguage;\\\\\\\\n    /** @type {string} */\\\\\\\\n    this.targetLanguage = targetLanguage;\\\\\\\\n    /** @type {Bergamot} */\\\\\\\\n    this.bergamot = bergamot;\\\\\\\\n    /** @type {Bergamot[\\\\\\\\\\\\\\\"TranslationModel\\\\\\\\\\\\\\\"][]} */\\\\\\\\n    this.languageTranslationModels = translationModelPayloads.map(translationModelPayload => BergamotUtils.constructSingleTranslationModel(bergamot, translationModelPayload));\\\\\\\\n\\\\\\\\n    /** @type {Bergamot[\\\\\\\\\\\\\\\"BlockingService\\\\\\\\\\\\\\\"]} */\\\\\\\\n    this.translationService = new bergamot.BlockingService({\\\\\\\\n      // Caching is disabled (see https://github.com/mozilla/firefox-translations/issues/288)\\\\\\\\n      cacheSize: 0\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * Run the translation models to perform a batch of message translations. The\\\\\\\\n   * promise is rejected when the sync version of this function throws an error.\\\\\\\\n   * This function creates an async interface over the synchronous translation\\\\\\\\n   * mechanism. This allows other microtasks such as message handling to still work\\\\\\\\n   * even though the translations are CPU-intensive.\\\\\\\\n   *\\\\\\\\n   * @param {string} sourceText\\\\\\\\n   * @param {boolean} isHTML\\\\\\\\n   * @param {number} innerWindowId - This is required\\\\\\\\n   * @param {number} translationId\\\\\\\\n   *\\\\\\\\n   * @returns {Promise<{ targetText: string, inferenceMilliseconds: number }>}\\\\\\\\n   *   Resolves with an object containing the translated text and the inference time in ms.\\\\\\\\n   */\\\\\\\\n  translate(sourceText, isHTML, innerWindowId, translationId) {\\\\\\\\n    return this.#getWorkQueue(innerWindowId).runTask(translationId, () => this.#syncTranslate(sourceText, isHTML, innerWindowId));\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * Map each innerWindowId to its own WorkQueue. This makes it easy to shut down\\\\\\\\n   * an entire queue of work when the page is unloaded.\\\\\\\\n   *\\\\\\\\n   * @type {Map<number, WorkQueue>}\\\\\\\\n   */\\\\\\\\n  #workQueues = new Map();\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * Get or create a `WorkQueue` that is unique to an `innerWindowId`.\\\\\\\\n   *\\\\\\\\n   * @param {number} innerWindowId\\\\\\\\n   * @returns {WorkQueue}\\\\\\\\n   */\\\\\\\\n  #getWorkQueue(innerWindowId) {\\\\\\\\n    let workQueue = this.#workQueues.get(innerWindowId);\\\\\\\\n    if (workQueue) {\\\\\\\\n      return workQueue;\\\\\\\\n    }\\\\\\\\n    workQueue = new WorkQueue(innerWindowId);\\\\\\\\n    this.#workQueues.set(innerWindowId, workQueue);\\\\\\\\n    return workQueue;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * Cancels any in-progress translations by removing the work queue.\\\\\\\\n   *\\\\\\\\n   * @param {number} innerWindowId\\\\\\\\n   */\\\\\\\\n  discardTranslations(innerWindowId) {\\\\\\\\n    let workQueue = this.#workQueues.get(innerWindowId);\\\\\\\\n    if (workQueue) {\\\\\\\\n      workQueue.cancelWork();\\\\\\\\n      this.#workQueues.delete(innerWindowId);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * Cancels any in-progress translations by removing the work queue.\\\\\\\\n   *\\\\\\\\n   * @param {number} innerWindowId\\\\\\\\n   * @param {number} translationId\\\\\\\\n   */\\\\\\\\n  discardSingleTranslation(innerWindowId, translationId) {\\\\\\\\n    const workQueue = this.#workQueues.get(innerWindowId);\\\\\\\\n    if (workQueue) {\\\\\\\\n      trace(\\\\\\\\\\\\\\\"Discarding translation with translationId\\\\\\\\\\\\\\\", translationId);\\\\\\\\n      workQueue.cancelTask(translationId);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * Run the translation models to perform a translation. This\\\\\\\\n   * blocks the worker thread until it is completed.\\\\\\\\n   *\\\\\\\\n   * @param {string} sourceText\\\\\\\\n   * @param {boolean} isHTML\\\\\\\\n   * @param {number} innerWindowId\\\\\\\\n   * @returns {{ targetText: string, inferenceMilliseconds: number }}\\\\\\\\n   *   An object containing the translated text and the inference time (in ms).\\\\\\\\n   */\\\\\\\\n  #syncTranslate(sourceText, isHTML, innerWindowId) {\\\\\\\\n    const startTime = ChromeUtils.now();\\\\\\\\n    let response;\\\\\\\\n    const {\\\\\\\\n      messages,\\\\\\\\n      options\\\\\\\\n    } = BergamotUtils.getTranslationArgs(this.bergamot, sourceText, isHTML);\\\\\\\\n    try {\\\\\\\\n      if (messages.size() === 0) {\\\\\\\\n        return [];\\\\\\\\n      }\\\\\\\\n\\\\\\\\n      /** @type {Bergamot[\\\\\\\\\\\\\\\"VectorResponse\\\\\\\\\\\\\\\"]} */\\\\\\\\n      let responses;\\\\\\\\n      if (this.languageTranslationModels.length === 1) {\\\\\\\\n        responses = this.translationService.translate(this.languageTranslationModels[0], messages, options);\\\\\\\\n      } else if (this.languageTranslationModels.length === 2) {\\\\\\\\n        responses = this.translationService.translateViaPivoting(this.languageTranslationModels[0], this.languageTranslationModels[1], messages, options);\\\\\\\\n      } else {\\\\\\\\n        throw new Error(\\\\\\\\\\\\\\\"Too many models were provided to the translation worker.\\\\\\\\\\\\\\\");\\\\\\\\n      }\\\\\\\\n\\\\\\\\n      // Report on the time it took to do this translation.\\\\\\\\n      ChromeUtils.addProfilerMarker(\\\\\\\\\\\\\\\"TranslationsWorker\\\\\\\\\\\\\\\", {\\\\\\\\n        startTime,\\\\\\\\n        innerWindowId\\\\\\\\n      }, `Translated ${sourceText.length} code units.`);\\\\\\\\n      const endTime = ChromeUtils.now();\\\\\\\\n      const targetText = responses.get(0).getTranslatedText();\\\\\\\\n      return {\\\\\\\\n        targetText,\\\\\\\\n        inferenceMilliseconds: endTime - startTime\\\\\\\\n      };\\\\\\\\n    } finally {\\\\\\\\n      // Free up any memory that was allocated. This will always run.\\\\\\\\n      messages?.delete();\\\\\\\\n      options?.delete();\\\\\\\\n      response?.delete();\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * Static utilities to help work with the Bergamot wasm module.\\\\\\\\n */\\\\\\\\nclass BergamotUtils {\\\\\\\\n  /**\\\\\\\\n   * Construct a single translation model.\\\\\\\\n   *\\\\\\\\n   * @param {Bergamot} bergamot\\\\\\\\n   * @param {TranslationModelPayload} translationModelPayload\\\\\\\\n   * @returns {Bergamot[\\\\\\\\\\\\\\\"TranslationModel\\\\\\\\\\\\\\\"]}\\\\\\\\n   */\\\\\\\\n  static constructSingleTranslationModel(bergamot, translationModelPayload) {\\\\\\\\n    log(`Constructing translation model.`);\\\\\\\\n    const {\\\\\\\\n      sourceLanguage,\\\\\\\\n      targetLanguage,\\\\\\\\n      languageModelFiles\\\\\\\\n    } = translationModelPayload;\\\\\\\\n    const {\\\\\\\\n      model,\\\\\\\\n      lex,\\\\\\\\n      vocab,\\\\\\\\n      qualityModel,\\\\\\\\n      srcvocab,\\\\\\\\n      trgvocab\\\\\\\\n    } = BergamotUtils.allocateModelMemory(bergamot, languageModelFiles);\\\\\\\\n\\\\\\\\n    // Transform the bytes to mb, like \\\\\\\\\\\\\\\"10.2mb\\\\\\\\\\\\\\\"\\\\\\\\n    const getMemory = memory => `${Math.floor(memory.size() / 100_000) / 10}mb`;\\\\\\\\n    let memoryLog = `Model memory sizes in wasm heap:`;\\\\\\\\n    memoryLog += `\\\\\\\\\\\\\\\\n  Model: ${getMemory(model)}`;\\\\\\\\n    if (lex) {\\\\\\\\n      memoryLog += `\\\\\\\\\\\\\\\\n  Shortlist: ${getMemory(lex)}`;\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    // Set up the vocab list, which could either be a single \\\\\\\\\\\\\\\"vocab\\\\\\\\\\\\\\\" model, or a\\\\\\\\n    // \\\\\\\\\\\\\\\"srcvocab\\\\\\\\\\\\\\\" and \\\\\\\\\\\\\\\"trgvocab\\\\\\\\\\\\\\\" pair.\\\\\\\\n    const vocabList = new bergamot.AlignedMemoryList();\\\\\\\\n    if (vocab) {\\\\\\\\n      vocabList.push_back(vocab);\\\\\\\\n      memoryLog += `\\\\\\\\\\\\\\\\n  Vocab: ${getMemory(vocab)}`;\\\\\\\\n    } else if (srcvocab && trgvocab) {\\\\\\\\n      vocabList.push_back(srcvocab);\\\\\\\\n      vocabList.push_back(trgvocab);\\\\\\\\n      memoryLog += `\\\\\\\\\\\\\\\\n  Src Vocab: ${getMemory(srcvocab)}`;\\\\\\\\n      memoryLog += `\\\\\\\\\\\\\\\\n  Trg Vocab: ${getMemory(trgvocab)}`;\\\\\\\\n    } else {\\\\\\\\n      throw new Error(\\\\\\\\\\\\\\\"Vocabulary key is not found.\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n    if (qualityModel) {\\\\\\\\n      memoryLog += `\\\\\\\\\\\\\\\\n  QualityModel: ${getMemory(qualityModel)}\\\\\\\\\\\\\\\\n`;\\\\\\\\n    }\\\\\\\\n    const config = BergamotUtils.generateTextConfig({\\\\\\\\n      \\\\\\\\\\\\\\\"beam-size\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\",\\\\\\\\n      normalize: \\\\\\\\\\\\\\\"1.0\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"word-penalty\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"max-length-break\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"128\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"mini-batch-words\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"1024\\\\\\\\\\\\\\\",\\\\\\\\n      workspace: \\\\\\\\\\\\\\\"128\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"max-length-factor\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"2.0\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"skip-cost\\\\\\\\\\\\\\\": (!qualityModel).toString(),\\\\\\\\n      \\\\\\\\\\\\\\\"cpu-threads\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\",\\\\\\\\n      quiet: \\\\\\\\\\\\\\\"true\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"quiet-translation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"true\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"gemm-precision\\\\\\\\\\\\\\\": languageModelFiles.model.record.name.endsWith(\\\\\\\\\\\\\\\"intgemm8.bin\\\\\\\\\\\\\\\") ? \\\\\\\\\\\\\\\"int8shiftAll\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"int8shiftAlphaAll\\\\\\\\\\\\\\\",\\\\\\\\n      alignment: \\\\\\\\\\\\\\\"soft\\\\\\\\\\\\\\\"\\\\\\\\n    });\\\\\\\\n    log(`Bergamot translation model config: ${config}`);\\\\\\\\n    log(memoryLog);\\\\\\\\n    return new bergamot.TranslationModel(sourceLanguage, targetLanguage, config, model, lex ?? null, vocabList, qualityModel ?? null);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * The models must be placed in aligned memory that the Bergamot wasm module has access\\\\\\\\n   * to. This function copies over the model blobs into this memory space.\\\\\\\\n   *\\\\\\\\n   * @param {Bergamot} bergamot\\\\\\\\n   * @param {LanguageTranslationModelFiles} languageModelFiles\\\\\\\\n   * @returns {LanguageTranslationModelFilesAligned}\\\\\\\\n   */\\\\\\\\n  static allocateModelMemory(bergamot, languageModelFiles) {\\\\\\\\n    /** @type {LanguageTranslationModelFilesAligned} */\\\\\\\\n    const results = {};\\\\\\\\n    for (const [fileType, file] of Object.entries(languageModelFiles)) {\\\\\\\\n      const alignment = MODEL_FILE_ALIGNMENTS[fileType];\\\\\\\\n      if (!alignment) {\\\\\\\\n        throw new Error(`Unknown file type: \\\\\\\\\\\\\\\"${fileType}\\\\\\\\\\\\\\\"`);\\\\\\\\n      }\\\\\\\\n      const alignedMemory = new bergamot.AlignedMemory(file.buffer.byteLength, alignment);\\\\\\\\n      alignedMemory.getByteArrayView().set(new Uint8Array(file.buffer));\\\\\\\\n      results[fileType] = alignedMemory;\\\\\\\\n    }\\\\\\\\n    return results;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * Initialize the Bergamot translation engine. It is a wasm compiled version of the\\\\\\\\n   * Marian translation software. The wasm is delivered remotely to cut down on binary size.\\\\\\\\n   *\\\\\\\\n   * https://github.com/mozilla/bergamot-translator/\\\\\\\\n   *\\\\\\\\n   * @param {ArrayBuffer} wasmBinary\\\\\\\\n   * @returns {Promise<Bergamot>}\\\\\\\\n   */\\\\\\\\n  static initializeWasm(wasmBinary) {\\\\\\\\n    return new Promise((resolve, reject) => {\\\\\\\\n      /** @type {number} */\\\\\\\\n      let start = performance.now();\\\\\\\\n\\\\\\\\n      /** @type {Bergamot} */\\\\\\\\n      const bergamot = loadBergamot({\\\\\\\\n        // Start with 40MiB initial memory. This value is arbitrary, but we have observed\\\\\\\\n        // through performance testing that starting small and allowing the buffer to grow\\\\\\\\n        // results in less memory usage than unintentionally overshooting the initial allocation.\\\\\\\\n        INITIAL_MEMORY: 41_943_040,\\\\\\\\n        print: log,\\\\\\\\n        onAbort() {\\\\\\\\n          reject(new Error(\\\\\\\\\\\\\\\"Error loading Bergamot wasm module.\\\\\\\\\\\\\\\"));\\\\\\\\n        },\\\\\\\\n        onRuntimeInitialized: async () => {\\\\\\\\n          const duration = performance.now() - start;\\\\\\\\n          log(`Bergamot wasm runtime initialized in ${duration / 1000} seconds.`);\\\\\\\\n          // Await at least one microtask so that the captured `bergamot` variable is\\\\\\\\n          // fully initialized.\\\\\\\\n          await Promise.resolve();\\\\\\\\n          resolve(bergamot);\\\\\\\\n        },\\\\\\\\n        wasmBinary\\\\\\\\n      });\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * Maps the Bergamot Vector to a JS array\\\\\\\\n   *\\\\\\\\n   * @param {Bergamot[\\\\\\\\\\\\\\\"Vector\\\\\\\\\\\\\\\"]} vector\\\\\\\\n   * @param {Function} fn\\\\\\\\n   * @returns {Array}\\\\\\\\n   */\\\\\\\\n  static mapVector(vector, fn) {\\\\\\\\n    const result = [];\\\\\\\\n    for (let index = 0; index < vector.size(); index++) {\\\\\\\\n      result.push(fn(vector.get(index), index));\\\\\\\\n    }\\\\\\\\n    return result;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * Generate a config for the Marian translation service. It requires specific whitespace.\\\\\\\\n   *\\\\\\\\n   * https://marian-nmt.github.io/docs/cmd/marian-decoder/\\\\\\\\n   *\\\\\\\\n   * @param {Record<string, string>} config\\\\\\\\n   * @returns {string}\\\\\\\\n   */\\\\\\\\n  static generateTextConfig(config) {\\\\\\\\n    const indent = \\\\\\\\\\\\\\\"            \\\\\\\\\\\\\\\";\\\\\\\\n    let result = \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\";\\\\\\\\n    for (const [key, value] of Object.entries(config)) {\\\\\\\\n      result += `${indent}${key}: ${value}\\\\\\\\\\\\\\\\n`;\\\\\\\\n    }\\\\\\\\n    return result + indent;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * JS objects need to be translated into wasm objects to configure the translation engine.\\\\\\\\n   *\\\\\\\\n   * @param {Bergamot} bergamot\\\\\\\\n   * @param {string} sourceText\\\\\\\\n   * @param {boolean} isHTML\\\\\\\\n   * @returns {{ messages: Bergamot[\\\\\\\\\\\\\\\"VectorString\\\\\\\\\\\\\\\"], options: Bergamot[\\\\\\\\\\\\\\\"VectorResponseOptions\\\\\\\\\\\\\\\"] }}\\\\\\\\n   */\\\\\\\\n  static getTranslationArgs(bergamot, sourceText, isHTML) {\\\\\\\\n    const messages = new bergamot.VectorString();\\\\\\\\n    const options = new bergamot.VectorResponseOptions();\\\\\\\\n\\\\\\\\n    // Empty paragraphs break the translation.\\\\\\\\n    if (sourceText) {\\\\\\\\n      messages.push_back(sourceText);\\\\\\\\n      options.push_back({\\\\\\\\n        qualityScores: false,\\\\\\\\n        alignment: true,\\\\\\\\n        html: isHTML\\\\\\\\n      });\\\\\\\\n    }\\\\\\\\n    return {\\\\\\\\n      messages,\\\\\\\\n      options\\\\\\\\n    };\\\\\\\\n  }\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * For testing purposes, provide a fully mocked engine. This allows for easy integration\\\\\\\\n * testing of the UI, without having to rely on downloading remote models and remote\\\\\\\\n * wasm binaries.\\\\\\\\n */\\\\\\\\nclass MockedEngine {\\\\\\\\n  /**\\\\\\\\n   * @param {string} sourceLanguage\\\\\\\\n   * @param {string} targetLanguage\\\\\\\\n   */\\\\\\\\n  constructor(sourceLanguage, targetLanguage) {\\\\\\\\n    /** @type {string} */\\\\\\\\n    this.sourceLanguage = sourceLanguage;\\\\\\\\n    /** @type {string} */\\\\\\\\n    this.targetLanguage = targetLanguage;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * Create a fake translation of the text, returning a mock object\\\\\\\\n   * with both the translated text and time spent.\\\\\\\\n   *\\\\\\\\n   * @param {string} sourceText\\\\\\\\n   * @param {boolean} isHTML\\\\\\\\n   * @returns {{ targetText: string, inferenceMilliseconds: number }}\\\\\\\\n   *   An object containing the \\\\\\\\\\\\\\\"translated\\\\\\\\\\\\\\\" text and a mock inference time in ms.\\\\\\\\n   */\\\\\\\\n  translate(sourceText, isHTML) {\\\\\\\\n    const startTime = performance.now();\\\\\\\\n\\\\\\\\n    // Note when an HTML translation is requested.\\\\\\\\n    let html = isHTML ? \\\\\\\\\\\\\\\", html\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\";\\\\\\\\n    const targetText = `${sourceText.toUpperCase()} [${this.sourceLanguage} to ${this.targetLanguage}${html}]`;\\\\\\\\n    const endTime = performance.now();\\\\\\\\n    return {\\\\\\\\n      targetText,\\\\\\\\n      inferenceMilliseconds: endTime - startTime\\\\\\\\n    };\\\\\\\\n  }\\\\\\\\n  discardTranslations() {}\\\\\\\\n}\\\\\\\\n\\\\\\\\n/**\\\\\\\\n * This class takes tasks that may block the thread's event loop, and has them yield\\\\\\\\n * after a time budget via setTimeout calls to allow other code to execute.\\\\\\\\n */\\\\\\\\nclass WorkQueue {\\\\\\\\n  #TIME_BUDGET = 100; // ms\\\\\\\\n  #RUN_IMMEDIATELY_COUNT = 20;\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * This is the list of work to be done. While it is a Map, it is treated as a FIFO\\\\\\\\n   * queue, but with work that can be canceled via the translationId.\\\\\\\\n   *\\\\\\\\n   * @type {Map<number, {task: Function, resolve: Function}>}\\\\\\\\n   */\\\\\\\\n  #tasksByTranslationId = new Map();\\\\\\\\n  #isRunning = false;\\\\\\\\n  #isWorkCancelled = false;\\\\\\\\n  #runImmediately = this.#RUN_IMMEDIATELY_COUNT;\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * @param {number} innerWindowId\\\\\\\\n   */\\\\\\\\n  constructor(innerWindowId) {\\\\\\\\n    this.innerWindowId = innerWindowId;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * Run the task and return the result.\\\\\\\\n   *\\\\\\\\n   * @template {any} T\\\\\\\\n   * @param {number} translationId\\\\\\\\n   * @param {() => T} task\\\\\\\\n   * @returns {Promise<T>}\\\\\\\\n   */\\\\\\\\n  runTask(translationId, task) {\\\\\\\\n    if (this.#runImmediately > 0) {\\\\\\\\n      // Run the first N translations immediately, most likely these are the user-visible\\\\\\\\n      // translations on the page, as they are sent in first. The setTimeout of 0 can\\\\\\\\n      // still delay the translations noticeably.\\\\\\\\n      this.#runImmediately--;\\\\\\\\n      return Promise.resolve(task());\\\\\\\\n    }\\\\\\\\n    return new Promise((resolve, reject) => {\\\\\\\\n      this.#tasksByTranslationId.set(translationId, {\\\\\\\\n        task,\\\\\\\\n        resolve,\\\\\\\\n        reject\\\\\\\\n      });\\\\\\\\n      this.#run().catch(error => console.error(error));\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * @param {number} translationId\\\\\\\\n   */\\\\\\\\n  cancelTask(translationId) {\\\\\\\\n    this.#tasksByTranslationId.delete(translationId);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  /**\\\\\\\\n   * The internal run function.\\\\\\\\n   */\\\\\\\\n  async #run() {\\\\\\\\n    if (this.#isRunning) {\\\\\\\\n      // The work queue is already running.\\\\\\\\n      return;\\\\\\\\n    }\\\\\\\\n    this.#isRunning = true;\\\\\\\\n\\\\\\\\n    // Measure the timeout\\\\\\\\n    let lastTimeout = null;\\\\\\\\n    let tasksInBatch = 0;\\\\\\\\n    const addProfilerMarker = () => {\\\\\\\\n      ChromeUtils.addProfilerMarker(\\\\\\\\\\\\\\\"TranslationsWorker WorkQueue\\\\\\\\\\\\\\\", {\\\\\\\\n        startTime: lastTimeout,\\\\\\\\n        innerWindowId: this.innerWindowId\\\\\\\\n      }, `WorkQueue processed ${tasksInBatch} tasks`);\\\\\\\\n    };\\\\\\\\n    while (this.#tasksByTranslationId.size) {\\\\\\\\n      if (this.#isWorkCancelled) {\\\\\\\\n        // The work was already cancelled.\\\\\\\\n        break;\\\\\\\\n      }\\\\\\\\n      const now = ChromeUtils.now();\\\\\\\\n      if (lastTimeout === null) {\\\\\\\\n        lastTimeout = now;\\\\\\\\n        // Allow other work to get on the queue.\\\\\\\\n        await new Promise(resolve => setTimeout(resolve, 0));\\\\\\\\n      } else if (now - lastTimeout > this.#TIME_BUDGET) {\\\\\\\\n        // Perform a timeout with no effective wait. This clears the current\\\\\\\\n        // promise queue from the event loop.\\\\\\\\n        await new Promise(resolve => setTimeout(resolve, 0));\\\\\\\\n        addProfilerMarker();\\\\\\\\n        lastTimeout = ChromeUtils.now();\\\\\\\\n      }\\\\\\\\n\\\\\\\\n      // Check this between every `await`.\\\\\\\\n      if (this.#isWorkCancelled || !this.#tasksByTranslationId.size) {\\\\\\\\n        break;\\\\\\\\n      }\\\\\\\\n      tasksInBatch++;\\\\\\\\n\\\\\\\\n      // Treat the `this.#tasksByTranslationId` Map as a FIFO queue, and take the oldest\\\\\\\\n      // item out by manually using the `entries()` iterator.\\\\\\\\n      const [translationId, taskAndResolvers] = this.#tasksByTranslationId.entries().next().value;\\\\\\\\n      const {\\\\\\\\n        task,\\\\\\\\n        resolve,\\\\\\\\n        reject\\\\\\\\n      } = taskAndResolvers;\\\\\\\\n      this.#tasksByTranslationId.delete(translationId);\\\\\\\\n      try {\\\\\\\\n        const result = await task();\\\\\\\\n\\\\\\\\n        // Check this between every `await`.\\\\\\\\n        if (this.#isWorkCancelled) {\\\\\\\\n          break;\\\\\\\\n        }\\\\\\\\n        // The work is done, resolve the original task.\\\\\\\\n        resolve(result);\\\\\\\\n      } catch (error) {\\\\\\\\n        reject(error);\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    addProfilerMarker();\\\\\\\\n    this.#isRunning = false;\\\\\\\\n  }\\\\\\\\n  async cancelWork() {\\\\\\\\n    this.#isWorkCancelled = true;\\\\\\\\n    this.#tasksByTranslationId = new Map();\\\\\\\\n    await new Promise(resolve => setTimeout(resolve, 0));\\\\\\\\n    this.#isWorkCancelled = false;\\\\\\\\n  }\\\\\\\\n}\\\\\\\\n\\\\\\\\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js?./node_modules/babel-loader/lib/index.js??ruleSet%5B1%5D.rules%5B1%5D.use%5B1%5D\\\\\\\");\\\\n\\\\n/***/ }),\\\\n\\\\n/***/ \\\\\\\"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js\\\\\\\":\\\\n/*!*******************************************************************************************************!*\\\\\\\\\\\\n  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js ***!\\\\n  \\\\\\\\*******************************************************************************************************/\\\\n/***/ ((module) => {\\\\n\\\\neval(\\\\\\\"module.exports = \\\\\\\\\\\\\\\"/* This Source Code Form is subject to the terms of the Mozilla Public\\\\\\\\\\\\\\\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\\\\\\\\\\\\\\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nfunction loadBergamot(Module) {\\\\\\\\\\\\\\\\n  var BERGAMOT_VERSION_FULL = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"v0.6.0+4a6a44c0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n  null;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var Module = typeof Module != \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" ? Module : {};\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var moduleOverrides = Object.assign({}, Module);\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var arguments_ = [];\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var thisProgram = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"./this.program\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var quit_ = (status, toThrow) => {\\\\\\\\\\\\\\\\n    throw toThrow;\\\\\\\\\\\\\\\\n  };\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var ENVIRONMENT_IS_WEB = typeof window == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var ENVIRONMENT_IS_WORKER = typeof importScripts == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var ENVIRONMENT_IS_NODE =\\\\\\\\\\\\\\\\n    typeof process == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" &&\\\\\\\\\\\\\\\\n    typeof process.versions == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" &&\\\\\\\\\\\\\\\\n    typeof process.versions.node == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"string\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var scriptDirectory = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function locateFile(path) {\\\\\\\\\\\\\\\\n    if (Module.locateFile) {\\\\\\\\\\\\\\\\n      return Module.locateFile(path, scriptDirectory);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return scriptDirectory + path;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var read_, readAsync, readBinary, setWindowTitle;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\\\\\\\\\\\\\\\\n    if (ENVIRONMENT_IS_WORKER) {\\\\\\\\\\\\\\\\n      scriptDirectory = self.location.href;\\\\\\\\\\\\\\\\n    } else if (typeof document != \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" && document.currentScript) {\\\\\\\\\\\\\\\\n      scriptDirectory = document.currentScript.src;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (scriptDirectory.indexOf(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"blob:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") !== 0) {\\\\\\\\\\\\\\\\n      scriptDirectory = scriptDirectory.substr(\\\\\\\\\\\\\\\\n        0,\\\\\\\\\\\\\\\\n        scriptDirectory.replace(/[?#].*/, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\").lastIndexOf(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") + 1\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    } else {\\\\\\\\\\\\\\\\n      scriptDirectory = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    {\\\\\\\\\\\\\\\\n      read_ = url => {\\\\\\\\\\\\\\\\n        var xhr = new XMLHttpRequest();\\\\\\\\\\\\\\\\n        xhr.open(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"GET\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", url, false);\\\\\\\\\\\\\\\\n        xhr.send(null);\\\\\\\\\\\\\\\\n        return xhr.responseText;\\\\\\\\\\\\\\\\n      };\\\\\\\\\\\\\\\\n      if (ENVIRONMENT_IS_WORKER) {\\\\\\\\\\\\\\\\n        readBinary = url => {\\\\\\\\\\\\\\\\n          var xhr = new XMLHttpRequest();\\\\\\\\\\\\\\\\n          xhr.open(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"GET\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", url, false);\\\\\\\\\\\\\\\\n          xhr.responseType = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"arraybuffer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n          xhr.send(null);\\\\\\\\\\\\\\\\n          return new Uint8Array(xhr.response);\\\\\\\\\\\\\\\\n        };\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      readAsync = (url, onload, onerror) => {\\\\\\\\\\\\\\\\n        var xhr = new XMLHttpRequest();\\\\\\\\\\\\\\\\n        xhr.open(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"GET\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", url, true);\\\\\\\\\\\\\\\\n        xhr.responseType = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"arraybuffer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n        xhr.onload = () => {\\\\\\\\\\\\\\\\n          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {\\\\\\\\\\\\\\\\n            onload(xhr.response);\\\\\\\\\\\\\\\\n            return;\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n          onerror();\\\\\\\\\\\\\\\\n        };\\\\\\\\\\\\\\\\n        xhr.onerror = onerror;\\\\\\\\\\\\\\\\n        xhr.send(null);\\\\\\\\\\\\\\\\n      };\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    setWindowTitle = title => (document.title = title);\\\\\\\\\\\\\\\\n  } else {\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var out = Module.print || console.log.bind(console);\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var err = Module.printErr || console.warn.bind(console);\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  Object.assign(Module, moduleOverrides);\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  moduleOverrides = null;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  if (Module.arguments) {\\\\\\\\\\\\\\\\n    arguments_ = Module.arguments;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  if (Module.thisProgram) {\\\\\\\\\\\\\\\\n    thisProgram = Module.thisProgram;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  if (Module.quit) {\\\\\\\\\\\\\\\\n    quit_ = Module.quit;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var tempRet0 = 0;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var setTempRet0 = value => {\\\\\\\\\\\\\\\\n    tempRet0 = value;\\\\\\\\\\\\\\\\n  };\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var wasmBinary;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  if (Module.wasmBinary) {\\\\\\\\\\\\\\\\n    wasmBinary = Module.wasmBinary;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var noExitRuntime = Module.noExitRuntime || true;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  if (typeof WebAssembly != \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") {\\\\\\\\\\\\\\\\n    abort(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"no native wasm support detected\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function setValue(ptr, value, type = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i8\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", noSafe) {\\\\\\\\\\\\\\\\n    if (type.charAt(type.length - 1) === \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") {\\\\\\\\\\\\\\\\n      type = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i32\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    switch (type) {\\\\\\\\\\\\\\\\n      case \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\n        HEAP8[ptr >> 0] = value;\\\\\\\\\\\\\\\\n        break;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      case \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i8\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\n        HEAP8[ptr >> 0] = value;\\\\\\\\\\\\\\\\n        break;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      case \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i16\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\n        HEAP16[ptr >> 1] = value;\\\\\\\\\\\\\\\\n        break;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      case \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i32\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\n        HEAP32[ptr >> 2] = value;\\\\\\\\\\\\\\\\n        break;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      case \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i64\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\n        ((tempI64 = [\\\\\\\\\\\\\\\\n          value >>> 0,\\\\\\\\\\\\\\\\n          ((tempDouble = value),\\\\\\\\\\\\\\\\n          +Math.abs(tempDouble) >= 1\\\\\\\\\\\\\\\\n            ? tempDouble > 0\\\\\\\\\\\\\\\\n              ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) |\\\\\\\\\\\\\\\\n                  0) >>>\\\\\\\\\\\\\\\\n                0\\\\\\\\\\\\\\\\n              : ~~+Math.ceil(\\\\\\\\\\\\\\\\n                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296\\\\\\\\\\\\\\\\n                ) >>> 0\\\\\\\\\\\\\\\\n            : 0),\\\\\\\\\\\\\\\\n        ]),\\\\\\\\\\\\\\\\n          (HEAP32[ptr >> 2] = tempI64[0]),\\\\\\\\\\\\\\\\n          (HEAP32[(ptr + 4) >> 2] = tempI64[1]));\\\\\\\\\\\\\\\\n        break;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      case \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"float\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\n        HEAPF32[ptr >> 2] = value;\\\\\\\\\\\\\\\\n        break;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      case \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"double\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\\n        HEAPF64[ptr >> 3] = value;\\\\\\\\\\\\\\\\n        break;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      default:\\\\\\\\\\\\\\\\n        abort(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"invalid type for setValue: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + type);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var wasmMemory;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var ABORT = false;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var EXITSTATUS;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function assert(condition, text) {\\\\\\\\\\\\\\\\n    if (!condition) {\\\\\\\\\\\\\\\\n      abort(text);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var UTF8Decoder =\\\\\\\\\\\\\\\\n    typeof TextDecoder != \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" ? new TextDecoder(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"utf8\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") : undefined;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\\\\\\\\\\\\\\\\n    var endIdx = idx + maxBytesToRead;\\\\\\\\\\\\\\\\n    var endPtr = idx;\\\\\\\\\\\\\\\\n    while (heapOrArray[endPtr] && !(endPtr >= endIdx)) {\\\\\\\\\\\\\\\\n      ++endPtr;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\\\\\\\\\\\\\\\\n      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var str = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    while (idx < endPtr) {\\\\\\\\\\\\\\\\n      var u0 = heapOrArray[idx++];\\\\\\\\\\\\\\\\n      if (!(u0 & 128)) {\\\\\\\\\\\\\\\\n        str += String.fromCharCode(u0);\\\\\\\\\\\\\\\\n        continue;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      var u1 = heapOrArray[idx++] & 63;\\\\\\\\\\\\\\\\n      if ((u0 & 224) == 192) {\\\\\\\\\\\\\\\\n        str += String.fromCharCode(((u0 & 31) << 6) | u1);\\\\\\\\\\\\\\\\n        continue;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      var u2 = heapOrArray[idx++] & 63;\\\\\\\\\\\\\\\\n      if ((u0 & 240) == 224) {\\\\\\\\\\\\\\\\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\\\\\\\\\\\\\\\\n      } else {\\\\\\\\\\\\\\\\n        u0 =\\\\\\\\\\\\\\\\n          ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      if (u0 < 65536) {\\\\\\\\\\\\\\\\n        str += String.fromCharCode(u0);\\\\\\\\\\\\\\\\n      } else {\\\\\\\\\\\\\\\\n        var ch = u0 - 65536;\\\\\\\\\\\\\\\\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    return str;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function UTF8ToString(ptr, maxBytesToRead) {\\\\\\\\\\\\\\\\n    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\\\\\\\\\\\\\\\\n    if (!(maxBytesToWrite > 0)) {\\\\\\\\\\\\\\\\n      return 0;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var startIdx = outIdx;\\\\\\\\\\\\\\\\n    var endIdx = outIdx + maxBytesToWrite - 1;\\\\\\\\\\\\\\\\n    for (var i = 0; i < str.length; ++i) {\\\\\\\\\\\\\\\\n      var u = str.charCodeAt(i);\\\\\\\\\\\\\\\\n      if (u >= 55296 && u <= 57343) {\\\\\\\\\\\\\\\\n        var u1 = str.charCodeAt(++i);\\\\\\\\\\\\\\\\n        u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      if (u <= 127) {\\\\\\\\\\\\\\\\n        if (outIdx >= endIdx) {\\\\\\\\\\\\\\\\n          break;\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        heap[outIdx++] = u;\\\\\\\\\\\\\\\\n      } else if (u <= 2047) {\\\\\\\\\\\\\\\\n        if (outIdx + 1 >= endIdx) {\\\\\\\\\\\\\\\\n          break;\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        heap[outIdx++] = 192 | (u >> 6);\\\\\\\\\\\\\\\\n        heap[outIdx++] = 128 | (u & 63);\\\\\\\\\\\\\\\\n      } else if (u <= 65535) {\\\\\\\\\\\\\\\\n        if (outIdx + 2 >= endIdx) {\\\\\\\\\\\\\\\\n          break;\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        heap[outIdx++] = 224 | (u >> 12);\\\\\\\\\\\\\\\\n        heap[outIdx++] = 128 | ((u >> 6) & 63);\\\\\\\\\\\\\\\\n        heap[outIdx++] = 128 | (u & 63);\\\\\\\\\\\\\\\\n      } else {\\\\\\\\\\\\\\\\n        if (outIdx + 3 >= endIdx) {\\\\\\\\\\\\\\\\n          break;\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        heap[outIdx++] = 240 | (u >> 18);\\\\\\\\\\\\\\\\n        heap[outIdx++] = 128 | ((u >> 12) & 63);\\\\\\\\\\\\\\\\n        heap[outIdx++] = 128 | ((u >> 6) & 63);\\\\\\\\\\\\\\\\n        heap[outIdx++] = 128 | (u & 63);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    heap[outIdx] = 0;\\\\\\\\\\\\\\\\n    return outIdx - startIdx;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function stringToUTF8(str, outPtr, maxBytesToWrite) {\\\\\\\\\\\\\\\\n    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function lengthBytesUTF8(str) {\\\\\\\\\\\\\\\\n    var len = 0;\\\\\\\\\\\\\\\\n    for (var i = 0; i < str.length; ++i) {\\\\\\\\\\\\\\\\n      var u = str.charCodeAt(i);\\\\\\\\\\\\\\\\n      if (u >= 55296 && u <= 57343) {\\\\\\\\\\\\\\\\n        u = (65536 + ((u & 1023) << 10)) | (str.charCodeAt(++i) & 1023);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      if (u <= 127) {\\\\\\\\\\\\\\\\n        ++len;\\\\\\\\\\\\\\\\n      } else if (u <= 2047) {\\\\\\\\\\\\\\\\n        len += 2;\\\\\\\\\\\\\\\\n      } else if (u <= 65535) {\\\\\\\\\\\\\\\\n        len += 3;\\\\\\\\\\\\\\\\n      } else {\\\\\\\\\\\\\\\\n        len += 4;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return len;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var UTF16Decoder =\\\\\\\\\\\\\\\\n    typeof TextDecoder != \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" ? new TextDecoder(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"utf-16le\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") : undefined;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function UTF16ToString(ptr, maxBytesToRead) {\\\\\\\\\\\\\\\\n    var endPtr = ptr;\\\\\\\\\\\\\\\\n    var idx = endPtr >> 1;\\\\\\\\\\\\\\\\n    var maxIdx = idx + maxBytesToRead / 2;\\\\\\\\\\\\\\\\n    while (!(idx >= maxIdx) && HEAPU16[idx]) {\\\\\\\\\\\\\\\\n      ++idx;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    endPtr = idx << 1;\\\\\\\\\\\\\\\\n    if (endPtr - ptr > 32 && UTF16Decoder) {\\\\\\\\\\\\\\\\n      return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var str = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\\\\\\\\\\\\\\\\n      var codeUnit = HEAP16[(ptr + i * 2) >> 1];\\\\\\\\\\\\\\\\n      if (codeUnit == 0) {\\\\\\\\\\\\\\\\n        break;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      str += String.fromCharCode(codeUnit);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return str;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function stringToUTF16(str, outPtr, maxBytesToWrite) {\\\\\\\\\\\\\\\\n    if (maxBytesToWrite === undefined) {\\\\\\\\\\\\\\\\n      maxBytesToWrite = 2147483647;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (maxBytesToWrite < 2) {\\\\\\\\\\\\\\\\n      return 0;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    maxBytesToWrite -= 2;\\\\\\\\\\\\\\\\n    var startPtr = outPtr;\\\\\\\\\\\\\\\\n    var numCharsToWrite =\\\\\\\\\\\\\\\\n      maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\\\\\\\\\\\\\\\\n    for (var i = 0; i < numCharsToWrite; ++i) {\\\\\\\\\\\\\\\\n      var codeUnit = str.charCodeAt(i);\\\\\\\\\\\\\\\\n      HEAP16[outPtr >> 1] = codeUnit;\\\\\\\\\\\\\\\\n      outPtr += 2;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    HEAP16[outPtr >> 1] = 0;\\\\\\\\\\\\\\\\n    return outPtr - startPtr;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function lengthBytesUTF16(str) {\\\\\\\\\\\\\\\\n    return str.length * 2;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function UTF32ToString(ptr, maxBytesToRead) {\\\\\\\\\\\\\\\\n    var i = 0;\\\\\\\\\\\\\\\\n    var str = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    while (!(i >= maxBytesToRead / 4)) {\\\\\\\\\\\\\\\\n      var utf32 = HEAP32[(ptr + i * 4) >> 2];\\\\\\\\\\\\\\\\n      if (utf32 == 0) {\\\\\\\\\\\\\\\\n        break;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      ++i;\\\\\\\\\\\\\\\\n      if (utf32 >= 65536) {\\\\\\\\\\\\\\\\n        var ch = utf32 - 65536;\\\\\\\\\\\\\\\\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\\\\\\\\\\\\\\\\n      } else {\\\\\\\\\\\\\\\\n        str += String.fromCharCode(utf32);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return str;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function stringToUTF32(str, outPtr, maxBytesToWrite) {\\\\\\\\\\\\\\\\n    if (maxBytesToWrite === undefined) {\\\\\\\\\\\\\\\\n      maxBytesToWrite = 2147483647;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (maxBytesToWrite < 4) {\\\\\\\\\\\\\\\\n      return 0;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var startPtr = outPtr;\\\\\\\\\\\\\\\\n    var endPtr = startPtr + maxBytesToWrite - 4;\\\\\\\\\\\\\\\\n    for (var i = 0; i < str.length; ++i) {\\\\\\\\\\\\\\\\n      var codeUnit = str.charCodeAt(i);\\\\\\\\\\\\\\\\n      if (codeUnit >= 55296 && codeUnit <= 57343) {\\\\\\\\\\\\\\\\n        var trailSurrogate = str.charCodeAt(++i);\\\\\\\\\\\\\\\\n        codeUnit =\\\\\\\\\\\\\\\\n          (65536 + ((codeUnit & 1023) << 10)) | (trailSurrogate & 1023);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      HEAP32[outPtr >> 2] = codeUnit;\\\\\\\\\\\\\\\\n      outPtr += 4;\\\\\\\\\\\\\\\\n      if (outPtr + 4 > endPtr) {\\\\\\\\\\\\\\\\n        break;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    HEAP32[outPtr >> 2] = 0;\\\\\\\\\\\\\\\\n    return outPtr - startPtr;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function lengthBytesUTF32(str) {\\\\\\\\\\\\\\\\n    var len = 0;\\\\\\\\\\\\\\\\n    for (var i = 0; i < str.length; ++i) {\\\\\\\\\\\\\\\\n      var codeUnit = str.charCodeAt(i);\\\\\\\\\\\\\\\\n      if (codeUnit >= 55296 && codeUnit <= 57343) {\\\\\\\\\\\\\\\\n        ++i;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      len += 4;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return len;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function allocateUTF8(str) {\\\\\\\\\\\\\\\\n    var size = lengthBytesUTF8(str) + 1;\\\\\\\\\\\\\\\\n    var ret = _malloc(size);\\\\\\\\\\\\\\\\n    if (ret) {\\\\\\\\\\\\\\\\n      stringToUTF8Array(str, HEAP8, ret, size);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return ret;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function writeArrayToMemory(array, buffer) {\\\\\\\\\\\\\\\\n    HEAP8.set(array, buffer);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function writeAsciiToMemory(str, buffer, dontAddNull) {\\\\\\\\\\\\\\\\n    for (var i = 0; i < str.length; ++i) {\\\\\\\\\\\\\\\\n      HEAP8[buffer++ >> 0] = str.charCodeAt(i);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (!dontAddNull) {\\\\\\\\\\\\\\\\n      HEAP8[buffer >> 0] = 0;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function updateGlobalBufferAndViews(buf) {\\\\\\\\\\\\\\\\n    const mb = (buf.byteLength / 1_000_000).toFixed();\\\\\\\\\\\\\\\\n    Module.print(`Growing wasm buffer to ${mb}MB (${buf.byteLength} bytes).`);\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    buffer = buf;\\\\\\\\\\\\\\\\n    Module.HEAP8 = HEAP8 = new Int8Array(buf);\\\\\\\\\\\\\\\\n    Module.HEAP16 = HEAP16 = new Int16Array(buf);\\\\\\\\\\\\\\\\n    Module.HEAP32 = HEAP32 = new Int32Array(buf);\\\\\\\\\\\\\\\\n    Module.HEAPU8 = HEAPU8 = new Uint8Array(buf);\\\\\\\\\\\\\\\\n    Module.HEAPU16 = HEAPU16 = new Uint16Array(buf);\\\\\\\\\\\\\\\\n    Module.HEAPU32 = HEAPU32 = new Uint32Array(buf);\\\\\\\\\\\\\\\\n    Module.HEAPF32 = HEAPF32 = new Float32Array(buf);\\\\\\\\\\\\\\\\n    Module.HEAPF64 = HEAPF64 = new Float64Array(buf);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var INITIAL_MEMORY = Module.INITIAL_MEMORY || 16777216;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  if (Module.wasmMemory) {\\\\\\\\\\\\\\\\n    wasmMemory = Module.wasmMemory;\\\\\\\\\\\\\\\\n  } else {\\\\\\\\\\\\\\\\n    wasmMemory = new WebAssembly.Memory({\\\\\\\\\\\\\\\\n      initial: INITIAL_MEMORY / 65536,\\\\\\\\\\\\\\\\n      maximum: 2147483648 / 65536,\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  if (wasmMemory) {\\\\\\\\\\\\\\\\n    buffer = wasmMemory.buffer;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  INITIAL_MEMORY = buffer.byteLength;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  updateGlobalBufferAndViews(buffer);\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var wasmTable;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var __ATPRERUN__ = [];\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var __ATINIT__ = [];\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var __ATPOSTRUN__ = [];\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var runtimeInitialized = false;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function keepRuntimeAlive() {\\\\\\\\\\\\\\\\n    return noExitRuntime;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function preRun() {\\\\\\\\\\\\\\\\n    if (Module.preRun) {\\\\\\\\\\\\\\\\n      if (typeof Module.preRun == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") {\\\\\\\\\\\\\\\\n        Module.preRun = [Module.preRun];\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      while (Module.preRun.length) {\\\\\\\\\\\\\\\\n        addOnPreRun(Module.preRun.shift());\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    callRuntimeCallbacks(__ATPRERUN__);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function initRuntime() {\\\\\\\\\\\\\\\\n    runtimeInitialized = true;\\\\\\\\\\\\\\\\n    callRuntimeCallbacks(__ATINIT__);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function postRun() {\\\\\\\\\\\\\\\\n    if (Module.postRun) {\\\\\\\\\\\\\\\\n      if (typeof Module.postRun == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") {\\\\\\\\\\\\\\\\n        Module.postRun = [Module.postRun];\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      while (Module.postRun.length) {\\\\\\\\\\\\\\\\n        addOnPostRun(Module.postRun.shift());\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    callRuntimeCallbacks(__ATPOSTRUN__);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function addOnPreRun(cb) {\\\\\\\\\\\\\\\\n    __ATPRERUN__.unshift(cb);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function addOnInit(cb) {\\\\\\\\\\\\\\\\n    __ATINIT__.unshift(cb);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function addOnPostRun(cb) {\\\\\\\\\\\\\\\\n    __ATPOSTRUN__.unshift(cb);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var runDependencies = 0;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var runDependencyWatcher = null;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var dependenciesFulfilled = null;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function addRunDependency(id) {\\\\\\\\\\\\\\\\n    runDependencies++;\\\\\\\\\\\\\\\\n    if (Module.monitorRunDependencies) {\\\\\\\\\\\\\\\\n      Module.monitorRunDependencies(runDependencies);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function removeRunDependency(id) {\\\\\\\\\\\\\\\\n    runDependencies--;\\\\\\\\\\\\\\\\n    if (Module.monitorRunDependencies) {\\\\\\\\\\\\\\\\n      Module.monitorRunDependencies(runDependencies);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (runDependencies == 0) {\\\\\\\\\\\\\\\\n      if (runDependencyWatcher !== null) {\\\\\\\\\\\\\\\\n        clearInterval(runDependencyWatcher);\\\\\\\\\\\\\\\\n        runDependencyWatcher = null;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      if (dependenciesFulfilled) {\\\\\\\\\\\\\\\\n        var callback = dependenciesFulfilled;\\\\\\\\\\\\\\\\n        dependenciesFulfilled = null;\\\\\\\\\\\\\\\\n        callback();\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  Module.preloadedImages = {};\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  Module.preloadedAudios = {};\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function abort(what) {\\\\\\\\\\\\\\\\n    {\\\\\\\\\\\\\\\\n      if (Module.onAbort) {\\\\\\\\\\\\\\\\n        Module.onAbort(what);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    what = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Aborted(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + what + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    err(what);\\\\\\\\\\\\\\\\n    ABORT = true;\\\\\\\\\\\\\\\\n    EXITSTATUS = 1;\\\\\\\\\\\\\\\\n    what += \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\". Build with -s ASSERTIONS=1 for more info.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    var e = new WebAssembly.RuntimeError(what);\\\\\\\\\\\\\\\\n    throw e;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var dataURIPrefix = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"data:application/octet-stream;base64,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function isDataURI(filename) {\\\\\\\\\\\\\\\\n    return filename.startsWith(dataURIPrefix);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var wasmBinaryFile;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  wasmBinaryFile = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"bergamot-translator.wasm\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  if (!isDataURI(wasmBinaryFile)) {\\\\\\\\\\\\\\\\n    wasmBinaryFile = locateFile(wasmBinaryFile);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function getBinary(file) {\\\\\\\\\\\\\\\\n    try {\\\\\\\\\\\\\\\\n      if (file == wasmBinaryFile && wasmBinary) {\\\\\\\\\\\\\\\\n        return new Uint8Array(wasmBinary);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      if (readBinary) {\\\\\\\\\\\\\\\\n        return readBinary(file);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      throw \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"both async and sync fetching of the wasm failed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    } catch (err) {\\\\\\\\\\\\\\\\n      abort(err);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function getBinaryPromise() {\\\\\\\\\\\\\\\\n    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\\\\\\\\\\\\\\\\n      if (typeof fetch == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") {\\\\\\\\\\\\\\\\n        return fetch(wasmBinaryFile, {\\\\\\\\\\\\\\\\n          credentials: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"same-origin\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n        })\\\\\\\\\\\\\\\\n          .then(function (response) {\\\\\\\\\\\\\\\\n            if (!response.ok) {\\\\\\\\\\\\\\\\n              throw (\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"failed to load wasm binary file at '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + wasmBinaryFile + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n              );\\\\\\\\\\\\\\\\n            }\\\\\\\\\\\\\\\\n            return response.arrayBuffer();\\\\\\\\\\\\\\\\n          })\\\\\\\\\\\\\\\\n          .catch(function () {\\\\\\\\\\\\\\\\n            return getBinary(wasmBinaryFile);\\\\\\\\\\\\\\\\n          });\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return Promise.resolve().then(function () {\\\\\\\\\\\\\\\\n      return getBinary(wasmBinaryFile);\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function createWasm() {\\\\\\\\\\\\\\\\n    var info = {\\\\\\\\\\\\\\\\n      env: asmLibraryArg,\\\\\\\\\\\\\\\\n      wasm_gemm: createWasmGemm(),\\\\\\\\\\\\\\\\n      wasi_snapshot_preview1: asmLibraryArg,\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    function receiveInstance(instance, module) {\\\\\\\\\\\\\\\\n      var exports = instance.exports;\\\\\\\\\\\\\\\\n      Module.asm = exports;\\\\\\\\\\\\\\\\n      wasmTable = Module.asm.__indirect_function_table;\\\\\\\\\\\\\\\\n      addOnInit(Module.asm.__wasm_call_ctors);\\\\\\\\\\\\\\\\n      exportAsmFunctions(exports);\\\\\\\\\\\\\\\\n      removeRunDependency(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"wasm-instantiate\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    addRunDependency(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"wasm-instantiate\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    function receiveInstantiationResult(result) {\\\\\\\\\\\\\\\\n      receiveInstance(result.instance);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    function instantiateArrayBuffer(receiver) {\\\\\\\\\\\\\\\\n      // This function has been patched from the original version.\\\\\\\\\\\\\\\\n      // See Bug 1988289.\\\\\\\\\\\\\\\\n      return getBinaryPromise()\\\\\\\\\\\\\\\\n        .then(binary => {\\\\\\\\\\\\\\\\n          const module = new WebAssembly.Module(binary);\\\\\\\\\\\\\\\\n          const instance = new WebAssembly.Instance(module, info);\\\\\\\\\\\\\\\\n          return { module, instance };\\\\\\\\\\\\\\\\n        })\\\\\\\\\\\\\\\\n        .then(function (instance) {\\\\\\\\\\\\\\\\n          return instance;\\\\\\\\\\\\\\\\n        })\\\\\\\\\\\\\\\\n        .then(receiver, function (reason) {\\\\\\\\\\\\\\\\n          err(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"failed to asynchronously prepare wasm: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + reason);\\\\\\\\\\\\\\\\n          abort(reason);\\\\\\\\\\\\\\\\n        });\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    function instantiateAsync() {\\\\\\\\\\\\\\\\n      if (\\\\\\\\\\\\\\\\n        !wasmBinary &&\\\\\\\\\\\\\\\\n        typeof WebAssembly.instantiateStreaming == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" &&\\\\\\\\\\\\\\\\n        !isDataURI(wasmBinaryFile) &&\\\\\\\\\\\\\\\\n        typeof fetch == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n      ) {\\\\\\\\\\\\\\\\n        return fetch(wasmBinaryFile, {\\\\\\\\\\\\\\\\n          credentials: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"same-origin\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n        }).then(function (response) {\\\\\\\\\\\\\\\\n          var result = WebAssembly.instantiateStreaming(response, info);\\\\\\\\\\\\\\\\n          return result.then(receiveInstantiationResult, function (reason) {\\\\\\\\\\\\\\\\n            err(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"wasm streaming compile failed: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + reason);\\\\\\\\\\\\\\\\n            err(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"falling back to ArrayBuffer instantiation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n            return instantiateArrayBuffer(receiveInstantiationResult);\\\\\\\\\\\\\\\\n          });\\\\\\\\\\\\\\\\n        });\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      return instantiateArrayBuffer(receiveInstantiationResult);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (Module.instantiateWasm) {\\\\\\\\\\\\\\\\n      try {\\\\\\\\\\\\\\\\n        var exports = Module.instantiateWasm(info, receiveInstance);\\\\\\\\\\\\\\\\n        return exports;\\\\\\\\\\\\\\\\n      } catch (e) {\\\\\\\\\\\\\\\\n        err(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Module.instantiateWasm callback failed with error: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + e);\\\\\\\\\\\\\\\\n        return false;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    instantiateAsync();\\\\\\\\\\\\\\\\n    return {};\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var tempDouble;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var tempI64;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var ASM_CONSTS = {\\\\\\\\\\\\\\\\n    1427332($0, $1, $2, $3, $4) {\\\\\\\\\\\\\\\\n      if (!Module.getOrCreateSentenceSegmenter) {\\\\\\\\\\\\\\\\n        Module.getOrCreateSentenceSegmenter = (function () {\\\\\\\\\\\\\\\\n          let segmenters = new Map();\\\\\\\\\\\\\\\\n          return function (lang) {\\\\\\\\\\\\\\\\n            let segmenter = segmenters.get(lang);\\\\\\\\\\\\\\\\n            if (!segmenter) {\\\\\\\\\\\\\\\\n              segmenter = new Intl.Segmenter(lang, {\\\\\\\\\\\\\\\\n                granularity: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"sentence\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n              });\\\\\\\\\\\\\\\\n              segmenters.set(lang, segmenter);\\\\\\\\\\\\\\\\n            }\\\\\\\\\\\\\\\\n            return segmenter;\\\\\\\\\\\\\\\\n          };\\\\\\\\\\\\\\\\n        })();\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      const inputUTF16 = UTF8ToString($0);\\\\\\\\\\\\\\\\n      const lang = UTF8ToString($1);\\\\\\\\\\\\\\\\n      const segmenter = Module.getOrCreateSentenceSegmenter(lang);\\\\\\\\\\\\\\\\n      const sentencesUTF16 = Array.from(segmenter.segment(inputUTF16));\\\\\\\\\\\\\\\\n      const sentenceCount = sentencesUTF16.length;\\\\\\\\\\\\\\\\n      const bytesPerInt = 4;\\\\\\\\\\\\\\\\n      const startsPtr = _malloc(sentenceCount * bytesPerInt);\\\\\\\\\\\\\\\\n      const endsPtr = _malloc(sentenceCount * bytesPerInt);\\\\\\\\\\\\\\\\n      if (!startsPtr || !endsPtr) {\\\\\\\\\\\\\\\\n        throw new Error(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Failed to allocate WASM memory for segmentation.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      let sentenceEndUTF8 = 0;\\\\\\\\\\\\\\\\n      sentencesUTF16.forEach(({ segment: sentenceUTF16 }, index) => {\\\\\\\\\\\\\\\\n        const sentenceStartUTF8 = sentenceEndUTF8;\\\\\\\\\\\\\\\\n        sentenceEndUTF8 += lengthBytesUTF8(sentenceUTF16);\\\\\\\\\\\\\\\\n        setValue(startsPtr + index * bytesPerInt, sentenceStartUTF8, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i32\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n        setValue(endsPtr + index * bytesPerInt, sentenceEndUTF8, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i32\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n      });\\\\\\\\\\\\\\\\n      setValue($2, sentenceCount, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i32\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n      setValue($3, startsPtr, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i32\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n      setValue($4, endsPtr, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"i32\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    },\\\\\\\\\\\\\\\\n  };\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function callRuntimeCallbacks(callbacks) {\\\\\\\\\\\\\\\\n    while (callbacks.length) {\\\\\\\\\\\\\\\\n      var callback = callbacks.shift();\\\\\\\\\\\\\\\\n      if (typeof callback == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") {\\\\\\\\\\\\\\\\n        callback(Module);\\\\\\\\\\\\\\\\n        continue;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      var func = callback.func;\\\\\\\\\\\\\\\\n      if (typeof func == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"number\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") {\\\\\\\\\\\\\\\\n        if (callback.arg === undefined) {\\\\\\\\\\\\\\\\n          getWasmTableEntry(func)();\\\\\\\\\\\\\\\\n        } else {\\\\\\\\\\\\\\\\n          getWasmTableEntry(func)(callback.arg);\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n      } else {\\\\\\\\\\\\\\\\n        func(callback.arg === undefined ? null : callback.arg);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function asmjsMangle(x) {\\\\\\\\\\\\\\\\n    var unmangledSymbols = [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"stackAlloc\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"stackSave\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"stackRestore\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"];\\\\\\\\\\\\\\\\n    return x.indexOf(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dynCall_\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") == 0 || unmangledSymbols.includes(x)\\\\\\\\\\\\\\\\n      ? x\\\\\\\\\\\\\\\\n      : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"_\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + x;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function exportAsmFunctions(asm) {\\\\\\\\\\\\\\\\n    var global_object = this;\\\\\\\\\\\\\\\\n    for (var __exportedFunc in asm) {\\\\\\\\\\\\\\\\n      var jsname = asmjsMangle(__exportedFunc);\\\\\\\\\\\\\\\\n      global_object[jsname] = Module[jsname] = asm[__exportedFunc];\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var wasmTableMirror = [];\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function getWasmTableEntry(funcPtr) {\\\\\\\\\\\\\\\\n    var func = wasmTableMirror[funcPtr];\\\\\\\\\\\\\\\\n    if (!func) {\\\\\\\\\\\\\\\\n      if (funcPtr >= wasmTableMirror.length) {\\\\\\\\\\\\\\\\n        wasmTableMirror.length = funcPtr + 1;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return func;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___assert_fail(condition, filename, line, func) {\\\\\\\\\\\\\\\\n    abort(\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Assertion failed: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n        UTF8ToString(condition) +\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", at: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n        [\\\\\\\\\\\\\\\\n          filename ? UTF8ToString(filename) : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"unknown filename\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n          line,\\\\\\\\\\\\\\\\n          func ? UTF8ToString(func) : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"unknown function\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n        ]\\\\\\\\\\\\\\\\n    );\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___cxa_allocate_exception(size) {\\\\\\\\\\\\\\\\n    return _malloc(size + 16) + 16;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var exceptionCaught = [];\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var exceptionLast = 0;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var uncaughtExceptionCount = 0;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___cxa_rethrow() {\\\\\\\\\\\\\\\\n    var catchInfo = exceptionCaught.pop();\\\\\\\\\\\\\\\\n    if (!catchInfo) {\\\\\\\\\\\\\\\\n      abort(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"no exception to throw\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var info = catchInfo.get_exception_info();\\\\\\\\\\\\\\\\n    var ptr = catchInfo.get_base_ptr();\\\\\\\\\\\\\\\\n    if (!info.get_rethrown()) {\\\\\\\\\\\\\\\\n      exceptionCaught.push(catchInfo);\\\\\\\\\\\\\\\\n      info.set_rethrown(true);\\\\\\\\\\\\\\\\n      info.set_caught(false);\\\\\\\\\\\\\\\\n      uncaughtExceptionCount++;\\\\\\\\\\\\\\\\n    } else {\\\\\\\\\\\\\\\\n      catchInfo.free();\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    exceptionLast = ptr;\\\\\\\\\\\\\\\\n    throw ptr;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ExceptionInfo(excPtr) {\\\\\\\\\\\\\\\\n    this.excPtr = excPtr;\\\\\\\\\\\\\\\\n    this.ptr = excPtr - 16;\\\\\\\\\\\\\\\\n    this.set_type = function (type) {\\\\\\\\\\\\\\\\n      HEAP32[(this.ptr + 4) >> 2] = type;\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    this.get_type = function () {\\\\\\\\\\\\\\\\n      return HEAP32[(this.ptr + 4) >> 2];\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    this.set_destructor = function (destructor) {\\\\\\\\\\\\\\\\n      HEAP32[(this.ptr + 8) >> 2] = destructor;\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    this.get_destructor = function () {\\\\\\\\\\\\\\\\n      return HEAP32[(this.ptr + 8) >> 2];\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    this.set_refcount = function (refcount) {\\\\\\\\\\\\\\\\n      HEAP32[this.ptr >> 2] = refcount;\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    this.set_caught = function (caught) {\\\\\\\\\\\\\\\\n      caught = caught ? 1 : 0;\\\\\\\\\\\\\\\\n      HEAP8[(this.ptr + 12) >> 0] = caught;\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    this.get_caught = function () {\\\\\\\\\\\\\\\\n      return HEAP8[(this.ptr + 12) >> 0] != 0;\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    this.set_rethrown = function (rethrown) {\\\\\\\\\\\\\\\\n      rethrown = rethrown ? 1 : 0;\\\\\\\\\\\\\\\\n      HEAP8[(this.ptr + 13) >> 0] = rethrown;\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    this.get_rethrown = function () {\\\\\\\\\\\\\\\\n      return HEAP8[(this.ptr + 13) >> 0] != 0;\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    this.init = function (type, destructor) {\\\\\\\\\\\\\\\\n      this.set_type(type);\\\\\\\\\\\\\\\\n      this.set_destructor(destructor);\\\\\\\\\\\\\\\\n      this.set_refcount(0);\\\\\\\\\\\\\\\\n      this.set_caught(false);\\\\\\\\\\\\\\\\n      this.set_rethrown(false);\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    this.add_ref = function () {\\\\\\\\\\\\\\\\n      var value = HEAP32[this.ptr >> 2];\\\\\\\\\\\\\\\\n      HEAP32[this.ptr >> 2] = value + 1;\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    this.release_ref = function () {\\\\\\\\\\\\\\\\n      var prev = HEAP32[this.ptr >> 2];\\\\\\\\\\\\\\\\n      HEAP32[this.ptr >> 2] = prev - 1;\\\\\\\\\\\\\\\\n      return prev === 1;\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___cxa_throw(ptr, type, destructor) {\\\\\\\\\\\\\\\\n    var info = new ExceptionInfo(ptr);\\\\\\\\\\\\\\\\n    info.init(type, destructor);\\\\\\\\\\\\\\\\n    exceptionLast = ptr;\\\\\\\\\\\\\\\\n    uncaughtExceptionCount++;\\\\\\\\\\\\\\\\n    throw ptr;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var SYSCALLS = {\\\\\\\\\\\\\\\\n    buffers: [null, [], []],\\\\\\\\\\\\\\\\n    printChar(stream, curr) {\\\\\\\\\\\\\\\\n      var buffer = SYSCALLS.buffers[stream];\\\\\\\\\\\\\\\\n      if (curr === 0 || curr === 10) {\\\\\\\\\\\\\\\\n        (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\\\\\\\\\\\\\\\\n        buffer.length = 0;\\\\\\\\\\\\\\\\n      } else {\\\\\\\\\\\\\\\\n        buffer.push(curr);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    },\\\\\\\\\\\\\\\\n    varargs: undefined,\\\\\\\\\\\\\\\\n    get() {\\\\\\\\\\\\\\\\n      SYSCALLS.varargs += 4;\\\\\\\\\\\\\\\\n      var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];\\\\\\\\\\\\\\\\n      return ret;\\\\\\\\\\\\\\\\n    },\\\\\\\\\\\\\\\\n    getStr(ptr) {\\\\\\\\\\\\\\\\n      var ret = UTF8ToString(ptr);\\\\\\\\\\\\\\\\n      return ret;\\\\\\\\\\\\\\\\n    },\\\\\\\\\\\\\\\\n    get64(low, high) {\\\\\\\\\\\\\\\\n      return low;\\\\\\\\\\\\\\\\n    },\\\\\\\\\\\\\\\\n  };\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___syscall_faccessat(dirfd, path, amode, flags) {\\\\\\\\\\\\\\\\n    path = SYSCALLS.getStr(path);\\\\\\\\\\\\\\\\n    path = SYSCALLS.calculateAt(dirfd, path);\\\\\\\\\\\\\\\\n    return SYSCALLS.doAccess(path, amode);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___syscall_fcntl64(fd, cmd, varargs) {\\\\\\\\\\\\\\\\n    SYSCALLS.varargs = varargs;\\\\\\\\\\\\\\\\n    return 0;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___syscall_fstat64(fd, buf) {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___syscall_getcwd(buf, size) {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___syscall_ioctl(fd, op, varargs) {\\\\\\\\\\\\\\\\n    SYSCALLS.varargs = varargs;\\\\\\\\\\\\\\\\n    return 0;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___syscall_lstat64(path, buf) {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___syscall_newfstatat(dirfd, path, buf, flags) {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___syscall_openat(dirfd, path, flags, varargs) {\\\\\\\\\\\\\\\\n    SYSCALLS.varargs = varargs;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___syscall_rmdir(path) {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___syscall_stat64(path, buf) {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ___syscall_unlinkat(dirfd, path, flags) {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var structRegistrations = {};\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function runDestructors(destructors) {\\\\\\\\\\\\\\\\n    while (destructors.length) {\\\\\\\\\\\\\\\\n      var ptr = destructors.pop();\\\\\\\\\\\\\\\\n      var del = destructors.pop();\\\\\\\\\\\\\\\\n      del(ptr);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function simpleReadValueFromPointer(pointer) {\\\\\\\\\\\\\\\\n    return this.fromWireType(HEAPU32[pointer >> 2]);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var awaitingDependencies = {};\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var registeredTypes = {};\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var typeDependencies = {};\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var char_0 = 48;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var char_9 = 57;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function makeLegalFunctionName(name) {\\\\\\\\\\\\\\\\n    if (undefined === name) {\\\\\\\\\\\\\\\\n      return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"_unknown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    name = name.replace(/[^a-zA-Z0-9_]/g, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"$\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    var f = name.charCodeAt(0);\\\\\\\\\\\\\\\\n    if (f >= char_0 && f <= char_9) {\\\\\\\\\\\\\\\\n      return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"_\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + name;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return name;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function createNamedFunction(name, body) {\\\\\\\\\\\\\\\\n    name = makeLegalFunctionName(name);\\\\\\\\\\\\\\\\n    return function () {\\\\\\\\\\\\\\\\n      null;\\\\\\\\\\\\\\\\n      return body.apply(this, arguments);\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function extendError(baseErrorType, errorName) {\\\\\\\\\\\\\\\\n    var errorClass = createNamedFunction(errorName, function (message) {\\\\\\\\\\\\\\\\n      this.name = errorName;\\\\\\\\\\\\\\\\n      this.message = message;\\\\\\\\\\\\\\\\n      var stack = new Error(message).stack;\\\\\\\\\\\\\\\\n      if (stack !== undefined) {\\\\\\\\\\\\\\\\n        this.stack =\\\\\\\\\\\\\\\\n          this.toString() + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + stack.replace(/^Error(:[^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n]*)?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n/, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n    errorClass.prototype = Object.create(baseErrorType.prototype);\\\\\\\\\\\\\\\\n    errorClass.prototype.constructor = errorClass;\\\\\\\\\\\\\\\\n    errorClass.prototype.toString = function () {\\\\\\\\\\\\\\\\n      if (this.message === undefined) {\\\\\\\\\\\\\\\\n        return this.name;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      return this.name + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + this.message;\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    return errorClass;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var InternalError = undefined;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function throwInternalError(message) {\\\\\\\\\\\\\\\\n    throw new InternalError(message);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function whenDependentTypesAreResolved(\\\\\\\\\\\\\\\\n    myTypes,\\\\\\\\\\\\\\\\n    dependentTypes,\\\\\\\\\\\\\\\\n    getTypeConverters\\\\\\\\\\\\\\\\n  ) {\\\\\\\\\\\\\\\\n    myTypes.forEach(function (type) {\\\\\\\\\\\\\\\\n      typeDependencies[type] = dependentTypes;\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n    function onComplete(typeConverters) {\\\\\\\\\\\\\\\\n      var myTypeConverters = getTypeConverters(typeConverters);\\\\\\\\\\\\\\\\n      if (myTypeConverters.length !== myTypes.length) {\\\\\\\\\\\\\\\\n        throwInternalError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Mismatched type converter count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      for (var i = 0; i < myTypes.length; ++i) {\\\\\\\\\\\\\\\\n        registerType(myTypes[i], myTypeConverters[i]);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var typeConverters = new Array(dependentTypes.length);\\\\\\\\\\\\\\\\n    var unregisteredTypes = [];\\\\\\\\\\\\\\\\n    var registered = 0;\\\\\\\\\\\\\\\\n    dependentTypes.forEach((dt, i) => {\\\\\\\\\\\\\\\\n      if (registeredTypes.hasOwnProperty(dt)) {\\\\\\\\\\\\\\\\n        typeConverters[i] = registeredTypes[dt];\\\\\\\\\\\\\\\\n      } else {\\\\\\\\\\\\\\\\n        unregisteredTypes.push(dt);\\\\\\\\\\\\\\\\n        if (!awaitingDependencies.hasOwnProperty(dt)) {\\\\\\\\\\\\\\\\n          awaitingDependencies[dt] = [];\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        awaitingDependencies[dt].push(() => {\\\\\\\\\\\\\\\\n          typeConverters[i] = registeredTypes[dt];\\\\\\\\\\\\\\\\n          ++registered;\\\\\\\\\\\\\\\\n          if (registered === unregisteredTypes.length) {\\\\\\\\\\\\\\\\n            onComplete(typeConverters);\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n        });\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n    if (0 === unregisteredTypes.length) {\\\\\\\\\\\\\\\\n      onComplete(typeConverters);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_finalize_value_object(structType) {\\\\\\\\\\\\\\\\n    var reg = structRegistrations[structType];\\\\\\\\\\\\\\\\n    delete structRegistrations[structType];\\\\\\\\\\\\\\\\n    var rawConstructor = reg.rawConstructor;\\\\\\\\\\\\\\\\n    var rawDestructor = reg.rawDestructor;\\\\\\\\\\\\\\\\n    var fieldRecords = reg.fields;\\\\\\\\\\\\\\\\n    var fieldTypes = fieldRecords\\\\\\\\\\\\\\\\n      .map(field => field.getterReturnType)\\\\\\\\\\\\\\\\n      .concat(fieldRecords.map(field => field.setterArgumentType));\\\\\\\\\\\\\\\\n    whenDependentTypesAreResolved([structType], fieldTypes, fieldTypes => {\\\\\\\\\\\\\\\\n      var fields = {};\\\\\\\\\\\\\\\\n      fieldRecords.forEach((field, i) => {\\\\\\\\\\\\\\\\n        var fieldName = field.fieldName;\\\\\\\\\\\\\\\\n        var getterReturnType = fieldTypes[i];\\\\\\\\\\\\\\\\n        var getter = field.getter;\\\\\\\\\\\\\\\\n        var getterContext = field.getterContext;\\\\\\\\\\\\\\\\n        var setterArgumentType = fieldTypes[i + fieldRecords.length];\\\\\\\\\\\\\\\\n        var setter = field.setter;\\\\\\\\\\\\\\\\n        var setterContext = field.setterContext;\\\\\\\\\\\\\\\\n        fields[fieldName] = {\\\\\\\\\\\\\\\\n          read: ptr => {\\\\\\\\\\\\\\\\n            return getterReturnType.fromWireType(getter(getterContext, ptr));\\\\\\\\\\\\\\\\n          },\\\\\\\\\\\\\\\\n          write: (ptr, o) => {\\\\\\\\\\\\\\\\n            var destructors = [];\\\\\\\\\\\\\\\\n            setter(\\\\\\\\\\\\\\\\n              setterContext,\\\\\\\\\\\\\\\\n              ptr,\\\\\\\\\\\\\\\\n              setterArgumentType.toWireType(destructors, o, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\n            );\\\\\\\\\\\\\\\\n            runDestructors(destructors);\\\\\\\\\\\\\\\\n          },\\\\\\\\\\\\\\\\n        };\\\\\\\\\\\\\\\\n      });\\\\\\\\\\\\\\\\n      return [\\\\\\\\\\\\\\\\n        {\\\\\\\\\\\\\\\\n          name: reg.name,\\\\\\\\\\\\\\\\n          fromWireType: function (ptr) {\\\\\\\\\\\\\\\\n            var rv = {};\\\\\\\\\\\\\\\\n            for (var i in fields) {\\\\\\\\\\\\\\\\n              rv[i] = fields[i].read(ptr);\\\\\\\\\\\\\\\\n            }\\\\\\\\\\\\\\\\n            rawDestructor(ptr);\\\\\\\\\\\\\\\\n            return rv;\\\\\\\\\\\\\\\\n          },\\\\\\\\\\\\\\\\n          toWireType: function (destructors, o) {\\\\\\\\\\\\\\\\n            for (var fieldName in fields) {\\\\\\\\\\\\\\\\n              if (!(fieldName in o)) {\\\\\\\\\\\\\\\\n                throw new TypeError('Missing field:  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"' + fieldName + '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"');\\\\\\\\\\\\\\\\n              }\\\\\\\\\\\\\\\\n            }\\\\\\\\\\\\\\\\n            var ptr = rawConstructor();\\\\\\\\\\\\\\\\n            for (fieldName in fields) {\\\\\\\\\\\\\\\\n              fields[fieldName].write(ptr, o[fieldName]);\\\\\\\\\\\\\\\\n            }\\\\\\\\\\\\\\\\n            if (destructors !== null) {\\\\\\\\\\\\\\\\n              destructors.push(rawDestructor, ptr);\\\\\\\\\\\\\\\\n            }\\\\\\\\\\\\\\\\n            return ptr;\\\\\\\\\\\\\\\\n          },\\\\\\\\\\\\\\\\n          argPackAdvance: 8,\\\\\\\\\\\\\\\\n          readValueFromPointer: simpleReadValueFromPointer,\\\\\\\\\\\\\\\\n          destructorFunction: rawDestructor,\\\\\\\\\\\\\\\\n        },\\\\\\\\\\\\\\\\n      ];\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_bigint(\\\\\\\\\\\\\\\\n    primitiveType,\\\\\\\\\\\\\\\\n    name,\\\\\\\\\\\\\\\\n    size,\\\\\\\\\\\\\\\\n    minRange,\\\\\\\\\\\\\\\\n    maxRange\\\\\\\\\\\\\\\\n  ) {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function getShiftFromSize(size) {\\\\\\\\\\\\\\\\n    switch (size) {\\\\\\\\\\\\\\\\n      case 1:\\\\\\\\\\\\\\\\n        return 0;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      case 2:\\\\\\\\\\\\\\\\n        return 1;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      case 4:\\\\\\\\\\\\\\\\n        return 2;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      case 8:\\\\\\\\\\\\\\\\n        return 3;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      default:\\\\\\\\\\\\\\\\n        throw new TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Unknown type size: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + size);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function embind_init_charCodes() {\\\\\\\\\\\\\\\\n    var codes = new Array(256);\\\\\\\\\\\\\\\\n    for (var i = 0; i < 256; ++i) {\\\\\\\\\\\\\\\\n      codes[i] = String.fromCharCode(i);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    embind_charCodes = codes;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var embind_charCodes = undefined;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function readLatin1String(ptr) {\\\\\\\\\\\\\\\\n    var ret = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    var c = ptr;\\\\\\\\\\\\\\\\n    while (HEAPU8[c]) {\\\\\\\\\\\\\\\\n      ret += embind_charCodes[HEAPU8[c++]];\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return ret;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var BindingError = undefined;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function throwBindingError(message) {\\\\\\\\\\\\\\\\n    throw new BindingError(message);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function registerType(rawType, registeredInstance, options = {}) {\\\\\\\\\\\\\\\\n    if (!(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"argPackAdvance\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" in registeredInstance)) {\\\\\\\\\\\\\\\\n      throw new TypeError(\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"registerType registeredInstance requires argPackAdvance\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var name = registeredInstance.name;\\\\\\\\\\\\\\\\n    if (!rawType) {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\n        'type \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"' + name + '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" must have a positive integer typeid pointer'\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (registeredTypes.hasOwnProperty(rawType)) {\\\\\\\\\\\\\\\\n      if (options.ignoreDuplicateRegistrations) {\\\\\\\\\\\\\\\\n        return;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot register type '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + name + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"' twice\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    registeredTypes[rawType] = registeredInstance;\\\\\\\\\\\\\\\\n    delete typeDependencies[rawType];\\\\\\\\\\\\\\\\n    if (awaitingDependencies.hasOwnProperty(rawType)) {\\\\\\\\\\\\\\\\n      var callbacks = awaitingDependencies[rawType];\\\\\\\\\\\\\\\\n      delete awaitingDependencies[rawType];\\\\\\\\\\\\\\\\n      callbacks.forEach(cb => cb());\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\\\\\\\\\\\\\\\\n    var shift = getShiftFromSize(size);\\\\\\\\\\\\\\\\n    name = readLatin1String(name);\\\\\\\\\\\\\\\\n    registerType(rawType, {\\\\\\\\\\\\\\\\n      name,\\\\\\\\\\\\\\\\n      fromWireType: function (wt) {\\\\\\\\\\\\\\\\n        return !!wt;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      toWireType: function (destructors, o) {\\\\\\\\\\\\\\\\n        return o ? trueValue : falseValue;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      argPackAdvance: 8,\\\\\\\\\\\\\\\\n      readValueFromPointer: function (pointer) {\\\\\\\\\\\\\\\\n        var heap;\\\\\\\\\\\\\\\\n        if (size === 1) {\\\\\\\\\\\\\\\\n          heap = HEAP8;\\\\\\\\\\\\\\\\n        } else if (size === 2) {\\\\\\\\\\\\\\\\n          heap = HEAP16;\\\\\\\\\\\\\\\\n        } else if (size === 4) {\\\\\\\\\\\\\\\\n          heap = HEAP32;\\\\\\\\\\\\\\\\n        } else {\\\\\\\\\\\\\\\\n          throw new TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Unknown boolean type size: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + name);\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        return this.fromWireType(heap[pointer >> shift]);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      destructorFunction: null,\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ClassHandle_isAliasOf(other) {\\\\\\\\\\\\\\\\n    if (!(this instanceof ClassHandle)) {\\\\\\\\\\\\\\\\n      return false;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (!(other instanceof ClassHandle)) {\\\\\\\\\\\\\\\\n      return false;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var leftClass = this.$$.ptrType.registeredClass;\\\\\\\\\\\\\\\\n    var left = this.$$.ptr;\\\\\\\\\\\\\\\\n    var rightClass = other.$$.ptrType.registeredClass;\\\\\\\\\\\\\\\\n    var right = other.$$.ptr;\\\\\\\\\\\\\\\\n    while (leftClass.baseClass) {\\\\\\\\\\\\\\\\n      left = leftClass.upcast(left);\\\\\\\\\\\\\\\\n      leftClass = leftClass.baseClass;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    while (rightClass.baseClass) {\\\\\\\\\\\\\\\\n      right = rightClass.upcast(right);\\\\\\\\\\\\\\\\n      rightClass = rightClass.baseClass;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return leftClass === rightClass && left === right;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function shallowCopyInternalPointer(o) {\\\\\\\\\\\\\\\\n    return {\\\\\\\\\\\\\\\\n      count: o.count,\\\\\\\\\\\\\\\\n      deleteScheduled: o.deleteScheduled,\\\\\\\\\\\\\\\\n      preservePointerOnDelete: o.preservePointerOnDelete,\\\\\\\\\\\\\\\\n      ptr: o.ptr,\\\\\\\\\\\\\\\\n      ptrType: o.ptrType,\\\\\\\\\\\\\\\\n      smartPtr: o.smartPtr,\\\\\\\\\\\\\\\\n      smartPtrType: o.smartPtrType,\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function throwInstanceAlreadyDeleted(obj) {\\\\\\\\\\\\\\\\n    function getInstanceTypeName(handle) {\\\\\\\\\\\\\\\\n      return handle.$$.ptrType.registeredClass.name;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    throwBindingError(getInstanceTypeName(obj) + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" instance already deleted\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var finalizationRegistry = false;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function detachFinalizer(handle) {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function runDestructor($$) {\\\\\\\\\\\\\\\\n    if ($$.smartPtr) {\\\\\\\\\\\\\\\\n      $$.smartPtrType.rawDestructor($$.smartPtr);\\\\\\\\\\\\\\\\n    } else {\\\\\\\\\\\\\\\\n      $$.ptrType.registeredClass.rawDestructor($$.ptr);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function releaseClassHandle($$) {\\\\\\\\\\\\\\\\n    $$.count.value -= 1;\\\\\\\\\\\\\\\\n    var toDelete = 0 === $$.count.value;\\\\\\\\\\\\\\\\n    if (toDelete) {\\\\\\\\\\\\\\\\n      runDestructor($$);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function downcastPointer(ptr, ptrClass, desiredClass) {\\\\\\\\\\\\\\\\n    if (ptrClass === desiredClass) {\\\\\\\\\\\\\\\\n      return ptr;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (undefined === desiredClass.baseClass) {\\\\\\\\\\\\\\\\n      return null;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\\\\\\\\\\\\\\\\n    if (rv === null) {\\\\\\\\\\\\\\\\n      return null;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return desiredClass.downcast(rv);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var registeredPointers = {};\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function getInheritedInstanceCount() {\\\\\\\\\\\\\\\\n    return Object.keys(registeredInstances).length;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function getLiveInheritedInstances() {\\\\\\\\\\\\\\\\n    var rv = [];\\\\\\\\\\\\\\\\n    for (var k in registeredInstances) {\\\\\\\\\\\\\\\\n      if (registeredInstances.hasOwnProperty(k)) {\\\\\\\\\\\\\\\\n        rv.push(registeredInstances[k]);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return rv;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var deletionQueue = [];\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function flushPendingDeletes() {\\\\\\\\\\\\\\\\n    while (deletionQueue.length) {\\\\\\\\\\\\\\\\n      var obj = deletionQueue.pop();\\\\\\\\\\\\\\\\n      obj.$$.deleteScheduled = false;\\\\\\\\\\\\\\\\n      obj.delete();\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var delayFunction = undefined;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function setDelayFunction(fn) {\\\\\\\\\\\\\\\\n    delayFunction = fn;\\\\\\\\\\\\\\\\n    if (deletionQueue.length && delayFunction) {\\\\\\\\\\\\\\\\n      delayFunction(flushPendingDeletes);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function init_embind() {\\\\\\\\\\\\\\\\n    Module.getInheritedInstanceCount = getInheritedInstanceCount;\\\\\\\\\\\\\\\\n    Module.getLiveInheritedInstances = getLiveInheritedInstances;\\\\\\\\\\\\\\\\n    Module.flushPendingDeletes = flushPendingDeletes;\\\\\\\\\\\\\\\\n    Module.setDelayFunction = setDelayFunction;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var registeredInstances = {};\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function getBasestPointer(class_, ptr) {\\\\\\\\\\\\\\\\n    if (ptr === undefined) {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ptr should not be undefined\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    while (class_.baseClass) {\\\\\\\\\\\\\\\\n      ptr = class_.upcast(ptr);\\\\\\\\\\\\\\\\n      class_ = class_.baseClass;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return ptr;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function getInheritedInstance(class_, ptr) {\\\\\\\\\\\\\\\\n    ptr = getBasestPointer(class_, ptr);\\\\\\\\\\\\\\\\n    return registeredInstances[ptr];\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function makeClassHandle(prototype, record) {\\\\\\\\\\\\\\\\n    if (!record.ptrType || !record.ptr) {\\\\\\\\\\\\\\\\n      throwInternalError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"makeClassHandle requires ptr and ptrType\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var hasSmartPtrType = !!record.smartPtrType;\\\\\\\\\\\\\\\\n    var hasSmartPtr = !!record.smartPtr;\\\\\\\\\\\\\\\\n    if (hasSmartPtrType !== hasSmartPtr) {\\\\\\\\\\\\\\\\n      throwInternalError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Both smartPtrType and smartPtr must be specified\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    record.count = {\\\\\\\\\\\\\\\\n      value: 1,\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    return attachFinalizer(\\\\\\\\\\\\\\\\n      Object.create(prototype, {\\\\\\\\\\\\\\\\n        $$: {\\\\\\\\\\\\\\\\n          value: record,\\\\\\\\\\\\\\\\n        },\\\\\\\\\\\\\\\\n      })\\\\\\\\\\\\\\\\n    );\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function RegisteredPointer_fromWireType(ptr) {\\\\\\\\\\\\\\\\n    var rawPointer = this.getPointee(ptr);\\\\\\\\\\\\\\\\n    if (!rawPointer) {\\\\\\\\\\\\\\\\n      this.destructor(ptr);\\\\\\\\\\\\\\\\n      return null;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var registeredInstance = getInheritedInstance(\\\\\\\\\\\\\\\\n      this.registeredClass,\\\\\\\\\\\\\\\\n      rawPointer\\\\\\\\\\\\\\\\n    );\\\\\\\\\\\\\\\\n    if (undefined !== registeredInstance) {\\\\\\\\\\\\\\\\n      if (0 === registeredInstance.$$.count.value) {\\\\\\\\\\\\\\\\n        registeredInstance.$$.ptr = rawPointer;\\\\\\\\\\\\\\\\n        registeredInstance.$$.smartPtr = ptr;\\\\\\\\\\\\\\\\n        return registeredInstance.clone();\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      var rv = registeredInstance.clone();\\\\\\\\\\\\\\\\n      this.destructor(ptr);\\\\\\\\\\\\\\\\n      return rv;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    function makeDefaultHandle() {\\\\\\\\\\\\\\\\n      if (this.isSmartPointer) {\\\\\\\\\\\\\\\\n        return makeClassHandle(this.registeredClass.instancePrototype, {\\\\\\\\\\\\\\\\n          ptrType: this.pointeeType,\\\\\\\\\\\\\\\\n          ptr: rawPointer,\\\\\\\\\\\\\\\\n          smartPtrType: this,\\\\\\\\\\\\\\\\n          smartPtr: ptr,\\\\\\\\\\\\\\\\n        });\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      return makeClassHandle(this.registeredClass.instancePrototype, {\\\\\\\\\\\\\\\\n        ptrType: this,\\\\\\\\\\\\\\\\n        ptr,\\\\\\\\\\\\\\\\n      });\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var actualType = this.registeredClass.getActualType(rawPointer);\\\\\\\\\\\\\\\\n    var registeredPointerRecord = registeredPointers[actualType];\\\\\\\\\\\\\\\\n    if (!registeredPointerRecord) {\\\\\\\\\\\\\\\\n      return makeDefaultHandle.call(this);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var toType;\\\\\\\\\\\\\\\\n    if (this.isConst) {\\\\\\\\\\\\\\\\n      toType = registeredPointerRecord.constPointerType;\\\\\\\\\\\\\\\\n    } else {\\\\\\\\\\\\\\\\n      toType = registeredPointerRecord.pointerType;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var dp = downcastPointer(\\\\\\\\\\\\\\\\n      rawPointer,\\\\\\\\\\\\\\\\n      this.registeredClass,\\\\\\\\\\\\\\\\n      toType.registeredClass\\\\\\\\\\\\\\\\n    );\\\\\\\\\\\\\\\\n    if (dp === null) {\\\\\\\\\\\\\\\\n      return makeDefaultHandle.call(this);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (this.isSmartPointer) {\\\\\\\\\\\\\\\\n      return makeClassHandle(toType.registeredClass.instancePrototype, {\\\\\\\\\\\\\\\\n        ptrType: toType,\\\\\\\\\\\\\\\\n        ptr: dp,\\\\\\\\\\\\\\\\n        smartPtrType: this,\\\\\\\\\\\\\\\\n        smartPtr: ptr,\\\\\\\\\\\\\\\\n      });\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return makeClassHandle(toType.registeredClass.instancePrototype, {\\\\\\\\\\\\\\\\n      ptrType: toType,\\\\\\\\\\\\\\\\n      ptr: dp,\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function attachFinalizer(handle) {\\\\\\\\\\\\\\\\n    if (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" === typeof FinalizationRegistry) {\\\\\\\\\\\\\\\\n      attachFinalizer = handle => handle;\\\\\\\\\\\\\\\\n      return handle;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    finalizationRegistry = new FinalizationRegistry(info => {\\\\\\\\\\\\\\\\n      releaseClassHandle(info.$$);\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n    attachFinalizer = handle => {\\\\\\\\\\\\\\\\n      var $$ = handle.$$;\\\\\\\\\\\\\\\\n      var hasSmartPtr = !!$$.smartPtr;\\\\\\\\\\\\\\\\n      if (hasSmartPtr) {\\\\\\\\\\\\\\\\n        var info = {\\\\\\\\\\\\\\\\n          $$,\\\\\\\\\\\\\\\\n        };\\\\\\\\\\\\\\\\n        finalizationRegistry.register(handle, info, handle);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      return handle;\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    detachFinalizer = handle => finalizationRegistry.unregister(handle);\\\\\\\\\\\\\\\\n    return attachFinalizer(handle);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ClassHandle_clone() {\\\\\\\\\\\\\\\\n    if (!this.$$.ptr) {\\\\\\\\\\\\\\\\n      throwInstanceAlreadyDeleted(this);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (this.$$.preservePointerOnDelete) {\\\\\\\\\\\\\\\\n      this.$$.count.value += 1;\\\\\\\\\\\\\\\\n      return this;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var clone = attachFinalizer(\\\\\\\\\\\\\\\\n      Object.create(Object.getPrototypeOf(this), {\\\\\\\\\\\\\\\\n        $$: {\\\\\\\\\\\\\\\\n          value: shallowCopyInternalPointer(this.$$),\\\\\\\\\\\\\\\\n        },\\\\\\\\\\\\\\\\n      })\\\\\\\\\\\\\\\\n    );\\\\\\\\\\\\\\\\n    clone.$$.count.value += 1;\\\\\\\\\\\\\\\\n    clone.$$.deleteScheduled = false;\\\\\\\\\\\\\\\\n    return clone;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ClassHandle_delete() {\\\\\\\\\\\\\\\\n    if (!this.$$.ptr) {\\\\\\\\\\\\\\\\n      throwInstanceAlreadyDeleted(this);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Object already scheduled for deletion\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    detachFinalizer(this);\\\\\\\\\\\\\\\\n    releaseClassHandle(this.$$);\\\\\\\\\\\\\\\\n    if (!this.$$.preservePointerOnDelete) {\\\\\\\\\\\\\\\\n      this.$$.smartPtr = undefined;\\\\\\\\\\\\\\\\n      this.$$.ptr = undefined;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ClassHandle_isDeleted() {\\\\\\\\\\\\\\\\n    return !this.$$.ptr;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ClassHandle_deleteLater() {\\\\\\\\\\\\\\\\n    if (!this.$$.ptr) {\\\\\\\\\\\\\\\\n      throwInstanceAlreadyDeleted(this);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Object already scheduled for deletion\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    deletionQueue.push(this);\\\\\\\\\\\\\\\\n    if (deletionQueue.length === 1 && delayFunction) {\\\\\\\\\\\\\\\\n      delayFunction(flushPendingDeletes);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    this.$$.deleteScheduled = true;\\\\\\\\\\\\\\\\n    return this;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function init_ClassHandle() {\\\\\\\\\\\\\\\\n    ClassHandle.prototype.isAliasOf = ClassHandle_isAliasOf;\\\\\\\\\\\\\\\\n    ClassHandle.prototype.clone = ClassHandle_clone;\\\\\\\\\\\\\\\\n    ClassHandle.prototype.delete = ClassHandle_delete;\\\\\\\\\\\\\\\\n    ClassHandle.prototype.isDeleted = ClassHandle_isDeleted;\\\\\\\\\\\\\\\\n    ClassHandle.prototype.deleteLater = ClassHandle_deleteLater;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ClassHandle() {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ensureOverloadTable(proto, methodName, humanName) {\\\\\\\\\\\\\\\\n    if (undefined === proto[methodName].overloadTable) {\\\\\\\\\\\\\\\\n      var prevFunc = proto[methodName];\\\\\\\\\\\\\\\\n      proto[methodName] = function () {\\\\\\\\\\\\\\\\n        if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\\\\\\\\\\\\\\\\n          throwBindingError(\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Function '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n              humanName +\\\\\\\\\\\\\\\\n              \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"' called with an invalid number of arguments (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n              arguments.length +\\\\\\\\\\\\\\\\n              \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") - expects one of (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n              proto[methodName].overloadTable +\\\\\\\\\\\\\\\\n              \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n          );\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        return proto[methodName].overloadTable[arguments.length].apply(\\\\\\\\\\\\\\\\n          this,\\\\\\\\\\\\\\\\n          arguments\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n      };\\\\\\\\\\\\\\\\n      proto[methodName].overloadTable = [];\\\\\\\\\\\\\\\\n      proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function exposePublicSymbol(name, value, numArguments) {\\\\\\\\\\\\\\\\n    if (Module.hasOwnProperty(name)) {\\\\\\\\\\\\\\\\n      if (\\\\\\\\\\\\\\\\n        undefined === numArguments ||\\\\\\\\\\\\\\\\n        (undefined !== Module[name].overloadTable &&\\\\\\\\\\\\\\\\n          undefined !== Module[name].overloadTable[numArguments])\\\\\\\\\\\\\\\\n      ) {\\\\\\\\\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot register public name '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + name + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"' twice\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      ensureOverloadTable(Module, name, name);\\\\\\\\\\\\\\\\n      if (Module.hasOwnProperty(numArguments)) {\\\\\\\\\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\\n          \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot register multiple overloads of a function with the same number of arguments (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n            numArguments +\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      Module[name].overloadTable[numArguments] = value;\\\\\\\\\\\\\\\\n    } else {\\\\\\\\\\\\\\\\n      Module[name] = value;\\\\\\\\\\\\\\\\n      if (undefined !== numArguments) {\\\\\\\\\\\\\\\\n        Module[name].numArguments = numArguments;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function RegisteredClass(\\\\\\\\\\\\\\\\n    name,\\\\\\\\\\\\\\\\n    constructor,\\\\\\\\\\\\\\\\n    instancePrototype,\\\\\\\\\\\\\\\\n    rawDestructor,\\\\\\\\\\\\\\\\n    baseClass,\\\\\\\\\\\\\\\\n    getActualType,\\\\\\\\\\\\\\\\n    upcast,\\\\\\\\\\\\\\\\n    downcast\\\\\\\\\\\\\\\\n  ) {\\\\\\\\\\\\\\\\n    this.name = name;\\\\\\\\\\\\\\\\n    this.constructor = constructor;\\\\\\\\\\\\\\\\n    this.instancePrototype = instancePrototype;\\\\\\\\\\\\\\\\n    this.rawDestructor = rawDestructor;\\\\\\\\\\\\\\\\n    this.baseClass = baseClass;\\\\\\\\\\\\\\\\n    this.getActualType = getActualType;\\\\\\\\\\\\\\\\n    this.upcast = upcast;\\\\\\\\\\\\\\\\n    this.downcast = downcast;\\\\\\\\\\\\\\\\n    this.pureVirtualFunctions = [];\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function upcastPointer(ptr, ptrClass, desiredClass) {\\\\\\\\\\\\\\\\n    while (ptrClass !== desiredClass) {\\\\\\\\\\\\\\\\n      if (!ptrClass.upcast) {\\\\\\\\\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\\n          \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Expected null or instance of \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n            desiredClass.name +\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", got an instance of \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n            ptrClass.name\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      ptr = ptrClass.upcast(ptr);\\\\\\\\\\\\\\\\n      ptrClass = ptrClass.baseClass;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return ptr;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function constNoSmartPtrRawPointerToWireType(destructors, handle) {\\\\\\\\\\\\\\\\n    if (handle === null) {\\\\\\\\\\\\\\\\n      if (this.isReference) {\\\\\\\\\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"null is not a valid \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + this.name);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      return 0;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (!handle.$$) {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\n        'Cannot pass \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"' + _embind_repr(handle) + '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" as a ' + this.name\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (!handle.$$.ptr) {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot pass deleted object as a pointer of type \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + this.name\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var handleClass = handle.$$.ptrType.registeredClass;\\\\\\\\\\\\\\\\n    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\\\\\\\\\\\\\\\\n    return ptr;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function genericPointerToWireType(destructors, handle) {\\\\\\\\\\\\\\\\n    var ptr;\\\\\\\\\\\\\\\\n    if (handle === null) {\\\\\\\\\\\\\\\\n      if (this.isReference) {\\\\\\\\\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"null is not a valid \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + this.name);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      if (this.isSmartPointer) {\\\\\\\\\\\\\\\\n        ptr = this.rawConstructor();\\\\\\\\\\\\\\\\n        if (destructors !== null) {\\\\\\\\\\\\\\\\n          destructors.push(this.rawDestructor, ptr);\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        return ptr;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      return 0;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (!handle.$$) {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\n        'Cannot pass \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"' + _embind_repr(handle) + '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" as a ' + this.name\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (!handle.$$.ptr) {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot pass deleted object as a pointer of type \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + this.name\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (!this.isConst && handle.$$.ptrType.isConst) {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot convert argument of type \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n          (handle.$$.smartPtrType\\\\\\\\\\\\\\\\n            ? handle.$$.smartPtrType.name\\\\\\\\\\\\\\\\n            : handle.$$.ptrType.name) +\\\\\\\\\\\\\\\\n          \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" to parameter type \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n          this.name\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var handleClass = handle.$$.ptrType.registeredClass;\\\\\\\\\\\\\\\\n    ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\\\\\\\\\\\\\\\\n    if (this.isSmartPointer) {\\\\\\\\\\\\\\\\n      if (undefined === handle.$$.smartPtr) {\\\\\\\\\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Passing raw pointer to smart pointer is illegal\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      switch (this.sharingPolicy) {\\\\\\\\\\\\\\\\n        case 0:\\\\\\\\\\\\\\\\n          if (handle.$$.smartPtrType === this) {\\\\\\\\\\\\\\\\n            ptr = handle.$$.smartPtr;\\\\\\\\\\\\\\\\n          } else {\\\\\\\\\\\\\\\\n            throwBindingError(\\\\\\\\\\\\\\\\n              \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot convert argument of type \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n                (handle.$$.smartPtrType\\\\\\\\\\\\\\\\n                  ? handle.$$.smartPtrType.name\\\\\\\\\\\\\\\\n                  : handle.$$.ptrType.name) +\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" to parameter type \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n                this.name\\\\\\\\\\\\\\\\n            );\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n          break;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n        case 1:\\\\\\\\\\\\\\\\n          ptr = handle.$$.smartPtr;\\\\\\\\\\\\\\\\n          break;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n        case 2:\\\\\\\\\\\\\\\\n          if (handle.$$.smartPtrType === this) {\\\\\\\\\\\\\\\\n            ptr = handle.$$.smartPtr;\\\\\\\\\\\\\\\\n          } else {\\\\\\\\\\\\\\\\n            var clonedHandle = handle.clone();\\\\\\\\\\\\\\\\n            ptr = this.rawShare(\\\\\\\\\\\\\\\\n              ptr,\\\\\\\\\\\\\\\\n              Emval.toHandle(function () {\\\\\\\\\\\\\\\\n                clonedHandle.delete();\\\\\\\\\\\\\\\\n              })\\\\\\\\\\\\\\\\n            );\\\\\\\\\\\\\\\\n            if (destructors !== null) {\\\\\\\\\\\\\\\\n              destructors.push(this.rawDestructor, ptr);\\\\\\\\\\\\\\\\n            }\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n          break;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n        default:\\\\\\\\\\\\\\\\n          throwBindingError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Unsupporting sharing policy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return ptr;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\\\\\\\\\\\\\\\\n    if (handle === null) {\\\\\\\\\\\\\\\\n      if (this.isReference) {\\\\\\\\\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"null is not a valid \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + this.name);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      return 0;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (!handle.$$) {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\n        'Cannot pass \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"' + _embind_repr(handle) + '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" as a ' + this.name\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (!handle.$$.ptr) {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot pass deleted object as a pointer of type \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + this.name\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (handle.$$.ptrType.isConst) {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot convert argument of type \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n          handle.$$.ptrType.name +\\\\\\\\\\\\\\\\n          \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" to parameter type \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n          this.name\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var handleClass = handle.$$.ptrType.registeredClass;\\\\\\\\\\\\\\\\n    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\\\\\\\\\\\\\\\\n    return ptr;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function RegisteredPointer_getPointee(ptr) {\\\\\\\\\\\\\\\\n    if (this.rawGetPointee) {\\\\\\\\\\\\\\\\n      ptr = this.rawGetPointee(ptr);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return ptr;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function RegisteredPointer_destructor(ptr) {\\\\\\\\\\\\\\\\n    if (this.rawDestructor) {\\\\\\\\\\\\\\\\n      this.rawDestructor(ptr);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function RegisteredPointer_deleteObject(handle) {\\\\\\\\\\\\\\\\n    if (handle !== null) {\\\\\\\\\\\\\\\\n      handle.delete();\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function init_RegisteredPointer() {\\\\\\\\\\\\\\\\n    RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\\\\\\\\\\\\\\\\n    RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\\\\\\\\\\\\\\\\n    RegisteredPointer.prototype.argPackAdvance = 8;\\\\\\\\\\\\\\\\n    RegisteredPointer.prototype.readValueFromPointer =\\\\\\\\\\\\\\\\n      simpleReadValueFromPointer;\\\\\\\\\\\\\\\\n    RegisteredPointer.prototype.deleteObject = RegisteredPointer_deleteObject;\\\\\\\\\\\\\\\\n    RegisteredPointer.prototype.fromWireType = RegisteredPointer_fromWireType;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function RegisteredPointer(\\\\\\\\\\\\\\\\n    name,\\\\\\\\\\\\\\\\n    registeredClass,\\\\\\\\\\\\\\\\n    isReference,\\\\\\\\\\\\\\\\n    isConst,\\\\\\\\\\\\\\\\n    isSmartPointer,\\\\\\\\\\\\\\\\n    pointeeType,\\\\\\\\\\\\\\\\n    sharingPolicy,\\\\\\\\\\\\\\\\n    rawGetPointee,\\\\\\\\\\\\\\\\n    rawConstructor,\\\\\\\\\\\\\\\\n    rawShare,\\\\\\\\\\\\\\\\n    rawDestructor\\\\\\\\\\\\\\\\n  ) {\\\\\\\\\\\\\\\\n    this.name = name;\\\\\\\\\\\\\\\\n    this.registeredClass = registeredClass;\\\\\\\\\\\\\\\\n    this.isReference = isReference;\\\\\\\\\\\\\\\\n    this.isConst = isConst;\\\\\\\\\\\\\\\\n    this.isSmartPointer = isSmartPointer;\\\\\\\\\\\\\\\\n    this.pointeeType = pointeeType;\\\\\\\\\\\\\\\\n    this.sharingPolicy = sharingPolicy;\\\\\\\\\\\\\\\\n    this.rawGetPointee = rawGetPointee;\\\\\\\\\\\\\\\\n    this.rawConstructor = rawConstructor;\\\\\\\\\\\\\\\\n    this.rawShare = rawShare;\\\\\\\\\\\\\\\\n    this.rawDestructor = rawDestructor;\\\\\\\\\\\\\\\\n    if (!isSmartPointer && registeredClass.baseClass === undefined) {\\\\\\\\\\\\\\\\n      if (isConst) {\\\\\\\\\\\\\\\\n        this.toWireType = constNoSmartPtrRawPointerToWireType;\\\\\\\\\\\\\\\\n        this.destructorFunction = null;\\\\\\\\\\\\\\\\n      } else {\\\\\\\\\\\\\\\\n        this.toWireType = nonConstNoSmartPtrRawPointerToWireType;\\\\\\\\\\\\\\\\n        this.destructorFunction = null;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    } else {\\\\\\\\\\\\\\\\n      this.toWireType = genericPointerToWireType;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function replacePublicSymbol(name, value, numArguments) {\\\\\\\\\\\\\\\\n    if (!Module.hasOwnProperty(name)) {\\\\\\\\\\\\\\\\n      throwInternalError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Replacing nonexistant public symbol\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (\\\\\\\\\\\\\\\\n      undefined !== Module[name].overloadTable &&\\\\\\\\\\\\\\\\n      undefined !== numArguments\\\\\\\\\\\\\\\\n    ) {\\\\\\\\\\\\\\\\n      Module[name].overloadTable[numArguments] = value;\\\\\\\\\\\\\\\\n    } else {\\\\\\\\\\\\\\\\n      Module[name] = value;\\\\\\\\\\\\\\\\n      Module[name].argCount = numArguments;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function dynCallLegacy(sig, ptr, args) {\\\\\\\\\\\\\\\\n    var f = Module[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"dynCall_\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + sig];\\\\\\\\\\\\\\\\n    return args && args.length\\\\\\\\\\\\\\\\n      ? f.apply(null, [ptr].concat(args))\\\\\\\\\\\\\\\\n      : f.call(null, ptr);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function dynCall(sig, ptr, args) {\\\\\\\\\\\\\\\\n    if (sig.includes(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"j\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")) {\\\\\\\\\\\\\\\\n      return dynCallLegacy(sig, ptr, args);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return getWasmTableEntry(ptr).apply(null, args);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function getDynCaller(sig, ptr) {\\\\\\\\\\\\\\\\n    var argCache = [];\\\\\\\\\\\\\\\\n    return function () {\\\\\\\\\\\\\\\\n      argCache.length = 0;\\\\\\\\\\\\\\\\n      Object.assign(argCache, arguments);\\\\\\\\\\\\\\\\n      return dynCall(sig, ptr, argCache);\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function embind__requireFunction(signature, rawFunction) {\\\\\\\\\\\\\\\\n    signature = readLatin1String(signature);\\\\\\\\\\\\\\\\n    function makeDynCaller() {\\\\\\\\\\\\\\\\n      if (signature.includes(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"j\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")) {\\\\\\\\\\\\\\\\n        return getDynCaller(signature, rawFunction);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      return getWasmTableEntry(rawFunction);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var fp = makeDynCaller();\\\\\\\\\\\\\\\\n    if (typeof fp != \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"unknown function pointer with signature \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n          signature +\\\\\\\\\\\\\\\\n          \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n          rawFunction\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return fp;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var UnboundTypeError = undefined;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function getTypeName(type) {\\\\\\\\\\\\\\\\n    var ptr = ___getTypeName(type);\\\\\\\\\\\\\\\\n    var rv = readLatin1String(ptr);\\\\\\\\\\\\\\\\n    _free(ptr);\\\\\\\\\\\\\\\\n    return rv;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function throwUnboundTypeError(message, types) {\\\\\\\\\\\\\\\\n    var unboundTypes = [];\\\\\\\\\\\\\\\\n    var seen = {};\\\\\\\\\\\\\\\\n    function visit(type) {\\\\\\\\\\\\\\\\n      if (seen[type]) {\\\\\\\\\\\\\\\\n        return;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      if (registeredTypes[type]) {\\\\\\\\\\\\\\\\n        return;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      if (typeDependencies[type]) {\\\\\\\\\\\\\\\\n        typeDependencies[type].forEach(visit);\\\\\\\\\\\\\\\\n        return;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      unboundTypes.push(type);\\\\\\\\\\\\\\\\n      seen[type] = true;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    types.forEach(visit);\\\\\\\\\\\\\\\\n    throw new UnboundTypeError(\\\\\\\\\\\\\\\\n      message + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + unboundTypes.map(getTypeName).join([\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"])\\\\\\\\\\\\\\\\n    );\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_class(\\\\\\\\\\\\\\\\n    rawType,\\\\\\\\\\\\\\\\n    rawPointerType,\\\\\\\\\\\\\\\\n    rawConstPointerType,\\\\\\\\\\\\\\\\n    baseClassRawType,\\\\\\\\\\\\\\\\n    getActualTypeSignature,\\\\\\\\\\\\\\\\n    getActualType,\\\\\\\\\\\\\\\\n    upcastSignature,\\\\\\\\\\\\\\\\n    upcast,\\\\\\\\\\\\\\\\n    downcastSignature,\\\\\\\\\\\\\\\\n    downcast,\\\\\\\\\\\\\\\\n    name,\\\\\\\\\\\\\\\\n    destructorSignature,\\\\\\\\\\\\\\\\n    rawDestructor\\\\\\\\\\\\\\\\n  ) {\\\\\\\\\\\\\\\\n    name = readLatin1String(name);\\\\\\\\\\\\\\\\n    getActualType = embind__requireFunction(\\\\\\\\\\\\\\\\n      getActualTypeSignature,\\\\\\\\\\\\\\\\n      getActualType\\\\\\\\\\\\\\\\n    );\\\\\\\\\\\\\\\\n    if (upcast) {\\\\\\\\\\\\\\\\n      upcast = embind__requireFunction(upcastSignature, upcast);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (downcast) {\\\\\\\\\\\\\\\\n      downcast = embind__requireFunction(downcastSignature, downcast);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\\\\\\\\\\\\\\\\n    var legalFunctionName = makeLegalFunctionName(name);\\\\\\\\\\\\\\\\n    exposePublicSymbol(legalFunctionName, function () {\\\\\\\\\\\\\\\\n      throwUnboundTypeError(\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot construct \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + name + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" due to unbound types\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n        [baseClassRawType]\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n    whenDependentTypesAreResolved(\\\\\\\\\\\\\\\\n      [rawType, rawPointerType, rawConstPointerType],\\\\\\\\\\\\\\\\n      baseClassRawType ? [baseClassRawType] : [],\\\\\\\\\\\\\\\\n      function (base) {\\\\\\\\\\\\\\\\n        base = base[0];\\\\\\\\\\\\\\\\n        var baseClass;\\\\\\\\\\\\\\\\n        var basePrototype;\\\\\\\\\\\\\\\\n        if (baseClassRawType) {\\\\\\\\\\\\\\\\n          baseClass = base.registeredClass;\\\\\\\\\\\\\\\\n          basePrototype = baseClass.instancePrototype;\\\\\\\\\\\\\\\\n        } else {\\\\\\\\\\\\\\\\n          basePrototype = ClassHandle.prototype;\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        var constructor = createNamedFunction(legalFunctionName, function () {\\\\\\\\\\\\\\\\n          if (Object.getPrototypeOf(this) !== instancePrototype) {\\\\\\\\\\\\\\\\n            throw new BindingError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Use 'new' to construct \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + name);\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n          if (undefined === registeredClass.constructor_body) {\\\\\\\\\\\\\\\\n            throw new BindingError(name + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" has no accessible constructor\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n          var body = registeredClass.constructor_body[arguments.length];\\\\\\\\\\\\\\\\n          if (undefined === body) {\\\\\\\\\\\\\\\\n            throw new BindingError(\\\\\\\\\\\\\\\\n              \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Tried to invoke ctor of \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n                name +\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" with invalid number of parameters (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n                arguments.length +\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") - expected (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n                Object.keys(registeredClass.constructor_body).toString() +\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") parameters instead!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n            );\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n          return body.apply(this, arguments);\\\\\\\\\\\\\\\\n        });\\\\\\\\\\\\\\\\n        var instancePrototype = Object.create(basePrototype, {\\\\\\\\\\\\\\\\n          constructor: {\\\\\\\\\\\\\\\\n            value: constructor,\\\\\\\\\\\\\\\\n          },\\\\\\\\\\\\\\\\n        });\\\\\\\\\\\\\\\\n        constructor.prototype = instancePrototype;\\\\\\\\\\\\\\\\n        var registeredClass = new RegisteredClass(\\\\\\\\\\\\\\\\n          name,\\\\\\\\\\\\\\\\n          constructor,\\\\\\\\\\\\\\\\n          instancePrototype,\\\\\\\\\\\\\\\\n          rawDestructor,\\\\\\\\\\\\\\\\n          baseClass,\\\\\\\\\\\\\\\\n          getActualType,\\\\\\\\\\\\\\\\n          upcast,\\\\\\\\\\\\\\\\n          downcast\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n        var referenceConverter = new RegisteredPointer(\\\\\\\\\\\\\\\\n          name,\\\\\\\\\\\\\\\\n          registeredClass,\\\\\\\\\\\\\\\\n          true,\\\\\\\\\\\\\\\\n          false,\\\\\\\\\\\\\\\\n          false\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n        var pointerConverter = new RegisteredPointer(\\\\\\\\\\\\\\\\n          name + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n          registeredClass,\\\\\\\\\\\\\\\\n          false,\\\\\\\\\\\\\\\\n          false,\\\\\\\\\\\\\\\\n          false\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n        var constPointerConverter = new RegisteredPointer(\\\\\\\\\\\\\\\\n          name + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" const*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n          registeredClass,\\\\\\\\\\\\\\\\n          false,\\\\\\\\\\\\\\\\n          true,\\\\\\\\\\\\\\\\n          false\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n        registeredPointers[rawType] = {\\\\\\\\\\\\\\\\n          pointerType: pointerConverter,\\\\\\\\\\\\\\\\n          constPointerType: constPointerConverter,\\\\\\\\\\\\\\\\n        };\\\\\\\\\\\\\\\\n        replacePublicSymbol(legalFunctionName, constructor);\\\\\\\\\\\\\\\\n        return [referenceConverter, pointerConverter, constPointerConverter];\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    );\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function heap32VectorToArray(count, firstElement) {\\\\\\\\\\\\\\\\n    var array = [];\\\\\\\\\\\\\\\\n    for (var i = 0; i < count; i++) {\\\\\\\\\\\\\\\\n      array.push(HEAP32[(firstElement >> 2) + i]);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return array;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_class_constructor(\\\\\\\\\\\\\\\\n    rawClassType,\\\\\\\\\\\\\\\\n    argCount,\\\\\\\\\\\\\\\\n    rawArgTypesAddr,\\\\\\\\\\\\\\\\n    invokerSignature,\\\\\\\\\\\\\\\\n    invoker,\\\\\\\\\\\\\\\\n    rawConstructor\\\\\\\\\\\\\\\\n  ) {\\\\\\\\\\\\\\\\n    assert(argCount > 0);\\\\\\\\\\\\\\\\n    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\\\\\\\\\\\\\\\\n    invoker = embind__requireFunction(invokerSignature, invoker);\\\\\\\\\\\\\\\\n    whenDependentTypesAreResolved([], [rawClassType], function (classType) {\\\\\\\\\\\\\\\\n      classType = classType[0];\\\\\\\\\\\\\\\\n      var humanName = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"constructor \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + classType.name;\\\\\\\\\\\\\\\\n      if (undefined === classType.registeredClass.constructor_body) {\\\\\\\\\\\\\\\\n        classType.registeredClass.constructor_body = [];\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      if (\\\\\\\\\\\\\\\\n        undefined !== classType.registeredClass.constructor_body[argCount - 1]\\\\\\\\\\\\\\\\n      ) {\\\\\\\\\\\\\\\\n        throw new BindingError(\\\\\\\\\\\\\\\\n          \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot register multiple constructors with identical number of parameters (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n            (argCount - 1) +\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") for class '\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n            classType.name +\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"'! Overload resolution is currently only performed using the parameter count, not actual type info!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      classType.registeredClass.constructor_body[argCount - 1] = () => {\\\\\\\\\\\\\\\\n        throwUnboundTypeError(\\\\\\\\\\\\\\\\n          \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot construct \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + classType.name + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" due to unbound types\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n          rawArgTypes\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n      };\\\\\\\\\\\\\\\\n      whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\\\\\\\\\\\\\\\\n        argTypes.splice(1, 0, null);\\\\\\\\\\\\\\\\n        classType.registeredClass.constructor_body[argCount - 1] =\\\\\\\\\\\\\\\\n          craftInvokerFunction(\\\\\\\\\\\\\\\\n            humanName,\\\\\\\\\\\\\\\\n            argTypes,\\\\\\\\\\\\\\\\n            null,\\\\\\\\\\\\\\\\n            invoker,\\\\\\\\\\\\\\\\n            rawConstructor\\\\\\\\\\\\\\\\n          );\\\\\\\\\\\\\\\\n        return [];\\\\\\\\\\\\\\\\n      });\\\\\\\\\\\\\\\\n      return [];\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function craftInvokerFunction(\\\\\\\\\\\\\\\\n    humanName,\\\\\\\\\\\\\\\\n    argTypes,\\\\\\\\\\\\\\\\n    classType,\\\\\\\\\\\\\\\\n    cppInvokerFunc,\\\\\\\\\\\\\\\\n    cppTargetFunc\\\\\\\\\\\\\\\\n  ) {\\\\\\\\\\\\\\\\n    var argCount = argTypes.length;\\\\\\\\\\\\\\\\n    if (argCount < 2) {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"argTypes array size mismatch! Must at least get return value and 'this' types!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var isClassMethodFunc = argTypes[1] !== null && classType !== null;\\\\\\\\\\\\\\\\n    var needsDestructorStack = false;\\\\\\\\\\\\\\\\n    for (var i = 1; i < argTypes.length; ++i) {\\\\\\\\\\\\\\\\n      if (\\\\\\\\\\\\\\\\n        argTypes[i] !== null &&\\\\\\\\\\\\\\\\n        argTypes[i].destructorFunction === undefined\\\\\\\\\\\\\\\\n      ) {\\\\\\\\\\\\\\\\n        needsDestructorStack = true;\\\\\\\\\\\\\\\\n        break;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var returns = argTypes[0].name !== \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"void\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    var expectedArgCount = argCount - 2;\\\\\\\\\\\\\\\\n    var argsWired = new Array(expectedArgCount);\\\\\\\\\\\\\\\\n    var invokerFuncArgs = [];\\\\\\\\\\\\\\\\n    var destructors = [];\\\\\\\\\\\\\\\\n    return function () {\\\\\\\\\\\\\\\\n      if (arguments.length !== expectedArgCount) {\\\\\\\\\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\\n          \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"function \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n            humanName +\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" called with \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n            arguments.length +\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" arguments, expected \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" +\\\\\\\\\\\\\\\\n            expectedArgCount +\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" args!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      destructors.length = 0;\\\\\\\\\\\\\\\\n      var thisWired;\\\\\\\\\\\\\\\\n      invokerFuncArgs.length = isClassMethodFunc ? 2 : 1;\\\\\\\\\\\\\\\\n      invokerFuncArgs[0] = cppTargetFunc;\\\\\\\\\\\\\\\\n      if (isClassMethodFunc) {\\\\\\\\\\\\\\\\n        thisWired = argTypes[1].toWireType(destructors, this, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo2\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n        invokerFuncArgs[1] = thisWired;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      for (var i = 0; i < expectedArgCount; ++i) {\\\\\\\\\\\\\\\\n        console.log('[dbg][issam][embind invoke]', humanName, 'argIndex', i, {\\\\\\\\\\\\\\\\n          expectedType: argTypes[i + 2]?.name,\\\\\\\\\\\\\\\\n          jsType: typeof arguments[i],\\\\\\\\\\\\\\\\n          isArrayBuffer: arguments[i] instanceof ArrayBuffer,\\\\\\\\\\\\\\\\n          isU8: arguments[i] instanceof Uint8Array,\\\\\\\\\\\\\\\\n          valueCtor: arguments[i]?.constructor?.name\\\\\\\\\\\\\\\\n        });\\\\\\\\\\\\\\\\n        if (arguments[i] === undefined) {\\\\\\\\\\\\\\\\n          console.error('[dbg][issam][embind invoke] ARG IS UNDEFINED at', humanName, 'argIndex', i);\\\\\\\\\\\\\\\\n          console.trace();\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        argsWired[i] = argTypes[i + 2].toWireType(destructors, arguments[i], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo3\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n        invokerFuncArgs.push(argsWired[i]);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      var rv = cppInvokerFunc.apply(null, invokerFuncArgs);\\\\\\\\\\\\\\\\n      function onDone(rv) {\\\\\\\\\\\\\\\\n        if (needsDestructorStack) {\\\\\\\\\\\\\\\\n          runDestructors(destructors);\\\\\\\\\\\\\\\\n        } else {\\\\\\\\\\\\\\\\n          for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; i++) {\\\\\\\\\\\\\\\\n            var param = i === 1 ? thisWired : argsWired[i - 2];\\\\\\\\\\\\\\\\n            if (argTypes[i].destructorFunction !== null) {\\\\\\\\\\\\\\\\n              argTypes[i].destructorFunction(param);\\\\\\\\\\\\\\\\n            }\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        if (returns) {\\\\\\\\\\\\\\\\n          return argTypes[0].fromWireType(rv);\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      return onDone(rv);\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_class_function(\\\\\\\\\\\\\\\\n    rawClassType,\\\\\\\\\\\\\\\\n    methodName,\\\\\\\\\\\\\\\\n    argCount,\\\\\\\\\\\\\\\\n    rawArgTypesAddr,\\\\\\\\\\\\\\\\n    invokerSignature,\\\\\\\\\\\\\\\\n    rawInvoker,\\\\\\\\\\\\\\\\n    context,\\\\\\\\\\\\\\\\n    isPureVirtual\\\\\\\\\\\\\\\\n  ) {\\\\\\\\\\\\\\\\n    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\\\\\\\\\\\\\\\\n    methodName = readLatin1String(methodName);\\\\\\\\\\\\\\\\n    rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\\\\\\\\\\\\\\\\n    whenDependentTypesAreResolved([], [rawClassType], function (classType) {\\\\\\\\\\\\\\\\n      classType = classType[0];\\\\\\\\\\\\\\\\n      var humanName = classType.name + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + methodName;\\\\\\\\\\\\\\\\n      if (methodName.startsWith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"@@\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")) {\\\\\\\\\\\\\\\\n        methodName = Symbol[methodName.substring(2)];\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      if (isPureVirtual) {\\\\\\\\\\\\\\\\n        classType.registeredClass.pureVirtualFunctions.push(methodName);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      function unboundTypesHandler() {\\\\\\\\\\\\\\\\n        throwUnboundTypeError(\\\\\\\\\\\\\\\\n          \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot call \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + humanName + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" due to unbound types\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n          rawArgTypes\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      var proto = classType.registeredClass.instancePrototype;\\\\\\\\\\\\\\\\n      var method = proto[methodName];\\\\\\\\\\\\\\\\n      if (\\\\\\\\\\\\\\\\n        undefined === method ||\\\\\\\\\\\\\\\\n        (undefined === method.overloadTable &&\\\\\\\\\\\\\\\\n          method.className !== classType.name &&\\\\\\\\\\\\\\\\n          method.argCount === argCount - 2)\\\\\\\\\\\\\\\\n      ) {\\\\\\\\\\\\\\\\n        unboundTypesHandler.argCount = argCount - 2;\\\\\\\\\\\\\\\\n        unboundTypesHandler.className = classType.name;\\\\\\\\\\\\\\\\n        proto[methodName] = unboundTypesHandler;\\\\\\\\\\\\\\\\n      } else {\\\\\\\\\\\\\\\\n        ensureOverloadTable(proto, methodName, humanName);\\\\\\\\\\\\\\\\n        proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\\\\\\\\\\\\\\\\n        var memberFunction = craftInvokerFunction(\\\\\\\\\\\\\\\\n          humanName,\\\\\\\\\\\\\\\\n          argTypes,\\\\\\\\\\\\\\\\n          classType,\\\\\\\\\\\\\\\\n          rawInvoker,\\\\\\\\\\\\\\\\n          context\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n        if (undefined === proto[methodName].overloadTable) {\\\\\\\\\\\\\\\\n          memberFunction.argCount = argCount - 2;\\\\\\\\\\\\\\\\n          proto[methodName] = memberFunction;\\\\\\\\\\\\\\\\n        } else {\\\\\\\\\\\\\\\\n          proto[methodName].overloadTable[argCount - 2] = memberFunction;\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        return [];\\\\\\\\\\\\\\\\n      });\\\\\\\\\\\\\\\\n      return [];\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var emval_free_list = [];\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var emval_handle_array = [\\\\\\\\\\\\\\\\n    {},\\\\\\\\\\\\\\\\n    {\\\\\\\\\\\\\\\\n      value: undefined,\\\\\\\\\\\\\\\\n    },\\\\\\\\\\\\\\\\n    {\\\\\\\\\\\\\\\\n      value: null,\\\\\\\\\\\\\\\\n    },\\\\\\\\\\\\\\\\n    {\\\\\\\\\\\\\\\\n      value: true,\\\\\\\\\\\\\\\\n    },\\\\\\\\\\\\\\\\n    {\\\\\\\\\\\\\\\\n      value: false,\\\\\\\\\\\\\\\\n    },\\\\\\\\\\\\\\\\n  ];\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __emval_decref(handle) {\\\\\\\\\\\\\\\\n    if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\\\\\\\\\\\\\\\\n      emval_handle_array[handle] = undefined;\\\\\\\\\\\\\\\\n      emval_free_list.push(handle);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function count_emval_handles() {\\\\\\\\\\\\\\\\n    var count = 0;\\\\\\\\\\\\\\\\n    for (var i = 5; i < emval_handle_array.length; ++i) {\\\\\\\\\\\\\\\\n      if (emval_handle_array[i] !== undefined) {\\\\\\\\\\\\\\\\n        ++count;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return count;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function get_first_emval() {\\\\\\\\\\\\\\\\n    for (var i = 5; i < emval_handle_array.length; ++i) {\\\\\\\\\\\\\\\\n      if (emval_handle_array[i] !== undefined) {\\\\\\\\\\\\\\\\n        return emval_handle_array[i];\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return null;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function init_emval() {\\\\\\\\\\\\\\\\n    Module.count_emval_handles = count_emval_handles;\\\\\\\\\\\\\\\\n    Module.get_first_emval = get_first_emval;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var Emval = {\\\\\\\\\\\\\\\\n    toValue: handle => {\\\\\\\\\\\\\\\\n      if (!handle) {\\\\\\\\\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot use deleted val. handle = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + handle);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      return emval_handle_array[handle].value;\\\\\\\\\\\\\\\\n    },\\\\\\\\\\\\\\\\n    toHandle: value => {\\\\\\\\\\\\\\\\n      switch (value) {\\\\\\\\\\\\\\\\n        case undefined:\\\\\\\\\\\\\\\\n          return 1;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n        case null:\\\\\\\\\\\\\\\\n          return 2;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n        case true:\\\\\\\\\\\\\\\\n          return 3;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n        case false:\\\\\\\\\\\\\\\\n          return 4;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n        default: {\\\\\\\\\\\\\\\\n          var handle = emval_free_list.length\\\\\\\\\\\\\\\\n            ? emval_free_list.pop()\\\\\\\\\\\\\\\\n            : emval_handle_array.length;\\\\\\\\\\\\\\\\n          emval_handle_array[handle] = {\\\\\\\\\\\\\\\\n            refcount: 1,\\\\\\\\\\\\\\\\n            value,\\\\\\\\\\\\\\\\n          };\\\\\\\\\\\\\\\\n          return handle;\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    },\\\\\\\\\\\\\\\\n  };\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_emval(rawType, name) {\\\\\\\\\\\\\\\\n    name = readLatin1String(name);\\\\\\\\\\\\\\\\n    registerType(rawType, {\\\\\\\\\\\\\\\\n      name,\\\\\\\\\\\\\\\\n      fromWireType: function (handle) {\\\\\\\\\\\\\\\\n        var rv = Emval.toValue(handle);\\\\\\\\\\\\\\\\n        __emval_decref(handle);\\\\\\\\\\\\\\\\n        return rv;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      toWireType: function (destructors, value) {\\\\\\\\\\\\\\\\n        return Emval.toHandle(value);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      argPackAdvance: 8,\\\\\\\\\\\\\\\\n      readValueFromPointer: simpleReadValueFromPointer,\\\\\\\\\\\\\\\\n      destructorFunction: null,\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _embind_repr(v) {\\\\\\\\\\\\\\\\n    if (v === null) {\\\\\\\\\\\\\\\\n      return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"null\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var t = typeof v;\\\\\\\\\\\\\\\\n    if (t === \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" || t === \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"array\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" || t === \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") {\\\\\\\\\\\\\\\\n      return v.toString();\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + v;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function floatReadValueFromPointer(name, shift) {\\\\\\\\\\\\\\\\n    switch (shift) {\\\\\\\\\\\\\\\\n      case 2:\\\\\\\\\\\\\\\\n        return function (pointer) {\\\\\\\\\\\\\\\\n          return this.fromWireType(HEAPF32[pointer >> 2]);\\\\\\\\\\\\\\\\n        };\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      case 3:\\\\\\\\\\\\\\\\n        return function (pointer) {\\\\\\\\\\\\\\\\n          return this.fromWireType(HEAPF64[pointer >> 3]);\\\\\\\\\\\\\\\\n        };\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      default:\\\\\\\\\\\\\\\\n        throw new TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Unknown float type: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + name);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_float(rawType, name, size) {\\\\\\\\\\\\\\\\n    var shift = getShiftFromSize(size);\\\\\\\\\\\\\\\\n    name = readLatin1String(name);\\\\\\\\\\\\\\\\n    registerType(rawType, {\\\\\\\\\\\\\\\\n      name,\\\\\\\\\\\\\\\\n      fromWireType: function (value) {\\\\\\\\\\\\\\\\n        return value;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      toWireType: function (destructors, value) {\\\\\\\\\\\\\\\\n        return value;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      argPackAdvance: 8,\\\\\\\\\\\\\\\\n      readValueFromPointer: floatReadValueFromPointer(name, shift),\\\\\\\\\\\\\\\\n      destructorFunction: null,\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function integerReadValueFromPointer(name, shift, signed) {\\\\\\\\\\\\\\\\n    switch (shift) {\\\\\\\\\\\\\\\\n      case 0:\\\\\\\\\\\\\\\\n        return signed\\\\\\\\\\\\\\\\n          ? function readS8FromPointer(pointer) {\\\\\\\\\\\\\\\\n              return HEAP8[pointer];\\\\\\\\\\\\\\\\n            }\\\\\\\\\\\\\\\\n          : function readU8FromPointer(pointer) {\\\\\\\\\\\\\\\\n              return HEAPU8[pointer];\\\\\\\\\\\\\\\\n            };\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      case 1:\\\\\\\\\\\\\\\\n        return signed\\\\\\\\\\\\\\\\n          ? function readS16FromPointer(pointer) {\\\\\\\\\\\\\\\\n              return HEAP16[pointer >> 1];\\\\\\\\\\\\\\\\n            }\\\\\\\\\\\\\\\\n          : function readU16FromPointer(pointer) {\\\\\\\\\\\\\\\\n              return HEAPU16[pointer >> 1];\\\\\\\\\\\\\\\\n            };\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      case 2:\\\\\\\\\\\\\\\\n        return signed\\\\\\\\\\\\\\\\n          ? function readS32FromPointer(pointer) {\\\\\\\\\\\\\\\\n              return HEAP32[pointer >> 2];\\\\\\\\\\\\\\\\n            }\\\\\\\\\\\\\\\\n          : function readU32FromPointer(pointer) {\\\\\\\\\\\\\\\\n              return HEAPU32[pointer >> 2];\\\\\\\\\\\\\\\\n            };\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n      default:\\\\\\\\\\\\\\\\n        throw new TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Unknown integer type: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + name);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_integer(\\\\\\\\\\\\\\\\n    primitiveType,\\\\\\\\\\\\\\\\n    name,\\\\\\\\\\\\\\\\n    size,\\\\\\\\\\\\\\\\n    minRange,\\\\\\\\\\\\\\\\n    maxRange\\\\\\\\\\\\\\\\n  ) {\\\\\\\\\\\\\\\\n    name = readLatin1String(name);\\\\\\\\\\\\\\\\n    if (maxRange === -1) {\\\\\\\\\\\\\\\\n      maxRange = 4294967295;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var shift = getShiftFromSize(size);\\\\\\\\\\\\\\\\n    var fromWireType = value => value;\\\\\\\\\\\\\\\\n    if (minRange === 0) {\\\\\\\\\\\\\\\\n      var bitshift = 32 - 8 * size;\\\\\\\\\\\\\\\\n      fromWireType = value => (value << bitshift) >>> bitshift;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var isUnsignedType = name.includes(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"unsigned\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    var checkAssertions = (value, toTypeName) => {};\\\\\\\\\\\\\\\\n    var toWireType;\\\\\\\\\\\\\\\\n    if (isUnsignedType) {\\\\\\\\\\\\\\\\n      toWireType = function (destructors, value) {\\\\\\\\\\\\\\\\n        checkAssertions(value, this.name);\\\\\\\\\\\\\\\\n        return value >>> 0;\\\\\\\\\\\\\\\\n      };\\\\\\\\\\\\\\\\n    } else {\\\\\\\\\\\\\\\\n      toWireType = function (destructors, value) {\\\\\\\\\\\\\\\\n        checkAssertions(value, this.name);\\\\\\\\\\\\\\\\n        return value;\\\\\\\\\\\\\\\\n      };\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    registerType(primitiveType, {\\\\\\\\\\\\\\\\n      name,\\\\\\\\\\\\\\\\n      fromWireType: fromWireType,\\\\\\\\\\\\\\\\n      toWireType: toWireType,\\\\\\\\\\\\\\\\n      argPackAdvance: 8,\\\\\\\\\\\\\\\\n      readValueFromPointer: integerReadValueFromPointer(\\\\\\\\\\\\\\\\n        name,\\\\\\\\\\\\\\\\n        shift,\\\\\\\\\\\\\\\\n        minRange !== 0\\\\\\\\\\\\\\\\n      ),\\\\\\\\\\\\\\\\n      destructorFunction: null,\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_memory_view(rawType, dataTypeIndex, name) {\\\\\\\\\\\\\\\\n    var typeMapping = [\\\\\\\\\\\\\\\\n      Int8Array,\\\\\\\\\\\\\\\\n      Uint8Array,\\\\\\\\\\\\\\\\n      Int16Array,\\\\\\\\\\\\\\\\n      Uint16Array,\\\\\\\\\\\\\\\\n      Int32Array,\\\\\\\\\\\\\\\\n      Uint32Array,\\\\\\\\\\\\\\\\n      Float32Array,\\\\\\\\\\\\\\\\n      Float64Array,\\\\\\\\\\\\\\\\n    ];\\\\\\\\\\\\\\\\n    var TA = typeMapping[dataTypeIndex];\\\\\\\\\\\\\\\\n    function decodeMemoryView(handle) {\\\\\\\\\\\\\\\\n      handle = handle >> 2;\\\\\\\\\\\\\\\\n      var heap = HEAPU32;\\\\\\\\\\\\\\\\n      var size = heap[handle];\\\\\\\\\\\\\\\\n      var data = heap[handle + 1];\\\\\\\\\\\\\\\\n      return new TA(buffer, data, size);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    name = readLatin1String(name);\\\\\\\\\\\\\\\\n    registerType(\\\\\\\\\\\\\\\\n      rawType,\\\\\\\\\\\\\\\\n      {\\\\\\\\\\\\\\\\n        name,\\\\\\\\\\\\\\\\n        fromWireType: decodeMemoryView,\\\\\\\\\\\\\\\\n        argPackAdvance: 8,\\\\\\\\\\\\\\\\n        readValueFromPointer: decodeMemoryView,\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      {\\\\\\\\\\\\\\\\n        ignoreDuplicateRegistrations: true,\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    );\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_smart_ptr(\\\\\\\\\\\\\\\\n    rawType,\\\\\\\\\\\\\\\\n    rawPointeeType,\\\\\\\\\\\\\\\\n    name,\\\\\\\\\\\\\\\\n    sharingPolicy,\\\\\\\\\\\\\\\\n    getPointeeSignature,\\\\\\\\\\\\\\\\n    rawGetPointee,\\\\\\\\\\\\\\\\n    constructorSignature,\\\\\\\\\\\\\\\\n    rawConstructor,\\\\\\\\\\\\\\\\n    shareSignature,\\\\\\\\\\\\\\\\n    rawShare,\\\\\\\\\\\\\\\\n    destructorSignature,\\\\\\\\\\\\\\\\n    rawDestructor\\\\\\\\\\\\\\\\n  ) {\\\\\\\\\\\\\\\\n    name = readLatin1String(name);\\\\\\\\\\\\\\\\n    rawGetPointee = embind__requireFunction(getPointeeSignature, rawGetPointee);\\\\\\\\\\\\\\\\n    rawConstructor = embind__requireFunction(\\\\\\\\\\\\\\\\n      constructorSignature,\\\\\\\\\\\\\\\\n      rawConstructor\\\\\\\\\\\\\\\\n    );\\\\\\\\\\\\\\\\n    rawShare = embind__requireFunction(shareSignature, rawShare);\\\\\\\\\\\\\\\\n    rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\\\\\\\\\\\\\\\\n    whenDependentTypesAreResolved(\\\\\\\\\\\\\\\\n      [rawType],\\\\\\\\\\\\\\\\n      [rawPointeeType],\\\\\\\\\\\\\\\\n      function (pointeeType) {\\\\\\\\\\\\\\\\n        pointeeType = pointeeType[0];\\\\\\\\\\\\\\\\n        var registeredPointer = new RegisteredPointer(\\\\\\\\\\\\\\\\n          name,\\\\\\\\\\\\\\\\n          pointeeType.registeredClass,\\\\\\\\\\\\\\\\n          false,\\\\\\\\\\\\\\\\n          false,\\\\\\\\\\\\\\\\n          true,\\\\\\\\\\\\\\\\n          pointeeType,\\\\\\\\\\\\\\\\n          sharingPolicy,\\\\\\\\\\\\\\\\n          rawGetPointee,\\\\\\\\\\\\\\\\n          rawConstructor,\\\\\\\\\\\\\\\\n          rawShare,\\\\\\\\\\\\\\\\n          rawDestructor\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n        return [registeredPointer];\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    );\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_std_string(rawType, name) {\\\\\\\\\\\\\\\\n    name = readLatin1String(name);\\\\\\\\\\\\\\\\n    var stdStringIsUTF8 = name === \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"std::string\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    registerType(rawType, {\\\\\\\\\\\\\\\\n      name,\\\\\\\\\\\\\\\\n      fromWireType: function (value) {\\\\\\\\\\\\\\\\n        var length = HEAPU32[value >> 2];\\\\\\\\\\\\\\\\n        var str;\\\\\\\\\\\\\\\\n        if (stdStringIsUTF8) {\\\\\\\\\\\\\\\\n          var decodeStartPtr = value + 4;\\\\\\\\\\\\\\\\n          for (var i = 0; i <= length; ++i) {\\\\\\\\\\\\\\\\n            var currentBytePtr = value + 4 + i;\\\\\\\\\\\\\\\\n            if (i == length || HEAPU8[currentBytePtr] == 0) {\\\\\\\\\\\\\\\\n              var maxRead = currentBytePtr - decodeStartPtr;\\\\\\\\\\\\\\\\n              var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\\\\\\\\\\\\\\\\n              if (str === undefined) {\\\\\\\\\\\\\\\\n                str = stringSegment;\\\\\\\\\\\\\\\\n              } else {\\\\\\\\\\\\\\\\n                str += String.fromCharCode(0);\\\\\\\\\\\\\\\\n                str += stringSegment;\\\\\\\\\\\\\\\\n              }\\\\\\\\\\\\\\\\n              decodeStartPtr = currentBytePtr + 1;\\\\\\\\\\\\\\\\n            }\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n        } else {\\\\\\\\\\\\\\\\n          var a = new Array(length);\\\\\\\\\\\\\\\\n          for (var i = 0; i < length; ++i) {\\\\\\\\\\\\\\\\n            a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n          str = a.join(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        _free(value);\\\\\\\\\\\\\\\\n        return str;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      toWireType: function (destructors, value, foo) {\\\\\\\\\\\\\\\\n        console.log(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"[dbg][issam][begamort-translator.js] value:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", value, foo);\\\\\\\\\\\\\\\\n        if (value instanceof ArrayBuffer) {\\\\\\\\\\\\\\\\n          value = new Uint8Array(value);\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        var getLength;\\\\\\\\\\\\\\\\n        var valueIsOfTypeString = typeof value == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"string\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n        if (\\\\\\\\\\\\\\\\n          !(\\\\\\\\\\\\\\\\n            valueIsOfTypeString ||\\\\\\\\\\\\\\\\n            value instanceof Uint8Array ||\\\\\\\\\\\\\\\\n            value instanceof Uint8ClampedArray ||\\\\\\\\\\\\\\\\n            value instanceof Int8Array\\\\\\\\\\\\\\\\n          )\\\\\\\\\\\\\\\\n        ) {\\\\\\\\\\\\\\\\n          console.log(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"[dbg][issam][begamort-translator.js] value:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", valueIsOfTypeString, value);\\\\\\\\\\\\\\\\n          throwBindingError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot pass non-string to std::string\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        if (stdStringIsUTF8 && valueIsOfTypeString) {\\\\\\\\\\\\\\\\n          getLength = () => lengthBytesUTF8(value);\\\\\\\\\\\\\\\\n        } else {\\\\\\\\\\\\\\\\n          getLength = () => value.length;\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        var length = getLength();\\\\\\\\\\\\\\\\n        var ptr = _malloc(4 + length + 1);\\\\\\\\\\\\\\\\n        HEAPU32[ptr >> 2] = length;\\\\\\\\\\\\\\\\n        if (stdStringIsUTF8 && valueIsOfTypeString) {\\\\\\\\\\\\\\\\n          stringToUTF8(value, ptr + 4, length + 1);\\\\\\\\\\\\\\\\n        } else if (valueIsOfTypeString) {\\\\\\\\\\\\\\\\n          for (var i = 0; i < length; ++i) {\\\\\\\\\\\\\\\\n            var charCode = value.charCodeAt(i);\\\\\\\\\\\\\\\\n            if (charCode > 255) {\\\\\\\\\\\\\\\\n              _free(ptr);\\\\\\\\\\\\\\\\n              throwBindingError(\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"String has UTF-16 code units that do not fit in 8 bits\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n              );\\\\\\\\\\\\\\\\n            }\\\\\\\\\\\\\\\\n            HEAPU8[ptr + 4 + i] = charCode;\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n        } else {\\\\\\\\\\\\\\\\n          for (var i = 0; i < length; ++i) {\\\\\\\\\\\\\\\\n            HEAPU8[ptr + 4 + i] = value[i];\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        if (destructors !== null) {\\\\\\\\\\\\\\\\n          destructors.push(_free, ptr);\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        return ptr;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      argPackAdvance: 8,\\\\\\\\\\\\\\\\n      readValueFromPointer: simpleReadValueFromPointer,\\\\\\\\\\\\\\\\n      destructorFunction(ptr) {\\\\\\\\\\\\\\\\n        _free(ptr);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_std_wstring(rawType, charSize, name) {\\\\\\\\\\\\\\\\n    name = readLatin1String(name);\\\\\\\\\\\\\\\\n    var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\\\\\\\\\\\\\\\\n    if (charSize === 2) {\\\\\\\\\\\\\\\\n      decodeString = UTF16ToString;\\\\\\\\\\\\\\\\n      encodeString = stringToUTF16;\\\\\\\\\\\\\\\\n      lengthBytesUTF = lengthBytesUTF16;\\\\\\\\\\\\\\\\n      getHeap = () => HEAPU16;\\\\\\\\\\\\\\\\n      shift = 1;\\\\\\\\\\\\\\\\n    } else if (charSize === 4) {\\\\\\\\\\\\\\\\n      decodeString = UTF32ToString;\\\\\\\\\\\\\\\\n      encodeString = stringToUTF32;\\\\\\\\\\\\\\\\n      lengthBytesUTF = lengthBytesUTF32;\\\\\\\\\\\\\\\\n      getHeap = () => HEAPU32;\\\\\\\\\\\\\\\\n      shift = 2;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    registerType(rawType, {\\\\\\\\\\\\\\\\n      name,\\\\\\\\\\\\\\\\n      fromWireType: function (value) {\\\\\\\\\\\\\\\\n        var length = HEAPU32[value >> 2];\\\\\\\\\\\\\\\\n        var HEAP = getHeap();\\\\\\\\\\\\\\\\n        var str;\\\\\\\\\\\\\\\\n        var decodeStartPtr = value + 4;\\\\\\\\\\\\\\\\n        for (var i = 0; i <= length; ++i) {\\\\\\\\\\\\\\\\n          var currentBytePtr = value + 4 + i * charSize;\\\\\\\\\\\\\\\\n          if (i == length || HEAP[currentBytePtr >> shift] == 0) {\\\\\\\\\\\\\\\\n            var maxReadBytes = currentBytePtr - decodeStartPtr;\\\\\\\\\\\\\\\\n            var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\\\\\\\\\\\\\\\\n            if (str === undefined) {\\\\\\\\\\\\\\\\n              str = stringSegment;\\\\\\\\\\\\\\\\n            } else {\\\\\\\\\\\\\\\\n              str += String.fromCharCode(0);\\\\\\\\\\\\\\\\n              str += stringSegment;\\\\\\\\\\\\\\\\n            }\\\\\\\\\\\\\\\\n            decodeStartPtr = currentBytePtr + charSize;\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        _free(value);\\\\\\\\\\\\\\\\n        return str;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      toWireType: function (destructors, value) {\\\\\\\\\\\\\\\\n        if (!(typeof value == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"string\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")) {\\\\\\\\\\\\\\\\n          throwBindingError(\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Cannot pass non-string to C++ string type \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + name\\\\\\\\\\\\\\\\n          );\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        var length = lengthBytesUTF(value);\\\\\\\\\\\\\\\\n        var ptr = _malloc(4 + length + charSize);\\\\\\\\\\\\\\\\n        HEAPU32[ptr >> 2] = length >> shift;\\\\\\\\\\\\\\\\n        encodeString(value, ptr + 4, length + charSize);\\\\\\\\\\\\\\\\n        if (destructors !== null) {\\\\\\\\\\\\\\\\n          destructors.push(_free, ptr);\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        return ptr;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      argPackAdvance: 8,\\\\\\\\\\\\\\\\n      readValueFromPointer: simpleReadValueFromPointer,\\\\\\\\\\\\\\\\n      destructorFunction(ptr) {\\\\\\\\\\\\\\\\n        _free(ptr);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_value_object(\\\\\\\\\\\\\\\\n    rawType,\\\\\\\\\\\\\\\\n    name,\\\\\\\\\\\\\\\\n    constructorSignature,\\\\\\\\\\\\\\\\n    rawConstructor,\\\\\\\\\\\\\\\\n    destructorSignature,\\\\\\\\\\\\\\\\n    rawDestructor\\\\\\\\\\\\\\\\n  ) {\\\\\\\\\\\\\\\\n    structRegistrations[rawType] = {\\\\\\\\\\\\\\\\n      name: readLatin1String(name),\\\\\\\\\\\\\\\\n      rawConstructor: embind__requireFunction(\\\\\\\\\\\\\\\\n        constructorSignature,\\\\\\\\\\\\\\\\n        rawConstructor\\\\\\\\\\\\\\\\n      ),\\\\\\\\\\\\\\\\n      rawDestructor: embind__requireFunction(\\\\\\\\\\\\\\\\n        destructorSignature,\\\\\\\\\\\\\\\\n        rawDestructor\\\\\\\\\\\\\\\\n      ),\\\\\\\\\\\\\\\\n      fields: [],\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_value_object_field(\\\\\\\\\\\\\\\\n    structType,\\\\\\\\\\\\\\\\n    fieldName,\\\\\\\\\\\\\\\\n    getterReturnType,\\\\\\\\\\\\\\\\n    getterSignature,\\\\\\\\\\\\\\\\n    getter,\\\\\\\\\\\\\\\\n    getterContext,\\\\\\\\\\\\\\\\n    setterArgumentType,\\\\\\\\\\\\\\\\n    setterSignature,\\\\\\\\\\\\\\\\n    setter,\\\\\\\\\\\\\\\\n    setterContext\\\\\\\\\\\\\\\\n  ) {\\\\\\\\\\\\\\\\n    structRegistrations[structType].fields.push({\\\\\\\\\\\\\\\\n      fieldName: readLatin1String(fieldName),\\\\\\\\\\\\\\\\n      getterReturnType,\\\\\\\\\\\\\\\\n      getter: embind__requireFunction(getterSignature, getter),\\\\\\\\\\\\\\\\n      getterContext,\\\\\\\\\\\\\\\\n      setterArgumentType,\\\\\\\\\\\\\\\\n      setter: embind__requireFunction(setterSignature, setter),\\\\\\\\\\\\\\\\n      setterContext,\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __embind_register_void(rawType, name) {\\\\\\\\\\\\\\\\n    name = readLatin1String(name);\\\\\\\\\\\\\\\\n    registerType(rawType, {\\\\\\\\\\\\\\\\n      isVoid: true,\\\\\\\\\\\\\\\\n      name,\\\\\\\\\\\\\\\\n      argPackAdvance: 0,\\\\\\\\\\\\\\\\n      fromWireType: function () {\\\\\\\\\\\\\\\\n        return undefined;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      toWireType: function (destructors, o) {\\\\\\\\\\\\\\\\n        return undefined;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __emscripten_date_now() {\\\\\\\\\\\\\\\\n    return Date.now();\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var nowIsMonotonic = true;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __emscripten_get_now_is_monotonic() {\\\\\\\\\\\\\\\\n    return nowIsMonotonic;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function requireRegisteredType(rawType, humanName) {\\\\\\\\\\\\\\\\n    var impl = registeredTypes[rawType];\\\\\\\\\\\\\\\\n    if (undefined === impl) {\\\\\\\\\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\\n        humanName + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" has unknown type \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + getTypeName(rawType)\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return impl;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __emval_lookupTypes(argCount, argTypes) {\\\\\\\\\\\\\\\\n    var a = new Array(argCount);\\\\\\\\\\\\\\\\n    for (var i = 0; i < argCount; ++i) {\\\\\\\\\\\\\\\\n      a[i] = requireRegisteredType(\\\\\\\\\\\\\\\\n        HEAP32[(argTypes >> 2) + i],\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"parameter \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + i\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return a;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __emval_call(handle, argCount, argTypes, argv) {\\\\\\\\\\\\\\\\n    handle = Emval.toValue(handle);\\\\\\\\\\\\\\\\n    var types = __emval_lookupTypes(argCount, argTypes);\\\\\\\\\\\\\\\\n    var args = new Array(argCount);\\\\\\\\\\\\\\\\n    for (var i = 0; i < argCount; ++i) {\\\\\\\\\\\\\\\\n      var type = types[i];\\\\\\\\\\\\\\\\n      args[i] = type.readValueFromPointer(argv);\\\\\\\\\\\\\\\\n      argv += type.argPackAdvance;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var rv = handle.apply(undefined, args);\\\\\\\\\\\\\\\\n    return Emval.toHandle(rv);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __emval_incref(handle) {\\\\\\\\\\\\\\\\n    if (handle > 4) {\\\\\\\\\\\\\\\\n      emval_handle_array[handle].refcount += 1;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __emval_take_value(type, argv) {\\\\\\\\\\\\\\\\n    type = requireRegisteredType(type, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"_emval_take_value\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    var v = type.readValueFromPointer(argv);\\\\\\\\\\\\\\\\n    return Emval.toHandle(v);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __localtime_js(time, tmPtr) {\\\\\\\\\\\\\\\\n    var date = new Date(HEAP32[time >> 2] * 1e3);\\\\\\\\\\\\\\\\n    HEAP32[tmPtr >> 2] = date.getSeconds();\\\\\\\\\\\\\\\\n    HEAP32[(tmPtr + 4) >> 2] = date.getMinutes();\\\\\\\\\\\\\\\\n    HEAP32[(tmPtr + 8) >> 2] = date.getHours();\\\\\\\\\\\\\\\\n    HEAP32[(tmPtr + 12) >> 2] = date.getDate();\\\\\\\\\\\\\\\\n    HEAP32[(tmPtr + 16) >> 2] = date.getMonth();\\\\\\\\\\\\\\\\n    HEAP32[(tmPtr + 20) >> 2] = date.getFullYear() - 1900;\\\\\\\\\\\\\\\\n    HEAP32[(tmPtr + 24) >> 2] = date.getDay();\\\\\\\\\\\\\\\\n    var start = new Date(date.getFullYear(), 0, 1);\\\\\\\\\\\\\\\\n    var yday = ((date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24)) | 0;\\\\\\\\\\\\\\\\n    HEAP32[(tmPtr + 28) >> 2] = yday;\\\\\\\\\\\\\\\\n    HEAP32[(tmPtr + 36) >> 2] = -(date.getTimezoneOffset() * 60);\\\\\\\\\\\\\\\\n    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\\\\\\\\\\\\\\\\n    var winterOffset = start.getTimezoneOffset();\\\\\\\\\\\\\\\\n    var dst =\\\\\\\\\\\\\\\\n      (summerOffset != winterOffset &&\\\\\\\\\\\\\\\\n        date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;\\\\\\\\\\\\\\\\n    HEAP32[(tmPtr + 32) >> 2] = dst;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __mmap_js(addr, len, prot, flags, fd, off, allocated, builtin) {\\\\\\\\\\\\\\\\n    return -52;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __munmap_js(addr, len, prot, flags, fd, offset) {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _tzset_impl(timezone, daylight, tzname) {\\\\\\\\\\\\\\\\n    var currentYear = new Date().getFullYear();\\\\\\\\\\\\\\\\n    var winter = new Date(currentYear, 0, 1);\\\\\\\\\\\\\\\\n    var summer = new Date(currentYear, 6, 1);\\\\\\\\\\\\\\\\n    var winterOffset = winter.getTimezoneOffset();\\\\\\\\\\\\\\\\n    var summerOffset = summer.getTimezoneOffset();\\\\\\\\\\\\\\\\n    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\\\\\\\\\\\\\\\\n    HEAP32[timezone >> 2] = stdTimezoneOffset * 60;\\\\\\\\\\\\\\\\n    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);\\\\\\\\\\\\\\\\n    function extractZone(date) {\\\\\\\\\\\\\\\\n      var match = date.toTimeString().match(/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\(([A-Za-z ]+)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)$/);\\\\\\\\\\\\\\\\n      return match ? match[1] : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"GMT\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var winterName = extractZone(winter);\\\\\\\\\\\\\\\\n    var summerName = extractZone(summer);\\\\\\\\\\\\\\\\n    var winterNamePtr = allocateUTF8(winterName);\\\\\\\\\\\\\\\\n    var summerNamePtr = allocateUTF8(summerName);\\\\\\\\\\\\\\\\n    if (summerOffset < winterOffset) {\\\\\\\\\\\\\\\\n      HEAP32[tzname >> 2] = winterNamePtr;\\\\\\\\\\\\\\\\n      HEAP32[(tzname + 4) >> 2] = summerNamePtr;\\\\\\\\\\\\\\\\n    } else {\\\\\\\\\\\\\\\\n      HEAP32[tzname >> 2] = summerNamePtr;\\\\\\\\\\\\\\\\n      HEAP32[(tzname + 4) >> 2] = winterNamePtr;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __tzset_js(timezone, daylight, tzname) {\\\\\\\\\\\\\\\\n    if (__tzset_js.called) {\\\\\\\\\\\\\\\\n      return;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    __tzset_js.called = true;\\\\\\\\\\\\\\\\n    _tzset_impl(timezone, daylight, tzname);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _abort() {\\\\\\\\\\\\\\\\n    abort(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var readAsmConstArgsArray = [];\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function readAsmConstArgs(sigPtr, buf) {\\\\\\\\\\\\\\\\n    readAsmConstArgsArray.length = 0;\\\\\\\\\\\\\\\\n    var ch;\\\\\\\\\\\\\\\\n    buf >>= 2;\\\\\\\\\\\\\\\\n    while ((ch = HEAPU8[sigPtr++])) {\\\\\\\\\\\\\\\\n      var readAsmConstArgsDouble = ch < 105;\\\\\\\\\\\\\\\\n      if (readAsmConstArgsDouble && buf & 1) {\\\\\\\\\\\\\\\\n        buf++;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      readAsmConstArgsArray.push(\\\\\\\\\\\\\\\\n        readAsmConstArgsDouble ? HEAPF64[buf++ >> 1] : HEAP32[buf]\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n      ++buf;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return readAsmConstArgsArray;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _emscripten_asm_const_int(code, sigPtr, argbuf) {\\\\\\\\\\\\\\\\n    var args = readAsmConstArgs(sigPtr, argbuf);\\\\\\\\\\\\\\\\n    return ASM_CONSTS[code].apply(null, args);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _emscripten_get_heap_max() {\\\\\\\\\\\\\\\\n    return 2147483648;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var _emscripten_get_now;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  _emscripten_get_now = () => performance.now();\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _emscripten_memcpy_big(dest, src, num) {\\\\\\\\\\\\\\\\n    HEAPU8.copyWithin(dest, src, src + num);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function emscripten_realloc_buffer(size) {\\\\\\\\\\\\\\\\n    try {\\\\\\\\\\\\\\\\n      wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16);\\\\\\\\\\\\\\\\n      updateGlobalBufferAndViews(wasmMemory.buffer);\\\\\\\\\\\\\\\\n      return 1;\\\\\\\\\\\\\\\\n    } catch (e) {}\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _emscripten_resize_heap(requestedSize) {\\\\\\\\\\\\\\\\n    var oldSize = HEAPU8.length;\\\\\\\\\\\\\\\\n    requestedSize = requestedSize >>> 0;\\\\\\\\\\\\\\\\n    var maxHeapSize = _emscripten_get_heap_max();\\\\\\\\\\\\\\\\n    if (requestedSize > maxHeapSize) {\\\\\\\\\\\\\\\\n      return false;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    let alignUp = (x, multiple) => x + ((multiple - (x % multiple)) % multiple);\\\\\\\\\\\\\\\\n    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\\\\\\\\\\\\\\\\n      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\\\\\\\\\\\\\\\\n      overGrownHeapSize = Math.min(\\\\\\\\\\\\\\\\n        overGrownHeapSize,\\\\\\\\\\\\\\\\n        requestedSize + 100663296\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n      var newSize = Math.min(\\\\\\\\\\\\\\\\n        maxHeapSize,\\\\\\\\\\\\\\\\n        alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n      var replacement = emscripten_realloc_buffer(newSize);\\\\\\\\\\\\\\\\n      if (replacement) {\\\\\\\\\\\\\\\\n        return true;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return false;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var ENV = {};\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function getExecutableName() {\\\\\\\\\\\\\\\\n    return thisProgram || \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"./this.program\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function getEnvStrings() {\\\\\\\\\\\\\\\\n    if (!getEnvStrings.strings) {\\\\\\\\\\\\\\\\n      var lang =\\\\\\\\\\\\\\\\n        (\\\\\\\\\\\\\\\\n          (typeof navigator == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" &&\\\\\\\\\\\\\\\\n            navigator.languages &&\\\\\\\\\\\\\\\\n            navigator.languages[0]) ||\\\\\\\\\\\\\\\\n          \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n        ).replace(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"-\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"_\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\".UTF-8\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n      var env = {\\\\\\\\\\\\\\\\n        USER: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"web_user\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n        LOGNAME: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"web_user\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n        PATH: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n        PWD: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n        HOME: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"/home/web_user\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n        LANG: lang,\\\\\\\\\\\\\\\\n        _: getExecutableName(),\\\\\\\\\\\\\\\\n      };\\\\\\\\\\\\\\\\n      for (var x in ENV) {\\\\\\\\\\\\\\\\n        if (ENV[x] === undefined) {\\\\\\\\\\\\\\\\n          delete env[x];\\\\\\\\\\\\\\\\n        } else {\\\\\\\\\\\\\\\\n          env[x] = ENV[x];\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      var strings = [];\\\\\\\\\\\\\\\\n      for (var x in env) {\\\\\\\\\\\\\\\\n        strings.push(x + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + env[x]);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      getEnvStrings.strings = strings;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return getEnvStrings.strings;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _environ_get(__environ, environ_buf) {\\\\\\\\\\\\\\\\n    var bufSize = 0;\\\\\\\\\\\\\\\\n    getEnvStrings().forEach(function (string, i) {\\\\\\\\\\\\\\\\n      var ptr = environ_buf + bufSize;\\\\\\\\\\\\\\\\n      HEAP32[(__environ + i * 4) >> 2] = ptr;\\\\\\\\\\\\\\\\n      writeAsciiToMemory(string, ptr);\\\\\\\\\\\\\\\\n      bufSize += string.length + 1;\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n    return 0;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _environ_sizes_get(penviron_count, penviron_buf_size) {\\\\\\\\\\\\\\\\n    var strings = getEnvStrings();\\\\\\\\\\\\\\\\n    HEAP32[penviron_count >> 2] = strings.length;\\\\\\\\\\\\\\\\n    var bufSize = 0;\\\\\\\\\\\\\\\\n    strings.forEach(function (string) {\\\\\\\\\\\\\\\\n      bufSize += string.length + 1;\\\\\\\\\\\\\\\\n    });\\\\\\\\\\\\\\\\n    HEAP32[penviron_buf_size >> 2] = bufSize;\\\\\\\\\\\\\\\\n    return 0;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _exit(status) {\\\\\\\\\\\\\\\\n    exit(status);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _fd_close(fd) {\\\\\\\\\\\\\\\\n    return 0;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _fd_read(fd, iov, iovcnt, pnum) {\\\\\\\\\\\\\\\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\\\\\\\\\\\\\\\n    var num = SYSCALLS.doReadv(stream, iov, iovcnt);\\\\\\\\\\\\\\\\n    HEAP32[pnum >> 2] = num;\\\\\\\\\\\\\\\\n    return 0;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _fd_write(fd, iov, iovcnt, pnum) {\\\\\\\\\\\\\\\\n    var num = 0;\\\\\\\\\\\\\\\\n    for (var i = 0; i < iovcnt; i++) {\\\\\\\\\\\\\\\\n      var ptr = HEAP32[iov >> 2];\\\\\\\\\\\\\\\\n      var len = HEAP32[(iov + 4) >> 2];\\\\\\\\\\\\\\\\n      iov += 8;\\\\\\\\\\\\\\\\n      for (var j = 0; j < len; j++) {\\\\\\\\\\\\\\\\n        SYSCALLS.printChar(fd, HEAPU8[ptr + j]);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      num += len;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    HEAP32[pnum >> 2] = num;\\\\\\\\\\\\\\\\n    return 0;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function getRandomDevice() {\\\\\\\\\\\\\\\\n    if (\\\\\\\\\\\\\\\\n      typeof crypto == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" &&\\\\\\\\\\\\\\\\n      typeof crypto.getRandomValues == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n    ) {\\\\\\\\\\\\\\\\n      var randomBuffer = new Uint8Array(1);\\\\\\\\\\\\\\\\n      return function () {\\\\\\\\\\\\\\\\n        crypto.getRandomValues(randomBuffer);\\\\\\\\\\\\\\\\n        return randomBuffer[0];\\\\\\\\\\\\\\\\n      };\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return function () {\\\\\\\\\\\\\\\\n      abort(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"randomDevice\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _getentropy(buffer, size) {\\\\\\\\\\\\\\\\n    if (!_getentropy.randomDevice) {\\\\\\\\\\\\\\\\n      _getentropy.randomDevice = getRandomDevice();\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    for (var i = 0; i < size; i++) {\\\\\\\\\\\\\\\\n      HEAP8[(buffer + i) >> 0] = _getentropy.randomDevice();\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return 0;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _pclose() {\\\\\\\\\\\\\\\\n    err(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"missing function: pclose\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    abort(-1);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _setTempRet0(val) {\\\\\\\\\\\\\\\\n    setTempRet0(val);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __isLeapYear(year) {\\\\\\\\\\\\\\\\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __arraySum(array, index) {\\\\\\\\\\\\\\\\n    var sum = 0;\\\\\\\\\\\\\\\\n    for (var i = 0; i <= index; sum += array[i++]) {}\\\\\\\\\\\\\\\\n    return sum;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function __addDays(date, days) {\\\\\\\\\\\\\\\\n    var newDate = new Date(date.getTime());\\\\\\\\\\\\\\\\n    while (days > 0) {\\\\\\\\\\\\\\\\n      var leap = __isLeapYear(newDate.getFullYear());\\\\\\\\\\\\\\\\n      var currentMonth = newDate.getMonth();\\\\\\\\\\\\\\\\n      var daysInCurrentMonth = (\\\\\\\\\\\\\\\\n        leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR\\\\\\\\\\\\\\\\n      )[currentMonth];\\\\\\\\\\\\\\\\n      if (days > daysInCurrentMonth - newDate.getDate()) {\\\\\\\\\\\\\\\\n        days -= daysInCurrentMonth - newDate.getDate() + 1;\\\\\\\\\\\\\\\\n        newDate.setDate(1);\\\\\\\\\\\\\\\\n        if (currentMonth < 11) {\\\\\\\\\\\\\\\\n          newDate.setMonth(currentMonth + 1);\\\\\\\\\\\\\\\\n        } else {\\\\\\\\\\\\\\\\n          newDate.setMonth(0);\\\\\\\\\\\\\\\\n          newDate.setFullYear(newDate.getFullYear() + 1);\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n      } else {\\\\\\\\\\\\\\\\n        newDate.setDate(newDate.getDate() + days);\\\\\\\\\\\\\\\\n        return newDate;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return newDate;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _strftime(s, maxsize, format, tm) {\\\\\\\\\\\\\\\\n    var tm_zone = HEAP32[(tm + 40) >> 2];\\\\\\\\\\\\\\\\n    var date = {\\\\\\\\\\\\\\\\n      tm_sec: HEAP32[tm >> 2],\\\\\\\\\\\\\\\\n      tm_min: HEAP32[(tm + 4) >> 2],\\\\\\\\\\\\\\\\n      tm_hour: HEAP32[(tm + 8) >> 2],\\\\\\\\\\\\\\\\n      tm_mday: HEAP32[(tm + 12) >> 2],\\\\\\\\\\\\\\\\n      tm_mon: HEAP32[(tm + 16) >> 2],\\\\\\\\\\\\\\\\n      tm_year: HEAP32[(tm + 20) >> 2],\\\\\\\\\\\\\\\\n      tm_wday: HEAP32[(tm + 24) >> 2],\\\\\\\\\\\\\\\\n      tm_yday: HEAP32[(tm + 28) >> 2],\\\\\\\\\\\\\\\\n      tm_isdst: HEAP32[(tm + 32) >> 2],\\\\\\\\\\\\\\\\n      tm_gmtoff: HEAP32[(tm + 36) >> 2],\\\\\\\\\\\\\\\\n      tm_zone: tm_zone ? UTF8ToString(tm_zone) : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    var pattern = UTF8ToString(format);\\\\\\\\\\\\\\\\n    var EXPANSION_RULES_1 = {\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%c\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%a %b %d %H:%M:%S %Y\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%D\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%m/%d/%y\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%F\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%Y-%m-%d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%h\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%r\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%I:%M:%S %p\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%R\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%H:%M\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%T\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%H:%M:%S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%x\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%m/%d/%y\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%X\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%H:%M:%S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%Ec\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%c\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%EC\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%Ex\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%m/%d/%y\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%EX\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%H:%M:%S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%Ey\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%y\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%EY\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%Y\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%Od\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%Oe\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%e\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%OH\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%H\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%OI\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%Om\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%m\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%OM\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%M\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%OS\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%Ou\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%u\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%OU\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%U\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%OV\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%V\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%Ow\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%w\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%OW\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%W\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%Oy\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%y\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    for (var rule in EXPANSION_RULES_1) {\\\\\\\\\\\\\\\\n      pattern = pattern.replace(new RegExp(rule, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"g\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"), EXPANSION_RULES_1[rule]);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var WEEKDAYS = [\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Sunday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Monday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Tuesday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Wednesday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Thursday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Friday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Saturday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n    ];\\\\\\\\\\\\\\\\n    var MONTHS = [\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"January\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"February\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"March\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"April\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"May\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"June\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"July\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"August\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"September\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"October\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"November\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"December\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n    ];\\\\\\\\\\\\\\\\n    function leadingSomething(value, digits, character) {\\\\\\\\\\\\\\\\n      var str = typeof value == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"number\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" ? value.toString() : value || \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n      while (str.length < digits) {\\\\\\\\\\\\\\\\n        str = character[0] + str;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      return str;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    function leadingNulls(value, digits) {\\\\\\\\\\\\\\\\n      return leadingSomething(value, digits, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    function compareByDay(date1, date2) {\\\\\\\\\\\\\\\\n      function sgn(value) {\\\\\\\\\\\\\\\\n        return value < 0 ? -1 : value > 0 ? 1 : 0;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      var compare;\\\\\\\\\\\\\\\\n      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\\\\\\\\\\\\\\\\n        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\\\\\\\\\\\\\\\\n          compare = sgn(date1.getDate() - date2.getDate());\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      return compare;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    function getFirstWeekStartDate(janFourth) {\\\\\\\\\\\\\\\\n      switch (janFourth.getDay()) {\\\\\\\\\\\\\\\\n        case 0:\\\\\\\\\\\\\\\\n          return new Date(janFourth.getFullYear() - 1, 11, 29);\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n        case 1:\\\\\\\\\\\\\\\\n          return janFourth;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n        case 2:\\\\\\\\\\\\\\\\n          return new Date(janFourth.getFullYear(), 0, 3);\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n        case 3:\\\\\\\\\\\\\\\\n          return new Date(janFourth.getFullYear(), 0, 2);\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n        case 4:\\\\\\\\\\\\\\\\n          return new Date(janFourth.getFullYear(), 0, 1);\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n        case 5:\\\\\\\\\\\\\\\\n          return new Date(janFourth.getFullYear() - 1, 11, 31);\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n        case 6:\\\\\\\\\\\\\\\\n          return new Date(janFourth.getFullYear() - 1, 11, 30);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    function getWeekBasedYear(date) {\\\\\\\\\\\\\\\\n      var thisDate = __addDays(\\\\\\\\\\\\\\\\n        new Date(date.tm_year + 1900, 0, 1),\\\\\\\\\\\\\\\\n        date.tm_yday\\\\\\\\\\\\\\\\n      );\\\\\\\\\\\\\\\\n      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\\\\\\\\\\\\\\\\n      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\\\\\\\\\\\\\\\\n      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\\\\\\\\\\\\\\\\n      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\\\\\\\\\\\\\\\\n      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\\\\\\\\\\\\\\\\n        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\\\\\\\\\\\\\\\\n          return thisDate.getFullYear() + 1;\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        return thisDate.getFullYear();\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      return thisDate.getFullYear() - 1;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    var EXPANSION_RULES_2 = {\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return WEEKDAYS[date.tm_wday].substring(0, 3);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%A\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return WEEKDAYS[date.tm_wday];\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return MONTHS[date.tm_mon].substring(0, 3);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%B\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return MONTHS[date.tm_mon];\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%C\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        var year = date.tm_year + 1900;\\\\\\\\\\\\\\\\n        return leadingNulls((year / 100) | 0, 2);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return leadingNulls(date.tm_mday, 2);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%e\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return leadingSomething(date.tm_mday, 2, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%g\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return getWeekBasedYear(date).toString().substring(2);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%G\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return getWeekBasedYear(date);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%H\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return leadingNulls(date.tm_hour, 2);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        var twelveHour = date.tm_hour;\\\\\\\\\\\\\\\\n        if (twelveHour == 0) {\\\\\\\\\\\\\\\\n          twelveHour = 12;\\\\\\\\\\\\\\\\n        } else if (twelveHour > 12) {\\\\\\\\\\\\\\\\n          twelveHour -= 12;\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        return leadingNulls(twelveHour, 2);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%j\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return leadingNulls(\\\\\\\\\\\\\\\\n          date.tm_mday +\\\\\\\\\\\\\\\\n            __arraySum(\\\\\\\\\\\\\\\\n              __isLeapYear(date.tm_year + 1900)\\\\\\\\\\\\\\\\n                ? __MONTH_DAYS_LEAP\\\\\\\\\\\\\\\\n                : __MONTH_DAYS_REGULAR,\\\\\\\\\\\\\\\\n              date.tm_mon - 1\\\\\\\\\\\\\\\\n            ),\\\\\\\\\\\\\\\\n          3\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%m\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return leadingNulls(date.tm_mon + 1, 2);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%M\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return leadingNulls(date.tm_min, 2);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function () {\\\\\\\\\\\\\\\\n        return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%p\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        if (date.tm_hour >= 0 && date.tm_hour < 12) {\\\\\\\\\\\\\\\\n          return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"AM\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"PM\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%S\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return leadingNulls(date.tm_sec, 2);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%t\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function () {\\\\\\\\\\\\\\\\n        return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\t\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%u\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return date.tm_wday || 7;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%U\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        var days = date.tm_yday + 7 - date.tm_wday;\\\\\\\\\\\\\\\\n        return leadingNulls(Math.floor(days / 7), 2);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%V\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        var val = Math.floor((date.tm_yday + 7 - ((date.tm_wday + 6) % 7)) / 7);\\\\\\\\\\\\\\\\n        if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\\\\\\\\\\\\\\\\n          val++;\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        if (!val) {\\\\\\\\\\\\\\\\n          val = 52;\\\\\\\\\\\\\\\\n          var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\\\\\\\\\\\\\\\\n          if (\\\\\\\\\\\\\\\\n            dec31 == 4 ||\\\\\\\\\\\\\\\\n            (dec31 == 5 && __isLeapYear((date.tm_year % 400) - 1))\\\\\\\\\\\\\\\\n          ) {\\\\\\\\\\\\\\\\n            val++;\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n        } else if (val == 53) {\\\\\\\\\\\\\\\\n          var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\\\\\\\\\\\\\\\\n          if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date.tm_year))) {\\\\\\\\\\\\\\\\n            val = 1;\\\\\\\\\\\\\\\\n          }\\\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\\\\n        return leadingNulls(val, 2);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%w\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return date.tm_wday;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%W\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);\\\\\\\\\\\\\\\\n        return leadingNulls(Math.floor(days / 7), 2);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%y\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return (date.tm_year + 1900).toString().substring(2);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%Y\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return date.tm_year + 1900;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%z\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        var off = date.tm_gmtoff;\\\\\\\\\\\\\\\\n        var ahead = off >= 0;\\\\\\\\\\\\\\\\n        off = Math.abs(off) / 60;\\\\\\\\\\\\\\\\n        off = (off / 60) * 100 + (off % 60);\\\\\\\\\\\\\\\\n        return (ahead ? \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"+\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"-\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") + String(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0000\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + off).slice(-4);\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%Z\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function (date) {\\\\\\\\\\\\\\\\n        return date.tm_zone;\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%%\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": function () {\\\\\\\\\\\\\\\\n        return \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n      },\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n    pattern = pattern.replace(/%%/g, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    for (var rule in EXPANSION_RULES_2) {\\\\\\\\\\\\\\\\n      if (pattern.includes(rule)) {\\\\\\\\\\\\\\\\n        pattern = pattern.replace(\\\\\\\\\\\\\\\\n          new RegExp(rule, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"g\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"),\\\\\\\\\\\\\\\\n          EXPANSION_RULES_2[rule](date)\\\\\\\\\\\\\\\\n        );\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    pattern = pattern.replace(/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\0/g, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"%\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n    var bytes = intArrayFromString(pattern, false);\\\\\\\\\\\\\\\\n    if (bytes.length > maxsize) {\\\\\\\\\\\\\\\\n      return 0;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    writeArrayToMemory(bytes, s);\\\\\\\\\\\\\\\\n    return bytes.length - 1;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function _strftime_l(s, maxsize, format, tm) {\\\\\\\\\\\\\\\\n    return _strftime(s, maxsize, format, tm);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  InternalError = Module.InternalError = extendError(Error, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"InternalError\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  embind_init_charCodes();\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  BindingError = Module.BindingError = extendError(Error, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"BindingError\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  init_ClassHandle();\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  init_embind();\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  init_RegisteredPointer();\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  UnboundTypeError = Module.UnboundTypeError = extendError(\\\\\\\\\\\\\\\\n    Error,\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"UnboundTypeError\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n  );\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  init_emval();\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function intArrayFromString(stringy, dontAddNull, length) {\\\\\\\\\\\\\\\\n    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\\\\\\\\\\\\\\\\n    var u8array = new Array(len);\\\\\\\\\\\\\\\\n    var numBytesWritten = stringToUTF8Array(\\\\\\\\\\\\\\\\n      stringy,\\\\\\\\\\\\\\\\n      u8array,\\\\\\\\\\\\\\\\n      0,\\\\\\\\\\\\\\\\n      u8array.length\\\\\\\\\\\\\\\\n    );\\\\\\\\\\\\\\\\n    if (dontAddNull) {\\\\\\\\\\\\\\\\n      u8array.length = numBytesWritten;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    return u8array;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var asmLibraryArg = {\\\\\\\\\\\\\\\\n    __assert_fail: ___assert_fail,\\\\\\\\\\\\\\\\n    __cxa_allocate_exception: ___cxa_allocate_exception,\\\\\\\\\\\\\\\\n    __cxa_rethrow: ___cxa_rethrow,\\\\\\\\\\\\\\\\n    __cxa_throw: ___cxa_throw,\\\\\\\\\\\\\\\\n    __syscall_faccessat: ___syscall_faccessat,\\\\\\\\\\\\\\\\n    __syscall_fcntl64: ___syscall_fcntl64,\\\\\\\\\\\\\\\\n    __syscall_fstat64: ___syscall_fstat64,\\\\\\\\\\\\\\\\n    __syscall_getcwd: ___syscall_getcwd,\\\\\\\\\\\\\\\\n    __syscall_ioctl: ___syscall_ioctl,\\\\\\\\\\\\\\\\n    __syscall_lstat64: ___syscall_lstat64,\\\\\\\\\\\\\\\\n    __syscall_newfstatat: ___syscall_newfstatat,\\\\\\\\\\\\\\\\n    __syscall_openat: ___syscall_openat,\\\\\\\\\\\\\\\\n    __syscall_renameat: ___syscall_renameat,\\\\\\\\\\\\\\\\n    __syscall_rmdir: ___syscall_rmdir,\\\\\\\\\\\\\\\\n    __syscall_stat64: ___syscall_stat64,\\\\\\\\\\\\\\\\n    __syscall_unlinkat: ___syscall_unlinkat,\\\\\\\\\\\\\\\\n    _embind_finalize_value_object: __embind_finalize_value_object,\\\\\\\\\\\\\\\\n    _embind_register_bigint: __embind_register_bigint,\\\\\\\\\\\\\\\\n    _embind_register_bool: __embind_register_bool,\\\\\\\\\\\\\\\\n    _embind_register_class: __embind_register_class,\\\\\\\\\\\\\\\\n    _embind_register_class_constructor: __embind_register_class_constructor,\\\\\\\\\\\\\\\\n    _embind_register_class_function: __embind_register_class_function,\\\\\\\\\\\\\\\\n    _embind_register_emval: __embind_register_emval,\\\\\\\\\\\\\\\\n    _embind_register_float: __embind_register_float,\\\\\\\\\\\\\\\\n    _embind_register_integer: __embind_register_integer,\\\\\\\\\\\\\\\\n    _embind_register_memory_view: __embind_register_memory_view,\\\\\\\\\\\\\\\\n    _embind_register_smart_ptr: __embind_register_smart_ptr,\\\\\\\\\\\\\\\\n    _embind_register_std_string: __embind_register_std_string,\\\\\\\\\\\\\\\\n    _embind_register_std_wstring: __embind_register_std_wstring,\\\\\\\\\\\\\\\\n    _embind_register_value_object: __embind_register_value_object,\\\\\\\\\\\\\\\\n    _embind_register_value_object_field: __embind_register_value_object_field,\\\\\\\\\\\\\\\\n    _embind_register_void: __embind_register_void,\\\\\\\\\\\\\\\\n    _emscripten_date_now: __emscripten_date_now,\\\\\\\\\\\\\\\\n    _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,\\\\\\\\\\\\\\\\n    _emval_call: __emval_call,\\\\\\\\\\\\\\\\n    _emval_decref: __emval_decref,\\\\\\\\\\\\\\\\n    _emval_incref: __emval_incref,\\\\\\\\\\\\\\\\n    _emval_take_value: __emval_take_value,\\\\\\\\\\\\\\\\n    _localtime_js: __localtime_js,\\\\\\\\\\\\\\\\n    _mmap_js: __mmap_js,\\\\\\\\\\\\\\\\n    _munmap_js: __munmap_js,\\\\\\\\\\\\\\\\n    _tzset_js: __tzset_js,\\\\\\\\\\\\\\\\n    abort: _abort,\\\\\\\\\\\\\\\\n    emscripten_asm_const_int: _emscripten_asm_const_int,\\\\\\\\\\\\\\\\n    emscripten_get_heap_max: _emscripten_get_heap_max,\\\\\\\\\\\\\\\\n    emscripten_get_now: _emscripten_get_now,\\\\\\\\\\\\\\\\n    emscripten_memcpy_big: _emscripten_memcpy_big,\\\\\\\\\\\\\\\\n    emscripten_resize_heap: _emscripten_resize_heap,\\\\\\\\\\\\\\\\n    environ_get: _environ_get,\\\\\\\\\\\\\\\\n    environ_sizes_get: _environ_sizes_get,\\\\\\\\\\\\\\\\n    exit: _exit,\\\\\\\\\\\\\\\\n    fd_close: _fd_close,\\\\\\\\\\\\\\\\n    fd_read: _fd_read,\\\\\\\\\\\\\\\\n    fd_seek: _fd_seek,\\\\\\\\\\\\\\\\n    fd_write: _fd_write,\\\\\\\\\\\\\\\\n    getentropy: _getentropy,\\\\\\\\\\\\\\\\n    memory: wasmMemory,\\\\\\\\\\\\\\\\n    pclose: _pclose,\\\\\\\\\\\\\\\\n    setTempRet0: _setTempRet0,\\\\\\\\\\\\\\\\n    strftime_l: _strftime_l,\\\\\\\\\\\\\\\\n  };\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var asm = createWasm();\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  var calledRun;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function ExitStatus(status) {\\\\\\\\\\\\\\\\n    this.name = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ExitStatus\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    this.message = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Program terminated with exit(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" + status + \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n    this.status = status;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  dependenciesFulfilled = function runCaller() {\\\\\\\\\\\\\\\\n    if (!calledRun) {\\\\\\\\\\\\\\\\n      run();\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (!calledRun) {\\\\\\\\\\\\\\\\n      dependenciesFulfilled = runCaller;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  };\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function run(args) {\\\\\\\\\\\\\\\\n    args = args || arguments_;\\\\\\\\\\\\\\\\n    if (runDependencies > 0) {\\\\\\\\\\\\\\\\n      return;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    preRun();\\\\\\\\\\\\\\\\n    if (runDependencies > 0) {\\\\\\\\\\\\\\\\n      return;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    function doRun() {\\\\\\\\\\\\\\\\n      if (calledRun) {\\\\\\\\\\\\\\\\n        return;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      calledRun = true;\\\\\\\\\\\\\\\\n      Module.calledRun = true;\\\\\\\\\\\\\\\\n      if (ABORT) {\\\\\\\\\\\\\\\\n        return;\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      initRuntime();\\\\\\\\\\\\\\\\n      if (Module.onRuntimeInitialized) {\\\\\\\\\\\\\\\\n        Module.onRuntimeInitialized();\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      postRun();\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    if (Module.setStatus) {\\\\\\\\\\\\\\\\n      Module.setStatus(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Running...\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n      setTimeout(function () {\\\\\\\\\\\\\\\\n        setTimeout(function () {\\\\\\\\\\\\\\\\n          Module.setStatus(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\");\\\\\\\\\\\\\\\\n        }, 1);\\\\\\\\\\\\\\\\n        doRun();\\\\\\\\\\\\\\\\n      }, 1);\\\\\\\\\\\\\\\\n    } else {\\\\\\\\\\\\\\\\n      doRun();\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  Module.run = run;\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function exit(status, implicit) {\\\\\\\\\\\\\\\\n    EXITSTATUS = status;\\\\\\\\\\\\\\\\n    procExit(status);\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  function procExit(code) {\\\\\\\\\\\\\\\\n    EXITSTATUS = code;\\\\\\\\\\\\\\\\n    if (!keepRuntimeAlive()) {\\\\\\\\\\\\\\\\n      if (Module.onExit) {\\\\\\\\\\\\\\\\n        Module.onExit(code);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n      ABORT = true;\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    quit_(code, new ExitStatus(code));\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  if (Module.preInit) {\\\\\\\\\\\\\\\\n    if (typeof Module.preInit == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\") {\\\\\\\\\\\\\\\\n      Module.preInit = [Module.preInit];\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    while (Module.preInit.length) {\\\\\\\\\\\\\\\\n      Module.preInit.pop()();\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  run();\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  /* Use an optimized gemm implementation if available, otherwise use the fallback\\\\\\\\\\\\\\\\n   * implementation.\\\\\\\\\\\\\\\\n   */\\\\\\\\\\\\\\\\n  function createWasmGemm() {\\\\\\\\\\\\\\\\n    // A map of expected gemm function to the corresponding fallback gemm function names.\\\\\\\\\\\\\\\\n    const GEMM_TO_FALLBACK_FUNCTIONS_MAP = {\\\\\\\\\\\\\\\\n      int8_prepare_a: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"int8PrepareAFallback\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      int8_prepare_b: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"int8PrepareBFallback\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      int8_prepare_b_from_transposed: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"int8PrepareBFromTransposedFallback\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      int8_prepare_b_from_quantized_transposed:\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"int8PrepareBFromQuantizedTransposedFallback\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      int8_prepare_bias: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"int8PrepareBiasFallback\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      int8_multiply_and_add_bias: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"int8MultiplyAndAddBiasFallback\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n      int8_select_columns_of_b: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"int8SelectColumnsOfBFallback\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\",\\\\\\\\\\\\\\\\n    };\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    // Name of the optimized gemm implementation.\\\\\\\\\\\\\\\\n    const OPTIMIZED_GEMM = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"mozIntGemm\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    const optimizedGemmModule = WebAssembly[OPTIMIZED_GEMM];\\\\\\\\\\\\\\\\n    if (!optimizedGemmModule) {\\\\\\\\\\\\\\\\n      return fallbackGemm(GEMM_TO_FALLBACK_FUNCTIONS_MAP);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    const optimizedGemmModuleExports = new WebAssembly.Instance(\\\\\\\\\\\\\\\\n      optimizedGemmModule(),\\\\\\\\\\\\\\\\n      { \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": { memory: wasmMemory } }\\\\\\\\\\\\\\\\n    ).exports;\\\\\\\\\\\\\\\\n    for (let key in GEMM_TO_FALLBACK_FUNCTIONS_MAP) {\\\\\\\\\\\\\\\\n      if (!optimizedGemmModuleExports[key]) {\\\\\\\\\\\\\\\\n        return fallbackGemm(GEMM_TO_FALLBACK_FUNCTIONS_MAP);\\\\\\\\\\\\\\\\n      }\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    Module.print(`Using optimized gemm (${OPTIMIZED_GEMM}) implementation`);\\\\\\\\\\\\\\\\n    return optimizedGemmModuleExports;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  // Return the fallback gemm implementation.\\\\\\\\\\\\\\\\n  function fallbackGemm(gemmToFallbackFunctionsMap) {\\\\\\\\\\\\\\\\n    // The fallback gemm implementation\\\\\\\\\\\\\\\\n    const FALLBACK_GEMM = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"asm\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\";\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    let fallbackGemmModuleExports = {};\\\\\\\\\\\\\\\\n    for (let key in gemmToFallbackFunctionsMap) {\\\\\\\\\\\\\\\\n      fallbackGemmModuleExports[key] = (...a) =>\\\\\\\\\\\\\\\\n        Module[FALLBACK_GEMM][gemmToFallbackFunctionsMap[key]](...a);\\\\\\\\\\\\\\\\n    }\\\\\\\\\\\\\\\\n    Module.print(`Using fallback gemm implementation`);\\\\\\\\\\\\\\\\n    return fallbackGemmModuleExports;\\\\\\\\\\\\\\\\n  }\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n  return Module;\\\\\\\\\\\\\\\\n}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js?./node_modules/raw-loader/index.js\\\\\\\");\\\\n\\\\n/***/ }),\\\\n\\\\n/***/ \\\\\\\"./node_modules/script-loader/addScript.js\\\\\\\":\\\\n/*!*************************************************!*\\\\\\\\\\\\n  !*** ./node_modules/script-loader/addScript.js ***!\\\\n  \\\\\\\\*************************************************/\\\\n/***/ ((module) => {\\\\n\\\\neval(\\\\\\\"/*\\\\\\\\n\\\\\\\\tMIT License http://www.opensource.org/licenses/mit-license.php\\\\\\\\n\\\\\\\\tAuthor Tobias Koppers @sokra\\\\\\\\n*/\\\\\\\\nmodule.exports = function(src) {\\\\\\\\n\\\\\\\\tfunction log(error) {\\\\\\\\n\\\\\\\\t\\\\\\\\t(typeof console !== \\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\t\\\\\\\\t&& (console.error || console.log)(\\\\\\\\\\\\\\\"[Script Loader]\\\\\\\\\\\\\\\", error);\\\\\\\\n\\\\\\\\t}\\\\\\\\n\\\\\\\\n\\\\\\\\t// Check for IE =< 8\\\\\\\\n\\\\\\\\tfunction isIE() {\\\\\\\\n\\\\\\\\t\\\\\\\\treturn typeof attachEvent !== \\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\" && typeof addEventListener === \\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\t}\\\\\\\\n\\\\\\\\n\\\\\\\\ttry {\\\\\\\\n\\\\\\\\t\\\\\\\\tif (typeof execScript !== \\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\" && isIE()) {\\\\\\\\n\\\\\\\\t\\\\\\\\t\\\\\\\\texecScript(src);\\\\\\\\n\\\\\\\\t\\\\\\\\t} else if (typeof eval !== \\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\") {\\\\\\\\n\\\\\\\\t\\\\\\\\t\\\\\\\\teval.call(null, src);\\\\\\\\n\\\\\\\\t\\\\\\\\t} else {\\\\\\\\n\\\\\\\\t\\\\\\\\t\\\\\\\\tlog(\\\\\\\\\\\\\\\"EvalError: No eval function available\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\t\\\\\\\\t}\\\\\\\\n\\\\\\\\t} catch (error) {\\\\\\\\n\\\\\\\\t\\\\\\\\tlog(error);\\\\\\\\n\\\\\\\\t}\\\\\\\\n}\\\\\\\\n\\\\\\\\n\\\\\\\\n//# sourceURL=webpack://firefox-ios/./node_modules/script-loader/addScript.js?\\\\\\\");\\\\n\\\\n/***/ }),\\\\n\\\\n/***/ \\\\\\\"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js\\\\\\\":\\\\n/*!**********************************************************************************************************!*\\\\\\\\\\\\n  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js ***!\\\\n  \\\\\\\\**********************************************************************************************************/\\\\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {\\\\n\\\\neval(\\\\\\\"__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \\\\\\\\\\\\\\\"./node_modules/script-loader/addScript.js\\\\\\\\\\\\\\\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js */ \\\\\\\\\\\\\\\"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js\\\\\\\\\\\\\\\"))\\\\\\\\n\\\\\\\\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js?./node_modules/script-loader/index.js\\\\\\\");\\\\n\\\\n/***/ })\\\\n\\\\n/******/ \\\\t});\\\\n/************************************************************************/\\\\n/******/ \\\\t// The module cache\\\\n/******/ \\\\tvar __webpack_module_cache__ = {};\\\\n/******/ \\\\t\\\\n/******/ \\\\t// The require function\\\\n/******/ \\\\tfunction __webpack_require__(moduleId) {\\\\n/******/ \\\\t\\\\t// Check if module is in cache\\\\n/******/ \\\\t\\\\tvar cachedModule = __webpack_module_cache__[moduleId];\\\\n/******/ \\\\t\\\\tif (cachedModule !== undefined) {\\\\n/******/ \\\\t\\\\t\\\\treturn cachedModule.exports;\\\\n/******/ \\\\t\\\\t}\\\\n/******/ \\\\t\\\\t// Create a new module (and put it into the cache)\\\\n/******/ \\\\t\\\\tvar module = __webpack_module_cache__[moduleId] = {\\\\n/******/ \\\\t\\\\t\\\\t// no module.id needed\\\\n/******/ \\\\t\\\\t\\\\t// no module.loaded needed\\\\n/******/ \\\\t\\\\t\\\\texports: {}\\\\n/******/ \\\\t\\\\t};\\\\n/******/ \\\\t\\\\n/******/ \\\\t\\\\t// Execute the module function\\\\n/******/ \\\\t\\\\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\\\\n/******/ \\\\t\\\\n/******/ \\\\t\\\\t// Return the exports of the module\\\\n/******/ \\\\t\\\\treturn module.exports;\\\\n/******/ \\\\t}\\\\n/******/ \\\\t\\\\n/************************************************************************/\\\\n/******/ \\\\t\\\\n/******/ \\\\t// startup\\\\n/******/ \\\\t// Load entry module and return exports\\\\n/******/ \\\\t// This entry module can't be inlined because the eval devtool is used.\\\\n/******/ \\\\tvar __webpack_exports__ = __webpack_require__(\\\\\\\"./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[1].use[1]!./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js\\\\\\\");\\\\n/******/ \\\\t\\\\n/******/ })()\\\\n;\\\", \\\"Worker\\\", undefined, undefined);\\n}\\n\"\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js?./node_modules/raw-loader/index.js!./node_modules/worker-loader/dist/cjs.js??ruleSet%5B1%5D.rules%5B1%5D.use%5B0%5D!./node_modules/babel-loader/lib/index.js??ruleSet%5B1%5D.rules%5B1%5D.use%5B1%5D");

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== \"undefined\")\n\t\t&& (console.error || console.log)(\"[Script Loader]\", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== \"undefined\" && typeof addEventListener === \"undefined\";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== \"undefined\" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== \"undefined\") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog(\"EvalError: No eval function available\");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n\n\n//# sourceURL=webpack://firefox-ios/./node_modules/script-loader/addScript.js?");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressParser.sys.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressParser.sys.mjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressParser.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressParser.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressParser.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AutofillFormFactory.sys.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AutofillFormFactory.sys.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AutofillFormFactory.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AutofillFormFactory.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AutofillFormFactory.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CC_Python_Update.py":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CC_Python_Update.py ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CC_Python_Update.py */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CC_Python_Update.py\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/CC_Python_Update.py?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs":
/*!******************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/EmptyModule.sys.mjs":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/EmptyModule.sys.mjs ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/EmptyModule.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/EmptyModule.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/EmptyModule.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs":
/*!********************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs":
/*!********************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs":
/*!******************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginFormFactory.sys.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginFormFactory.sys.mjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginFormFactory.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginFormFactory.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/LoginFormFactory.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginFormState.sys.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginFormState.sys.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginFormState.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginFormState.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/LoginFormState.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.sys.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.sys.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/NewPasswordModel.sys.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/NewPasswordModel.sys.mjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/NewPasswordModel.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/NewPasswordModel.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/NewPasswordModel.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PasswordGenerator.sys.mjs":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PasswordGenerator.sys.mjs ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PasswordGenerator.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PasswordGenerator.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PasswordGenerator.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PasswordRulesParser.sys.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PasswordRulesParser.sys.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PasswordRulesParser.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PasswordRulesParser.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PasswordRulesParser.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/TranslationsHelpers.ios.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/TranslationsHelpers.ios.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/TranslationsHelpers.ios.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/TranslationsHelpers.ios.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/TranslationsHelpers.ios.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/TranslationsUtils.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/TranslationsUtils.mjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/TranslationsUtils.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/TranslationsUtils.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/TranslationsUtils.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/addressFormLayout.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/addressFormLayout.mjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/addressFormLayout.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/addressFormLayout.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/addressFormLayout.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/fathom.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/fathom.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/fathom.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/fathom.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/fathom.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-document.sys.mjs":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-document.sys.mjs ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-document.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-document.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/translations-document.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-engine.sys.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-engine.sys.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-engine.sys.mjs */ \"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-engine.sys.mjs\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/translations-engine.sys.mjs?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./node_modules/worker-loader/dist/cjs.js??ruleSet[1].rules[1].use[0]!./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[1].use[1]!./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js */ \"./node_modules/raw-loader/index.js!./node_modules/worker-loader/dist/cjs.js??ruleSet[1].rules[1].use[0]!./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[1].use[1]!./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js\"))\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js?./node_modules/script-loader/index.js");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js":
/*!***************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar worker = __webpack_require__(/*! !!../../../../node_modules/worker-loader/dist/runtime/inline.js */ \"./node_modules/worker-loader/dist/runtime/inline.js\");\n\nmodule.exports = function Worker_fn() {\n  return worker(\"/*\\n * ATTENTION: The \\\"eval\\\" devtool has been used (maybe by default in mode: \\\"development\\\").\\n * This devtool is neither made for production nor for readable output files.\\n * It uses \\\"eval()\\\" calls to create a separate source file in the browser devtools.\\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\\n * or disable the default devtool with \\\"devtool: false\\\".\\n * If you are looking for production-ready output files, see mode: \\\"production\\\" (https://webpack.js.org/configuration/mode/).\\n */\\n/******/ (() => { // webpackBootstrap\\n/******/ \\tvar __webpack_modules__ = ({\\n\\n/***/ \\\"./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[1].use[1]!./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js\\\":\\n/*!************************************************************************************************************************************************!*\\\\\\n  !*** ./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[1].use[1]!./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js ***!\\n  \\\\************************************************************************************************************************************************/\\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {\\n\\n\\\"use strict\\\";\\neval(\\\"/* This Source Code Form is subject to the terms of the Mozilla Public\\\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\\\n\\\\n\\\\n\\\\n/**\\\\n * @typedef {import(\\\\\\\"../translations\\\\\\\").Bergamot} Bergamot\\\\n * @typedef {import(\\\\\\\"../translations\\\\\\\").TranslationModelPayload} TranslationModelPayload\\\\n * @typedef {import(\\\\\\\"../translations\\\\\\\").LanguageTranslationModelFiles} LanguageTranslationModelFiles\\\\n */\\\\n\\\\n/* global loadBergamot */\\\\n__webpack_require__(/*! script-loader!./bergamot-translator.js */ \\\\\\\"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js\\\\\\\");\\\\n\\\\n// TODO(Issam): tmp fix should be in shims file.\\\\nconst ChromeUtils = {\\\\n  addProfilerMarker: () => {},\\\\n  now: () => performance.now()\\\\n};\\\\n\\\\n// Respect the preference \\\\\\\"browser.translations.logLevel\\\\\\\".\\\\nlet _loggingLevel = \\\\\\\"Error\\\\\\\";\\\\nfunction log(...args) {\\\\n  if (_loggingLevel !== \\\\\\\"Error\\\\\\\" && _loggingLevel !== \\\\\\\"Warn\\\\\\\") {\\\\n    console.log(\\\\\\\"Translations:\\\\\\\", ...args);\\\\n  }\\\\n}\\\\nfunction trace(...args) {\\\\n  if (_loggingLevel === \\\\\\\"Trace\\\\\\\" || _loggingLevel === \\\\\\\"All\\\\\\\") {\\\\n    console.log(\\\\\\\"Translations:\\\\\\\", ...args);\\\\n  }\\\\n}\\\\n\\\\n// Throw Promise rejection errors so that they are visible in the console.\\\\nself.addEventListener(\\\\\\\"unhandledrejection\\\\\\\", event => {\\\\n  throw event.reason;\\\\n});\\\\n\\\\n/**\\\\n * The alignment for each file type, file type strings should be same as in the\\\\n * model registry.\\\\n */\\\\nconst MODEL_FILE_ALIGNMENTS = {\\\\n  model: 256,\\\\n  lex: 64,\\\\n  vocab: 64,\\\\n  qualityModel: 64,\\\\n  srcvocab: 64,\\\\n  trgvocab: 64\\\\n};\\\\n\\\\n/**\\\\n * This regex matches the whitespace before and after a text, so that it is preserved.\\\\n */\\\\nconst WHITESPACE_REGEX = /^(\\\\\\\\s*)(.*?)(\\\\\\\\s*)$/s;\\\\n//                                         /s  Include newlines in .*\\\\n//                         (^^^)     (^^^)     Match the whitespace at the beginning and end.\\\\n//                              (^^^)          Non-greedily match the text (including newlines).\\\\n\\\\n/**\\\\n * At the time of writing, the Intl.Segmenter has a less-than-ideal segmentation pattern when\\\\n * a Left Double Quotation Mark (U+201C) is preceded by a full-width punctuation mark, in which\\\\n * it fails to segment the quotation mark with the sentence it logically belongs to.\\\\n *\\\\n * Example Source Text:\\\\n *   - 这是第一句话。“这是第二句话。”\\\\n *\\\\n * Expected Segmentation:\\\\n *   - Object { index: 0, segment: 这是第一句话。 }\\\\n *   - Object { index: 7, segment: “这是第二句话。” }\\\\n *\\\\n * Actual Segmentation:\\\\n *   - Object { index: 0, segment: 这是第一句话。“ }\\\\n *   - Object { index: 8, segment: 这是第二句话。” }\\\\n *\\\\n * By inserting a space between the full-width punctuation and the Left Double Quotation Mark,\\\\n * we can trick the segmenter into breaking the sentence at the correct location.\\\\n *\\\\n * This code may be able to be removed with further upstream improvements to Intl.Segmenter.\\\\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter\\\\n */\\\\nconst FULL_WIDTH_PUNCTUATION_REGEX = /([。！？])“/g;\\\\n\\\\n/**\\\\n * A list of languages that utilize full-width punctuation as described by the regex above.\\\\n * https://www.unicode.org/charts/PDF/U3000.pdf\\\\n *\\\\n * @see {FULL_WIDTH_PUNCTUATION_REGEX}\\\\n */\\\\nconst FULL_WIDTH_PUNCTUATION_LANGUAGE_TAGS = [\\\\\\\"ja\\\\\\\", \\\\\\\"ko\\\\\\\", \\\\\\\"zh\\\\\\\"];\\\\n\\\\n/**\\\\n * Do any cleaning steps for the text that are required before sending it into\\\\n * the translation engine.\\\\n *\\\\n * @param {string} sourceLanguage - The BCP-47 language tag for the source language.\\\\n * @param {string} sourceText - The source text to be cleaned.\\\\n * @returns {{ whitespaceBefore: string, whitespaceAfter: string, cleanedSourceText: string }}\\\\n */\\\\nfunction cleanText(sourceLanguage, sourceText) {\\\\n  // Whitespace at the beginning or end can confuse translations, but can affect the\\\\n  // presentation of the final result.\\\\n  const result = WHITESPACE_REGEX.exec(sourceText);\\\\n  if (!result) {\\\\n    throw new Error(\\\\\\\"The whitespace regex should always return a result.\\\\\\\");\\\\n  }\\\\n  const whitespaceBefore = result[1];\\\\n  const whitespaceAfter = result[3];\\\\n  let cleanedSourceText = result[2];\\\\n\\\\n  // Remove any soft hyphens, as they will break tokenization.\\\\n  cleanedSourceText = cleanedSourceText.replaceAll(\\\\\\\"\\\\\\\\u00AD\\\\\\\", \\\\\\\"\\\\\\\");\\\\n  if (FULL_WIDTH_PUNCTUATION_LANGUAGE_TAGS.includes(sourceLanguage)) {\\\\n    // Add a space to full-width punctuation when it precedes a Left Double Quotation Mark\\\\n    // (U+201C) to trick the Intl.Segmenter algorithm into breaking a sentence there.\\\\n    /** @see {FULL_WIDTH_PUNCTUATION_REGEX} for a detailed description. */\\\\n    cleanedSourceText = cleanedSourceText.replaceAll(FULL_WIDTH_PUNCTUATION_REGEX, \\\\\\\"$1 “\\\\\\\");\\\\n  }\\\\n  return {\\\\n    whitespaceBefore,\\\\n    whitespaceAfter,\\\\n    cleanedSourceText\\\\n  };\\\\n}\\\\n\\\\n/**\\\\n * Initialize the engine, and get it ready to handle translation requests.\\\\n * The \\\\\\\"initialize\\\\\\\" message must be received before any other message handling\\\\n * requests will be processed.\\\\n */\\\\naddEventListener(\\\\\\\"message\\\\\\\", handleInitializationMessage);\\\\nasync function handleInitializationMessage({\\\\n  data\\\\n}) {\\\\n  const startTime = ChromeUtils.now();\\\\n  if (data.type !== \\\\\\\"initialize\\\\\\\") {\\\\n    console.error(\\\\\\\"The TranslationEngine worker received a message before it was initialized.\\\\\\\");\\\\n    return;\\\\n  }\\\\n  try {\\\\n    const {\\\\n      sourceLanguage,\\\\n      targetLanguage,\\\\n      enginePayload,\\\\n      logLevel,\\\\n      innerWindowId\\\\n    } = data;\\\\n    if (!sourceLanguage) {\\\\n      throw new Error('Worker initialization missing \\\\\\\"sourceLanguage\\\\\\\"');\\\\n    }\\\\n    if (!targetLanguage) {\\\\n      throw new Error('Worker initialization missing \\\\\\\"targetLanguage\\\\\\\"');\\\\n    }\\\\n    if (logLevel) {\\\\n      // Respect the \\\\\\\"browser.translations.logLevel\\\\\\\" preference.\\\\n      _loggingLevel = logLevel;\\\\n    }\\\\n    let engine;\\\\n    if (enginePayload.isMocked) {\\\\n      // The engine is testing mode, and no Bergamot wasm is available.\\\\n      engine = new MockedEngine(sourceLanguage, targetLanguage);\\\\n    } else {\\\\n      const {\\\\n        bergamotWasmArrayBuffer,\\\\n        translationModelPayloads\\\\n      } = enginePayload;\\\\n      const bergamot = await BergamotUtils.initializeWasm(bergamotWasmArrayBuffer);\\\\n      engine = new Engine(sourceLanguage, targetLanguage, bergamot, translationModelPayloads);\\\\n\\\\n      // Ensure that no memory is leaked by transfering the ArrayBuffers. They should\\\\n      // all be loaded into Wasm memory at this time. The emscripten generated code\\\\n      // appears to retain the Wasm ArrayBuffer. The transfer creates a new JS object\\\\n      // that gains ownership of the original buffer, allowing it to be GCed even\\\\n      // if the original ArrayBuffer object is retained.\\\\n      //\\\\n      // There is no evidence the language model files are retained, but this will\\\\n      // absolutely ensure we don't leak this large files.\\\\n      bergamotWasmArrayBuffer.transfer();\\\\n      for (const {\\\\n        languageModelFiles\\\\n      } of translationModelPayloads) {\\\\n        for (const file of Object.values(languageModelFiles)) {\\\\n          file.buffer.transfer();\\\\n        }\\\\n      }\\\\n    }\\\\n    ChromeUtils.addProfilerMarker(\\\\\\\"TranslationsWorker\\\\\\\", {\\\\n      startTime,\\\\n      innerWindowId\\\\n    }, \\\\\\\"Translations engine loaded.\\\\\\\");\\\\n    handleMessages(engine);\\\\n    postMessage({\\\\n      type: \\\\\\\"initialization-success\\\\\\\"\\\\n    });\\\\n  } catch (error) {\\\\n    console.error(error);\\\\n    postMessage({\\\\n      type: \\\\\\\"initialization-error\\\\\\\",\\\\n      error: error?.message\\\\n    });\\\\n  }\\\\n  removeEventListener(\\\\\\\"message\\\\\\\", handleInitializationMessage);\\\\n}\\\\n\\\\n/**\\\\n * Sets up the message handling for the worker.\\\\n *\\\\n * @param {Engine | MockedEngine} engine\\\\n */\\\\nfunction handleMessages(engine) {\\\\n  let discardPromise;\\\\n  addEventListener(\\\\\\\"message\\\\\\\", async ({\\\\n    data\\\\n  }) => {\\\\n    try {\\\\n      if (data.type === \\\\\\\"initialize\\\\\\\") {\\\\n        throw new Error(\\\\\\\"The Translations engine must not be re-initialized.\\\\\\\");\\\\n      }\\\\n      if (data.type === \\\\\\\"translation-request\\\\\\\") {\\\\n        // Only show these messages when \\\\\\\"All\\\\\\\" logging is on, since there are so many\\\\n        // of them.\\\\n        trace(\\\\\\\"Received message\\\\\\\", data);\\\\n      } else {\\\\n        log(\\\\\\\"Received message\\\\\\\", data);\\\\n      }\\\\n      switch (data.type) {\\\\n        case \\\\\\\"translation-request\\\\\\\":\\\\n          {\\\\n            const {\\\\n              sourceText,\\\\n              messageId,\\\\n              translationId,\\\\n              isHTML,\\\\n              innerWindowId\\\\n            } = data;\\\\n            if (discardPromise) {\\\\n              // Wait for messages to be discarded if there are any.\\\\n              await discardPromise;\\\\n            }\\\\n            try {\\\\n              const {\\\\n                whitespaceBefore,\\\\n                whitespaceAfter,\\\\n                cleanedSourceText\\\\n              } = cleanText(engine.sourceLanguage, sourceText);\\\\n\\\\n              // Add a translation to the work queue, and when it returns, post the message\\\\n              // back. The translation may never return if the translations are discarded\\\\n              // before it have time to be run. In this case this await is just never\\\\n              // resolved, and the postMessage is never run.\\\\n              let {\\\\n                targetText,\\\\n                inferenceMilliseconds\\\\n              } = await engine.translate(cleanedSourceText, isHTML, innerWindowId, translationId);\\\\n\\\\n              // Ensure the whitespace is retained.\\\\n              targetText = whitespaceBefore + targetText + whitespaceAfter;\\\\n\\\\n              // This logging level can be very verbose and slow, so only do it under the\\\\n              // \\\\\\\"Trace\\\\\\\" level, which is the most verbose. Set the logging level to \\\\\\\"Info\\\\\\\" to avoid\\\\n              // these, and get all of the other logs.\\\\n              trace(\\\\\\\"Translation complete\\\\\\\", {\\\\n                sourceText,\\\\n                targetText,\\\\n                isHTML,\\\\n                innerWindowId\\\\n              });\\\\n              postMessage({\\\\n                type: \\\\\\\"translation-response\\\\\\\",\\\\n                targetText,\\\\n                inferenceMilliseconds,\\\\n                translationId,\\\\n                messageId\\\\n              });\\\\n            } catch (error) {\\\\n              console.error(error);\\\\n              let message = \\\\\\\"An error occurred in the engine worker.\\\\\\\";\\\\n              if (typeof error?.message === \\\\\\\"string\\\\\\\") {\\\\n                message = error.message;\\\\n              }\\\\n              let stack = \\\\\\\"(no stack)\\\\\\\";\\\\n              if (typeof error?.stack === \\\\\\\"string\\\\\\\") {\\\\n                stack = error.stack;\\\\n              }\\\\n              postMessage({\\\\n                type: \\\\\\\"translation-error\\\\\\\",\\\\n                error: {\\\\n                  message,\\\\n                  stack\\\\n                },\\\\n                messageId,\\\\n                innerWindowId\\\\n              });\\\\n            }\\\\n            break;\\\\n          }\\\\n        case \\\\\\\"discard-translation-queue\\\\\\\":\\\\n          {\\\\n            ChromeUtils.addProfilerMarker(\\\\\\\"TranslationsWorker\\\\\\\", {\\\\n              innerWindowId: data.innerWindowId\\\\n            }, \\\\\\\"Translations discard requested\\\\\\\");\\\\n            discardPromise = engine.discardTranslations(data.innerWindowId);\\\\n            await discardPromise;\\\\n            discardPromise = null;\\\\n\\\\n            // Signal to the \\\\\\\"message\\\\\\\" listeners in the main thread to stop listening.\\\\n            postMessage({\\\\n              type: \\\\\\\"translations-discarded\\\\\\\"\\\\n            });\\\\n            break;\\\\n          }\\\\n        case \\\\\\\"cancel-single-translation\\\\\\\":\\\\n          {\\\\n            engine.discardSingleTranslation(data.innerWindowId, data.translationId);\\\\n            break;\\\\n          }\\\\n        default:\\\\n          console.warn(\\\\\\\"Unknown message type:\\\\\\\", data.type);\\\\n      }\\\\n    } catch (error) {\\\\n      // Ensure the unexpected errors are surfaced in the console.\\\\n      console.error(error);\\\\n    }\\\\n  });\\\\n}\\\\n\\\\n/**\\\\n * The Engine is created once for a language pair. The initialization process copies the\\\\n * ArrayBuffers for the language buffers from JS-managed ArrayBuffers, to aligned\\\\n * internal memory for the wasm heap.\\\\n *\\\\n * After this the ArrayBuffers are discarded and GC'd. This file should be managed\\\\n * from the TranslationsEngine class on the main thread.\\\\n *\\\\n * This class starts listening for messages only after the Bergamot engine has been\\\\n * fully initialized.\\\\n */\\\\nclass Engine {\\\\n  /**\\\\n   * @param {string} sourceLanguage\\\\n   * @param {string} targetLanguage\\\\n   * @param {Bergamot} bergamot\\\\n   * @param {Array<TranslationModelPayload>} translationModelPayloads\\\\n   */\\\\n  constructor(sourceLanguage, targetLanguage, bergamot, translationModelPayloads) {\\\\n    /** @type {string} */\\\\n    this.sourceLanguage = sourceLanguage;\\\\n    /** @type {string} */\\\\n    this.targetLanguage = targetLanguage;\\\\n    /** @type {Bergamot} */\\\\n    this.bergamot = bergamot;\\\\n    /** @type {Bergamot[\\\\\\\"TranslationModel\\\\\\\"][]} */\\\\n    this.languageTranslationModels = translationModelPayloads.map(translationModelPayload => BergamotUtils.constructSingleTranslationModel(bergamot, translationModelPayload));\\\\n\\\\n    /** @type {Bergamot[\\\\\\\"BlockingService\\\\\\\"]} */\\\\n    this.translationService = new bergamot.BlockingService({\\\\n      // Caching is disabled (see https://github.com/mozilla/firefox-translations/issues/288)\\\\n      cacheSize: 0\\\\n    });\\\\n  }\\\\n\\\\n  /**\\\\n   * Run the translation models to perform a batch of message translations. The\\\\n   * promise is rejected when the sync version of this function throws an error.\\\\n   * This function creates an async interface over the synchronous translation\\\\n   * mechanism. This allows other microtasks such as message handling to still work\\\\n   * even though the translations are CPU-intensive.\\\\n   *\\\\n   * @param {string} sourceText\\\\n   * @param {boolean} isHTML\\\\n   * @param {number} innerWindowId - This is required\\\\n   * @param {number} translationId\\\\n   *\\\\n   * @returns {Promise<{ targetText: string, inferenceMilliseconds: number }>}\\\\n   *   Resolves with an object containing the translated text and the inference time in ms.\\\\n   */\\\\n  translate(sourceText, isHTML, innerWindowId, translationId) {\\\\n    return this.#getWorkQueue(innerWindowId).runTask(translationId, () => this.#syncTranslate(sourceText, isHTML, innerWindowId));\\\\n  }\\\\n\\\\n  /**\\\\n   * Map each innerWindowId to its own WorkQueue. This makes it easy to shut down\\\\n   * an entire queue of work when the page is unloaded.\\\\n   *\\\\n   * @type {Map<number, WorkQueue>}\\\\n   */\\\\n  #workQueues = new Map();\\\\n\\\\n  /**\\\\n   * Get or create a `WorkQueue` that is unique to an `innerWindowId`.\\\\n   *\\\\n   * @param {number} innerWindowId\\\\n   * @returns {WorkQueue}\\\\n   */\\\\n  #getWorkQueue(innerWindowId) {\\\\n    let workQueue = this.#workQueues.get(innerWindowId);\\\\n    if (workQueue) {\\\\n      return workQueue;\\\\n    }\\\\n    workQueue = new WorkQueue(innerWindowId);\\\\n    this.#workQueues.set(innerWindowId, workQueue);\\\\n    return workQueue;\\\\n  }\\\\n\\\\n  /**\\\\n   * Cancels any in-progress translations by removing the work queue.\\\\n   *\\\\n   * @param {number} innerWindowId\\\\n   */\\\\n  discardTranslations(innerWindowId) {\\\\n    let workQueue = this.#workQueues.get(innerWindowId);\\\\n    if (workQueue) {\\\\n      workQueue.cancelWork();\\\\n      this.#workQueues.delete(innerWindowId);\\\\n    }\\\\n  }\\\\n\\\\n  /**\\\\n   * Cancels any in-progress translations by removing the work queue.\\\\n   *\\\\n   * @param {number} innerWindowId\\\\n   * @param {number} translationId\\\\n   */\\\\n  discardSingleTranslation(innerWindowId, translationId) {\\\\n    const workQueue = this.#workQueues.get(innerWindowId);\\\\n    if (workQueue) {\\\\n      trace(\\\\\\\"Discarding translation with translationId\\\\\\\", translationId);\\\\n      workQueue.cancelTask(translationId);\\\\n    }\\\\n  }\\\\n\\\\n  /**\\\\n   * Run the translation models to perform a translation. This\\\\n   * blocks the worker thread until it is completed.\\\\n   *\\\\n   * @param {string} sourceText\\\\n   * @param {boolean} isHTML\\\\n   * @param {number} innerWindowId\\\\n   * @returns {{ targetText: string, inferenceMilliseconds: number }}\\\\n   *   An object containing the translated text and the inference time (in ms).\\\\n   */\\\\n  #syncTranslate(sourceText, isHTML, innerWindowId) {\\\\n    const startTime = ChromeUtils.now();\\\\n    let response;\\\\n    const {\\\\n      messages,\\\\n      options\\\\n    } = BergamotUtils.getTranslationArgs(this.bergamot, sourceText, isHTML);\\\\n    try {\\\\n      if (messages.size() === 0) {\\\\n        return [];\\\\n      }\\\\n\\\\n      /** @type {Bergamot[\\\\\\\"VectorResponse\\\\\\\"]} */\\\\n      let responses;\\\\n      if (this.languageTranslationModels.length === 1) {\\\\n        responses = this.translationService.translate(this.languageTranslationModels[0], messages, options);\\\\n      } else if (this.languageTranslationModels.length === 2) {\\\\n        responses = this.translationService.translateViaPivoting(this.languageTranslationModels[0], this.languageTranslationModels[1], messages, options);\\\\n      } else {\\\\n        throw new Error(\\\\\\\"Too many models were provided to the translation worker.\\\\\\\");\\\\n      }\\\\n\\\\n      // Report on the time it took to do this translation.\\\\n      ChromeUtils.addProfilerMarker(\\\\\\\"TranslationsWorker\\\\\\\", {\\\\n        startTime,\\\\n        innerWindowId\\\\n      }, `Translated ${sourceText.length} code units.`);\\\\n      const endTime = ChromeUtils.now();\\\\n      const targetText = responses.get(0).getTranslatedText();\\\\n      return {\\\\n        targetText,\\\\n        inferenceMilliseconds: endTime - startTime\\\\n      };\\\\n    } finally {\\\\n      // Free up any memory that was allocated. This will always run.\\\\n      messages?.delete();\\\\n      options?.delete();\\\\n      response?.delete();\\\\n    }\\\\n  }\\\\n}\\\\n\\\\n/**\\\\n * Static utilities to help work with the Bergamot wasm module.\\\\n */\\\\nclass BergamotUtils {\\\\n  /**\\\\n   * Construct a single translation model.\\\\n   *\\\\n   * @param {Bergamot} bergamot\\\\n   * @param {TranslationModelPayload} translationModelPayload\\\\n   * @returns {Bergamot[\\\\\\\"TranslationModel\\\\\\\"]}\\\\n   */\\\\n  static constructSingleTranslationModel(bergamot, translationModelPayload) {\\\\n    log(`Constructing translation model.`);\\\\n    const {\\\\n      sourceLanguage,\\\\n      targetLanguage,\\\\n      languageModelFiles\\\\n    } = translationModelPayload;\\\\n    const {\\\\n      model,\\\\n      lex,\\\\n      vocab,\\\\n      qualityModel,\\\\n      srcvocab,\\\\n      trgvocab\\\\n    } = BergamotUtils.allocateModelMemory(bergamot, languageModelFiles);\\\\n\\\\n    // Transform the bytes to mb, like \\\\\\\"10.2mb\\\\\\\"\\\\n    const getMemory = memory => `${Math.floor(memory.size() / 100_000) / 10}mb`;\\\\n    let memoryLog = `Model memory sizes in wasm heap:`;\\\\n    memoryLog += `\\\\\\\\n  Model: ${getMemory(model)}`;\\\\n    if (lex) {\\\\n      memoryLog += `\\\\\\\\n  Shortlist: ${getMemory(lex)}`;\\\\n    }\\\\n\\\\n    // Set up the vocab list, which could either be a single \\\\\\\"vocab\\\\\\\" model, or a\\\\n    // \\\\\\\"srcvocab\\\\\\\" and \\\\\\\"trgvocab\\\\\\\" pair.\\\\n    const vocabList = new bergamot.AlignedMemoryList();\\\\n    if (vocab) {\\\\n      vocabList.push_back(vocab);\\\\n      memoryLog += `\\\\\\\\n  Vocab: ${getMemory(vocab)}`;\\\\n    } else if (srcvocab && trgvocab) {\\\\n      vocabList.push_back(srcvocab);\\\\n      vocabList.push_back(trgvocab);\\\\n      memoryLog += `\\\\\\\\n  Src Vocab: ${getMemory(srcvocab)}`;\\\\n      memoryLog += `\\\\\\\\n  Trg Vocab: ${getMemory(trgvocab)}`;\\\\n    } else {\\\\n      throw new Error(\\\\\\\"Vocabulary key is not found.\\\\\\\");\\\\n    }\\\\n    if (qualityModel) {\\\\n      memoryLog += `\\\\\\\\n  QualityModel: ${getMemory(qualityModel)}\\\\\\\\n`;\\\\n    }\\\\n    const config = BergamotUtils.generateTextConfig({\\\\n      \\\\\\\"beam-size\\\\\\\": \\\\\\\"1\\\\\\\",\\\\n      normalize: \\\\\\\"1.0\\\\\\\",\\\\n      \\\\\\\"word-penalty\\\\\\\": \\\\\\\"0\\\\\\\",\\\\n      \\\\\\\"max-length-break\\\\\\\": \\\\\\\"128\\\\\\\",\\\\n      \\\\\\\"mini-batch-words\\\\\\\": \\\\\\\"1024\\\\\\\",\\\\n      workspace: \\\\\\\"128\\\\\\\",\\\\n      \\\\\\\"max-length-factor\\\\\\\": \\\\\\\"2.0\\\\\\\",\\\\n      \\\\\\\"skip-cost\\\\\\\": (!qualityModel).toString(),\\\\n      \\\\\\\"cpu-threads\\\\\\\": \\\\\\\"0\\\\\\\",\\\\n      quiet: \\\\\\\"true\\\\\\\",\\\\n      \\\\\\\"quiet-translation\\\\\\\": \\\\\\\"true\\\\\\\",\\\\n      \\\\\\\"gemm-precision\\\\\\\": languageModelFiles.model.record.name.endsWith(\\\\\\\"intgemm8.bin\\\\\\\") ? \\\\\\\"int8shiftAll\\\\\\\" : \\\\\\\"int8shiftAlphaAll\\\\\\\",\\\\n      alignment: \\\\\\\"soft\\\\\\\"\\\\n    });\\\\n    log(`Bergamot translation model config: ${config}`);\\\\n    log(memoryLog);\\\\n    return new bergamot.TranslationModel(sourceLanguage, targetLanguage, config, model, lex ?? null, vocabList, qualityModel ?? null);\\\\n  }\\\\n\\\\n  /**\\\\n   * The models must be placed in aligned memory that the Bergamot wasm module has access\\\\n   * to. This function copies over the model blobs into this memory space.\\\\n   *\\\\n   * @param {Bergamot} bergamot\\\\n   * @param {LanguageTranslationModelFiles} languageModelFiles\\\\n   * @returns {LanguageTranslationModelFilesAligned}\\\\n   */\\\\n  static allocateModelMemory(bergamot, languageModelFiles) {\\\\n    /** @type {LanguageTranslationModelFilesAligned} */\\\\n    const results = {};\\\\n    for (const [fileType, file] of Object.entries(languageModelFiles)) {\\\\n      const alignment = MODEL_FILE_ALIGNMENTS[fileType];\\\\n      if (!alignment) {\\\\n        throw new Error(`Unknown file type: \\\\\\\"${fileType}\\\\\\\"`);\\\\n      }\\\\n      const alignedMemory = new bergamot.AlignedMemory(file.buffer.byteLength, alignment);\\\\n      alignedMemory.getByteArrayView().set(new Uint8Array(file.buffer));\\\\n      results[fileType] = alignedMemory;\\\\n    }\\\\n    return results;\\\\n  }\\\\n\\\\n  /**\\\\n   * Initialize the Bergamot translation engine. It is a wasm compiled version of the\\\\n   * Marian translation software. The wasm is delivered remotely to cut down on binary size.\\\\n   *\\\\n   * https://github.com/mozilla/bergamot-translator/\\\\n   *\\\\n   * @param {ArrayBuffer} wasmBinary\\\\n   * @returns {Promise<Bergamot>}\\\\n   */\\\\n  static initializeWasm(wasmBinary) {\\\\n    return new Promise((resolve, reject) => {\\\\n      /** @type {number} */\\\\n      let start = performance.now();\\\\n\\\\n      /** @type {Bergamot} */\\\\n      const bergamot = loadBergamot({\\\\n        // Start with 40MiB initial memory. This value is arbitrary, but we have observed\\\\n        // through performance testing that starting small and allowing the buffer to grow\\\\n        // results in less memory usage than unintentionally overshooting the initial allocation.\\\\n        INITIAL_MEMORY: 41_943_040,\\\\n        print: log,\\\\n        onAbort() {\\\\n          reject(new Error(\\\\\\\"Error loading Bergamot wasm module.\\\\\\\"));\\\\n        },\\\\n        onRuntimeInitialized: async () => {\\\\n          const duration = performance.now() - start;\\\\n          log(`Bergamot wasm runtime initialized in ${duration / 1000} seconds.`);\\\\n          // Await at least one microtask so that the captured `bergamot` variable is\\\\n          // fully initialized.\\\\n          await Promise.resolve();\\\\n          resolve(bergamot);\\\\n        },\\\\n        wasmBinary\\\\n      });\\\\n    });\\\\n  }\\\\n\\\\n  /**\\\\n   * Maps the Bergamot Vector to a JS array\\\\n   *\\\\n   * @param {Bergamot[\\\\\\\"Vector\\\\\\\"]} vector\\\\n   * @param {Function} fn\\\\n   * @returns {Array}\\\\n   */\\\\n  static mapVector(vector, fn) {\\\\n    const result = [];\\\\n    for (let index = 0; index < vector.size(); index++) {\\\\n      result.push(fn(vector.get(index), index));\\\\n    }\\\\n    return result;\\\\n  }\\\\n\\\\n  /**\\\\n   * Generate a config for the Marian translation service. It requires specific whitespace.\\\\n   *\\\\n   * https://marian-nmt.github.io/docs/cmd/marian-decoder/\\\\n   *\\\\n   * @param {Record<string, string>} config\\\\n   * @returns {string}\\\\n   */\\\\n  static generateTextConfig(config) {\\\\n    const indent = \\\\\\\"            \\\\\\\";\\\\n    let result = \\\\\\\"\\\\\\\\n\\\\\\\";\\\\n    for (const [key, value] of Object.entries(config)) {\\\\n      result += `${indent}${key}: ${value}\\\\\\\\n`;\\\\n    }\\\\n    return result + indent;\\\\n  }\\\\n\\\\n  /**\\\\n   * JS objects need to be translated into wasm objects to configure the translation engine.\\\\n   *\\\\n   * @param {Bergamot} bergamot\\\\n   * @param {string} sourceText\\\\n   * @param {boolean} isHTML\\\\n   * @returns {{ messages: Bergamot[\\\\\\\"VectorString\\\\\\\"], options: Bergamot[\\\\\\\"VectorResponseOptions\\\\\\\"] }}\\\\n   */\\\\n  static getTranslationArgs(bergamot, sourceText, isHTML) {\\\\n    const messages = new bergamot.VectorString();\\\\n    const options = new bergamot.VectorResponseOptions();\\\\n\\\\n    // Empty paragraphs break the translation.\\\\n    if (sourceText) {\\\\n      messages.push_back(sourceText);\\\\n      options.push_back({\\\\n        qualityScores: false,\\\\n        alignment: true,\\\\n        html: isHTML\\\\n      });\\\\n    }\\\\n    return {\\\\n      messages,\\\\n      options\\\\n    };\\\\n  }\\\\n}\\\\n\\\\n/**\\\\n * For testing purposes, provide a fully mocked engine. This allows for easy integration\\\\n * testing of the UI, without having to rely on downloading remote models and remote\\\\n * wasm binaries.\\\\n */\\\\nclass MockedEngine {\\\\n  /**\\\\n   * @param {string} sourceLanguage\\\\n   * @param {string} targetLanguage\\\\n   */\\\\n  constructor(sourceLanguage, targetLanguage) {\\\\n    /** @type {string} */\\\\n    this.sourceLanguage = sourceLanguage;\\\\n    /** @type {string} */\\\\n    this.targetLanguage = targetLanguage;\\\\n  }\\\\n\\\\n  /**\\\\n   * Create a fake translation of the text, returning a mock object\\\\n   * with both the translated text and time spent.\\\\n   *\\\\n   * @param {string} sourceText\\\\n   * @param {boolean} isHTML\\\\n   * @returns {{ targetText: string, inferenceMilliseconds: number }}\\\\n   *   An object containing the \\\\\\\"translated\\\\\\\" text and a mock inference time in ms.\\\\n   */\\\\n  translate(sourceText, isHTML) {\\\\n    const startTime = performance.now();\\\\n\\\\n    // Note when an HTML translation is requested.\\\\n    let html = isHTML ? \\\\\\\", html\\\\\\\" : \\\\\\\"\\\\\\\";\\\\n    const targetText = `${sourceText.toUpperCase()} [${this.sourceLanguage} to ${this.targetLanguage}${html}]`;\\\\n    const endTime = performance.now();\\\\n    return {\\\\n      targetText,\\\\n      inferenceMilliseconds: endTime - startTime\\\\n    };\\\\n  }\\\\n  discardTranslations() {}\\\\n}\\\\n\\\\n/**\\\\n * This class takes tasks that may block the thread's event loop, and has them yield\\\\n * after a time budget via setTimeout calls to allow other code to execute.\\\\n */\\\\nclass WorkQueue {\\\\n  #TIME_BUDGET = 100; // ms\\\\n  #RUN_IMMEDIATELY_COUNT = 20;\\\\n\\\\n  /**\\\\n   * This is the list of work to be done. While it is a Map, it is treated as a FIFO\\\\n   * queue, but with work that can be canceled via the translationId.\\\\n   *\\\\n   * @type {Map<number, {task: Function, resolve: Function}>}\\\\n   */\\\\n  #tasksByTranslationId = new Map();\\\\n  #isRunning = false;\\\\n  #isWorkCancelled = false;\\\\n  #runImmediately = this.#RUN_IMMEDIATELY_COUNT;\\\\n\\\\n  /**\\\\n   * @param {number} innerWindowId\\\\n   */\\\\n  constructor(innerWindowId) {\\\\n    this.innerWindowId = innerWindowId;\\\\n  }\\\\n\\\\n  /**\\\\n   * Run the task and return the result.\\\\n   *\\\\n   * @template {any} T\\\\n   * @param {number} translationId\\\\n   * @param {() => T} task\\\\n   * @returns {Promise<T>}\\\\n   */\\\\n  runTask(translationId, task) {\\\\n    if (this.#runImmediately > 0) {\\\\n      // Run the first N translations immediately, most likely these are the user-visible\\\\n      // translations on the page, as they are sent in first. The setTimeout of 0 can\\\\n      // still delay the translations noticeably.\\\\n      this.#runImmediately--;\\\\n      return Promise.resolve(task());\\\\n    }\\\\n    return new Promise((resolve, reject) => {\\\\n      this.#tasksByTranslationId.set(translationId, {\\\\n        task,\\\\n        resolve,\\\\n        reject\\\\n      });\\\\n      this.#run().catch(error => console.error(error));\\\\n    });\\\\n  }\\\\n\\\\n  /**\\\\n   * @param {number} translationId\\\\n   */\\\\n  cancelTask(translationId) {\\\\n    this.#tasksByTranslationId.delete(translationId);\\\\n  }\\\\n\\\\n  /**\\\\n   * The internal run function.\\\\n   */\\\\n  async #run() {\\\\n    if (this.#isRunning) {\\\\n      // The work queue is already running.\\\\n      return;\\\\n    }\\\\n    this.#isRunning = true;\\\\n\\\\n    // Measure the timeout\\\\n    let lastTimeout = null;\\\\n    let tasksInBatch = 0;\\\\n    const addProfilerMarker = () => {\\\\n      ChromeUtils.addProfilerMarker(\\\\\\\"TranslationsWorker WorkQueue\\\\\\\", {\\\\n        startTime: lastTimeout,\\\\n        innerWindowId: this.innerWindowId\\\\n      }, `WorkQueue processed ${tasksInBatch} tasks`);\\\\n    };\\\\n    while (this.#tasksByTranslationId.size) {\\\\n      if (this.#isWorkCancelled) {\\\\n        // The work was already cancelled.\\\\n        break;\\\\n      }\\\\n      const now = ChromeUtils.now();\\\\n      if (lastTimeout === null) {\\\\n        lastTimeout = now;\\\\n        // Allow other work to get on the queue.\\\\n        await new Promise(resolve => setTimeout(resolve, 0));\\\\n      } else if (now - lastTimeout > this.#TIME_BUDGET) {\\\\n        // Perform a timeout with no effective wait. This clears the current\\\\n        // promise queue from the event loop.\\\\n        await new Promise(resolve => setTimeout(resolve, 0));\\\\n        addProfilerMarker();\\\\n        lastTimeout = ChromeUtils.now();\\\\n      }\\\\n\\\\n      // Check this between every `await`.\\\\n      if (this.#isWorkCancelled || !this.#tasksByTranslationId.size) {\\\\n        break;\\\\n      }\\\\n      tasksInBatch++;\\\\n\\\\n      // Treat the `this.#tasksByTranslationId` Map as a FIFO queue, and take the oldest\\\\n      // item out by manually using the `entries()` iterator.\\\\n      const [translationId, taskAndResolvers] = this.#tasksByTranslationId.entries().next().value;\\\\n      const {\\\\n        task,\\\\n        resolve,\\\\n        reject\\\\n      } = taskAndResolvers;\\\\n      this.#tasksByTranslationId.delete(translationId);\\\\n      try {\\\\n        const result = await task();\\\\n\\\\n        // Check this between every `await`.\\\\n        if (this.#isWorkCancelled) {\\\\n          break;\\\\n        }\\\\n        // The work is done, resolve the original task.\\\\n        resolve(result);\\\\n      } catch (error) {\\\\n        reject(error);\\\\n      }\\\\n    }\\\\n    addProfilerMarker();\\\\n    this.#isRunning = false;\\\\n  }\\\\n  async cancelWork() {\\\\n    this.#isWorkCancelled = true;\\\\n    this.#tasksByTranslationId = new Map();\\\\n    await new Promise(resolve => setTimeout(resolve, 0));\\\\n    this.#isWorkCancelled = false;\\\\n  }\\\\n}\\\\n\\\\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js?./node_modules/babel-loader/lib/index.js??ruleSet%5B1%5D.rules%5B1%5D.use%5B1%5D\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js\\\":\\n/*!*******************************************************************************************************!*\\\\\\n  !*** ./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js ***!\\n  \\\\*******************************************************************************************************/\\n/***/ ((module) => {\\n\\neval(\\\"module.exports = \\\\\\\"/* This Source Code Form is subject to the terms of the Mozilla Public\\\\\\\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\\\\\\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\\\\\\\\n\\\\\\\\nfunction loadBergamot(Module) {\\\\\\\\n  var BERGAMOT_VERSION_FULL = \\\\\\\\\\\\\\\"v0.6.0+4a6a44c0\\\\\\\\\\\\\\\";\\\\\\\\n  null;\\\\\\\\n\\\\\\\\n  var Module = typeof Module != \\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\" ? Module : {};\\\\\\\\n\\\\\\\\n  var moduleOverrides = Object.assign({}, Module);\\\\\\\\n\\\\\\\\n  var arguments_ = [];\\\\\\\\n\\\\\\\\n  var thisProgram = \\\\\\\\\\\\\\\"./this.program\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n  var quit_ = (status, toThrow) => {\\\\\\\\n    throw toThrow;\\\\\\\\n  };\\\\\\\\n\\\\\\\\n  var ENVIRONMENT_IS_WEB = typeof window == \\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n  var ENVIRONMENT_IS_WORKER = typeof importScripts == \\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n  var ENVIRONMENT_IS_NODE =\\\\\\\\n    typeof process == \\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\" &&\\\\\\\\n    typeof process.versions == \\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\" &&\\\\\\\\n    typeof process.versions.node == \\\\\\\\\\\\\\\"string\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n  var scriptDirectory = \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n  function locateFile(path) {\\\\\\\\n    if (Module.locateFile) {\\\\\\\\n      return Module.locateFile(path, scriptDirectory);\\\\\\\\n    }\\\\\\\\n    return scriptDirectory + path;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var read_, readAsync, readBinary, setWindowTitle;\\\\\\\\n\\\\\\\\n  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\\\\\\\\n    if (ENVIRONMENT_IS_WORKER) {\\\\\\\\n      scriptDirectory = self.location.href;\\\\\\\\n    } else if (typeof document != \\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\" && document.currentScript) {\\\\\\\\n      scriptDirectory = document.currentScript.src;\\\\\\\\n    }\\\\\\\\n    if (scriptDirectory.indexOf(\\\\\\\\\\\\\\\"blob:\\\\\\\\\\\\\\\") !== 0) {\\\\\\\\n      scriptDirectory = scriptDirectory.substr(\\\\\\\\n        0,\\\\\\\\n        scriptDirectory.replace(/[?#].*/, \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\").lastIndexOf(\\\\\\\\\\\\\\\"/\\\\\\\\\\\\\\\") + 1\\\\\\\\n      );\\\\\\\\n    } else {\\\\\\\\n      scriptDirectory = \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\";\\\\\\\\n    }\\\\\\\\n    {\\\\\\\\n      read_ = url => {\\\\\\\\n        var xhr = new XMLHttpRequest();\\\\\\\\n        xhr.open(\\\\\\\\\\\\\\\"GET\\\\\\\\\\\\\\\", url, false);\\\\\\\\n        xhr.send(null);\\\\\\\\n        return xhr.responseText;\\\\\\\\n      };\\\\\\\\n      if (ENVIRONMENT_IS_WORKER) {\\\\\\\\n        readBinary = url => {\\\\\\\\n          var xhr = new XMLHttpRequest();\\\\\\\\n          xhr.open(\\\\\\\\\\\\\\\"GET\\\\\\\\\\\\\\\", url, false);\\\\\\\\n          xhr.responseType = \\\\\\\\\\\\\\\"arraybuffer\\\\\\\\\\\\\\\";\\\\\\\\n          xhr.send(null);\\\\\\\\n          return new Uint8Array(xhr.response);\\\\\\\\n        };\\\\\\\\n      }\\\\\\\\n      readAsync = (url, onload, onerror) => {\\\\\\\\n        var xhr = new XMLHttpRequest();\\\\\\\\n        xhr.open(\\\\\\\\\\\\\\\"GET\\\\\\\\\\\\\\\", url, true);\\\\\\\\n        xhr.responseType = \\\\\\\\\\\\\\\"arraybuffer\\\\\\\\\\\\\\\";\\\\\\\\n        xhr.onload = () => {\\\\\\\\n          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {\\\\\\\\n            onload(xhr.response);\\\\\\\\n            return;\\\\\\\\n          }\\\\\\\\n          onerror();\\\\\\\\n        };\\\\\\\\n        xhr.onerror = onerror;\\\\\\\\n        xhr.send(null);\\\\\\\\n      };\\\\\\\\n    }\\\\\\\\n    setWindowTitle = title => (document.title = title);\\\\\\\\n  } else {\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var out = Module.print || console.log.bind(console);\\\\\\\\n\\\\\\\\n  var err = Module.printErr || console.warn.bind(console);\\\\\\\\n\\\\\\\\n  Object.assign(Module, moduleOverrides);\\\\\\\\n\\\\\\\\n  moduleOverrides = null;\\\\\\\\n\\\\\\\\n  if (Module.arguments) {\\\\\\\\n    arguments_ = Module.arguments;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  if (Module.thisProgram) {\\\\\\\\n    thisProgram = Module.thisProgram;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  if (Module.quit) {\\\\\\\\n    quit_ = Module.quit;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var tempRet0 = 0;\\\\\\\\n\\\\\\\\n  var setTempRet0 = value => {\\\\\\\\n    tempRet0 = value;\\\\\\\\n  };\\\\\\\\n\\\\\\\\n  var wasmBinary;\\\\\\\\n\\\\\\\\n  if (Module.wasmBinary) {\\\\\\\\n    wasmBinary = Module.wasmBinary;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var noExitRuntime = Module.noExitRuntime || true;\\\\\\\\n\\\\\\\\n  if (typeof WebAssembly != \\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\") {\\\\\\\\n    abort(\\\\\\\\\\\\\\\"no native wasm support detected\\\\\\\\\\\\\\\");\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function setValue(ptr, value, type = \\\\\\\\\\\\\\\"i8\\\\\\\\\\\\\\\", noSafe) {\\\\\\\\n    if (type.charAt(type.length - 1) === \\\\\\\\\\\\\\\"*\\\\\\\\\\\\\\\") {\\\\\\\\n      type = \\\\\\\\\\\\\\\"i32\\\\\\\\\\\\\\\";\\\\\\\\n    }\\\\\\\\n    switch (type) {\\\\\\\\n      case \\\\\\\\\\\\\\\"i1\\\\\\\\\\\\\\\":\\\\\\\\n        HEAP8[ptr >> 0] = value;\\\\\\\\n        break;\\\\\\\\n\\\\\\\\n      case \\\\\\\\\\\\\\\"i8\\\\\\\\\\\\\\\":\\\\\\\\n        HEAP8[ptr >> 0] = value;\\\\\\\\n        break;\\\\\\\\n\\\\\\\\n      case \\\\\\\\\\\\\\\"i16\\\\\\\\\\\\\\\":\\\\\\\\n        HEAP16[ptr >> 1] = value;\\\\\\\\n        break;\\\\\\\\n\\\\\\\\n      case \\\\\\\\\\\\\\\"i32\\\\\\\\\\\\\\\":\\\\\\\\n        HEAP32[ptr >> 2] = value;\\\\\\\\n        break;\\\\\\\\n\\\\\\\\n      case \\\\\\\\\\\\\\\"i64\\\\\\\\\\\\\\\":\\\\\\\\n        ((tempI64 = [\\\\\\\\n          value >>> 0,\\\\\\\\n          ((tempDouble = value),\\\\\\\\n          +Math.abs(tempDouble) >= 1\\\\\\\\n            ? tempDouble > 0\\\\\\\\n              ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) |\\\\\\\\n                  0) >>>\\\\\\\\n                0\\\\\\\\n              : ~~+Math.ceil(\\\\\\\\n                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296\\\\\\\\n                ) >>> 0\\\\\\\\n            : 0),\\\\\\\\n        ]),\\\\\\\\n          (HEAP32[ptr >> 2] = tempI64[0]),\\\\\\\\n          (HEAP32[(ptr + 4) >> 2] = tempI64[1]));\\\\\\\\n        break;\\\\\\\\n\\\\\\\\n      case \\\\\\\\\\\\\\\"float\\\\\\\\\\\\\\\":\\\\\\\\n        HEAPF32[ptr >> 2] = value;\\\\\\\\n        break;\\\\\\\\n\\\\\\\\n      case \\\\\\\\\\\\\\\"double\\\\\\\\\\\\\\\":\\\\\\\\n        HEAPF64[ptr >> 3] = value;\\\\\\\\n        break;\\\\\\\\n\\\\\\\\n      default:\\\\\\\\n        abort(\\\\\\\\\\\\\\\"invalid type for setValue: \\\\\\\\\\\\\\\" + type);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var wasmMemory;\\\\\\\\n\\\\\\\\n  var ABORT = false;\\\\\\\\n\\\\\\\\n  var EXITSTATUS;\\\\\\\\n\\\\\\\\n  function assert(condition, text) {\\\\\\\\n    if (!condition) {\\\\\\\\n      abort(text);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var UTF8Decoder =\\\\\\\\n    typeof TextDecoder != \\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\" ? new TextDecoder(\\\\\\\\\\\\\\\"utf8\\\\\\\\\\\\\\\") : undefined;\\\\\\\\n\\\\\\\\n  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\\\\\\\\n    var endIdx = idx + maxBytesToRead;\\\\\\\\n    var endPtr = idx;\\\\\\\\n    while (heapOrArray[endPtr] && !(endPtr >= endIdx)) {\\\\\\\\n      ++endPtr;\\\\\\\\n    }\\\\\\\\n    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\\\\\\\\n      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\\\\\\\\n    }\\\\\\\\n    var str = \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\";\\\\\\\\n    while (idx < endPtr) {\\\\\\\\n      var u0 = heapOrArray[idx++];\\\\\\\\n      if (!(u0 & 128)) {\\\\\\\\n        str += String.fromCharCode(u0);\\\\\\\\n        continue;\\\\\\\\n      }\\\\\\\\n      var u1 = heapOrArray[idx++] & 63;\\\\\\\\n      if ((u0 & 224) == 192) {\\\\\\\\n        str += String.fromCharCode(((u0 & 31) << 6) | u1);\\\\\\\\n        continue;\\\\\\\\n      }\\\\\\\\n      var u2 = heapOrArray[idx++] & 63;\\\\\\\\n      if ((u0 & 240) == 224) {\\\\\\\\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\\\\\\\\n      } else {\\\\\\\\n        u0 =\\\\\\\\n          ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\\\\\\\\n      }\\\\\\\\n      if (u0 < 65536) {\\\\\\\\n        str += String.fromCharCode(u0);\\\\\\\\n      } else {\\\\\\\\n        var ch = u0 - 65536;\\\\\\\\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    return str;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function UTF8ToString(ptr, maxBytesToRead) {\\\\\\\\n    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\";\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\\\\\\\\n    if (!(maxBytesToWrite > 0)) {\\\\\\\\n      return 0;\\\\\\\\n    }\\\\\\\\n    var startIdx = outIdx;\\\\\\\\n    var endIdx = outIdx + maxBytesToWrite - 1;\\\\\\\\n    for (var i = 0; i < str.length; ++i) {\\\\\\\\n      var u = str.charCodeAt(i);\\\\\\\\n      if (u >= 55296 && u <= 57343) {\\\\\\\\n        var u1 = str.charCodeAt(++i);\\\\\\\\n        u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);\\\\\\\\n      }\\\\\\\\n      if (u <= 127) {\\\\\\\\n        if (outIdx >= endIdx) {\\\\\\\\n          break;\\\\\\\\n        }\\\\\\\\n        heap[outIdx++] = u;\\\\\\\\n      } else if (u <= 2047) {\\\\\\\\n        if (outIdx + 1 >= endIdx) {\\\\\\\\n          break;\\\\\\\\n        }\\\\\\\\n        heap[outIdx++] = 192 | (u >> 6);\\\\\\\\n        heap[outIdx++] = 128 | (u & 63);\\\\\\\\n      } else if (u <= 65535) {\\\\\\\\n        if (outIdx + 2 >= endIdx) {\\\\\\\\n          break;\\\\\\\\n        }\\\\\\\\n        heap[outIdx++] = 224 | (u >> 12);\\\\\\\\n        heap[outIdx++] = 128 | ((u >> 6) & 63);\\\\\\\\n        heap[outIdx++] = 128 | (u & 63);\\\\\\\\n      } else {\\\\\\\\n        if (outIdx + 3 >= endIdx) {\\\\\\\\n          break;\\\\\\\\n        }\\\\\\\\n        heap[outIdx++] = 240 | (u >> 18);\\\\\\\\n        heap[outIdx++] = 128 | ((u >> 12) & 63);\\\\\\\\n        heap[outIdx++] = 128 | ((u >> 6) & 63);\\\\\\\\n        heap[outIdx++] = 128 | (u & 63);\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    heap[outIdx] = 0;\\\\\\\\n    return outIdx - startIdx;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function stringToUTF8(str, outPtr, maxBytesToWrite) {\\\\\\\\n    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function lengthBytesUTF8(str) {\\\\\\\\n    var len = 0;\\\\\\\\n    for (var i = 0; i < str.length; ++i) {\\\\\\\\n      var u = str.charCodeAt(i);\\\\\\\\n      if (u >= 55296 && u <= 57343) {\\\\\\\\n        u = (65536 + ((u & 1023) << 10)) | (str.charCodeAt(++i) & 1023);\\\\\\\\n      }\\\\\\\\n      if (u <= 127) {\\\\\\\\n        ++len;\\\\\\\\n      } else if (u <= 2047) {\\\\\\\\n        len += 2;\\\\\\\\n      } else if (u <= 65535) {\\\\\\\\n        len += 3;\\\\\\\\n      } else {\\\\\\\\n        len += 4;\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    return len;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var UTF16Decoder =\\\\\\\\n    typeof TextDecoder != \\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\" ? new TextDecoder(\\\\\\\\\\\\\\\"utf-16le\\\\\\\\\\\\\\\") : undefined;\\\\\\\\n\\\\\\\\n  function UTF16ToString(ptr, maxBytesToRead) {\\\\\\\\n    var endPtr = ptr;\\\\\\\\n    var idx = endPtr >> 1;\\\\\\\\n    var maxIdx = idx + maxBytesToRead / 2;\\\\\\\\n    while (!(idx >= maxIdx) && HEAPU16[idx]) {\\\\\\\\n      ++idx;\\\\\\\\n    }\\\\\\\\n    endPtr = idx << 1;\\\\\\\\n    if (endPtr - ptr > 32 && UTF16Decoder) {\\\\\\\\n      return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\\\\\\\\n    }\\\\\\\\n    var str = \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\";\\\\\\\\n    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\\\\\\\\n      var codeUnit = HEAP16[(ptr + i * 2) >> 1];\\\\\\\\n      if (codeUnit == 0) {\\\\\\\\n        break;\\\\\\\\n      }\\\\\\\\n      str += String.fromCharCode(codeUnit);\\\\\\\\n    }\\\\\\\\n    return str;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function stringToUTF16(str, outPtr, maxBytesToWrite) {\\\\\\\\n    if (maxBytesToWrite === undefined) {\\\\\\\\n      maxBytesToWrite = 2147483647;\\\\\\\\n    }\\\\\\\\n    if (maxBytesToWrite < 2) {\\\\\\\\n      return 0;\\\\\\\\n    }\\\\\\\\n    maxBytesToWrite -= 2;\\\\\\\\n    var startPtr = outPtr;\\\\\\\\n    var numCharsToWrite =\\\\\\\\n      maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\\\\\\\\n    for (var i = 0; i < numCharsToWrite; ++i) {\\\\\\\\n      var codeUnit = str.charCodeAt(i);\\\\\\\\n      HEAP16[outPtr >> 1] = codeUnit;\\\\\\\\n      outPtr += 2;\\\\\\\\n    }\\\\\\\\n    HEAP16[outPtr >> 1] = 0;\\\\\\\\n    return outPtr - startPtr;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function lengthBytesUTF16(str) {\\\\\\\\n    return str.length * 2;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function UTF32ToString(ptr, maxBytesToRead) {\\\\\\\\n    var i = 0;\\\\\\\\n    var str = \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\";\\\\\\\\n    while (!(i >= maxBytesToRead / 4)) {\\\\\\\\n      var utf32 = HEAP32[(ptr + i * 4) >> 2];\\\\\\\\n      if (utf32 == 0) {\\\\\\\\n        break;\\\\\\\\n      }\\\\\\\\n      ++i;\\\\\\\\n      if (utf32 >= 65536) {\\\\\\\\n        var ch = utf32 - 65536;\\\\\\\\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\\\\\\\\n      } else {\\\\\\\\n        str += String.fromCharCode(utf32);\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    return str;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function stringToUTF32(str, outPtr, maxBytesToWrite) {\\\\\\\\n    if (maxBytesToWrite === undefined) {\\\\\\\\n      maxBytesToWrite = 2147483647;\\\\\\\\n    }\\\\\\\\n    if (maxBytesToWrite < 4) {\\\\\\\\n      return 0;\\\\\\\\n    }\\\\\\\\n    var startPtr = outPtr;\\\\\\\\n    var endPtr = startPtr + maxBytesToWrite - 4;\\\\\\\\n    for (var i = 0; i < str.length; ++i) {\\\\\\\\n      var codeUnit = str.charCodeAt(i);\\\\\\\\n      if (codeUnit >= 55296 && codeUnit <= 57343) {\\\\\\\\n        var trailSurrogate = str.charCodeAt(++i);\\\\\\\\n        codeUnit =\\\\\\\\n          (65536 + ((codeUnit & 1023) << 10)) | (trailSurrogate & 1023);\\\\\\\\n      }\\\\\\\\n      HEAP32[outPtr >> 2] = codeUnit;\\\\\\\\n      outPtr += 4;\\\\\\\\n      if (outPtr + 4 > endPtr) {\\\\\\\\n        break;\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    HEAP32[outPtr >> 2] = 0;\\\\\\\\n    return outPtr - startPtr;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function lengthBytesUTF32(str) {\\\\\\\\n    var len = 0;\\\\\\\\n    for (var i = 0; i < str.length; ++i) {\\\\\\\\n      var codeUnit = str.charCodeAt(i);\\\\\\\\n      if (codeUnit >= 55296 && codeUnit <= 57343) {\\\\\\\\n        ++i;\\\\\\\\n      }\\\\\\\\n      len += 4;\\\\\\\\n    }\\\\\\\\n    return len;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function allocateUTF8(str) {\\\\\\\\n    var size = lengthBytesUTF8(str) + 1;\\\\\\\\n    var ret = _malloc(size);\\\\\\\\n    if (ret) {\\\\\\\\n      stringToUTF8Array(str, HEAP8, ret, size);\\\\\\\\n    }\\\\\\\\n    return ret;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function writeArrayToMemory(array, buffer) {\\\\\\\\n    HEAP8.set(array, buffer);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function writeAsciiToMemory(str, buffer, dontAddNull) {\\\\\\\\n    for (var i = 0; i < str.length; ++i) {\\\\\\\\n      HEAP8[buffer++ >> 0] = str.charCodeAt(i);\\\\\\\\n    }\\\\\\\\n    if (!dontAddNull) {\\\\\\\\n      HEAP8[buffer >> 0] = 0;\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\\\\\\\\n\\\\\\\\n  function updateGlobalBufferAndViews(buf) {\\\\\\\\n    const mb = (buf.byteLength / 1_000_000).toFixed();\\\\\\\\n    Module.print(`Growing wasm buffer to ${mb}MB (${buf.byteLength} bytes).`);\\\\\\\\n\\\\\\\\n    buffer = buf;\\\\\\\\n    Module.HEAP8 = HEAP8 = new Int8Array(buf);\\\\\\\\n    Module.HEAP16 = HEAP16 = new Int16Array(buf);\\\\\\\\n    Module.HEAP32 = HEAP32 = new Int32Array(buf);\\\\\\\\n    Module.HEAPU8 = HEAPU8 = new Uint8Array(buf);\\\\\\\\n    Module.HEAPU16 = HEAPU16 = new Uint16Array(buf);\\\\\\\\n    Module.HEAPU32 = HEAPU32 = new Uint32Array(buf);\\\\\\\\n    Module.HEAPF32 = HEAPF32 = new Float32Array(buf);\\\\\\\\n    Module.HEAPF64 = HEAPF64 = new Float64Array(buf);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var INITIAL_MEMORY = Module.INITIAL_MEMORY || 16777216;\\\\\\\\n\\\\\\\\n  if (Module.wasmMemory) {\\\\\\\\n    wasmMemory = Module.wasmMemory;\\\\\\\\n  } else {\\\\\\\\n    wasmMemory = new WebAssembly.Memory({\\\\\\\\n      initial: INITIAL_MEMORY / 65536,\\\\\\\\n      maximum: 2147483648 / 65536,\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  if (wasmMemory) {\\\\\\\\n    buffer = wasmMemory.buffer;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  INITIAL_MEMORY = buffer.byteLength;\\\\\\\\n\\\\\\\\n  updateGlobalBufferAndViews(buffer);\\\\\\\\n\\\\\\\\n  var wasmTable;\\\\\\\\n\\\\\\\\n  var __ATPRERUN__ = [];\\\\\\\\n\\\\\\\\n  var __ATINIT__ = [];\\\\\\\\n\\\\\\\\n  var __ATPOSTRUN__ = [];\\\\\\\\n\\\\\\\\n  var runtimeInitialized = false;\\\\\\\\n\\\\\\\\n  function keepRuntimeAlive() {\\\\\\\\n    return noExitRuntime;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function preRun() {\\\\\\\\n    if (Module.preRun) {\\\\\\\\n      if (typeof Module.preRun == \\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\") {\\\\\\\\n        Module.preRun = [Module.preRun];\\\\\\\\n      }\\\\\\\\n      while (Module.preRun.length) {\\\\\\\\n        addOnPreRun(Module.preRun.shift());\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    callRuntimeCallbacks(__ATPRERUN__);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function initRuntime() {\\\\\\\\n    runtimeInitialized = true;\\\\\\\\n    callRuntimeCallbacks(__ATINIT__);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function postRun() {\\\\\\\\n    if (Module.postRun) {\\\\\\\\n      if (typeof Module.postRun == \\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\") {\\\\\\\\n        Module.postRun = [Module.postRun];\\\\\\\\n      }\\\\\\\\n      while (Module.postRun.length) {\\\\\\\\n        addOnPostRun(Module.postRun.shift());\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    callRuntimeCallbacks(__ATPOSTRUN__);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function addOnPreRun(cb) {\\\\\\\\n    __ATPRERUN__.unshift(cb);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function addOnInit(cb) {\\\\\\\\n    __ATINIT__.unshift(cb);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function addOnPostRun(cb) {\\\\\\\\n    __ATPOSTRUN__.unshift(cb);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var runDependencies = 0;\\\\\\\\n\\\\\\\\n  var runDependencyWatcher = null;\\\\\\\\n\\\\\\\\n  var dependenciesFulfilled = null;\\\\\\\\n\\\\\\\\n  function addRunDependency(id) {\\\\\\\\n    runDependencies++;\\\\\\\\n    if (Module.monitorRunDependencies) {\\\\\\\\n      Module.monitorRunDependencies(runDependencies);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function removeRunDependency(id) {\\\\\\\\n    runDependencies--;\\\\\\\\n    if (Module.monitorRunDependencies) {\\\\\\\\n      Module.monitorRunDependencies(runDependencies);\\\\\\\\n    }\\\\\\\\n    if (runDependencies == 0) {\\\\\\\\n      if (runDependencyWatcher !== null) {\\\\\\\\n        clearInterval(runDependencyWatcher);\\\\\\\\n        runDependencyWatcher = null;\\\\\\\\n      }\\\\\\\\n      if (dependenciesFulfilled) {\\\\\\\\n        var callback = dependenciesFulfilled;\\\\\\\\n        dependenciesFulfilled = null;\\\\\\\\n        callback();\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  Module.preloadedImages = {};\\\\\\\\n\\\\\\\\n  Module.preloadedAudios = {};\\\\\\\\n\\\\\\\\n  function abort(what) {\\\\\\\\n    {\\\\\\\\n      if (Module.onAbort) {\\\\\\\\n        Module.onAbort(what);\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    what = \\\\\\\\\\\\\\\"Aborted(\\\\\\\\\\\\\\\" + what + \\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\";\\\\\\\\n    err(what);\\\\\\\\n    ABORT = true;\\\\\\\\n    EXITSTATUS = 1;\\\\\\\\n    what += \\\\\\\\\\\\\\\". Build with -s ASSERTIONS=1 for more info.\\\\\\\\\\\\\\\";\\\\\\\\n    var e = new WebAssembly.RuntimeError(what);\\\\\\\\n    throw e;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var dataURIPrefix = \\\\\\\\\\\\\\\"data:application/octet-stream;base64,\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n  function isDataURI(filename) {\\\\\\\\n    return filename.startsWith(dataURIPrefix);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var wasmBinaryFile;\\\\\\\\n\\\\\\\\n  wasmBinaryFile = \\\\\\\\\\\\\\\"bergamot-translator.wasm\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n  if (!isDataURI(wasmBinaryFile)) {\\\\\\\\n    wasmBinaryFile = locateFile(wasmBinaryFile);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function getBinary(file) {\\\\\\\\n    try {\\\\\\\\n      if (file == wasmBinaryFile && wasmBinary) {\\\\\\\\n        return new Uint8Array(wasmBinary);\\\\\\\\n      }\\\\\\\\n      if (readBinary) {\\\\\\\\n        return readBinary(file);\\\\\\\\n      }\\\\\\\\n      throw \\\\\\\\\\\\\\\"both async and sync fetching of the wasm failed\\\\\\\\\\\\\\\";\\\\\\\\n    } catch (err) {\\\\\\\\n      abort(err);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function getBinaryPromise() {\\\\\\\\n    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\\\\\\\\n      if (typeof fetch == \\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\") {\\\\\\\\n        return fetch(wasmBinaryFile, {\\\\\\\\n          credentials: \\\\\\\\\\\\\\\"same-origin\\\\\\\\\\\\\\\",\\\\\\\\n        })\\\\\\\\n          .then(function (response) {\\\\\\\\n            if (!response.ok) {\\\\\\\\n              throw (\\\\\\\\n                \\\\\\\\\\\\\\\"failed to load wasm binary file at '\\\\\\\\\\\\\\\" + wasmBinaryFile + \\\\\\\\\\\\\\\"'\\\\\\\\\\\\\\\"\\\\\\\\n              );\\\\\\\\n            }\\\\\\\\n            return response.arrayBuffer();\\\\\\\\n          })\\\\\\\\n          .catch(function () {\\\\\\\\n            return getBinary(wasmBinaryFile);\\\\\\\\n          });\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    return Promise.resolve().then(function () {\\\\\\\\n      return getBinary(wasmBinaryFile);\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function createWasm() {\\\\\\\\n    var info = {\\\\\\\\n      env: asmLibraryArg,\\\\\\\\n      wasm_gemm: createWasmGemm(),\\\\\\\\n      wasi_snapshot_preview1: asmLibraryArg,\\\\\\\\n    };\\\\\\\\n    function receiveInstance(instance, module) {\\\\\\\\n      var exports = instance.exports;\\\\\\\\n      Module.asm = exports;\\\\\\\\n      wasmTable = Module.asm.__indirect_function_table;\\\\\\\\n      addOnInit(Module.asm.__wasm_call_ctors);\\\\\\\\n      exportAsmFunctions(exports);\\\\\\\\n      removeRunDependency(\\\\\\\\\\\\\\\"wasm-instantiate\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n    addRunDependency(\\\\\\\\\\\\\\\"wasm-instantiate\\\\\\\\\\\\\\\");\\\\\\\\n    function receiveInstantiationResult(result) {\\\\\\\\n      receiveInstance(result.instance);\\\\\\\\n    }\\\\\\\\n    function instantiateArrayBuffer(receiver) {\\\\\\\\n      // This function has been patched from the original version.\\\\\\\\n      // See Bug 1988289.\\\\\\\\n      return getBinaryPromise()\\\\\\\\n        .then(binary => {\\\\\\\\n          const module = new WebAssembly.Module(binary);\\\\\\\\n          const instance = new WebAssembly.Instance(module, info);\\\\\\\\n          return { module, instance };\\\\\\\\n        })\\\\\\\\n        .then(function (instance) {\\\\\\\\n          return instance;\\\\\\\\n        })\\\\\\\\n        .then(receiver, function (reason) {\\\\\\\\n          err(\\\\\\\\\\\\\\\"failed to asynchronously prepare wasm: \\\\\\\\\\\\\\\" + reason);\\\\\\\\n          abort(reason);\\\\\\\\n        });\\\\\\\\n    }\\\\\\\\n    function instantiateAsync() {\\\\\\\\n      if (\\\\\\\\n        !wasmBinary &&\\\\\\\\n        typeof WebAssembly.instantiateStreaming == \\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\" &&\\\\\\\\n        !isDataURI(wasmBinaryFile) &&\\\\\\\\n        typeof fetch == \\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\"\\\\\\\\n      ) {\\\\\\\\n        return fetch(wasmBinaryFile, {\\\\\\\\n          credentials: \\\\\\\\\\\\\\\"same-origin\\\\\\\\\\\\\\\",\\\\\\\\n        }).then(function (response) {\\\\\\\\n          var result = WebAssembly.instantiateStreaming(response, info);\\\\\\\\n          return result.then(receiveInstantiationResult, function (reason) {\\\\\\\\n            err(\\\\\\\\\\\\\\\"wasm streaming compile failed: \\\\\\\\\\\\\\\" + reason);\\\\\\\\n            err(\\\\\\\\\\\\\\\"falling back to ArrayBuffer instantiation\\\\\\\\\\\\\\\");\\\\\\\\n            return instantiateArrayBuffer(receiveInstantiationResult);\\\\\\\\n          });\\\\\\\\n        });\\\\\\\\n      }\\\\\\\\n      return instantiateArrayBuffer(receiveInstantiationResult);\\\\\\\\n    }\\\\\\\\n    if (Module.instantiateWasm) {\\\\\\\\n      try {\\\\\\\\n        var exports = Module.instantiateWasm(info, receiveInstance);\\\\\\\\n        return exports;\\\\\\\\n      } catch (e) {\\\\\\\\n        err(\\\\\\\\\\\\\\\"Module.instantiateWasm callback failed with error: \\\\\\\\\\\\\\\" + e);\\\\\\\\n        return false;\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    instantiateAsync();\\\\\\\\n    return {};\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var tempDouble;\\\\\\\\n\\\\\\\\n  var tempI64;\\\\\\\\n\\\\\\\\n  var ASM_CONSTS = {\\\\\\\\n    1427332($0, $1, $2, $3, $4) {\\\\\\\\n      if (!Module.getOrCreateSentenceSegmenter) {\\\\\\\\n        Module.getOrCreateSentenceSegmenter = (function () {\\\\\\\\n          let segmenters = new Map();\\\\\\\\n          return function (lang) {\\\\\\\\n            let segmenter = segmenters.get(lang);\\\\\\\\n            if (!segmenter) {\\\\\\\\n              segmenter = new Intl.Segmenter(lang, {\\\\\\\\n                granularity: \\\\\\\\\\\\\\\"sentence\\\\\\\\\\\\\\\",\\\\\\\\n              });\\\\\\\\n              segmenters.set(lang, segmenter);\\\\\\\\n            }\\\\\\\\n            return segmenter;\\\\\\\\n          };\\\\\\\\n        })();\\\\\\\\n      }\\\\\\\\n      const inputUTF16 = UTF8ToString($0);\\\\\\\\n      const lang = UTF8ToString($1);\\\\\\\\n      const segmenter = Module.getOrCreateSentenceSegmenter(lang);\\\\\\\\n      const sentencesUTF16 = Array.from(segmenter.segment(inputUTF16));\\\\\\\\n      const sentenceCount = sentencesUTF16.length;\\\\\\\\n      const bytesPerInt = 4;\\\\\\\\n      const startsPtr = _malloc(sentenceCount * bytesPerInt);\\\\\\\\n      const endsPtr = _malloc(sentenceCount * bytesPerInt);\\\\\\\\n      if (!startsPtr || !endsPtr) {\\\\\\\\n        throw new Error(\\\\\\\\\\\\\\\"Failed to allocate WASM memory for segmentation.\\\\\\\\\\\\\\\");\\\\\\\\n      }\\\\\\\\n      let sentenceEndUTF8 = 0;\\\\\\\\n      sentencesUTF16.forEach(({ segment: sentenceUTF16 }, index) => {\\\\\\\\n        const sentenceStartUTF8 = sentenceEndUTF8;\\\\\\\\n        sentenceEndUTF8 += lengthBytesUTF8(sentenceUTF16);\\\\\\\\n        setValue(startsPtr + index * bytesPerInt, sentenceStartUTF8, \\\\\\\\\\\\\\\"i32\\\\\\\\\\\\\\\");\\\\\\\\n        setValue(endsPtr + index * bytesPerInt, sentenceEndUTF8, \\\\\\\\\\\\\\\"i32\\\\\\\\\\\\\\\");\\\\\\\\n      });\\\\\\\\n      setValue($2, sentenceCount, \\\\\\\\\\\\\\\"i32\\\\\\\\\\\\\\\");\\\\\\\\n      setValue($3, startsPtr, \\\\\\\\\\\\\\\"i32\\\\\\\\\\\\\\\");\\\\\\\\n      setValue($4, endsPtr, \\\\\\\\\\\\\\\"i32\\\\\\\\\\\\\\\");\\\\\\\\n    },\\\\\\\\n  };\\\\\\\\n\\\\\\\\n  function callRuntimeCallbacks(callbacks) {\\\\\\\\n    while (callbacks.length) {\\\\\\\\n      var callback = callbacks.shift();\\\\\\\\n      if (typeof callback == \\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\") {\\\\\\\\n        callback(Module);\\\\\\\\n        continue;\\\\\\\\n      }\\\\\\\\n      var func = callback.func;\\\\\\\\n      if (typeof func == \\\\\\\\\\\\\\\"number\\\\\\\\\\\\\\\") {\\\\\\\\n        if (callback.arg === undefined) {\\\\\\\\n          getWasmTableEntry(func)();\\\\\\\\n        } else {\\\\\\\\n          getWasmTableEntry(func)(callback.arg);\\\\\\\\n        }\\\\\\\\n      } else {\\\\\\\\n        func(callback.arg === undefined ? null : callback.arg);\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function asmjsMangle(x) {\\\\\\\\n    var unmangledSymbols = [\\\\\\\\\\\\\\\"stackAlloc\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"stackSave\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"stackRestore\\\\\\\\\\\\\\\"];\\\\\\\\n    return x.indexOf(\\\\\\\\\\\\\\\"dynCall_\\\\\\\\\\\\\\\") == 0 || unmangledSymbols.includes(x)\\\\\\\\n      ? x\\\\\\\\n      : \\\\\\\\\\\\\\\"_\\\\\\\\\\\\\\\" + x;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function exportAsmFunctions(asm) {\\\\\\\\n    var global_object = this;\\\\\\\\n    for (var __exportedFunc in asm) {\\\\\\\\n      var jsname = asmjsMangle(__exportedFunc);\\\\\\\\n      global_object[jsname] = Module[jsname] = asm[__exportedFunc];\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var wasmTableMirror = [];\\\\\\\\n\\\\\\\\n  function getWasmTableEntry(funcPtr) {\\\\\\\\n    var func = wasmTableMirror[funcPtr];\\\\\\\\n    if (!func) {\\\\\\\\n      if (funcPtr >= wasmTableMirror.length) {\\\\\\\\n        wasmTableMirror.length = funcPtr + 1;\\\\\\\\n      }\\\\\\\\n      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\\\\\\\\n    }\\\\\\\\n    return func;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function ___assert_fail(condition, filename, line, func) {\\\\\\\\n    abort(\\\\\\\\n      \\\\\\\\\\\\\\\"Assertion failed: \\\\\\\\\\\\\\\" +\\\\\\\\n        UTF8ToString(condition) +\\\\\\\\n        \\\\\\\\\\\\\\\", at: \\\\\\\\\\\\\\\" +\\\\\\\\n        [\\\\\\\\n          filename ? UTF8ToString(filename) : \\\\\\\\\\\\\\\"unknown filename\\\\\\\\\\\\\\\",\\\\\\\\n          line,\\\\\\\\n          func ? UTF8ToString(func) : \\\\\\\\\\\\\\\"unknown function\\\\\\\\\\\\\\\",\\\\\\\\n        ]\\\\\\\\n    );\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function ___cxa_allocate_exception(size) {\\\\\\\\n    return _malloc(size + 16) + 16;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var exceptionCaught = [];\\\\\\\\n\\\\\\\\n  var exceptionLast = 0;\\\\\\\\n\\\\\\\\n  var uncaughtExceptionCount = 0;\\\\\\\\n\\\\\\\\n  function ___cxa_rethrow() {\\\\\\\\n    var catchInfo = exceptionCaught.pop();\\\\\\\\n    if (!catchInfo) {\\\\\\\\n      abort(\\\\\\\\\\\\\\\"no exception to throw\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n    var info = catchInfo.get_exception_info();\\\\\\\\n    var ptr = catchInfo.get_base_ptr();\\\\\\\\n    if (!info.get_rethrown()) {\\\\\\\\n      exceptionCaught.push(catchInfo);\\\\\\\\n      info.set_rethrown(true);\\\\\\\\n      info.set_caught(false);\\\\\\\\n      uncaughtExceptionCount++;\\\\\\\\n    } else {\\\\\\\\n      catchInfo.free();\\\\\\\\n    }\\\\\\\\n    exceptionLast = ptr;\\\\\\\\n    throw ptr;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function ExceptionInfo(excPtr) {\\\\\\\\n    this.excPtr = excPtr;\\\\\\\\n    this.ptr = excPtr - 16;\\\\\\\\n    this.set_type = function (type) {\\\\\\\\n      HEAP32[(this.ptr + 4) >> 2] = type;\\\\\\\\n    };\\\\\\\\n    this.get_type = function () {\\\\\\\\n      return HEAP32[(this.ptr + 4) >> 2];\\\\\\\\n    };\\\\\\\\n    this.set_destructor = function (destructor) {\\\\\\\\n      HEAP32[(this.ptr + 8) >> 2] = destructor;\\\\\\\\n    };\\\\\\\\n    this.get_destructor = function () {\\\\\\\\n      return HEAP32[(this.ptr + 8) >> 2];\\\\\\\\n    };\\\\\\\\n    this.set_refcount = function (refcount) {\\\\\\\\n      HEAP32[this.ptr >> 2] = refcount;\\\\\\\\n    };\\\\\\\\n    this.set_caught = function (caught) {\\\\\\\\n      caught = caught ? 1 : 0;\\\\\\\\n      HEAP8[(this.ptr + 12) >> 0] = caught;\\\\\\\\n    };\\\\\\\\n    this.get_caught = function () {\\\\\\\\n      return HEAP8[(this.ptr + 12) >> 0] != 0;\\\\\\\\n    };\\\\\\\\n    this.set_rethrown = function (rethrown) {\\\\\\\\n      rethrown = rethrown ? 1 : 0;\\\\\\\\n      HEAP8[(this.ptr + 13) >> 0] = rethrown;\\\\\\\\n    };\\\\\\\\n    this.get_rethrown = function () {\\\\\\\\n      return HEAP8[(this.ptr + 13) >> 0] != 0;\\\\\\\\n    };\\\\\\\\n    this.init = function (type, destructor) {\\\\\\\\n      this.set_type(type);\\\\\\\\n      this.set_destructor(destructor);\\\\\\\\n      this.set_refcount(0);\\\\\\\\n      this.set_caught(false);\\\\\\\\n      this.set_rethrown(false);\\\\\\\\n    };\\\\\\\\n    this.add_ref = function () {\\\\\\\\n      var value = HEAP32[this.ptr >> 2];\\\\\\\\n      HEAP32[this.ptr >> 2] = value + 1;\\\\\\\\n    };\\\\\\\\n    this.release_ref = function () {\\\\\\\\n      var prev = HEAP32[this.ptr >> 2];\\\\\\\\n      HEAP32[this.ptr >> 2] = prev - 1;\\\\\\\\n      return prev === 1;\\\\\\\\n    };\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function ___cxa_throw(ptr, type, destructor) {\\\\\\\\n    var info = new ExceptionInfo(ptr);\\\\\\\\n    info.init(type, destructor);\\\\\\\\n    exceptionLast = ptr;\\\\\\\\n    uncaughtExceptionCount++;\\\\\\\\n    throw ptr;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var SYSCALLS = {\\\\\\\\n    buffers: [null, [], []],\\\\\\\\n    printChar(stream, curr) {\\\\\\\\n      var buffer = SYSCALLS.buffers[stream];\\\\\\\\n      if (curr === 0 || curr === 10) {\\\\\\\\n        (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\\\\\\\\n        buffer.length = 0;\\\\\\\\n      } else {\\\\\\\\n        buffer.push(curr);\\\\\\\\n      }\\\\\\\\n    },\\\\\\\\n    varargs: undefined,\\\\\\\\n    get() {\\\\\\\\n      SYSCALLS.varargs += 4;\\\\\\\\n      var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];\\\\\\\\n      return ret;\\\\\\\\n    },\\\\\\\\n    getStr(ptr) {\\\\\\\\n      var ret = UTF8ToString(ptr);\\\\\\\\n      return ret;\\\\\\\\n    },\\\\\\\\n    get64(low, high) {\\\\\\\\n      return low;\\\\\\\\n    },\\\\\\\\n  };\\\\\\\\n\\\\\\\\n  function ___syscall_faccessat(dirfd, path, amode, flags) {\\\\\\\\n    path = SYSCALLS.getStr(path);\\\\\\\\n    path = SYSCALLS.calculateAt(dirfd, path);\\\\\\\\n    return SYSCALLS.doAccess(path, amode);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function ___syscall_fcntl64(fd, cmd, varargs) {\\\\\\\\n    SYSCALLS.varargs = varargs;\\\\\\\\n    return 0;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function ___syscall_fstat64(fd, buf) {}\\\\\\\\n\\\\\\\\n  function ___syscall_getcwd(buf, size) {}\\\\\\\\n\\\\\\\\n  function ___syscall_ioctl(fd, op, varargs) {\\\\\\\\n    SYSCALLS.varargs = varargs;\\\\\\\\n    return 0;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function ___syscall_lstat64(path, buf) {}\\\\\\\\n\\\\\\\\n  function ___syscall_newfstatat(dirfd, path, buf, flags) {}\\\\\\\\n\\\\\\\\n  function ___syscall_openat(dirfd, path, flags, varargs) {\\\\\\\\n    SYSCALLS.varargs = varargs;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {}\\\\\\\\n\\\\\\\\n  function ___syscall_rmdir(path) {}\\\\\\\\n\\\\\\\\n  function ___syscall_stat64(path, buf) {}\\\\\\\\n\\\\\\\\n  function ___syscall_unlinkat(dirfd, path, flags) {}\\\\\\\\n\\\\\\\\n  var structRegistrations = {};\\\\\\\\n\\\\\\\\n  function runDestructors(destructors) {\\\\\\\\n    while (destructors.length) {\\\\\\\\n      var ptr = destructors.pop();\\\\\\\\n      var del = destructors.pop();\\\\\\\\n      del(ptr);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function simpleReadValueFromPointer(pointer) {\\\\\\\\n    return this.fromWireType(HEAPU32[pointer >> 2]);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var awaitingDependencies = {};\\\\\\\\n\\\\\\\\n  var registeredTypes = {};\\\\\\\\n\\\\\\\\n  var typeDependencies = {};\\\\\\\\n\\\\\\\\n  var char_0 = 48;\\\\\\\\n\\\\\\\\n  var char_9 = 57;\\\\\\\\n\\\\\\\\n  function makeLegalFunctionName(name) {\\\\\\\\n    if (undefined === name) {\\\\\\\\n      return \\\\\\\\\\\\\\\"_unknown\\\\\\\\\\\\\\\";\\\\\\\\n    }\\\\\\\\n    name = name.replace(/[^a-zA-Z0-9_]/g, \\\\\\\\\\\\\\\"$\\\\\\\\\\\\\\\");\\\\\\\\n    var f = name.charCodeAt(0);\\\\\\\\n    if (f >= char_0 && f <= char_9) {\\\\\\\\n      return \\\\\\\\\\\\\\\"_\\\\\\\\\\\\\\\" + name;\\\\\\\\n    }\\\\\\\\n    return name;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function createNamedFunction(name, body) {\\\\\\\\n    name = makeLegalFunctionName(name);\\\\\\\\n    return function () {\\\\\\\\n      null;\\\\\\\\n      return body.apply(this, arguments);\\\\\\\\n    };\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function extendError(baseErrorType, errorName) {\\\\\\\\n    var errorClass = createNamedFunction(errorName, function (message) {\\\\\\\\n      this.name = errorName;\\\\\\\\n      this.message = message;\\\\\\\\n      var stack = new Error(message).stack;\\\\\\\\n      if (stack !== undefined) {\\\\\\\\n        this.stack =\\\\\\\\n          this.toString() + \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\" + stack.replace(/^Error(:[^\\\\\\\\\\\\\\\\n]*)?\\\\\\\\\\\\\\\\n/, \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\");\\\\\\\\n      }\\\\\\\\n    });\\\\\\\\n    errorClass.prototype = Object.create(baseErrorType.prototype);\\\\\\\\n    errorClass.prototype.constructor = errorClass;\\\\\\\\n    errorClass.prototype.toString = function () {\\\\\\\\n      if (this.message === undefined) {\\\\\\\\n        return this.name;\\\\\\\\n      }\\\\\\\\n      return this.name + \\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\" + this.message;\\\\\\\\n    };\\\\\\\\n    return errorClass;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var InternalError = undefined;\\\\\\\\n\\\\\\\\n  function throwInternalError(message) {\\\\\\\\n    throw new InternalError(message);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function whenDependentTypesAreResolved(\\\\\\\\n    myTypes,\\\\\\\\n    dependentTypes,\\\\\\\\n    getTypeConverters\\\\\\\\n  ) {\\\\\\\\n    myTypes.forEach(function (type) {\\\\\\\\n      typeDependencies[type] = dependentTypes;\\\\\\\\n    });\\\\\\\\n    function onComplete(typeConverters) {\\\\\\\\n      var myTypeConverters = getTypeConverters(typeConverters);\\\\\\\\n      if (myTypeConverters.length !== myTypes.length) {\\\\\\\\n        throwInternalError(\\\\\\\\\\\\\\\"Mismatched type converter count\\\\\\\\\\\\\\\");\\\\\\\\n      }\\\\\\\\n      for (var i = 0; i < myTypes.length; ++i) {\\\\\\\\n        registerType(myTypes[i], myTypeConverters[i]);\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    var typeConverters = new Array(dependentTypes.length);\\\\\\\\n    var unregisteredTypes = [];\\\\\\\\n    var registered = 0;\\\\\\\\n    dependentTypes.forEach((dt, i) => {\\\\\\\\n      if (registeredTypes.hasOwnProperty(dt)) {\\\\\\\\n        typeConverters[i] = registeredTypes[dt];\\\\\\\\n      } else {\\\\\\\\n        unregisteredTypes.push(dt);\\\\\\\\n        if (!awaitingDependencies.hasOwnProperty(dt)) {\\\\\\\\n          awaitingDependencies[dt] = [];\\\\\\\\n        }\\\\\\\\n        awaitingDependencies[dt].push(() => {\\\\\\\\n          typeConverters[i] = registeredTypes[dt];\\\\\\\\n          ++registered;\\\\\\\\n          if (registered === unregisteredTypes.length) {\\\\\\\\n            onComplete(typeConverters);\\\\\\\\n          }\\\\\\\\n        });\\\\\\\\n      }\\\\\\\\n    });\\\\\\\\n    if (0 === unregisteredTypes.length) {\\\\\\\\n      onComplete(typeConverters);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_finalize_value_object(structType) {\\\\\\\\n    var reg = structRegistrations[structType];\\\\\\\\n    delete structRegistrations[structType];\\\\\\\\n    var rawConstructor = reg.rawConstructor;\\\\\\\\n    var rawDestructor = reg.rawDestructor;\\\\\\\\n    var fieldRecords = reg.fields;\\\\\\\\n    var fieldTypes = fieldRecords\\\\\\\\n      .map(field => field.getterReturnType)\\\\\\\\n      .concat(fieldRecords.map(field => field.setterArgumentType));\\\\\\\\n    whenDependentTypesAreResolved([structType], fieldTypes, fieldTypes => {\\\\\\\\n      var fields = {};\\\\\\\\n      fieldRecords.forEach((field, i) => {\\\\\\\\n        var fieldName = field.fieldName;\\\\\\\\n        var getterReturnType = fieldTypes[i];\\\\\\\\n        var getter = field.getter;\\\\\\\\n        var getterContext = field.getterContext;\\\\\\\\n        var setterArgumentType = fieldTypes[i + fieldRecords.length];\\\\\\\\n        var setter = field.setter;\\\\\\\\n        var setterContext = field.setterContext;\\\\\\\\n        fields[fieldName] = {\\\\\\\\n          read: ptr => {\\\\\\\\n            return getterReturnType.fromWireType(getter(getterContext, ptr));\\\\\\\\n          },\\\\\\\\n          write: (ptr, o) => {\\\\\\\\n            var destructors = [];\\\\\\\\n            setter(\\\\\\\\n              setterContext,\\\\\\\\n              ptr,\\\\\\\\n              setterArgumentType.toWireType(destructors, o, \\\\\\\\\\\\\\\"foo1\\\\\\\\\\\\\\\")\\\\\\\\n            );\\\\\\\\n            runDestructors(destructors);\\\\\\\\n          },\\\\\\\\n        };\\\\\\\\n      });\\\\\\\\n      return [\\\\\\\\n        {\\\\\\\\n          name: reg.name,\\\\\\\\n          fromWireType: function (ptr) {\\\\\\\\n            var rv = {};\\\\\\\\n            for (var i in fields) {\\\\\\\\n              rv[i] = fields[i].read(ptr);\\\\\\\\n            }\\\\\\\\n            rawDestructor(ptr);\\\\\\\\n            return rv;\\\\\\\\n          },\\\\\\\\n          toWireType: function (destructors, o) {\\\\\\\\n            for (var fieldName in fields) {\\\\\\\\n              if (!(fieldName in o)) {\\\\\\\\n                throw new TypeError('Missing field:  \\\\\\\\\\\\\\\"' + fieldName + '\\\\\\\\\\\\\\\"');\\\\\\\\n              }\\\\\\\\n            }\\\\\\\\n            var ptr = rawConstructor();\\\\\\\\n            for (fieldName in fields) {\\\\\\\\n              fields[fieldName].write(ptr, o[fieldName]);\\\\\\\\n            }\\\\\\\\n            if (destructors !== null) {\\\\\\\\n              destructors.push(rawDestructor, ptr);\\\\\\\\n            }\\\\\\\\n            return ptr;\\\\\\\\n          },\\\\\\\\n          argPackAdvance: 8,\\\\\\\\n          readValueFromPointer: simpleReadValueFromPointer,\\\\\\\\n          destructorFunction: rawDestructor,\\\\\\\\n        },\\\\\\\\n      ];\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_register_bigint(\\\\\\\\n    primitiveType,\\\\\\\\n    name,\\\\\\\\n    size,\\\\\\\\n    minRange,\\\\\\\\n    maxRange\\\\\\\\n  ) {}\\\\\\\\n\\\\\\\\n  function getShiftFromSize(size) {\\\\\\\\n    switch (size) {\\\\\\\\n      case 1:\\\\\\\\n        return 0;\\\\\\\\n\\\\\\\\n      case 2:\\\\\\\\n        return 1;\\\\\\\\n\\\\\\\\n      case 4:\\\\\\\\n        return 2;\\\\\\\\n\\\\\\\\n      case 8:\\\\\\\\n        return 3;\\\\\\\\n\\\\\\\\n      default:\\\\\\\\n        throw new TypeError(\\\\\\\\\\\\\\\"Unknown type size: \\\\\\\\\\\\\\\" + size);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function embind_init_charCodes() {\\\\\\\\n    var codes = new Array(256);\\\\\\\\n    for (var i = 0; i < 256; ++i) {\\\\\\\\n      codes[i] = String.fromCharCode(i);\\\\\\\\n    }\\\\\\\\n    embind_charCodes = codes;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var embind_charCodes = undefined;\\\\\\\\n\\\\\\\\n  function readLatin1String(ptr) {\\\\\\\\n    var ret = \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\";\\\\\\\\n    var c = ptr;\\\\\\\\n    while (HEAPU8[c]) {\\\\\\\\n      ret += embind_charCodes[HEAPU8[c++]];\\\\\\\\n    }\\\\\\\\n    return ret;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var BindingError = undefined;\\\\\\\\n\\\\\\\\n  function throwBindingError(message) {\\\\\\\\n    throw new BindingError(message);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function registerType(rawType, registeredInstance, options = {}) {\\\\\\\\n    if (!(\\\\\\\\\\\\\\\"argPackAdvance\\\\\\\\\\\\\\\" in registeredInstance)) {\\\\\\\\n      throw new TypeError(\\\\\\\\n        \\\\\\\\\\\\\\\"registerType registeredInstance requires argPackAdvance\\\\\\\\\\\\\\\"\\\\\\\\n      );\\\\\\\\n    }\\\\\\\\n    var name = registeredInstance.name;\\\\\\\\n    if (!rawType) {\\\\\\\\n      throwBindingError(\\\\\\\\n        'type \\\\\\\\\\\\\\\"' + name + '\\\\\\\\\\\\\\\" must have a positive integer typeid pointer'\\\\\\\\n      );\\\\\\\\n    }\\\\\\\\n    if (registeredTypes.hasOwnProperty(rawType)) {\\\\\\\\n      if (options.ignoreDuplicateRegistrations) {\\\\\\\\n        return;\\\\\\\\n      }\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\"Cannot register type '\\\\\\\\\\\\\\\" + name + \\\\\\\\\\\\\\\"' twice\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n    registeredTypes[rawType] = registeredInstance;\\\\\\\\n    delete typeDependencies[rawType];\\\\\\\\n    if (awaitingDependencies.hasOwnProperty(rawType)) {\\\\\\\\n      var callbacks = awaitingDependencies[rawType];\\\\\\\\n      delete awaitingDependencies[rawType];\\\\\\\\n      callbacks.forEach(cb => cb());\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\\\\\\\\n    var shift = getShiftFromSize(size);\\\\\\\\n    name = readLatin1String(name);\\\\\\\\n    registerType(rawType, {\\\\\\\\n      name,\\\\\\\\n      fromWireType: function (wt) {\\\\\\\\n        return !!wt;\\\\\\\\n      },\\\\\\\\n      toWireType: function (destructors, o) {\\\\\\\\n        return o ? trueValue : falseValue;\\\\\\\\n      },\\\\\\\\n      argPackAdvance: 8,\\\\\\\\n      readValueFromPointer: function (pointer) {\\\\\\\\n        var heap;\\\\\\\\n        if (size === 1) {\\\\\\\\n          heap = HEAP8;\\\\\\\\n        } else if (size === 2) {\\\\\\\\n          heap = HEAP16;\\\\\\\\n        } else if (size === 4) {\\\\\\\\n          heap = HEAP32;\\\\\\\\n        } else {\\\\\\\\n          throw new TypeError(\\\\\\\\\\\\\\\"Unknown boolean type size: \\\\\\\\\\\\\\\" + name);\\\\\\\\n        }\\\\\\\\n        return this.fromWireType(heap[pointer >> shift]);\\\\\\\\n      },\\\\\\\\n      destructorFunction: null,\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function ClassHandle_isAliasOf(other) {\\\\\\\\n    if (!(this instanceof ClassHandle)) {\\\\\\\\n      return false;\\\\\\\\n    }\\\\\\\\n    if (!(other instanceof ClassHandle)) {\\\\\\\\n      return false;\\\\\\\\n    }\\\\\\\\n    var leftClass = this.$$.ptrType.registeredClass;\\\\\\\\n    var left = this.$$.ptr;\\\\\\\\n    var rightClass = other.$$.ptrType.registeredClass;\\\\\\\\n    var right = other.$$.ptr;\\\\\\\\n    while (leftClass.baseClass) {\\\\\\\\n      left = leftClass.upcast(left);\\\\\\\\n      leftClass = leftClass.baseClass;\\\\\\\\n    }\\\\\\\\n    while (rightClass.baseClass) {\\\\\\\\n      right = rightClass.upcast(right);\\\\\\\\n      rightClass = rightClass.baseClass;\\\\\\\\n    }\\\\\\\\n    return leftClass === rightClass && left === right;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function shallowCopyInternalPointer(o) {\\\\\\\\n    return {\\\\\\\\n      count: o.count,\\\\\\\\n      deleteScheduled: o.deleteScheduled,\\\\\\\\n      preservePointerOnDelete: o.preservePointerOnDelete,\\\\\\\\n      ptr: o.ptr,\\\\\\\\n      ptrType: o.ptrType,\\\\\\\\n      smartPtr: o.smartPtr,\\\\\\\\n      smartPtrType: o.smartPtrType,\\\\\\\\n    };\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function throwInstanceAlreadyDeleted(obj) {\\\\\\\\n    function getInstanceTypeName(handle) {\\\\\\\\n      return handle.$$.ptrType.registeredClass.name;\\\\\\\\n    }\\\\\\\\n    throwBindingError(getInstanceTypeName(obj) + \\\\\\\\\\\\\\\" instance already deleted\\\\\\\\\\\\\\\");\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var finalizationRegistry = false;\\\\\\\\n\\\\\\\\n  function detachFinalizer(handle) {}\\\\\\\\n\\\\\\\\n  function runDestructor($$) {\\\\\\\\n    if ($$.smartPtr) {\\\\\\\\n      $$.smartPtrType.rawDestructor($$.smartPtr);\\\\\\\\n    } else {\\\\\\\\n      $$.ptrType.registeredClass.rawDestructor($$.ptr);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function releaseClassHandle($$) {\\\\\\\\n    $$.count.value -= 1;\\\\\\\\n    var toDelete = 0 === $$.count.value;\\\\\\\\n    if (toDelete) {\\\\\\\\n      runDestructor($$);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function downcastPointer(ptr, ptrClass, desiredClass) {\\\\\\\\n    if (ptrClass === desiredClass) {\\\\\\\\n      return ptr;\\\\\\\\n    }\\\\\\\\n    if (undefined === desiredClass.baseClass) {\\\\\\\\n      return null;\\\\\\\\n    }\\\\\\\\n    var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\\\\\\\\n    if (rv === null) {\\\\\\\\n      return null;\\\\\\\\n    }\\\\\\\\n    return desiredClass.downcast(rv);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var registeredPointers = {};\\\\\\\\n\\\\\\\\n  function getInheritedInstanceCount() {\\\\\\\\n    return Object.keys(registeredInstances).length;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function getLiveInheritedInstances() {\\\\\\\\n    var rv = [];\\\\\\\\n    for (var k in registeredInstances) {\\\\\\\\n      if (registeredInstances.hasOwnProperty(k)) {\\\\\\\\n        rv.push(registeredInstances[k]);\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    return rv;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var deletionQueue = [];\\\\\\\\n\\\\\\\\n  function flushPendingDeletes() {\\\\\\\\n    while (deletionQueue.length) {\\\\\\\\n      var obj = deletionQueue.pop();\\\\\\\\n      obj.$$.deleteScheduled = false;\\\\\\\\n      obj.delete();\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var delayFunction = undefined;\\\\\\\\n\\\\\\\\n  function setDelayFunction(fn) {\\\\\\\\n    delayFunction = fn;\\\\\\\\n    if (deletionQueue.length && delayFunction) {\\\\\\\\n      delayFunction(flushPendingDeletes);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function init_embind() {\\\\\\\\n    Module.getInheritedInstanceCount = getInheritedInstanceCount;\\\\\\\\n    Module.getLiveInheritedInstances = getLiveInheritedInstances;\\\\\\\\n    Module.flushPendingDeletes = flushPendingDeletes;\\\\\\\\n    Module.setDelayFunction = setDelayFunction;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var registeredInstances = {};\\\\\\\\n\\\\\\\\n  function getBasestPointer(class_, ptr) {\\\\\\\\n    if (ptr === undefined) {\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\"ptr should not be undefined\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n    while (class_.baseClass) {\\\\\\\\n      ptr = class_.upcast(ptr);\\\\\\\\n      class_ = class_.baseClass;\\\\\\\\n    }\\\\\\\\n    return ptr;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function getInheritedInstance(class_, ptr) {\\\\\\\\n    ptr = getBasestPointer(class_, ptr);\\\\\\\\n    return registeredInstances[ptr];\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function makeClassHandle(prototype, record) {\\\\\\\\n    if (!record.ptrType || !record.ptr) {\\\\\\\\n      throwInternalError(\\\\\\\\\\\\\\\"makeClassHandle requires ptr and ptrType\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n    var hasSmartPtrType = !!record.smartPtrType;\\\\\\\\n    var hasSmartPtr = !!record.smartPtr;\\\\\\\\n    if (hasSmartPtrType !== hasSmartPtr) {\\\\\\\\n      throwInternalError(\\\\\\\\\\\\\\\"Both smartPtrType and smartPtr must be specified\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n    record.count = {\\\\\\\\n      value: 1,\\\\\\\\n    };\\\\\\\\n    return attachFinalizer(\\\\\\\\n      Object.create(prototype, {\\\\\\\\n        $$: {\\\\\\\\n          value: record,\\\\\\\\n        },\\\\\\\\n      })\\\\\\\\n    );\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function RegisteredPointer_fromWireType(ptr) {\\\\\\\\n    var rawPointer = this.getPointee(ptr);\\\\\\\\n    if (!rawPointer) {\\\\\\\\n      this.destructor(ptr);\\\\\\\\n      return null;\\\\\\\\n    }\\\\\\\\n    var registeredInstance = getInheritedInstance(\\\\\\\\n      this.registeredClass,\\\\\\\\n      rawPointer\\\\\\\\n    );\\\\\\\\n    if (undefined !== registeredInstance) {\\\\\\\\n      if (0 === registeredInstance.$$.count.value) {\\\\\\\\n        registeredInstance.$$.ptr = rawPointer;\\\\\\\\n        registeredInstance.$$.smartPtr = ptr;\\\\\\\\n        return registeredInstance.clone();\\\\\\\\n      }\\\\\\\\n      var rv = registeredInstance.clone();\\\\\\\\n      this.destructor(ptr);\\\\\\\\n      return rv;\\\\\\\\n    }\\\\\\\\n    function makeDefaultHandle() {\\\\\\\\n      if (this.isSmartPointer) {\\\\\\\\n        return makeClassHandle(this.registeredClass.instancePrototype, {\\\\\\\\n          ptrType: this.pointeeType,\\\\\\\\n          ptr: rawPointer,\\\\\\\\n          smartPtrType: this,\\\\\\\\n          smartPtr: ptr,\\\\\\\\n        });\\\\\\\\n      }\\\\\\\\n      return makeClassHandle(this.registeredClass.instancePrototype, {\\\\\\\\n        ptrType: this,\\\\\\\\n        ptr,\\\\\\\\n      });\\\\\\\\n    }\\\\\\\\n    var actualType = this.registeredClass.getActualType(rawPointer);\\\\\\\\n    var registeredPointerRecord = registeredPointers[actualType];\\\\\\\\n    if (!registeredPointerRecord) {\\\\\\\\n      return makeDefaultHandle.call(this);\\\\\\\\n    }\\\\\\\\n    var toType;\\\\\\\\n    if (this.isConst) {\\\\\\\\n      toType = registeredPointerRecord.constPointerType;\\\\\\\\n    } else {\\\\\\\\n      toType = registeredPointerRecord.pointerType;\\\\\\\\n    }\\\\\\\\n    var dp = downcastPointer(\\\\\\\\n      rawPointer,\\\\\\\\n      this.registeredClass,\\\\\\\\n      toType.registeredClass\\\\\\\\n    );\\\\\\\\n    if (dp === null) {\\\\\\\\n      return makeDefaultHandle.call(this);\\\\\\\\n    }\\\\\\\\n    if (this.isSmartPointer) {\\\\\\\\n      return makeClassHandle(toType.registeredClass.instancePrototype, {\\\\\\\\n        ptrType: toType,\\\\\\\\n        ptr: dp,\\\\\\\\n        smartPtrType: this,\\\\\\\\n        smartPtr: ptr,\\\\\\\\n      });\\\\\\\\n    }\\\\\\\\n    return makeClassHandle(toType.registeredClass.instancePrototype, {\\\\\\\\n      ptrType: toType,\\\\\\\\n      ptr: dp,\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function attachFinalizer(handle) {\\\\\\\\n    if (\\\\\\\\\\\\\\\"undefined\\\\\\\\\\\\\\\" === typeof FinalizationRegistry) {\\\\\\\\n      attachFinalizer = handle => handle;\\\\\\\\n      return handle;\\\\\\\\n    }\\\\\\\\n    finalizationRegistry = new FinalizationRegistry(info => {\\\\\\\\n      releaseClassHandle(info.$$);\\\\\\\\n    });\\\\\\\\n    attachFinalizer = handle => {\\\\\\\\n      var $$ = handle.$$;\\\\\\\\n      var hasSmartPtr = !!$$.smartPtr;\\\\\\\\n      if (hasSmartPtr) {\\\\\\\\n        var info = {\\\\\\\\n          $$,\\\\\\\\n        };\\\\\\\\n        finalizationRegistry.register(handle, info, handle);\\\\\\\\n      }\\\\\\\\n      return handle;\\\\\\\\n    };\\\\\\\\n    detachFinalizer = handle => finalizationRegistry.unregister(handle);\\\\\\\\n    return attachFinalizer(handle);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function ClassHandle_clone() {\\\\\\\\n    if (!this.$$.ptr) {\\\\\\\\n      throwInstanceAlreadyDeleted(this);\\\\\\\\n    }\\\\\\\\n    if (this.$$.preservePointerOnDelete) {\\\\\\\\n      this.$$.count.value += 1;\\\\\\\\n      return this;\\\\\\\\n    }\\\\\\\\n    var clone = attachFinalizer(\\\\\\\\n      Object.create(Object.getPrototypeOf(this), {\\\\\\\\n        $$: {\\\\\\\\n          value: shallowCopyInternalPointer(this.$$),\\\\\\\\n        },\\\\\\\\n      })\\\\\\\\n    );\\\\\\\\n    clone.$$.count.value += 1;\\\\\\\\n    clone.$$.deleteScheduled = false;\\\\\\\\n    return clone;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function ClassHandle_delete() {\\\\\\\\n    if (!this.$$.ptr) {\\\\\\\\n      throwInstanceAlreadyDeleted(this);\\\\\\\\n    }\\\\\\\\n    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\"Object already scheduled for deletion\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n    detachFinalizer(this);\\\\\\\\n    releaseClassHandle(this.$$);\\\\\\\\n    if (!this.$$.preservePointerOnDelete) {\\\\\\\\n      this.$$.smartPtr = undefined;\\\\\\\\n      this.$$.ptr = undefined;\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function ClassHandle_isDeleted() {\\\\\\\\n    return !this.$$.ptr;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function ClassHandle_deleteLater() {\\\\\\\\n    if (!this.$$.ptr) {\\\\\\\\n      throwInstanceAlreadyDeleted(this);\\\\\\\\n    }\\\\\\\\n    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\\\\\\\\n      throwBindingError(\\\\\\\\\\\\\\\"Object already scheduled for deletion\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n    deletionQueue.push(this);\\\\\\\\n    if (deletionQueue.length === 1 && delayFunction) {\\\\\\\\n      delayFunction(flushPendingDeletes);\\\\\\\\n    }\\\\\\\\n    this.$$.deleteScheduled = true;\\\\\\\\n    return this;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function init_ClassHandle() {\\\\\\\\n    ClassHandle.prototype.isAliasOf = ClassHandle_isAliasOf;\\\\\\\\n    ClassHandle.prototype.clone = ClassHandle_clone;\\\\\\\\n    ClassHandle.prototype.delete = ClassHandle_delete;\\\\\\\\n    ClassHandle.prototype.isDeleted = ClassHandle_isDeleted;\\\\\\\\n    ClassHandle.prototype.deleteLater = ClassHandle_deleteLater;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function ClassHandle() {}\\\\\\\\n\\\\\\\\n  function ensureOverloadTable(proto, methodName, humanName) {\\\\\\\\n    if (undefined === proto[methodName].overloadTable) {\\\\\\\\n      var prevFunc = proto[methodName];\\\\\\\\n      proto[methodName] = function () {\\\\\\\\n        if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\\\\\\\\n          throwBindingError(\\\\\\\\n            \\\\\\\\\\\\\\\"Function '\\\\\\\\\\\\\\\" +\\\\\\\\n              humanName +\\\\\\\\n              \\\\\\\\\\\\\\\"' called with an invalid number of arguments (\\\\\\\\\\\\\\\" +\\\\\\\\n              arguments.length +\\\\\\\\n              \\\\\\\\\\\\\\\") - expects one of (\\\\\\\\\\\\\\\" +\\\\\\\\n              proto[methodName].overloadTable +\\\\\\\\n              \\\\\\\\\\\\\\\")!\\\\\\\\\\\\\\\"\\\\\\\\n          );\\\\\\\\n        }\\\\\\\\n        return proto[methodName].overloadTable[arguments.length].apply(\\\\\\\\n          this,\\\\\\\\n          arguments\\\\\\\\n        );\\\\\\\\n      };\\\\\\\\n      proto[methodName].overloadTable = [];\\\\\\\\n      proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function exposePublicSymbol(name, value, numArguments) {\\\\\\\\n    if (Module.hasOwnProperty(name)) {\\\\\\\\n      if (\\\\\\\\n        undefined === numArguments ||\\\\\\\\n        (undefined !== Module[name].overloadTable &&\\\\\\\\n          undefined !== Module[name].overloadTable[numArguments])\\\\\\\\n      ) {\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\"Cannot register public name '\\\\\\\\\\\\\\\" + name + \\\\\\\\\\\\\\\"' twice\\\\\\\\\\\\\\\");\\\\\\\\n      }\\\\\\\\n      ensureOverloadTable(Module, name, name);\\\\\\\\n      if (Module.hasOwnProperty(numArguments)) {\\\\\\\\n        throwBindingError(\\\\\\\\n          \\\\\\\\\\\\\\\"Cannot register multiple overloads of a function with the same number of arguments (\\\\\\\\\\\\\\\" +\\\\\\\\n            numArguments +\\\\\\\\n            \\\\\\\\\\\\\\\")!\\\\\\\\\\\\\\\"\\\\\\\\n        );\\\\\\\\n      }\\\\\\\\n      Module[name].overloadTable[numArguments] = value;\\\\\\\\n    } else {\\\\\\\\n      Module[name] = value;\\\\\\\\n      if (undefined !== numArguments) {\\\\\\\\n        Module[name].numArguments = numArguments;\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function RegisteredClass(\\\\\\\\n    name,\\\\\\\\n    constructor,\\\\\\\\n    instancePrototype,\\\\\\\\n    rawDestructor,\\\\\\\\n    baseClass,\\\\\\\\n    getActualType,\\\\\\\\n    upcast,\\\\\\\\n    downcast\\\\\\\\n  ) {\\\\\\\\n    this.name = name;\\\\\\\\n    this.constructor = constructor;\\\\\\\\n    this.instancePrototype = instancePrototype;\\\\\\\\n    this.rawDestructor = rawDestructor;\\\\\\\\n    this.baseClass = baseClass;\\\\\\\\n    this.getActualType = getActualType;\\\\\\\\n    this.upcast = upcast;\\\\\\\\n    this.downcast = downcast;\\\\\\\\n    this.pureVirtualFunctions = [];\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function upcastPointer(ptr, ptrClass, desiredClass) {\\\\\\\\n    while (ptrClass !== desiredClass) {\\\\\\\\n      if (!ptrClass.upcast) {\\\\\\\\n        throwBindingError(\\\\\\\\n          \\\\\\\\\\\\\\\"Expected null or instance of \\\\\\\\\\\\\\\" +\\\\\\\\n            desiredClass.name +\\\\\\\\n            \\\\\\\\\\\\\\\", got an instance of \\\\\\\\\\\\\\\" +\\\\\\\\n            ptrClass.name\\\\\\\\n        );\\\\\\\\n      }\\\\\\\\n      ptr = ptrClass.upcast(ptr);\\\\\\\\n      ptrClass = ptrClass.baseClass;\\\\\\\\n    }\\\\\\\\n    return ptr;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function constNoSmartPtrRawPointerToWireType(destructors, handle) {\\\\\\\\n    if (handle === null) {\\\\\\\\n      if (this.isReference) {\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\"null is not a valid \\\\\\\\\\\\\\\" + this.name);\\\\\\\\n      }\\\\\\\\n      return 0;\\\\\\\\n    }\\\\\\\\n    if (!handle.$$) {\\\\\\\\n      throwBindingError(\\\\\\\\n        'Cannot pass \\\\\\\\\\\\\\\"' + _embind_repr(handle) + '\\\\\\\\\\\\\\\" as a ' + this.name\\\\\\\\n      );\\\\\\\\n    }\\\\\\\\n    if (!handle.$$.ptr) {\\\\\\\\n      throwBindingError(\\\\\\\\n        \\\\\\\\\\\\\\\"Cannot pass deleted object as a pointer of type \\\\\\\\\\\\\\\" + this.name\\\\\\\\n      );\\\\\\\\n    }\\\\\\\\n    var handleClass = handle.$$.ptrType.registeredClass;\\\\\\\\n    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\\\\\\\\n    return ptr;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function genericPointerToWireType(destructors, handle) {\\\\\\\\n    var ptr;\\\\\\\\n    if (handle === null) {\\\\\\\\n      if (this.isReference) {\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\"null is not a valid \\\\\\\\\\\\\\\" + this.name);\\\\\\\\n      }\\\\\\\\n      if (this.isSmartPointer) {\\\\\\\\n        ptr = this.rawConstructor();\\\\\\\\n        if (destructors !== null) {\\\\\\\\n          destructors.push(this.rawDestructor, ptr);\\\\\\\\n        }\\\\\\\\n        return ptr;\\\\\\\\n      }\\\\\\\\n      return 0;\\\\\\\\n    }\\\\\\\\n    if (!handle.$$) {\\\\\\\\n      throwBindingError(\\\\\\\\n        'Cannot pass \\\\\\\\\\\\\\\"' + _embind_repr(handle) + '\\\\\\\\\\\\\\\" as a ' + this.name\\\\\\\\n      );\\\\\\\\n    }\\\\\\\\n    if (!handle.$$.ptr) {\\\\\\\\n      throwBindingError(\\\\\\\\n        \\\\\\\\\\\\\\\"Cannot pass deleted object as a pointer of type \\\\\\\\\\\\\\\" + this.name\\\\\\\\n      );\\\\\\\\n    }\\\\\\\\n    if (!this.isConst && handle.$$.ptrType.isConst) {\\\\\\\\n      throwBindingError(\\\\\\\\n        \\\\\\\\\\\\\\\"Cannot convert argument of type \\\\\\\\\\\\\\\" +\\\\\\\\n          (handle.$$.smartPtrType\\\\\\\\n            ? handle.$$.smartPtrType.name\\\\\\\\n            : handle.$$.ptrType.name) +\\\\\\\\n          \\\\\\\\\\\\\\\" to parameter type \\\\\\\\\\\\\\\" +\\\\\\\\n          this.name\\\\\\\\n      );\\\\\\\\n    }\\\\\\\\n    var handleClass = handle.$$.ptrType.registeredClass;\\\\\\\\n    ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\\\\\\\\n    if (this.isSmartPointer) {\\\\\\\\n      if (undefined === handle.$$.smartPtr) {\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\"Passing raw pointer to smart pointer is illegal\\\\\\\\\\\\\\\");\\\\\\\\n      }\\\\\\\\n      switch (this.sharingPolicy) {\\\\\\\\n        case 0:\\\\\\\\n          if (handle.$$.smartPtrType === this) {\\\\\\\\n            ptr = handle.$$.smartPtr;\\\\\\\\n          } else {\\\\\\\\n            throwBindingError(\\\\\\\\n              \\\\\\\\\\\\\\\"Cannot convert argument of type \\\\\\\\\\\\\\\" +\\\\\\\\n                (handle.$$.smartPtrType\\\\\\\\n                  ? handle.$$.smartPtrType.name\\\\\\\\n                  : handle.$$.ptrType.name) +\\\\\\\\n                \\\\\\\\\\\\\\\" to parameter type \\\\\\\\\\\\\\\" +\\\\\\\\n                this.name\\\\\\\\n            );\\\\\\\\n          }\\\\\\\\n          break;\\\\\\\\n\\\\\\\\n        case 1:\\\\\\\\n          ptr = handle.$$.smartPtr;\\\\\\\\n          break;\\\\\\\\n\\\\\\\\n        case 2:\\\\\\\\n          if (handle.$$.smartPtrType === this) {\\\\\\\\n            ptr = handle.$$.smartPtr;\\\\\\\\n          } else {\\\\\\\\n            var clonedHandle = handle.clone();\\\\\\\\n            ptr = this.rawShare(\\\\\\\\n              ptr,\\\\\\\\n              Emval.toHandle(function () {\\\\\\\\n                clonedHandle.delete();\\\\\\\\n              })\\\\\\\\n            );\\\\\\\\n            if (destructors !== null) {\\\\\\\\n              destructors.push(this.rawDestructor, ptr);\\\\\\\\n            }\\\\\\\\n          }\\\\\\\\n          break;\\\\\\\\n\\\\\\\\n        default:\\\\\\\\n          throwBindingError(\\\\\\\\\\\\\\\"Unsupporting sharing policy\\\\\\\\\\\\\\\");\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    return ptr;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\\\\\\\\n    if (handle === null) {\\\\\\\\n      if (this.isReference) {\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\"null is not a valid \\\\\\\\\\\\\\\" + this.name);\\\\\\\\n      }\\\\\\\\n      return 0;\\\\\\\\n    }\\\\\\\\n    if (!handle.$$) {\\\\\\\\n      throwBindingError(\\\\\\\\n        'Cannot pass \\\\\\\\\\\\\\\"' + _embind_repr(handle) + '\\\\\\\\\\\\\\\" as a ' + this.name\\\\\\\\n      );\\\\\\\\n    }\\\\\\\\n    if (!handle.$$.ptr) {\\\\\\\\n      throwBindingError(\\\\\\\\n        \\\\\\\\\\\\\\\"Cannot pass deleted object as a pointer of type \\\\\\\\\\\\\\\" + this.name\\\\\\\\n      );\\\\\\\\n    }\\\\\\\\n    if (handle.$$.ptrType.isConst) {\\\\\\\\n      throwBindingError(\\\\\\\\n        \\\\\\\\\\\\\\\"Cannot convert argument of type \\\\\\\\\\\\\\\" +\\\\\\\\n          handle.$$.ptrType.name +\\\\\\\\n          \\\\\\\\\\\\\\\" to parameter type \\\\\\\\\\\\\\\" +\\\\\\\\n          this.name\\\\\\\\n      );\\\\\\\\n    }\\\\\\\\n    var handleClass = handle.$$.ptrType.registeredClass;\\\\\\\\n    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\\\\\\\\n    return ptr;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function RegisteredPointer_getPointee(ptr) {\\\\\\\\n    if (this.rawGetPointee) {\\\\\\\\n      ptr = this.rawGetPointee(ptr);\\\\\\\\n    }\\\\\\\\n    return ptr;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function RegisteredPointer_destructor(ptr) {\\\\\\\\n    if (this.rawDestructor) {\\\\\\\\n      this.rawDestructor(ptr);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function RegisteredPointer_deleteObject(handle) {\\\\\\\\n    if (handle !== null) {\\\\\\\\n      handle.delete();\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function init_RegisteredPointer() {\\\\\\\\n    RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\\\\\\\\n    RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\\\\\\\\n    RegisteredPointer.prototype.argPackAdvance = 8;\\\\\\\\n    RegisteredPointer.prototype.readValueFromPointer =\\\\\\\\n      simpleReadValueFromPointer;\\\\\\\\n    RegisteredPointer.prototype.deleteObject = RegisteredPointer_deleteObject;\\\\\\\\n    RegisteredPointer.prototype.fromWireType = RegisteredPointer_fromWireType;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function RegisteredPointer(\\\\\\\\n    name,\\\\\\\\n    registeredClass,\\\\\\\\n    isReference,\\\\\\\\n    isConst,\\\\\\\\n    isSmartPointer,\\\\\\\\n    pointeeType,\\\\\\\\n    sharingPolicy,\\\\\\\\n    rawGetPointee,\\\\\\\\n    rawConstructor,\\\\\\\\n    rawShare,\\\\\\\\n    rawDestructor\\\\\\\\n  ) {\\\\\\\\n    this.name = name;\\\\\\\\n    this.registeredClass = registeredClass;\\\\\\\\n    this.isReference = isReference;\\\\\\\\n    this.isConst = isConst;\\\\\\\\n    this.isSmartPointer = isSmartPointer;\\\\\\\\n    this.pointeeType = pointeeType;\\\\\\\\n    this.sharingPolicy = sharingPolicy;\\\\\\\\n    this.rawGetPointee = rawGetPointee;\\\\\\\\n    this.rawConstructor = rawConstructor;\\\\\\\\n    this.rawShare = rawShare;\\\\\\\\n    this.rawDestructor = rawDestructor;\\\\\\\\n    if (!isSmartPointer && registeredClass.baseClass === undefined) {\\\\\\\\n      if (isConst) {\\\\\\\\n        this.toWireType = constNoSmartPtrRawPointerToWireType;\\\\\\\\n        this.destructorFunction = null;\\\\\\\\n      } else {\\\\\\\\n        this.toWireType = nonConstNoSmartPtrRawPointerToWireType;\\\\\\\\n        this.destructorFunction = null;\\\\\\\\n      }\\\\\\\\n    } else {\\\\\\\\n      this.toWireType = genericPointerToWireType;\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function replacePublicSymbol(name, value, numArguments) {\\\\\\\\n    if (!Module.hasOwnProperty(name)) {\\\\\\\\n      throwInternalError(\\\\\\\\\\\\\\\"Replacing nonexistant public symbol\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n    if (\\\\\\\\n      undefined !== Module[name].overloadTable &&\\\\\\\\n      undefined !== numArguments\\\\\\\\n    ) {\\\\\\\\n      Module[name].overloadTable[numArguments] = value;\\\\\\\\n    } else {\\\\\\\\n      Module[name] = value;\\\\\\\\n      Module[name].argCount = numArguments;\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function dynCallLegacy(sig, ptr, args) {\\\\\\\\n    var f = Module[\\\\\\\\\\\\\\\"dynCall_\\\\\\\\\\\\\\\" + sig];\\\\\\\\n    return args && args.length\\\\\\\\n      ? f.apply(null, [ptr].concat(args))\\\\\\\\n      : f.call(null, ptr);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function dynCall(sig, ptr, args) {\\\\\\\\n    if (sig.includes(\\\\\\\\\\\\\\\"j\\\\\\\\\\\\\\\")) {\\\\\\\\n      return dynCallLegacy(sig, ptr, args);\\\\\\\\n    }\\\\\\\\n    return getWasmTableEntry(ptr).apply(null, args);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function getDynCaller(sig, ptr) {\\\\\\\\n    var argCache = [];\\\\\\\\n    return function () {\\\\\\\\n      argCache.length = 0;\\\\\\\\n      Object.assign(argCache, arguments);\\\\\\\\n      return dynCall(sig, ptr, argCache);\\\\\\\\n    };\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function embind__requireFunction(signature, rawFunction) {\\\\\\\\n    signature = readLatin1String(signature);\\\\\\\\n    function makeDynCaller() {\\\\\\\\n      if (signature.includes(\\\\\\\\\\\\\\\"j\\\\\\\\\\\\\\\")) {\\\\\\\\n        return getDynCaller(signature, rawFunction);\\\\\\\\n      }\\\\\\\\n      return getWasmTableEntry(rawFunction);\\\\\\\\n    }\\\\\\\\n    var fp = makeDynCaller();\\\\\\\\n    if (typeof fp != \\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\") {\\\\\\\\n      throwBindingError(\\\\\\\\n        \\\\\\\\\\\\\\\"unknown function pointer with signature \\\\\\\\\\\\\\\" +\\\\\\\\n          signature +\\\\\\\\n          \\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\" +\\\\\\\\n          rawFunction\\\\\\\\n      );\\\\\\\\n    }\\\\\\\\n    return fp;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var UnboundTypeError = undefined;\\\\\\\\n\\\\\\\\n  function getTypeName(type) {\\\\\\\\n    var ptr = ___getTypeName(type);\\\\\\\\n    var rv = readLatin1String(ptr);\\\\\\\\n    _free(ptr);\\\\\\\\n    return rv;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function throwUnboundTypeError(message, types) {\\\\\\\\n    var unboundTypes = [];\\\\\\\\n    var seen = {};\\\\\\\\n    function visit(type) {\\\\\\\\n      if (seen[type]) {\\\\\\\\n        return;\\\\\\\\n      }\\\\\\\\n      if (registeredTypes[type]) {\\\\\\\\n        return;\\\\\\\\n      }\\\\\\\\n      if (typeDependencies[type]) {\\\\\\\\n        typeDependencies[type].forEach(visit);\\\\\\\\n        return;\\\\\\\\n      }\\\\\\\\n      unboundTypes.push(type);\\\\\\\\n      seen[type] = true;\\\\\\\\n    }\\\\\\\\n    types.forEach(visit);\\\\\\\\n    throw new UnboundTypeError(\\\\\\\\n      message + \\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\" + unboundTypes.map(getTypeName).join([\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"])\\\\\\\\n    );\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_register_class(\\\\\\\\n    rawType,\\\\\\\\n    rawPointerType,\\\\\\\\n    rawConstPointerType,\\\\\\\\n    baseClassRawType,\\\\\\\\n    getActualTypeSignature,\\\\\\\\n    getActualType,\\\\\\\\n    upcastSignature,\\\\\\\\n    upcast,\\\\\\\\n    downcastSignature,\\\\\\\\n    downcast,\\\\\\\\n    name,\\\\\\\\n    destructorSignature,\\\\\\\\n    rawDestructor\\\\\\\\n  ) {\\\\\\\\n    name = readLatin1String(name);\\\\\\\\n    getActualType = embind__requireFunction(\\\\\\\\n      getActualTypeSignature,\\\\\\\\n      getActualType\\\\\\\\n    );\\\\\\\\n    if (upcast) {\\\\\\\\n      upcast = embind__requireFunction(upcastSignature, upcast);\\\\\\\\n    }\\\\\\\\n    if (downcast) {\\\\\\\\n      downcast = embind__requireFunction(downcastSignature, downcast);\\\\\\\\n    }\\\\\\\\n    rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\\\\\\\\n    var legalFunctionName = makeLegalFunctionName(name);\\\\\\\\n    exposePublicSymbol(legalFunctionName, function () {\\\\\\\\n      throwUnboundTypeError(\\\\\\\\n        \\\\\\\\\\\\\\\"Cannot construct \\\\\\\\\\\\\\\" + name + \\\\\\\\\\\\\\\" due to unbound types\\\\\\\\\\\\\\\",\\\\\\\\n        [baseClassRawType]\\\\\\\\n      );\\\\\\\\n    });\\\\\\\\n    whenDependentTypesAreResolved(\\\\\\\\n      [rawType, rawPointerType, rawConstPointerType],\\\\\\\\n      baseClassRawType ? [baseClassRawType] : [],\\\\\\\\n      function (base) {\\\\\\\\n        base = base[0];\\\\\\\\n        var baseClass;\\\\\\\\n        var basePrototype;\\\\\\\\n        if (baseClassRawType) {\\\\\\\\n          baseClass = base.registeredClass;\\\\\\\\n          basePrototype = baseClass.instancePrototype;\\\\\\\\n        } else {\\\\\\\\n          basePrototype = ClassHandle.prototype;\\\\\\\\n        }\\\\\\\\n        var constructor = createNamedFunction(legalFunctionName, function () {\\\\\\\\n          if (Object.getPrototypeOf(this) !== instancePrototype) {\\\\\\\\n            throw new BindingError(\\\\\\\\\\\\\\\"Use 'new' to construct \\\\\\\\\\\\\\\" + name);\\\\\\\\n          }\\\\\\\\n          if (undefined === registeredClass.constructor_body) {\\\\\\\\n            throw new BindingError(name + \\\\\\\\\\\\\\\" has no accessible constructor\\\\\\\\\\\\\\\");\\\\\\\\n          }\\\\\\\\n          var body = registeredClass.constructor_body[arguments.length];\\\\\\\\n          if (undefined === body) {\\\\\\\\n            throw new BindingError(\\\\\\\\n              \\\\\\\\\\\\\\\"Tried to invoke ctor of \\\\\\\\\\\\\\\" +\\\\\\\\n                name +\\\\\\\\n                \\\\\\\\\\\\\\\" with invalid number of parameters (\\\\\\\\\\\\\\\" +\\\\\\\\n                arguments.length +\\\\\\\\n                \\\\\\\\\\\\\\\") - expected (\\\\\\\\\\\\\\\" +\\\\\\\\n                Object.keys(registeredClass.constructor_body).toString() +\\\\\\\\n                \\\\\\\\\\\\\\\") parameters instead!\\\\\\\\\\\\\\\"\\\\\\\\n            );\\\\\\\\n          }\\\\\\\\n          return body.apply(this, arguments);\\\\\\\\n        });\\\\\\\\n        var instancePrototype = Object.create(basePrototype, {\\\\\\\\n          constructor: {\\\\\\\\n            value: constructor,\\\\\\\\n          },\\\\\\\\n        });\\\\\\\\n        constructor.prototype = instancePrototype;\\\\\\\\n        var registeredClass = new RegisteredClass(\\\\\\\\n          name,\\\\\\\\n          constructor,\\\\\\\\n          instancePrototype,\\\\\\\\n          rawDestructor,\\\\\\\\n          baseClass,\\\\\\\\n          getActualType,\\\\\\\\n          upcast,\\\\\\\\n          downcast\\\\\\\\n        );\\\\\\\\n        var referenceConverter = new RegisteredPointer(\\\\\\\\n          name,\\\\\\\\n          registeredClass,\\\\\\\\n          true,\\\\\\\\n          false,\\\\\\\\n          false\\\\\\\\n        );\\\\\\\\n        var pointerConverter = new RegisteredPointer(\\\\\\\\n          name + \\\\\\\\\\\\\\\"*\\\\\\\\\\\\\\\",\\\\\\\\n          registeredClass,\\\\\\\\n          false,\\\\\\\\n          false,\\\\\\\\n          false\\\\\\\\n        );\\\\\\\\n        var constPointerConverter = new RegisteredPointer(\\\\\\\\n          name + \\\\\\\\\\\\\\\" const*\\\\\\\\\\\\\\\",\\\\\\\\n          registeredClass,\\\\\\\\n          false,\\\\\\\\n          true,\\\\\\\\n          false\\\\\\\\n        );\\\\\\\\n        registeredPointers[rawType] = {\\\\\\\\n          pointerType: pointerConverter,\\\\\\\\n          constPointerType: constPointerConverter,\\\\\\\\n        };\\\\\\\\n        replacePublicSymbol(legalFunctionName, constructor);\\\\\\\\n        return [referenceConverter, pointerConverter, constPointerConverter];\\\\\\\\n      }\\\\\\\\n    );\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function heap32VectorToArray(count, firstElement) {\\\\\\\\n    var array = [];\\\\\\\\n    for (var i = 0; i < count; i++) {\\\\\\\\n      array.push(HEAP32[(firstElement >> 2) + i]);\\\\\\\\n    }\\\\\\\\n    return array;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_register_class_constructor(\\\\\\\\n    rawClassType,\\\\\\\\n    argCount,\\\\\\\\n    rawArgTypesAddr,\\\\\\\\n    invokerSignature,\\\\\\\\n    invoker,\\\\\\\\n    rawConstructor\\\\\\\\n  ) {\\\\\\\\n    assert(argCount > 0);\\\\\\\\n    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\\\\\\\\n    invoker = embind__requireFunction(invokerSignature, invoker);\\\\\\\\n    whenDependentTypesAreResolved([], [rawClassType], function (classType) {\\\\\\\\n      classType = classType[0];\\\\\\\\n      var humanName = \\\\\\\\\\\\\\\"constructor \\\\\\\\\\\\\\\" + classType.name;\\\\\\\\n      if (undefined === classType.registeredClass.constructor_body) {\\\\\\\\n        classType.registeredClass.constructor_body = [];\\\\\\\\n      }\\\\\\\\n      if (\\\\\\\\n        undefined !== classType.registeredClass.constructor_body[argCount - 1]\\\\\\\\n      ) {\\\\\\\\n        throw new BindingError(\\\\\\\\n          \\\\\\\\\\\\\\\"Cannot register multiple constructors with identical number of parameters (\\\\\\\\\\\\\\\" +\\\\\\\\n            (argCount - 1) +\\\\\\\\n            \\\\\\\\\\\\\\\") for class '\\\\\\\\\\\\\\\" +\\\\\\\\n            classType.name +\\\\\\\\n            \\\\\\\\\\\\\\\"'! Overload resolution is currently only performed using the parameter count, not actual type info!\\\\\\\\\\\\\\\"\\\\\\\\n        );\\\\\\\\n      }\\\\\\\\n      classType.registeredClass.constructor_body[argCount - 1] = () => {\\\\\\\\n        throwUnboundTypeError(\\\\\\\\n          \\\\\\\\\\\\\\\"Cannot construct \\\\\\\\\\\\\\\" + classType.name + \\\\\\\\\\\\\\\" due to unbound types\\\\\\\\\\\\\\\",\\\\\\\\n          rawArgTypes\\\\\\\\n        );\\\\\\\\n      };\\\\\\\\n      whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\\\\\\\\n        argTypes.splice(1, 0, null);\\\\\\\\n        classType.registeredClass.constructor_body[argCount - 1] =\\\\\\\\n          craftInvokerFunction(\\\\\\\\n            humanName,\\\\\\\\n            argTypes,\\\\\\\\n            null,\\\\\\\\n            invoker,\\\\\\\\n            rawConstructor\\\\\\\\n          );\\\\\\\\n        return [];\\\\\\\\n      });\\\\\\\\n      return [];\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function craftInvokerFunction(\\\\\\\\n    humanName,\\\\\\\\n    argTypes,\\\\\\\\n    classType,\\\\\\\\n    cppInvokerFunc,\\\\\\\\n    cppTargetFunc\\\\\\\\n  ) {\\\\\\\\n    var argCount = argTypes.length;\\\\\\\\n    if (argCount < 2) {\\\\\\\\n      throwBindingError(\\\\\\\\n        \\\\\\\\\\\\\\\"argTypes array size mismatch! Must at least get return value and 'this' types!\\\\\\\\\\\\\\\"\\\\\\\\n      );\\\\\\\\n    }\\\\\\\\n    var isClassMethodFunc = argTypes[1] !== null && classType !== null;\\\\\\\\n    var needsDestructorStack = false;\\\\\\\\n    for (var i = 1; i < argTypes.length; ++i) {\\\\\\\\n      if (\\\\\\\\n        argTypes[i] !== null &&\\\\\\\\n        argTypes[i].destructorFunction === undefined\\\\\\\\n      ) {\\\\\\\\n        needsDestructorStack = true;\\\\\\\\n        break;\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    var returns = argTypes[0].name !== \\\\\\\\\\\\\\\"void\\\\\\\\\\\\\\\";\\\\\\\\n    var expectedArgCount = argCount - 2;\\\\\\\\n    var argsWired = new Array(expectedArgCount);\\\\\\\\n    var invokerFuncArgs = [];\\\\\\\\n    var destructors = [];\\\\\\\\n    return function () {\\\\\\\\n      if (arguments.length !== expectedArgCount) {\\\\\\\\n        throwBindingError(\\\\\\\\n          \\\\\\\\\\\\\\\"function \\\\\\\\\\\\\\\" +\\\\\\\\n            humanName +\\\\\\\\n            \\\\\\\\\\\\\\\" called with \\\\\\\\\\\\\\\" +\\\\\\\\n            arguments.length +\\\\\\\\n            \\\\\\\\\\\\\\\" arguments, expected \\\\\\\\\\\\\\\" +\\\\\\\\n            expectedArgCount +\\\\\\\\n            \\\\\\\\\\\\\\\" args!\\\\\\\\\\\\\\\"\\\\\\\\n        );\\\\\\\\n      }\\\\\\\\n      destructors.length = 0;\\\\\\\\n      var thisWired;\\\\\\\\n      invokerFuncArgs.length = isClassMethodFunc ? 2 : 1;\\\\\\\\n      invokerFuncArgs[0] = cppTargetFunc;\\\\\\\\n      if (isClassMethodFunc) {\\\\\\\\n        thisWired = argTypes[1].toWireType(destructors, this, \\\\\\\\\\\\\\\"foo2\\\\\\\\\\\\\\\");\\\\\\\\n        invokerFuncArgs[1] = thisWired;\\\\\\\\n      }\\\\\\\\n      for (var i = 0; i < expectedArgCount; ++i) {\\\\\\\\n        console.log('[dbg][issam][embind invoke]', humanName, 'argIndex', i, {\\\\\\\\n          expectedType: argTypes[i + 2]?.name,\\\\\\\\n          jsType: typeof arguments[i],\\\\\\\\n          isArrayBuffer: arguments[i] instanceof ArrayBuffer,\\\\\\\\n          isU8: arguments[i] instanceof Uint8Array,\\\\\\\\n          valueCtor: arguments[i]?.constructor?.name\\\\\\\\n        });\\\\\\\\n        if (arguments[i] === undefined) {\\\\\\\\n          console.error('[dbg][issam][embind invoke] ARG IS UNDEFINED at', humanName, 'argIndex', i);\\\\\\\\n          console.trace();\\\\\\\\n        }\\\\\\\\n        argsWired[i] = argTypes[i + 2].toWireType(destructors, arguments[i], \\\\\\\\\\\\\\\"foo3\\\\\\\\\\\\\\\");\\\\\\\\n        invokerFuncArgs.push(argsWired[i]);\\\\\\\\n      }\\\\\\\\n      var rv = cppInvokerFunc.apply(null, invokerFuncArgs);\\\\\\\\n      function onDone(rv) {\\\\\\\\n        if (needsDestructorStack) {\\\\\\\\n          runDestructors(destructors);\\\\\\\\n        } else {\\\\\\\\n          for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; i++) {\\\\\\\\n            var param = i === 1 ? thisWired : argsWired[i - 2];\\\\\\\\n            if (argTypes[i].destructorFunction !== null) {\\\\\\\\n              argTypes[i].destructorFunction(param);\\\\\\\\n            }\\\\\\\\n          }\\\\\\\\n        }\\\\\\\\n        if (returns) {\\\\\\\\n          return argTypes[0].fromWireType(rv);\\\\\\\\n        }\\\\\\\\n      }\\\\\\\\n      return onDone(rv);\\\\\\\\n    };\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_register_class_function(\\\\\\\\n    rawClassType,\\\\\\\\n    methodName,\\\\\\\\n    argCount,\\\\\\\\n    rawArgTypesAddr,\\\\\\\\n    invokerSignature,\\\\\\\\n    rawInvoker,\\\\\\\\n    context,\\\\\\\\n    isPureVirtual\\\\\\\\n  ) {\\\\\\\\n    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\\\\\\\\n    methodName = readLatin1String(methodName);\\\\\\\\n    rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\\\\\\\\n    whenDependentTypesAreResolved([], [rawClassType], function (classType) {\\\\\\\\n      classType = classType[0];\\\\\\\\n      var humanName = classType.name + \\\\\\\\\\\\\\\".\\\\\\\\\\\\\\\" + methodName;\\\\\\\\n      if (methodName.startsWith(\\\\\\\\\\\\\\\"@@\\\\\\\\\\\\\\\")) {\\\\\\\\n        methodName = Symbol[methodName.substring(2)];\\\\\\\\n      }\\\\\\\\n      if (isPureVirtual) {\\\\\\\\n        classType.registeredClass.pureVirtualFunctions.push(methodName);\\\\\\\\n      }\\\\\\\\n      function unboundTypesHandler() {\\\\\\\\n        throwUnboundTypeError(\\\\\\\\n          \\\\\\\\\\\\\\\"Cannot call \\\\\\\\\\\\\\\" + humanName + \\\\\\\\\\\\\\\" due to unbound types\\\\\\\\\\\\\\\",\\\\\\\\n          rawArgTypes\\\\\\\\n        );\\\\\\\\n      }\\\\\\\\n      var proto = classType.registeredClass.instancePrototype;\\\\\\\\n      var method = proto[methodName];\\\\\\\\n      if (\\\\\\\\n        undefined === method ||\\\\\\\\n        (undefined === method.overloadTable &&\\\\\\\\n          method.className !== classType.name &&\\\\\\\\n          method.argCount === argCount - 2)\\\\\\\\n      ) {\\\\\\\\n        unboundTypesHandler.argCount = argCount - 2;\\\\\\\\n        unboundTypesHandler.className = classType.name;\\\\\\\\n        proto[methodName] = unboundTypesHandler;\\\\\\\\n      } else {\\\\\\\\n        ensureOverloadTable(proto, methodName, humanName);\\\\\\\\n        proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\\\\\\\\n      }\\\\\\\\n      whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\\\\\\\\n        var memberFunction = craftInvokerFunction(\\\\\\\\n          humanName,\\\\\\\\n          argTypes,\\\\\\\\n          classType,\\\\\\\\n          rawInvoker,\\\\\\\\n          context\\\\\\\\n        );\\\\\\\\n        if (undefined === proto[methodName].overloadTable) {\\\\\\\\n          memberFunction.argCount = argCount - 2;\\\\\\\\n          proto[methodName] = memberFunction;\\\\\\\\n        } else {\\\\\\\\n          proto[methodName].overloadTable[argCount - 2] = memberFunction;\\\\\\\\n        }\\\\\\\\n        return [];\\\\\\\\n      });\\\\\\\\n      return [];\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var emval_free_list = [];\\\\\\\\n\\\\\\\\n  var emval_handle_array = [\\\\\\\\n    {},\\\\\\\\n    {\\\\\\\\n      value: undefined,\\\\\\\\n    },\\\\\\\\n    {\\\\\\\\n      value: null,\\\\\\\\n    },\\\\\\\\n    {\\\\\\\\n      value: true,\\\\\\\\n    },\\\\\\\\n    {\\\\\\\\n      value: false,\\\\\\\\n    },\\\\\\\\n  ];\\\\\\\\n\\\\\\\\n  function __emval_decref(handle) {\\\\\\\\n    if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\\\\\\\\n      emval_handle_array[handle] = undefined;\\\\\\\\n      emval_free_list.push(handle);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function count_emval_handles() {\\\\\\\\n    var count = 0;\\\\\\\\n    for (var i = 5; i < emval_handle_array.length; ++i) {\\\\\\\\n      if (emval_handle_array[i] !== undefined) {\\\\\\\\n        ++count;\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    return count;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function get_first_emval() {\\\\\\\\n    for (var i = 5; i < emval_handle_array.length; ++i) {\\\\\\\\n      if (emval_handle_array[i] !== undefined) {\\\\\\\\n        return emval_handle_array[i];\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    return null;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function init_emval() {\\\\\\\\n    Module.count_emval_handles = count_emval_handles;\\\\\\\\n    Module.get_first_emval = get_first_emval;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var Emval = {\\\\\\\\n    toValue: handle => {\\\\\\\\n      if (!handle) {\\\\\\\\n        throwBindingError(\\\\\\\\\\\\\\\"Cannot use deleted val. handle = \\\\\\\\\\\\\\\" + handle);\\\\\\\\n      }\\\\\\\\n      return emval_handle_array[handle].value;\\\\\\\\n    },\\\\\\\\n    toHandle: value => {\\\\\\\\n      switch (value) {\\\\\\\\n        case undefined:\\\\\\\\n          return 1;\\\\\\\\n\\\\\\\\n        case null:\\\\\\\\n          return 2;\\\\\\\\n\\\\\\\\n        case true:\\\\\\\\n          return 3;\\\\\\\\n\\\\\\\\n        case false:\\\\\\\\n          return 4;\\\\\\\\n\\\\\\\\n        default: {\\\\\\\\n          var handle = emval_free_list.length\\\\\\\\n            ? emval_free_list.pop()\\\\\\\\n            : emval_handle_array.length;\\\\\\\\n          emval_handle_array[handle] = {\\\\\\\\n            refcount: 1,\\\\\\\\n            value,\\\\\\\\n          };\\\\\\\\n          return handle;\\\\\\\\n        }\\\\\\\\n      }\\\\\\\\n    },\\\\\\\\n  };\\\\\\\\n\\\\\\\\n  function __embind_register_emval(rawType, name) {\\\\\\\\n    name = readLatin1String(name);\\\\\\\\n    registerType(rawType, {\\\\\\\\n      name,\\\\\\\\n      fromWireType: function (handle) {\\\\\\\\n        var rv = Emval.toValue(handle);\\\\\\\\n        __emval_decref(handle);\\\\\\\\n        return rv;\\\\\\\\n      },\\\\\\\\n      toWireType: function (destructors, value) {\\\\\\\\n        return Emval.toHandle(value);\\\\\\\\n      },\\\\\\\\n      argPackAdvance: 8,\\\\\\\\n      readValueFromPointer: simpleReadValueFromPointer,\\\\\\\\n      destructorFunction: null,\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _embind_repr(v) {\\\\\\\\n    if (v === null) {\\\\\\\\n      return \\\\\\\\\\\\\\\"null\\\\\\\\\\\\\\\";\\\\\\\\n    }\\\\\\\\n    var t = typeof v;\\\\\\\\n    if (t === \\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\" || t === \\\\\\\\\\\\\\\"array\\\\\\\\\\\\\\\" || t === \\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\") {\\\\\\\\n      return v.toString();\\\\\\\\n    }\\\\\\\\n    return \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\" + v;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function floatReadValueFromPointer(name, shift) {\\\\\\\\n    switch (shift) {\\\\\\\\n      case 2:\\\\\\\\n        return function (pointer) {\\\\\\\\n          return this.fromWireType(HEAPF32[pointer >> 2]);\\\\\\\\n        };\\\\\\\\n\\\\\\\\n      case 3:\\\\\\\\n        return function (pointer) {\\\\\\\\n          return this.fromWireType(HEAPF64[pointer >> 3]);\\\\\\\\n        };\\\\\\\\n\\\\\\\\n      default:\\\\\\\\n        throw new TypeError(\\\\\\\\\\\\\\\"Unknown float type: \\\\\\\\\\\\\\\" + name);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_register_float(rawType, name, size) {\\\\\\\\n    var shift = getShiftFromSize(size);\\\\\\\\n    name = readLatin1String(name);\\\\\\\\n    registerType(rawType, {\\\\\\\\n      name,\\\\\\\\n      fromWireType: function (value) {\\\\\\\\n        return value;\\\\\\\\n      },\\\\\\\\n      toWireType: function (destructors, value) {\\\\\\\\n        return value;\\\\\\\\n      },\\\\\\\\n      argPackAdvance: 8,\\\\\\\\n      readValueFromPointer: floatReadValueFromPointer(name, shift),\\\\\\\\n      destructorFunction: null,\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function integerReadValueFromPointer(name, shift, signed) {\\\\\\\\n    switch (shift) {\\\\\\\\n      case 0:\\\\\\\\n        return signed\\\\\\\\n          ? function readS8FromPointer(pointer) {\\\\\\\\n              return HEAP8[pointer];\\\\\\\\n            }\\\\\\\\n          : function readU8FromPointer(pointer) {\\\\\\\\n              return HEAPU8[pointer];\\\\\\\\n            };\\\\\\\\n\\\\\\\\n      case 1:\\\\\\\\n        return signed\\\\\\\\n          ? function readS16FromPointer(pointer) {\\\\\\\\n              return HEAP16[pointer >> 1];\\\\\\\\n            }\\\\\\\\n          : function readU16FromPointer(pointer) {\\\\\\\\n              return HEAPU16[pointer >> 1];\\\\\\\\n            };\\\\\\\\n\\\\\\\\n      case 2:\\\\\\\\n        return signed\\\\\\\\n          ? function readS32FromPointer(pointer) {\\\\\\\\n              return HEAP32[pointer >> 2];\\\\\\\\n            }\\\\\\\\n          : function readU32FromPointer(pointer) {\\\\\\\\n              return HEAPU32[pointer >> 2];\\\\\\\\n            };\\\\\\\\n\\\\\\\\n      default:\\\\\\\\n        throw new TypeError(\\\\\\\\\\\\\\\"Unknown integer type: \\\\\\\\\\\\\\\" + name);\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_register_integer(\\\\\\\\n    primitiveType,\\\\\\\\n    name,\\\\\\\\n    size,\\\\\\\\n    minRange,\\\\\\\\n    maxRange\\\\\\\\n  ) {\\\\\\\\n    name = readLatin1String(name);\\\\\\\\n    if (maxRange === -1) {\\\\\\\\n      maxRange = 4294967295;\\\\\\\\n    }\\\\\\\\n    var shift = getShiftFromSize(size);\\\\\\\\n    var fromWireType = value => value;\\\\\\\\n    if (minRange === 0) {\\\\\\\\n      var bitshift = 32 - 8 * size;\\\\\\\\n      fromWireType = value => (value << bitshift) >>> bitshift;\\\\\\\\n    }\\\\\\\\n    var isUnsignedType = name.includes(\\\\\\\\\\\\\\\"unsigned\\\\\\\\\\\\\\\");\\\\\\\\n    var checkAssertions = (value, toTypeName) => {};\\\\\\\\n    var toWireType;\\\\\\\\n    if (isUnsignedType) {\\\\\\\\n      toWireType = function (destructors, value) {\\\\\\\\n        checkAssertions(value, this.name);\\\\\\\\n        return value >>> 0;\\\\\\\\n      };\\\\\\\\n    } else {\\\\\\\\n      toWireType = function (destructors, value) {\\\\\\\\n        checkAssertions(value, this.name);\\\\\\\\n        return value;\\\\\\\\n      };\\\\\\\\n    }\\\\\\\\n    registerType(primitiveType, {\\\\\\\\n      name,\\\\\\\\n      fromWireType: fromWireType,\\\\\\\\n      toWireType: toWireType,\\\\\\\\n      argPackAdvance: 8,\\\\\\\\n      readValueFromPointer: integerReadValueFromPointer(\\\\\\\\n        name,\\\\\\\\n        shift,\\\\\\\\n        minRange !== 0\\\\\\\\n      ),\\\\\\\\n      destructorFunction: null,\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_register_memory_view(rawType, dataTypeIndex, name) {\\\\\\\\n    var typeMapping = [\\\\\\\\n      Int8Array,\\\\\\\\n      Uint8Array,\\\\\\\\n      Int16Array,\\\\\\\\n      Uint16Array,\\\\\\\\n      Int32Array,\\\\\\\\n      Uint32Array,\\\\\\\\n      Float32Array,\\\\\\\\n      Float64Array,\\\\\\\\n    ];\\\\\\\\n    var TA = typeMapping[dataTypeIndex];\\\\\\\\n    function decodeMemoryView(handle) {\\\\\\\\n      handle = handle >> 2;\\\\\\\\n      var heap = HEAPU32;\\\\\\\\n      var size = heap[handle];\\\\\\\\n      var data = heap[handle + 1];\\\\\\\\n      return new TA(buffer, data, size);\\\\\\\\n    }\\\\\\\\n    name = readLatin1String(name);\\\\\\\\n    registerType(\\\\\\\\n      rawType,\\\\\\\\n      {\\\\\\\\n        name,\\\\\\\\n        fromWireType: decodeMemoryView,\\\\\\\\n        argPackAdvance: 8,\\\\\\\\n        readValueFromPointer: decodeMemoryView,\\\\\\\\n      },\\\\\\\\n      {\\\\\\\\n        ignoreDuplicateRegistrations: true,\\\\\\\\n      }\\\\\\\\n    );\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_register_smart_ptr(\\\\\\\\n    rawType,\\\\\\\\n    rawPointeeType,\\\\\\\\n    name,\\\\\\\\n    sharingPolicy,\\\\\\\\n    getPointeeSignature,\\\\\\\\n    rawGetPointee,\\\\\\\\n    constructorSignature,\\\\\\\\n    rawConstructor,\\\\\\\\n    shareSignature,\\\\\\\\n    rawShare,\\\\\\\\n    destructorSignature,\\\\\\\\n    rawDestructor\\\\\\\\n  ) {\\\\\\\\n    name = readLatin1String(name);\\\\\\\\n    rawGetPointee = embind__requireFunction(getPointeeSignature, rawGetPointee);\\\\\\\\n    rawConstructor = embind__requireFunction(\\\\\\\\n      constructorSignature,\\\\\\\\n      rawConstructor\\\\\\\\n    );\\\\\\\\n    rawShare = embind__requireFunction(shareSignature, rawShare);\\\\\\\\n    rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\\\\\\\\n    whenDependentTypesAreResolved(\\\\\\\\n      [rawType],\\\\\\\\n      [rawPointeeType],\\\\\\\\n      function (pointeeType) {\\\\\\\\n        pointeeType = pointeeType[0];\\\\\\\\n        var registeredPointer = new RegisteredPointer(\\\\\\\\n          name,\\\\\\\\n          pointeeType.registeredClass,\\\\\\\\n          false,\\\\\\\\n          false,\\\\\\\\n          true,\\\\\\\\n          pointeeType,\\\\\\\\n          sharingPolicy,\\\\\\\\n          rawGetPointee,\\\\\\\\n          rawConstructor,\\\\\\\\n          rawShare,\\\\\\\\n          rawDestructor\\\\\\\\n        );\\\\\\\\n        return [registeredPointer];\\\\\\\\n      }\\\\\\\\n    );\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_register_std_string(rawType, name) {\\\\\\\\n    name = readLatin1String(name);\\\\\\\\n    var stdStringIsUTF8 = name === \\\\\\\\\\\\\\\"std::string\\\\\\\\\\\\\\\";\\\\\\\\n    registerType(rawType, {\\\\\\\\n      name,\\\\\\\\n      fromWireType: function (value) {\\\\\\\\n        var length = HEAPU32[value >> 2];\\\\\\\\n        var str;\\\\\\\\n        if (stdStringIsUTF8) {\\\\\\\\n          var decodeStartPtr = value + 4;\\\\\\\\n          for (var i = 0; i <= length; ++i) {\\\\\\\\n            var currentBytePtr = value + 4 + i;\\\\\\\\n            if (i == length || HEAPU8[currentBytePtr] == 0) {\\\\\\\\n              var maxRead = currentBytePtr - decodeStartPtr;\\\\\\\\n              var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\\\\\\\\n              if (str === undefined) {\\\\\\\\n                str = stringSegment;\\\\\\\\n              } else {\\\\\\\\n                str += String.fromCharCode(0);\\\\\\\\n                str += stringSegment;\\\\\\\\n              }\\\\\\\\n              decodeStartPtr = currentBytePtr + 1;\\\\\\\\n            }\\\\\\\\n          }\\\\\\\\n        } else {\\\\\\\\n          var a = new Array(length);\\\\\\\\n          for (var i = 0; i < length; ++i) {\\\\\\\\n            a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\\\\\\\\n          }\\\\\\\\n          str = a.join(\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        _free(value);\\\\\\\\n        return str;\\\\\\\\n      },\\\\\\\\n      toWireType: function (destructors, value, foo) {\\\\\\\\n        console.log(\\\\\\\\\\\\\\\"[dbg][issam][begamort-translator.js] value:\\\\\\\\\\\\\\\", value, foo);\\\\\\\\n        if (value instanceof ArrayBuffer) {\\\\\\\\n          value = new Uint8Array(value);\\\\\\\\n        }\\\\\\\\n        var getLength;\\\\\\\\n        var valueIsOfTypeString = typeof value == \\\\\\\\\\\\\\\"string\\\\\\\\\\\\\\\";\\\\\\\\n        if (\\\\\\\\n          !(\\\\\\\\n            valueIsOfTypeString ||\\\\\\\\n            value instanceof Uint8Array ||\\\\\\\\n            value instanceof Uint8ClampedArray ||\\\\\\\\n            value instanceof Int8Array\\\\\\\\n          )\\\\\\\\n        ) {\\\\\\\\n          console.log(\\\\\\\\\\\\\\\"[dbg][issam][begamort-translator.js] value:\\\\\\\\\\\\\\\", valueIsOfTypeString, value);\\\\\\\\n          throwBindingError(\\\\\\\\\\\\\\\"Cannot pass non-string to std::string\\\\\\\\\\\\\\\");\\\\\\\\n        }\\\\\\\\n        if (stdStringIsUTF8 && valueIsOfTypeString) {\\\\\\\\n          getLength = () => lengthBytesUTF8(value);\\\\\\\\n        } else {\\\\\\\\n          getLength = () => value.length;\\\\\\\\n        }\\\\\\\\n        var length = getLength();\\\\\\\\n        var ptr = _malloc(4 + length + 1);\\\\\\\\n        HEAPU32[ptr >> 2] = length;\\\\\\\\n        if (stdStringIsUTF8 && valueIsOfTypeString) {\\\\\\\\n          stringToUTF8(value, ptr + 4, length + 1);\\\\\\\\n        } else if (valueIsOfTypeString) {\\\\\\\\n          for (var i = 0; i < length; ++i) {\\\\\\\\n            var charCode = value.charCodeAt(i);\\\\\\\\n            if (charCode > 255) {\\\\\\\\n              _free(ptr);\\\\\\\\n              throwBindingError(\\\\\\\\n                \\\\\\\\\\\\\\\"String has UTF-16 code units that do not fit in 8 bits\\\\\\\\\\\\\\\"\\\\\\\\n              );\\\\\\\\n            }\\\\\\\\n            HEAPU8[ptr + 4 + i] = charCode;\\\\\\\\n          }\\\\\\\\n        } else {\\\\\\\\n          for (var i = 0; i < length; ++i) {\\\\\\\\n            HEAPU8[ptr + 4 + i] = value[i];\\\\\\\\n          }\\\\\\\\n        }\\\\\\\\n        if (destructors !== null) {\\\\\\\\n          destructors.push(_free, ptr);\\\\\\\\n        }\\\\\\\\n        return ptr;\\\\\\\\n      },\\\\\\\\n      argPackAdvance: 8,\\\\\\\\n      readValueFromPointer: simpleReadValueFromPointer,\\\\\\\\n      destructorFunction(ptr) {\\\\\\\\n        _free(ptr);\\\\\\\\n      },\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_register_std_wstring(rawType, charSize, name) {\\\\\\\\n    name = readLatin1String(name);\\\\\\\\n    var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\\\\\\\\n    if (charSize === 2) {\\\\\\\\n      decodeString = UTF16ToString;\\\\\\\\n      encodeString = stringToUTF16;\\\\\\\\n      lengthBytesUTF = lengthBytesUTF16;\\\\\\\\n      getHeap = () => HEAPU16;\\\\\\\\n      shift = 1;\\\\\\\\n    } else if (charSize === 4) {\\\\\\\\n      decodeString = UTF32ToString;\\\\\\\\n      encodeString = stringToUTF32;\\\\\\\\n      lengthBytesUTF = lengthBytesUTF32;\\\\\\\\n      getHeap = () => HEAPU32;\\\\\\\\n      shift = 2;\\\\\\\\n    }\\\\\\\\n    registerType(rawType, {\\\\\\\\n      name,\\\\\\\\n      fromWireType: function (value) {\\\\\\\\n        var length = HEAPU32[value >> 2];\\\\\\\\n        var HEAP = getHeap();\\\\\\\\n        var str;\\\\\\\\n        var decodeStartPtr = value + 4;\\\\\\\\n        for (var i = 0; i <= length; ++i) {\\\\\\\\n          var currentBytePtr = value + 4 + i * charSize;\\\\\\\\n          if (i == length || HEAP[currentBytePtr >> shift] == 0) {\\\\\\\\n            var maxReadBytes = currentBytePtr - decodeStartPtr;\\\\\\\\n            var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\\\\\\\\n            if (str === undefined) {\\\\\\\\n              str = stringSegment;\\\\\\\\n            } else {\\\\\\\\n              str += String.fromCharCode(0);\\\\\\\\n              str += stringSegment;\\\\\\\\n            }\\\\\\\\n            decodeStartPtr = currentBytePtr + charSize;\\\\\\\\n          }\\\\\\\\n        }\\\\\\\\n        _free(value);\\\\\\\\n        return str;\\\\\\\\n      },\\\\\\\\n      toWireType: function (destructors, value) {\\\\\\\\n        if (!(typeof value == \\\\\\\\\\\\\\\"string\\\\\\\\\\\\\\\")) {\\\\\\\\n          throwBindingError(\\\\\\\\n            \\\\\\\\\\\\\\\"Cannot pass non-string to C++ string type \\\\\\\\\\\\\\\" + name\\\\\\\\n          );\\\\\\\\n        }\\\\\\\\n        var length = lengthBytesUTF(value);\\\\\\\\n        var ptr = _malloc(4 + length + charSize);\\\\\\\\n        HEAPU32[ptr >> 2] = length >> shift;\\\\\\\\n        encodeString(value, ptr + 4, length + charSize);\\\\\\\\n        if (destructors !== null) {\\\\\\\\n          destructors.push(_free, ptr);\\\\\\\\n        }\\\\\\\\n        return ptr;\\\\\\\\n      },\\\\\\\\n      argPackAdvance: 8,\\\\\\\\n      readValueFromPointer: simpleReadValueFromPointer,\\\\\\\\n      destructorFunction(ptr) {\\\\\\\\n        _free(ptr);\\\\\\\\n      },\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_register_value_object(\\\\\\\\n    rawType,\\\\\\\\n    name,\\\\\\\\n    constructorSignature,\\\\\\\\n    rawConstructor,\\\\\\\\n    destructorSignature,\\\\\\\\n    rawDestructor\\\\\\\\n  ) {\\\\\\\\n    structRegistrations[rawType] = {\\\\\\\\n      name: readLatin1String(name),\\\\\\\\n      rawConstructor: embind__requireFunction(\\\\\\\\n        constructorSignature,\\\\\\\\n        rawConstructor\\\\\\\\n      ),\\\\\\\\n      rawDestructor: embind__requireFunction(\\\\\\\\n        destructorSignature,\\\\\\\\n        rawDestructor\\\\\\\\n      ),\\\\\\\\n      fields: [],\\\\\\\\n    };\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_register_value_object_field(\\\\\\\\n    structType,\\\\\\\\n    fieldName,\\\\\\\\n    getterReturnType,\\\\\\\\n    getterSignature,\\\\\\\\n    getter,\\\\\\\\n    getterContext,\\\\\\\\n    setterArgumentType,\\\\\\\\n    setterSignature,\\\\\\\\n    setter,\\\\\\\\n    setterContext\\\\\\\\n  ) {\\\\\\\\n    structRegistrations[structType].fields.push({\\\\\\\\n      fieldName: readLatin1String(fieldName),\\\\\\\\n      getterReturnType,\\\\\\\\n      getter: embind__requireFunction(getterSignature, getter),\\\\\\\\n      getterContext,\\\\\\\\n      setterArgumentType,\\\\\\\\n      setter: embind__requireFunction(setterSignature, setter),\\\\\\\\n      setterContext,\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __embind_register_void(rawType, name) {\\\\\\\\n    name = readLatin1String(name);\\\\\\\\n    registerType(rawType, {\\\\\\\\n      isVoid: true,\\\\\\\\n      name,\\\\\\\\n      argPackAdvance: 0,\\\\\\\\n      fromWireType: function () {\\\\\\\\n        return undefined;\\\\\\\\n      },\\\\\\\\n      toWireType: function (destructors, o) {\\\\\\\\n        return undefined;\\\\\\\\n      },\\\\\\\\n    });\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __emscripten_date_now() {\\\\\\\\n    return Date.now();\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var nowIsMonotonic = true;\\\\\\\\n\\\\\\\\n  function __emscripten_get_now_is_monotonic() {\\\\\\\\n    return nowIsMonotonic;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function requireRegisteredType(rawType, humanName) {\\\\\\\\n    var impl = registeredTypes[rawType];\\\\\\\\n    if (undefined === impl) {\\\\\\\\n      throwBindingError(\\\\\\\\n        humanName + \\\\\\\\\\\\\\\" has unknown type \\\\\\\\\\\\\\\" + getTypeName(rawType)\\\\\\\\n      );\\\\\\\\n    }\\\\\\\\n    return impl;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __emval_lookupTypes(argCount, argTypes) {\\\\\\\\n    var a = new Array(argCount);\\\\\\\\n    for (var i = 0; i < argCount; ++i) {\\\\\\\\n      a[i] = requireRegisteredType(\\\\\\\\n        HEAP32[(argTypes >> 2) + i],\\\\\\\\n        \\\\\\\\\\\\\\\"parameter \\\\\\\\\\\\\\\" + i\\\\\\\\n      );\\\\\\\\n    }\\\\\\\\n    return a;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __emval_call(handle, argCount, argTypes, argv) {\\\\\\\\n    handle = Emval.toValue(handle);\\\\\\\\n    var types = __emval_lookupTypes(argCount, argTypes);\\\\\\\\n    var args = new Array(argCount);\\\\\\\\n    for (var i = 0; i < argCount; ++i) {\\\\\\\\n      var type = types[i];\\\\\\\\n      args[i] = type.readValueFromPointer(argv);\\\\\\\\n      argv += type.argPackAdvance;\\\\\\\\n    }\\\\\\\\n    var rv = handle.apply(undefined, args);\\\\\\\\n    return Emval.toHandle(rv);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __emval_incref(handle) {\\\\\\\\n    if (handle > 4) {\\\\\\\\n      emval_handle_array[handle].refcount += 1;\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __emval_take_value(type, argv) {\\\\\\\\n    type = requireRegisteredType(type, \\\\\\\\\\\\\\\"_emval_take_value\\\\\\\\\\\\\\\");\\\\\\\\n    var v = type.readValueFromPointer(argv);\\\\\\\\n    return Emval.toHandle(v);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __localtime_js(time, tmPtr) {\\\\\\\\n    var date = new Date(HEAP32[time >> 2] * 1e3);\\\\\\\\n    HEAP32[tmPtr >> 2] = date.getSeconds();\\\\\\\\n    HEAP32[(tmPtr + 4) >> 2] = date.getMinutes();\\\\\\\\n    HEAP32[(tmPtr + 8) >> 2] = date.getHours();\\\\\\\\n    HEAP32[(tmPtr + 12) >> 2] = date.getDate();\\\\\\\\n    HEAP32[(tmPtr + 16) >> 2] = date.getMonth();\\\\\\\\n    HEAP32[(tmPtr + 20) >> 2] = date.getFullYear() - 1900;\\\\\\\\n    HEAP32[(tmPtr + 24) >> 2] = date.getDay();\\\\\\\\n    var start = new Date(date.getFullYear(), 0, 1);\\\\\\\\n    var yday = ((date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24)) | 0;\\\\\\\\n    HEAP32[(tmPtr + 28) >> 2] = yday;\\\\\\\\n    HEAP32[(tmPtr + 36) >> 2] = -(date.getTimezoneOffset() * 60);\\\\\\\\n    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\\\\\\\\n    var winterOffset = start.getTimezoneOffset();\\\\\\\\n    var dst =\\\\\\\\n      (summerOffset != winterOffset &&\\\\\\\\n        date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;\\\\\\\\n    HEAP32[(tmPtr + 32) >> 2] = dst;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __mmap_js(addr, len, prot, flags, fd, off, allocated, builtin) {\\\\\\\\n    return -52;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __munmap_js(addr, len, prot, flags, fd, offset) {}\\\\\\\\n\\\\\\\\n  function _tzset_impl(timezone, daylight, tzname) {\\\\\\\\n    var currentYear = new Date().getFullYear();\\\\\\\\n    var winter = new Date(currentYear, 0, 1);\\\\\\\\n    var summer = new Date(currentYear, 6, 1);\\\\\\\\n    var winterOffset = winter.getTimezoneOffset();\\\\\\\\n    var summerOffset = summer.getTimezoneOffset();\\\\\\\\n    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\\\\\\\\n    HEAP32[timezone >> 2] = stdTimezoneOffset * 60;\\\\\\\\n    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);\\\\\\\\n    function extractZone(date) {\\\\\\\\n      var match = date.toTimeString().match(/\\\\\\\\\\\\\\\\(([A-Za-z ]+)\\\\\\\\\\\\\\\\)$/);\\\\\\\\n      return match ? match[1] : \\\\\\\\\\\\\\\"GMT\\\\\\\\\\\\\\\";\\\\\\\\n    }\\\\\\\\n    var winterName = extractZone(winter);\\\\\\\\n    var summerName = extractZone(summer);\\\\\\\\n    var winterNamePtr = allocateUTF8(winterName);\\\\\\\\n    var summerNamePtr = allocateUTF8(summerName);\\\\\\\\n    if (summerOffset < winterOffset) {\\\\\\\\n      HEAP32[tzname >> 2] = winterNamePtr;\\\\\\\\n      HEAP32[(tzname + 4) >> 2] = summerNamePtr;\\\\\\\\n    } else {\\\\\\\\n      HEAP32[tzname >> 2] = summerNamePtr;\\\\\\\\n      HEAP32[(tzname + 4) >> 2] = winterNamePtr;\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __tzset_js(timezone, daylight, tzname) {\\\\\\\\n    if (__tzset_js.called) {\\\\\\\\n      return;\\\\\\\\n    }\\\\\\\\n    __tzset_js.called = true;\\\\\\\\n    _tzset_impl(timezone, daylight, tzname);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _abort() {\\\\\\\\n    abort(\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\");\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var readAsmConstArgsArray = [];\\\\\\\\n\\\\\\\\n  function readAsmConstArgs(sigPtr, buf) {\\\\\\\\n    readAsmConstArgsArray.length = 0;\\\\\\\\n    var ch;\\\\\\\\n    buf >>= 2;\\\\\\\\n    while ((ch = HEAPU8[sigPtr++])) {\\\\\\\\n      var readAsmConstArgsDouble = ch < 105;\\\\\\\\n      if (readAsmConstArgsDouble && buf & 1) {\\\\\\\\n        buf++;\\\\\\\\n      }\\\\\\\\n      readAsmConstArgsArray.push(\\\\\\\\n        readAsmConstArgsDouble ? HEAPF64[buf++ >> 1] : HEAP32[buf]\\\\\\\\n      );\\\\\\\\n      ++buf;\\\\\\\\n    }\\\\\\\\n    return readAsmConstArgsArray;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _emscripten_asm_const_int(code, sigPtr, argbuf) {\\\\\\\\n    var args = readAsmConstArgs(sigPtr, argbuf);\\\\\\\\n    return ASM_CONSTS[code].apply(null, args);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _emscripten_get_heap_max() {\\\\\\\\n    return 2147483648;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var _emscripten_get_now;\\\\\\\\n\\\\\\\\n  _emscripten_get_now = () => performance.now();\\\\\\\\n\\\\\\\\n  function _emscripten_memcpy_big(dest, src, num) {\\\\\\\\n    HEAPU8.copyWithin(dest, src, src + num);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function emscripten_realloc_buffer(size) {\\\\\\\\n    try {\\\\\\\\n      wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16);\\\\\\\\n      updateGlobalBufferAndViews(wasmMemory.buffer);\\\\\\\\n      return 1;\\\\\\\\n    } catch (e) {}\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _emscripten_resize_heap(requestedSize) {\\\\\\\\n    var oldSize = HEAPU8.length;\\\\\\\\n    requestedSize = requestedSize >>> 0;\\\\\\\\n    var maxHeapSize = _emscripten_get_heap_max();\\\\\\\\n    if (requestedSize > maxHeapSize) {\\\\\\\\n      return false;\\\\\\\\n    }\\\\\\\\n    let alignUp = (x, multiple) => x + ((multiple - (x % multiple)) % multiple);\\\\\\\\n    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\\\\\\\\n      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\\\\\\\\n      overGrownHeapSize = Math.min(\\\\\\\\n        overGrownHeapSize,\\\\\\\\n        requestedSize + 100663296\\\\\\\\n      );\\\\\\\\n      var newSize = Math.min(\\\\\\\\n        maxHeapSize,\\\\\\\\n        alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)\\\\\\\\n      );\\\\\\\\n      var replacement = emscripten_realloc_buffer(newSize);\\\\\\\\n      if (replacement) {\\\\\\\\n        return true;\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    return false;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var ENV = {};\\\\\\\\n\\\\\\\\n  function getExecutableName() {\\\\\\\\n    return thisProgram || \\\\\\\\\\\\\\\"./this.program\\\\\\\\\\\\\\\";\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function getEnvStrings() {\\\\\\\\n    if (!getEnvStrings.strings) {\\\\\\\\n      var lang =\\\\\\\\n        (\\\\\\\\n          (typeof navigator == \\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\" &&\\\\\\\\n            navigator.languages &&\\\\\\\\n            navigator.languages[0]) ||\\\\\\\\n          \\\\\\\\\\\\\\\"C\\\\\\\\\\\\\\\"\\\\\\\\n        ).replace(\\\\\\\\\\\\\\\"-\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"_\\\\\\\\\\\\\\\") + \\\\\\\\\\\\\\\".UTF-8\\\\\\\\\\\\\\\";\\\\\\\\n      var env = {\\\\\\\\n        USER: \\\\\\\\\\\\\\\"web_user\\\\\\\\\\\\\\\",\\\\\\\\n        LOGNAME: \\\\\\\\\\\\\\\"web_user\\\\\\\\\\\\\\\",\\\\\\\\n        PATH: \\\\\\\\\\\\\\\"/\\\\\\\\\\\\\\\",\\\\\\\\n        PWD: \\\\\\\\\\\\\\\"/\\\\\\\\\\\\\\\",\\\\\\\\n        HOME: \\\\\\\\\\\\\\\"/home/web_user\\\\\\\\\\\\\\\",\\\\\\\\n        LANG: lang,\\\\\\\\n        _: getExecutableName(),\\\\\\\\n      };\\\\\\\\n      for (var x in ENV) {\\\\\\\\n        if (ENV[x] === undefined) {\\\\\\\\n          delete env[x];\\\\\\\\n        } else {\\\\\\\\n          env[x] = ENV[x];\\\\\\\\n        }\\\\\\\\n      }\\\\\\\\n      var strings = [];\\\\\\\\n      for (var x in env) {\\\\\\\\n        strings.push(x + \\\\\\\\\\\\\\\"=\\\\\\\\\\\\\\\" + env[x]);\\\\\\\\n      }\\\\\\\\n      getEnvStrings.strings = strings;\\\\\\\\n    }\\\\\\\\n    return getEnvStrings.strings;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _environ_get(__environ, environ_buf) {\\\\\\\\n    var bufSize = 0;\\\\\\\\n    getEnvStrings().forEach(function (string, i) {\\\\\\\\n      var ptr = environ_buf + bufSize;\\\\\\\\n      HEAP32[(__environ + i * 4) >> 2] = ptr;\\\\\\\\n      writeAsciiToMemory(string, ptr);\\\\\\\\n      bufSize += string.length + 1;\\\\\\\\n    });\\\\\\\\n    return 0;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _environ_sizes_get(penviron_count, penviron_buf_size) {\\\\\\\\n    var strings = getEnvStrings();\\\\\\\\n    HEAP32[penviron_count >> 2] = strings.length;\\\\\\\\n    var bufSize = 0;\\\\\\\\n    strings.forEach(function (string) {\\\\\\\\n      bufSize += string.length + 1;\\\\\\\\n    });\\\\\\\\n    HEAP32[penviron_buf_size >> 2] = bufSize;\\\\\\\\n    return 0;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _exit(status) {\\\\\\\\n    exit(status);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _fd_close(fd) {\\\\\\\\n    return 0;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _fd_read(fd, iov, iovcnt, pnum) {\\\\\\\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\\\\\\\n    var num = SYSCALLS.doReadv(stream, iov, iovcnt);\\\\\\\\n    HEAP32[pnum >> 2] = num;\\\\\\\\n    return 0;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}\\\\\\\\n\\\\\\\\n  function _fd_write(fd, iov, iovcnt, pnum) {\\\\\\\\n    var num = 0;\\\\\\\\n    for (var i = 0; i < iovcnt; i++) {\\\\\\\\n      var ptr = HEAP32[iov >> 2];\\\\\\\\n      var len = HEAP32[(iov + 4) >> 2];\\\\\\\\n      iov += 8;\\\\\\\\n      for (var j = 0; j < len; j++) {\\\\\\\\n        SYSCALLS.printChar(fd, HEAPU8[ptr + j]);\\\\\\\\n      }\\\\\\\\n      num += len;\\\\\\\\n    }\\\\\\\\n    HEAP32[pnum >> 2] = num;\\\\\\\\n    return 0;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function getRandomDevice() {\\\\\\\\n    if (\\\\\\\\n      typeof crypto == \\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\" &&\\\\\\\\n      typeof crypto.getRandomValues == \\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\"\\\\\\\\n    ) {\\\\\\\\n      var randomBuffer = new Uint8Array(1);\\\\\\\\n      return function () {\\\\\\\\n        crypto.getRandomValues(randomBuffer);\\\\\\\\n        return randomBuffer[0];\\\\\\\\n      };\\\\\\\\n    }\\\\\\\\n    return function () {\\\\\\\\n      abort(\\\\\\\\\\\\\\\"randomDevice\\\\\\\\\\\\\\\");\\\\\\\\n    };\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _getentropy(buffer, size) {\\\\\\\\n    if (!_getentropy.randomDevice) {\\\\\\\\n      _getentropy.randomDevice = getRandomDevice();\\\\\\\\n    }\\\\\\\\n    for (var i = 0; i < size; i++) {\\\\\\\\n      HEAP8[(buffer + i) >> 0] = _getentropy.randomDevice();\\\\\\\\n    }\\\\\\\\n    return 0;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _pclose() {\\\\\\\\n    err(\\\\\\\\\\\\\\\"missing function: pclose\\\\\\\\\\\\\\\");\\\\\\\\n    abort(-1);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _setTempRet0(val) {\\\\\\\\n    setTempRet0(val);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __isLeapYear(year) {\\\\\\\\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function __arraySum(array, index) {\\\\\\\\n    var sum = 0;\\\\\\\\n    for (var i = 0; i <= index; sum += array[i++]) {}\\\\\\\\n    return sum;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\\\\\\\n\\\\\\\\n  var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\\\\\\\n\\\\\\\\n  function __addDays(date, days) {\\\\\\\\n    var newDate = new Date(date.getTime());\\\\\\\\n    while (days > 0) {\\\\\\\\n      var leap = __isLeapYear(newDate.getFullYear());\\\\\\\\n      var currentMonth = newDate.getMonth();\\\\\\\\n      var daysInCurrentMonth = (\\\\\\\\n        leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR\\\\\\\\n      )[currentMonth];\\\\\\\\n      if (days > daysInCurrentMonth - newDate.getDate()) {\\\\\\\\n        days -= daysInCurrentMonth - newDate.getDate() + 1;\\\\\\\\n        newDate.setDate(1);\\\\\\\\n        if (currentMonth < 11) {\\\\\\\\n          newDate.setMonth(currentMonth + 1);\\\\\\\\n        } else {\\\\\\\\n          newDate.setMonth(0);\\\\\\\\n          newDate.setFullYear(newDate.getFullYear() + 1);\\\\\\\\n        }\\\\\\\\n      } else {\\\\\\\\n        newDate.setDate(newDate.getDate() + days);\\\\\\\\n        return newDate;\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    return newDate;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _strftime(s, maxsize, format, tm) {\\\\\\\\n    var tm_zone = HEAP32[(tm + 40) >> 2];\\\\\\\\n    var date = {\\\\\\\\n      tm_sec: HEAP32[tm >> 2],\\\\\\\\n      tm_min: HEAP32[(tm + 4) >> 2],\\\\\\\\n      tm_hour: HEAP32[(tm + 8) >> 2],\\\\\\\\n      tm_mday: HEAP32[(tm + 12) >> 2],\\\\\\\\n      tm_mon: HEAP32[(tm + 16) >> 2],\\\\\\\\n      tm_year: HEAP32[(tm + 20) >> 2],\\\\\\\\n      tm_wday: HEAP32[(tm + 24) >> 2],\\\\\\\\n      tm_yday: HEAP32[(tm + 28) >> 2],\\\\\\\\n      tm_isdst: HEAP32[(tm + 32) >> 2],\\\\\\\\n      tm_gmtoff: HEAP32[(tm + 36) >> 2],\\\\\\\\n      tm_zone: tm_zone ? UTF8ToString(tm_zone) : \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\",\\\\\\\\n    };\\\\\\\\n    var pattern = UTF8ToString(format);\\\\\\\\n    var EXPANSION_RULES_1 = {\\\\\\\\n      \\\\\\\\\\\\\\\"%c\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%a %b %d %H:%M:%S %Y\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%D\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%m/%d/%y\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%F\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%Y-%m-%d\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%h\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%b\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%r\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%I:%M:%S %p\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%R\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%H:%M\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%T\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%H:%M:%S\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%x\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%m/%d/%y\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%X\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%H:%M:%S\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%Ec\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%c\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%EC\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%C\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%Ex\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%m/%d/%y\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%EX\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%H:%M:%S\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%Ey\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%y\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%EY\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%Y\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%Od\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%d\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%Oe\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%e\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%OH\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%H\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%OI\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%I\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%Om\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%m\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%OM\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%M\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%OS\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%S\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%Ou\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%u\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%OU\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%U\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%OV\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%V\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%Ow\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%w\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%OW\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%W\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"%Oy\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"%y\\\\\\\\\\\\\\\",\\\\\\\\n    };\\\\\\\\n    for (var rule in EXPANSION_RULES_1) {\\\\\\\\n      pattern = pattern.replace(new RegExp(rule, \\\\\\\\\\\\\\\"g\\\\\\\\\\\\\\\"), EXPANSION_RULES_1[rule]);\\\\\\\\n    }\\\\\\\\n    var WEEKDAYS = [\\\\\\\\n      \\\\\\\\\\\\\\\"Sunday\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"Monday\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"Tuesday\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"Wednesday\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"Thursday\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"Friday\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"Saturday\\\\\\\\\\\\\\\",\\\\\\\\n    ];\\\\\\\\n    var MONTHS = [\\\\\\\\n      \\\\\\\\\\\\\\\"January\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"February\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"March\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"April\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"May\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"June\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"July\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"August\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"September\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"October\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"November\\\\\\\\\\\\\\\",\\\\\\\\n      \\\\\\\\\\\\\\\"December\\\\\\\\\\\\\\\",\\\\\\\\n    ];\\\\\\\\n    function leadingSomething(value, digits, character) {\\\\\\\\n      var str = typeof value == \\\\\\\\\\\\\\\"number\\\\\\\\\\\\\\\" ? value.toString() : value || \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\";\\\\\\\\n      while (str.length < digits) {\\\\\\\\n        str = character[0] + str;\\\\\\\\n      }\\\\\\\\n      return str;\\\\\\\\n    }\\\\\\\\n    function leadingNulls(value, digits) {\\\\\\\\n      return leadingSomething(value, digits, \\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\");\\\\\\\\n    }\\\\\\\\n    function compareByDay(date1, date2) {\\\\\\\\n      function sgn(value) {\\\\\\\\n        return value < 0 ? -1 : value > 0 ? 1 : 0;\\\\\\\\n      }\\\\\\\\n      var compare;\\\\\\\\n      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\\\\\\\\n        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\\\\\\\\n          compare = sgn(date1.getDate() - date2.getDate());\\\\\\\\n        }\\\\\\\\n      }\\\\\\\\n      return compare;\\\\\\\\n    }\\\\\\\\n    function getFirstWeekStartDate(janFourth) {\\\\\\\\n      switch (janFourth.getDay()) {\\\\\\\\n        case 0:\\\\\\\\n          return new Date(janFourth.getFullYear() - 1, 11, 29);\\\\\\\\n\\\\\\\\n        case 1:\\\\\\\\n          return janFourth;\\\\\\\\n\\\\\\\\n        case 2:\\\\\\\\n          return new Date(janFourth.getFullYear(), 0, 3);\\\\\\\\n\\\\\\\\n        case 3:\\\\\\\\n          return new Date(janFourth.getFullYear(), 0, 2);\\\\\\\\n\\\\\\\\n        case 4:\\\\\\\\n          return new Date(janFourth.getFullYear(), 0, 1);\\\\\\\\n\\\\\\\\n        case 5:\\\\\\\\n          return new Date(janFourth.getFullYear() - 1, 11, 31);\\\\\\\\n\\\\\\\\n        case 6:\\\\\\\\n          return new Date(janFourth.getFullYear() - 1, 11, 30);\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    function getWeekBasedYear(date) {\\\\\\\\n      var thisDate = __addDays(\\\\\\\\n        new Date(date.tm_year + 1900, 0, 1),\\\\\\\\n        date.tm_yday\\\\\\\\n      );\\\\\\\\n      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\\\\\\\\n      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\\\\\\\\n      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\\\\\\\\n      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\\\\\\\\n      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\\\\\\\\n        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\\\\\\\\n          return thisDate.getFullYear() + 1;\\\\\\\\n        }\\\\\\\\n        return thisDate.getFullYear();\\\\\\\\n      }\\\\\\\\n      return thisDate.getFullYear() - 1;\\\\\\\\n    }\\\\\\\\n    var EXPANSION_RULES_2 = {\\\\\\\\n      \\\\\\\\\\\\\\\"%a\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return WEEKDAYS[date.tm_wday].substring(0, 3);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%A\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return WEEKDAYS[date.tm_wday];\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%b\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return MONTHS[date.tm_mon].substring(0, 3);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%B\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return MONTHS[date.tm_mon];\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%C\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        var year = date.tm_year + 1900;\\\\\\\\n        return leadingNulls((year / 100) | 0, 2);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%d\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return leadingNulls(date.tm_mday, 2);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%e\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return leadingSomething(date.tm_mday, 2, \\\\\\\\\\\\\\\" \\\\\\\\\\\\\\\");\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%g\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return getWeekBasedYear(date).toString().substring(2);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%G\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return getWeekBasedYear(date);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%H\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return leadingNulls(date.tm_hour, 2);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%I\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        var twelveHour = date.tm_hour;\\\\\\\\n        if (twelveHour == 0) {\\\\\\\\n          twelveHour = 12;\\\\\\\\n        } else if (twelveHour > 12) {\\\\\\\\n          twelveHour -= 12;\\\\\\\\n        }\\\\\\\\n        return leadingNulls(twelveHour, 2);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%j\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return leadingNulls(\\\\\\\\n          date.tm_mday +\\\\\\\\n            __arraySum(\\\\\\\\n              __isLeapYear(date.tm_year + 1900)\\\\\\\\n                ? __MONTH_DAYS_LEAP\\\\\\\\n                : __MONTH_DAYS_REGULAR,\\\\\\\\n              date.tm_mon - 1\\\\\\\\n            ),\\\\\\\\n          3\\\\\\\\n        );\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%m\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return leadingNulls(date.tm_mon + 1, 2);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%M\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return leadingNulls(date.tm_min, 2);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%n\\\\\\\\\\\\\\\": function () {\\\\\\\\n        return \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\";\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%p\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        if (date.tm_hour >= 0 && date.tm_hour < 12) {\\\\\\\\n          return \\\\\\\\\\\\\\\"AM\\\\\\\\\\\\\\\";\\\\\\\\n        }\\\\\\\\n        return \\\\\\\\\\\\\\\"PM\\\\\\\\\\\\\\\";\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%S\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return leadingNulls(date.tm_sec, 2);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%t\\\\\\\\\\\\\\\": function () {\\\\\\\\n        return \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\t\\\\\\\\\\\\\\\";\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%u\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return date.tm_wday || 7;\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%U\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        var days = date.tm_yday + 7 - date.tm_wday;\\\\\\\\n        return leadingNulls(Math.floor(days / 7), 2);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%V\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        var val = Math.floor((date.tm_yday + 7 - ((date.tm_wday + 6) % 7)) / 7);\\\\\\\\n        if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\\\\\\\\n          val++;\\\\\\\\n        }\\\\\\\\n        if (!val) {\\\\\\\\n          val = 52;\\\\\\\\n          var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\\\\\\\\n          if (\\\\\\\\n            dec31 == 4 ||\\\\\\\\n            (dec31 == 5 && __isLeapYear((date.tm_year % 400) - 1))\\\\\\\\n          ) {\\\\\\\\n            val++;\\\\\\\\n          }\\\\\\\\n        } else if (val == 53) {\\\\\\\\n          var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\\\\\\\\n          if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date.tm_year))) {\\\\\\\\n            val = 1;\\\\\\\\n          }\\\\\\\\n        }\\\\\\\\n        return leadingNulls(val, 2);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%w\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return date.tm_wday;\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%W\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);\\\\\\\\n        return leadingNulls(Math.floor(days / 7), 2);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%y\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return (date.tm_year + 1900).toString().substring(2);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%Y\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return date.tm_year + 1900;\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%z\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        var off = date.tm_gmtoff;\\\\\\\\n        var ahead = off >= 0;\\\\\\\\n        off = Math.abs(off) / 60;\\\\\\\\n        off = (off / 60) * 100 + (off % 60);\\\\\\\\n        return (ahead ? \\\\\\\\\\\\\\\"+\\\\\\\\\\\\\\\" : \\\\\\\\\\\\\\\"-\\\\\\\\\\\\\\\") + String(\\\\\\\\\\\\\\\"0000\\\\\\\\\\\\\\\" + off).slice(-4);\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%Z\\\\\\\\\\\\\\\": function (date) {\\\\\\\\n        return date.tm_zone;\\\\\\\\n      },\\\\\\\\n      \\\\\\\\\\\\\\\"%%\\\\\\\\\\\\\\\": function () {\\\\\\\\n        return \\\\\\\\\\\\\\\"%\\\\\\\\\\\\\\\";\\\\\\\\n      },\\\\\\\\n    };\\\\\\\\n    pattern = pattern.replace(/%%/g, \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\0\\\\\\\\\\\\\\\\0\\\\\\\\\\\\\\\");\\\\\\\\n    for (var rule in EXPANSION_RULES_2) {\\\\\\\\n      if (pattern.includes(rule)) {\\\\\\\\n        pattern = pattern.replace(\\\\\\\\n          new RegExp(rule, \\\\\\\\\\\\\\\"g\\\\\\\\\\\\\\\"),\\\\\\\\n          EXPANSION_RULES_2[rule](date)\\\\\\\\n        );\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    pattern = pattern.replace(/\\\\\\\\\\\\\\\\0\\\\\\\\\\\\\\\\0/g, \\\\\\\\\\\\\\\"%\\\\\\\\\\\\\\\");\\\\\\\\n    var bytes = intArrayFromString(pattern, false);\\\\\\\\n    if (bytes.length > maxsize) {\\\\\\\\n      return 0;\\\\\\\\n    }\\\\\\\\n    writeArrayToMemory(bytes, s);\\\\\\\\n    return bytes.length - 1;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function _strftime_l(s, maxsize, format, tm) {\\\\\\\\n    return _strftime(s, maxsize, format, tm);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  InternalError = Module.InternalError = extendError(Error, \\\\\\\\\\\\\\\"InternalError\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n  embind_init_charCodes();\\\\\\\\n\\\\\\\\n  BindingError = Module.BindingError = extendError(Error, \\\\\\\\\\\\\\\"BindingError\\\\\\\\\\\\\\\");\\\\\\\\n\\\\\\\\n  init_ClassHandle();\\\\\\\\n\\\\\\\\n  init_embind();\\\\\\\\n\\\\\\\\n  init_RegisteredPointer();\\\\\\\\n\\\\\\\\n  UnboundTypeError = Module.UnboundTypeError = extendError(\\\\\\\\n    Error,\\\\\\\\n    \\\\\\\\\\\\\\\"UnboundTypeError\\\\\\\\\\\\\\\"\\\\\\\\n  );\\\\\\\\n\\\\\\\\n  init_emval();\\\\\\\\n\\\\\\\\n  function intArrayFromString(stringy, dontAddNull, length) {\\\\\\\\n    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\\\\\\\\n    var u8array = new Array(len);\\\\\\\\n    var numBytesWritten = stringToUTF8Array(\\\\\\\\n      stringy,\\\\\\\\n      u8array,\\\\\\\\n      0,\\\\\\\\n      u8array.length\\\\\\\\n    );\\\\\\\\n    if (dontAddNull) {\\\\\\\\n      u8array.length = numBytesWritten;\\\\\\\\n    }\\\\\\\\n    return u8array;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  var asmLibraryArg = {\\\\\\\\n    __assert_fail: ___assert_fail,\\\\\\\\n    __cxa_allocate_exception: ___cxa_allocate_exception,\\\\\\\\n    __cxa_rethrow: ___cxa_rethrow,\\\\\\\\n    __cxa_throw: ___cxa_throw,\\\\\\\\n    __syscall_faccessat: ___syscall_faccessat,\\\\\\\\n    __syscall_fcntl64: ___syscall_fcntl64,\\\\\\\\n    __syscall_fstat64: ___syscall_fstat64,\\\\\\\\n    __syscall_getcwd: ___syscall_getcwd,\\\\\\\\n    __syscall_ioctl: ___syscall_ioctl,\\\\\\\\n    __syscall_lstat64: ___syscall_lstat64,\\\\\\\\n    __syscall_newfstatat: ___syscall_newfstatat,\\\\\\\\n    __syscall_openat: ___syscall_openat,\\\\\\\\n    __syscall_renameat: ___syscall_renameat,\\\\\\\\n    __syscall_rmdir: ___syscall_rmdir,\\\\\\\\n    __syscall_stat64: ___syscall_stat64,\\\\\\\\n    __syscall_unlinkat: ___syscall_unlinkat,\\\\\\\\n    _embind_finalize_value_object: __embind_finalize_value_object,\\\\\\\\n    _embind_register_bigint: __embind_register_bigint,\\\\\\\\n    _embind_register_bool: __embind_register_bool,\\\\\\\\n    _embind_register_class: __embind_register_class,\\\\\\\\n    _embind_register_class_constructor: __embind_register_class_constructor,\\\\\\\\n    _embind_register_class_function: __embind_register_class_function,\\\\\\\\n    _embind_register_emval: __embind_register_emval,\\\\\\\\n    _embind_register_float: __embind_register_float,\\\\\\\\n    _embind_register_integer: __embind_register_integer,\\\\\\\\n    _embind_register_memory_view: __embind_register_memory_view,\\\\\\\\n    _embind_register_smart_ptr: __embind_register_smart_ptr,\\\\\\\\n    _embind_register_std_string: __embind_register_std_string,\\\\\\\\n    _embind_register_std_wstring: __embind_register_std_wstring,\\\\\\\\n    _embind_register_value_object: __embind_register_value_object,\\\\\\\\n    _embind_register_value_object_field: __embind_register_value_object_field,\\\\\\\\n    _embind_register_void: __embind_register_void,\\\\\\\\n    _emscripten_date_now: __emscripten_date_now,\\\\\\\\n    _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,\\\\\\\\n    _emval_call: __emval_call,\\\\\\\\n    _emval_decref: __emval_decref,\\\\\\\\n    _emval_incref: __emval_incref,\\\\\\\\n    _emval_take_value: __emval_take_value,\\\\\\\\n    _localtime_js: __localtime_js,\\\\\\\\n    _mmap_js: __mmap_js,\\\\\\\\n    _munmap_js: __munmap_js,\\\\\\\\n    _tzset_js: __tzset_js,\\\\\\\\n    abort: _abort,\\\\\\\\n    emscripten_asm_const_int: _emscripten_asm_const_int,\\\\\\\\n    emscripten_get_heap_max: _emscripten_get_heap_max,\\\\\\\\n    emscripten_get_now: _emscripten_get_now,\\\\\\\\n    emscripten_memcpy_big: _emscripten_memcpy_big,\\\\\\\\n    emscripten_resize_heap: _emscripten_resize_heap,\\\\\\\\n    environ_get: _environ_get,\\\\\\\\n    environ_sizes_get: _environ_sizes_get,\\\\\\\\n    exit: _exit,\\\\\\\\n    fd_close: _fd_close,\\\\\\\\n    fd_read: _fd_read,\\\\\\\\n    fd_seek: _fd_seek,\\\\\\\\n    fd_write: _fd_write,\\\\\\\\n    getentropy: _getentropy,\\\\\\\\n    memory: wasmMemory,\\\\\\\\n    pclose: _pclose,\\\\\\\\n    setTempRet0: _setTempRet0,\\\\\\\\n    strftime_l: _strftime_l,\\\\\\\\n  };\\\\\\\\n\\\\\\\\n  var asm = createWasm();\\\\\\\\n\\\\\\\\n  var calledRun;\\\\\\\\n\\\\\\\\n  function ExitStatus(status) {\\\\\\\\n    this.name = \\\\\\\\\\\\\\\"ExitStatus\\\\\\\\\\\\\\\";\\\\\\\\n    this.message = \\\\\\\\\\\\\\\"Program terminated with exit(\\\\\\\\\\\\\\\" + status + \\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\";\\\\\\\\n    this.status = status;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  dependenciesFulfilled = function runCaller() {\\\\\\\\n    if (!calledRun) {\\\\\\\\n      run();\\\\\\\\n    }\\\\\\\\n    if (!calledRun) {\\\\\\\\n      dependenciesFulfilled = runCaller;\\\\\\\\n    }\\\\\\\\n  };\\\\\\\\n\\\\\\\\n  function run(args) {\\\\\\\\n    args = args || arguments_;\\\\\\\\n    if (runDependencies > 0) {\\\\\\\\n      return;\\\\\\\\n    }\\\\\\\\n    preRun();\\\\\\\\n    if (runDependencies > 0) {\\\\\\\\n      return;\\\\\\\\n    }\\\\\\\\n    function doRun() {\\\\\\\\n      if (calledRun) {\\\\\\\\n        return;\\\\\\\\n      }\\\\\\\\n      calledRun = true;\\\\\\\\n      Module.calledRun = true;\\\\\\\\n      if (ABORT) {\\\\\\\\n        return;\\\\\\\\n      }\\\\\\\\n      initRuntime();\\\\\\\\n      if (Module.onRuntimeInitialized) {\\\\\\\\n        Module.onRuntimeInitialized();\\\\\\\\n      }\\\\\\\\n      postRun();\\\\\\\\n    }\\\\\\\\n    if (Module.setStatus) {\\\\\\\\n      Module.setStatus(\\\\\\\\\\\\\\\"Running...\\\\\\\\\\\\\\\");\\\\\\\\n      setTimeout(function () {\\\\\\\\n        setTimeout(function () {\\\\\\\\n          Module.setStatus(\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\");\\\\\\\\n        }, 1);\\\\\\\\n        doRun();\\\\\\\\n      }, 1);\\\\\\\\n    } else {\\\\\\\\n      doRun();\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  Module.run = run;\\\\\\\\n\\\\\\\\n  function exit(status, implicit) {\\\\\\\\n    EXITSTATUS = status;\\\\\\\\n    procExit(status);\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  function procExit(code) {\\\\\\\\n    EXITSTATUS = code;\\\\\\\\n    if (!keepRuntimeAlive()) {\\\\\\\\n      if (Module.onExit) {\\\\\\\\n        Module.onExit(code);\\\\\\\\n      }\\\\\\\\n      ABORT = true;\\\\\\\\n    }\\\\\\\\n    quit_(code, new ExitStatus(code));\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  if (Module.preInit) {\\\\\\\\n    if (typeof Module.preInit == \\\\\\\\\\\\\\\"function\\\\\\\\\\\\\\\") {\\\\\\\\n      Module.preInit = [Module.preInit];\\\\\\\\n    }\\\\\\\\n    while (Module.preInit.length) {\\\\\\\\n      Module.preInit.pop()();\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  run();\\\\\\\\n\\\\\\\\n  /* Use an optimized gemm implementation if available, otherwise use the fallback\\\\\\\\n   * implementation.\\\\\\\\n   */\\\\\\\\n  function createWasmGemm() {\\\\\\\\n    // A map of expected gemm function to the corresponding fallback gemm function names.\\\\\\\\n    const GEMM_TO_FALLBACK_FUNCTIONS_MAP = {\\\\\\\\n      int8_prepare_a: \\\\\\\\\\\\\\\"int8PrepareAFallback\\\\\\\\\\\\\\\",\\\\\\\\n      int8_prepare_b: \\\\\\\\\\\\\\\"int8PrepareBFallback\\\\\\\\\\\\\\\",\\\\\\\\n      int8_prepare_b_from_transposed: \\\\\\\\\\\\\\\"int8PrepareBFromTransposedFallback\\\\\\\\\\\\\\\",\\\\\\\\n      int8_prepare_b_from_quantized_transposed:\\\\\\\\n        \\\\\\\\\\\\\\\"int8PrepareBFromQuantizedTransposedFallback\\\\\\\\\\\\\\\",\\\\\\\\n      int8_prepare_bias: \\\\\\\\\\\\\\\"int8PrepareBiasFallback\\\\\\\\\\\\\\\",\\\\\\\\n      int8_multiply_and_add_bias: \\\\\\\\\\\\\\\"int8MultiplyAndAddBiasFallback\\\\\\\\\\\\\\\",\\\\\\\\n      int8_select_columns_of_b: \\\\\\\\\\\\\\\"int8SelectColumnsOfBFallback\\\\\\\\\\\\\\\",\\\\\\\\n    };\\\\\\\\n\\\\\\\\n    // Name of the optimized gemm implementation.\\\\\\\\n    const OPTIMIZED_GEMM = \\\\\\\\\\\\\\\"mozIntGemm\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n    const optimizedGemmModule = WebAssembly[OPTIMIZED_GEMM];\\\\\\\\n    if (!optimizedGemmModule) {\\\\\\\\n      return fallbackGemm(GEMM_TO_FALLBACK_FUNCTIONS_MAP);\\\\\\\\n    }\\\\\\\\n\\\\\\\\n    const optimizedGemmModuleExports = new WebAssembly.Instance(\\\\\\\\n      optimizedGemmModule(),\\\\\\\\n      { \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\": { memory: wasmMemory } }\\\\\\\\n    ).exports;\\\\\\\\n    for (let key in GEMM_TO_FALLBACK_FUNCTIONS_MAP) {\\\\\\\\n      if (!optimizedGemmModuleExports[key]) {\\\\\\\\n        return fallbackGemm(GEMM_TO_FALLBACK_FUNCTIONS_MAP);\\\\\\\\n      }\\\\\\\\n    }\\\\\\\\n    Module.print(`Using optimized gemm (${OPTIMIZED_GEMM}) implementation`);\\\\\\\\n    return optimizedGemmModuleExports;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  // Return the fallback gemm implementation.\\\\\\\\n  function fallbackGemm(gemmToFallbackFunctionsMap) {\\\\\\\\n    // The fallback gemm implementation\\\\\\\\n    const FALLBACK_GEMM = \\\\\\\\\\\\\\\"asm\\\\\\\\\\\\\\\";\\\\\\\\n\\\\\\\\n    let fallbackGemmModuleExports = {};\\\\\\\\n    for (let key in gemmToFallbackFunctionsMap) {\\\\\\\\n      fallbackGemmModuleExports[key] = (...a) =>\\\\\\\\n        Module[FALLBACK_GEMM][gemmToFallbackFunctionsMap[key]](...a);\\\\\\\\n    }\\\\\\\\n    Module.print(`Using fallback gemm implementation`);\\\\\\\\n    return fallbackGemmModuleExports;\\\\\\\\n  }\\\\\\\\n\\\\\\\\n  return Module;\\\\\\\\n}\\\\\\\\n\\\\\\\"\\\\n\\\\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js?./node_modules/raw-loader/index.js\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/script-loader/addScript.js\\\":\\n/*!*************************************************!*\\\\\\n  !*** ./node_modules/script-loader/addScript.js ***!\\n  \\\\*************************************************/\\n/***/ ((module) => {\\n\\neval(\\\"/*\\\\n\\\\tMIT License http://www.opensource.org/licenses/mit-license.php\\\\n\\\\tAuthor Tobias Koppers @sokra\\\\n*/\\\\nmodule.exports = function(src) {\\\\n\\\\tfunction log(error) {\\\\n\\\\t\\\\t(typeof console !== \\\\\\\"undefined\\\\\\\")\\\\n\\\\t\\\\t&& (console.error || console.log)(\\\\\\\"[Script Loader]\\\\\\\", error);\\\\n\\\\t}\\\\n\\\\n\\\\t// Check for IE =< 8\\\\n\\\\tfunction isIE() {\\\\n\\\\t\\\\treturn typeof attachEvent !== \\\\\\\"undefined\\\\\\\" && typeof addEventListener === \\\\\\\"undefined\\\\\\\";\\\\n\\\\t}\\\\n\\\\n\\\\ttry {\\\\n\\\\t\\\\tif (typeof execScript !== \\\\\\\"undefined\\\\\\\" && isIE()) {\\\\n\\\\t\\\\t\\\\texecScript(src);\\\\n\\\\t\\\\t} else if (typeof eval !== \\\\\\\"undefined\\\\\\\") {\\\\n\\\\t\\\\t\\\\teval.call(null, src);\\\\n\\\\t\\\\t} else {\\\\n\\\\t\\\\t\\\\tlog(\\\\\\\"EvalError: No eval function available\\\\\\\");\\\\n\\\\t\\\\t}\\\\n\\\\t} catch (error) {\\\\n\\\\t\\\\tlog(error);\\\\n\\\\t}\\\\n}\\\\n\\\\n\\\\n//# sourceURL=webpack://firefox-ios/./node_modules/script-loader/addScript.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js\\\":\\n/*!**********************************************************************************************************!*\\\\\\n  !*** ./node_modules/script-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js ***!\\n  \\\\**********************************************************************************************************/\\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {\\n\\neval(\\\"__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ \\\\\\\"./node_modules/script-loader/addScript.js\\\\\\\")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js */ \\\\\\\"./node_modules/raw-loader/index.js!./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js\\\\\\\"))\\\\n\\\\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/bergamot-translator.js?./node_modules/script-loader/index.js\\\");\\n\\n/***/ })\\n\\n/******/ \\t});\\n/************************************************************************/\\n/******/ \\t// The module cache\\n/******/ \\tvar __webpack_module_cache__ = {};\\n/******/ \\t\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tvar cachedModule = __webpack_module_cache__[moduleId];\\n/******/ \\t\\tif (cachedModule !== undefined) {\\n/******/ \\t\\t\\treturn cachedModule.exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = __webpack_module_cache__[moduleId] = {\\n/******/ \\t\\t\\t// no module.id needed\\n/******/ \\t\\t\\t// no module.loaded needed\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/ \\t\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\\n/******/ \\t\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/ \\t\\n/************************************************************************/\\n/******/ \\t\\n/******/ \\t// startup\\n/******/ \\t// Load entry module and return exports\\n/******/ \\t// This entry module can't be inlined because the eval devtool is used.\\n/******/ \\tvar __webpack_exports__ = __webpack_require__(\\\"./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[1].use[1]!./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js\\\");\\n/******/ \\t\\n/******/ })()\\n;\", \"Worker\", undefined, undefined);\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/translations-engine.worker.js?");

/***/ }),

/***/ "./node_modules/worker-loader/dist/runtime/inline.js":
/*!***********************************************************!*\
  !*** ./node_modules/worker-loader/dist/runtime/inline.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint-env browser */\n\n/* eslint-disable no-undef, no-use-before-define, new-cap */\nmodule.exports = function (content, workerConstructor, workerOptions, url) {\n  var globalScope = self || window;\n\n  try {\n    try {\n      var blob;\n\n      try {\n        // New API\n        blob = new globalScope.Blob([content]);\n      } catch (e) {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n        blob = new BlobBuilder();\n        blob.append(content);\n        blob = blob.getBlob();\n      }\n\n      var URL = globalScope.URL || globalScope.webkitURL;\n      var objectURL = URL.createObjectURL(blob);\n      var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n      URL.revokeObjectURL(objectURL);\n      return worker;\n    } catch (e) {\n      return new globalScope[workerConstructor](\"data:application/javascript,\".concat(encodeURIComponent(content)), workerOptions);\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error(\"Inline worker is not supported\");\n    }\n\n    return new globalScope[workerConstructor](url, workerOptions);\n  }\n};\n\n//# sourceURL=webpack://firefox-ios/./node_modules/worker-loader/dist/runtime/inline.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./firefox-ios/Client/Frontend/UserContent/UserScripts/TranslationsEngine/TranslationsEngine.js");
/******/ 	
/******/ })()
;